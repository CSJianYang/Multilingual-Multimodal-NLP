[
    {
        "title": "N-Queens II",
        "question_content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the&nbsp;n-queens puzzle.\n&nbsp;\nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9",
        "solutions": [
            {
                "id": 2111583,
                "title": "cpp-explained-clean",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/4a277b77-14e4-44ff-87eb-e400a3d7d41e_1654392063.0433629.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){ \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1); \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false; \\n\\t\\t}                                \\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111857,
                "title": "java-c-n-queens-1-2-almost-same-solution",
                "content": "**Rules For N-Queens in a chess Board :-**\\n1. Every Row should Have 1 queen\\n\\n\\n2. Every Column should have 1 quuen\\n3. No 2 queens can attack each other\\n\\n![image](https://assets.leetcode.com/users/images/a69e681e-0067-4c46-8659-f10d126eb181_1654402034.2685366.png)\\n\\n```\\nN-Quuens I\\n```\\n\\n**Problem Statement:** The n-queens is the problem of placing n queens on n \\xD7 n chessboard such that no two queens can attack each other. Given an integer n, return all distinct solutions to the n -queens puzzle. Each solution contains a distinct boards configuration of the queen\\u2019s placement, where \\u2018Q\\u2019 and \\u2018.\\u2019 indicate queen and empty space respectively.\\n\\n**Intuition:** Using the concept of Backtracking, we will place Queen at different positions of the chessboard and find the right arrangement where all the n queens can be placed on the n*n grid.\\n\\n![image](https://assets.leetcode.com/users/images/cad068d6-420e-4588-87cc-ccee4a719323_1654402478.1131492.png)\\n\\n\\n**Approach:**\\n\\n**Ist position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 3rd column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/92f73459-712f-4564-a82b-a33364ea38fb_1654401381.1760585.png)\\n\\n**2nd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/7c6019f5-930c-4fed-bd6b-0f53440db5a9_1654401405.4075787.png)\\n\\n**3rd position:** One of the correct possible arrangements is found. So we will store it as our answer.\\n\\n![image](https://assets.leetcode.com/users/images/dd4669ff-be65-40df-88dd-ae1a04442ae5_1654401442.4140863.png)\\n\\n**4th position:** This is the position where we can see no possible arrangement is found where all queens can be placed since, at the 4th column, the Queen will be killed at all possible positions of row.\\n\\n![image](https://assets.leetcode.com/users/images/93fc6398-0119-4ba3-82a6-5162845f35fe_1654401463.9854825.png)\\n\\n<iframe src=\"https://leetcode.com/playground/MgCvV5hU/shared\" frameBorder=\"0\" width=\"1400\" height=\"1000\"></iframe>\\n\\n\\nANALYSIS :-\\n* **Time Complexity:** Exponential in nature, since we are trying out all ways. To be precise it goes as O(N! * N) nearly.\\n\\n* **Space Complexity:** O(N^2)\\n```\\nN-Quuens II\\n```\\n\\nThis Problem is Almost Similar to N-Queens what extra we have to done over here is, Instead of printing the position we have to **count** the no. of ways in which Queens can be arranged on N-By-N chess \\n\\n![image](https://assets.leetcode.com/users/images/c8f00056-d8d7-4965-a879-f3fac38d8bfc_1654399504.9641533.png)\\n\\n<iframe src=\"https://leetcode.com/playground/H7a7hggm/shared\" frameBorder=\"0\" width=\"1200\" height=\"800\"></iframe>\\n\\nANALYSIS :-\\n* **Time Complexity:** O(N! * N)\\n\\n* **Space Complexity:** O(N^2)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nN-Quuens I\\n```\n```\\nN-Quuens II\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20058,
                "title": "accepted-java-solution",
                "content": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * don't need to actually place the queen,\\n     * instead, for each row, try to place without violation on\\n     * col/ diagonal1/ diagnol2.\\n     * trick: to detect whether 2 positions sit on the same diagnol:\\n     * if delta(col, row) equals, same diagnol1;\\n     * if sum(col, row) equals, same diagnal2.\\n     */\\n    private final Set<Integer> occupiedCols = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag1s = new HashSet<Integer>();\\n    private final Set<Integer> occupiedDiag2s = new HashSet<Integer>();\\n    public int totalNQueens(int n) {\\n        return totalNQueensHelper(0, 0, n);\\n    }\\n    \\n    private int totalNQueensHelper(int row, int count, int n) {\\n        for (int col = 0; col < n; col++) {\\n            if (occupiedCols.contains(col))\\n                continue;\\n            int diag1 = row - col;\\n            if (occupiedDiag1s.contains(diag1))\\n                continue;\\n            int diag2 = row + col;\\n            if (occupiedDiag2s.contains(diag2))\\n                continue;\\n            // we can now place a queen here\\n            if (row == n-1)\\n                count++;\\n            else {\\n                occupiedCols.add(col);\\n                occupiedDiag1s.add(diag1);\\n                occupiedDiag2s.add(diag2);\\n                count = totalNQueensHelper(row+1, count, n);\\n                // recover\\n                occupiedCols.remove(col);\\n                occupiedDiag1s.remove(diag1);\\n                occupiedDiag2s.remove(diag2);\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20048,
                "title": "easiest-java-solution-1ms-98-22",
                "content": "This is a classic backtracking problem. \\n\\nStart row by row, and loop through columns. At each decision point, skip unsafe positions by using three boolean arrays.\\n\\nStart going back when we reach row n.\\n\\nJust FYI, if using HashSet, running time will be at least 3 times slower!\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n        \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n                \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237811,
                "title": "short-easy-w-explanation-visualization-backtracking-explained",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126533,
                "title": "python-backtracking-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        diag1 = set()\\n        diag2 = set()\\n        usedCols = set()\\n        \\n        return self.helper(n, diag1, diag2, usedCols, 0)\\n\\n    def helper(self, n, diag1, diag2, usedCols, row):\\n        if row == n:\\n            return 1\\n        \\n        solutions = 0\\n        \\n        for col in range(n):\\n            if row + col in diag1 or row - col in diag2 or col in usedCols:\\n                continue\\n                \\n            diag1.add(row + col)\\n            diag2.add(row - col)\\n            usedCols.add(col)\\n            \\n            solutions += self.helper(n, diag1, diag2, usedCols, row + 1)\\n        \\n            diag1.remove(row + col)\\n            diag2.remove(row - col)\\n            usedCols.remove(col)\\n        \\n        return solutions\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 20147,
                "title": "python-recursive-dfs-solution",
                "content": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "The idea here is quite similar to [N-Queens ][1] while we don\\'t need to record the path, and as the return value is a number not a list, it\\'s better to use a global variable to record the result.\\n       \\n    def totalNQueens(self, n):\\n        self.res = 0\\n        self.dfs([-1]*n, 0)\\n        return self.res\\n        \\n    def dfs(self, nums, index):\\n        if index == len(nums):\\n            self.res += 1\\n            return #backtracking\\n        for i in range(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):\\n                self.dfs(nums, index+1)\\n        \\n    def valid(self, nums, n):\\n        for i in range(n):\\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\\n                return False\\n        return True\\n\\n\\n  [1]: https://leetcode.com/discuss/53764/python-recursive-dfs-solution-with-comments",
                "codeTag": "Python3"
            },
            {
                "id": 20077,
                "title": "c-solution-dfs-easy-understanding",
                "content": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int totalNQueens(int n) {\\n        vector<bool> col(n, true);\\n        vector<bool> anti(2*n-1, true);\\n        vector<bool> main(2*n-1, true);\\n        vector<int> row(n, 0);\\n        int count = 0;\\n        dfs(0, row, col, main, anti, count);\\n        return count;\\n    }\\n    void dfs(int i, vector<int> &row, vector<bool> &col, vector<bool>& main, vector<bool> &anti, int &count) {\\n            if (i == row.size()) {\\n                count++;\\n                return;\\n            }\\n           for (int j = 0; j < col.size(); j++) {\\n             if (col[j] && main[i+j] && anti[i+col.size()-1-j]) {\\n                 row[i] = j; \\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = false;\\n                 dfs(i+1, row, col, main, anti, count);\\n                 col[j] = main[i+j] = anti[i+col.size()-1-j] = true;\\n          }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238198,
                "title": "python-super-short-backtracking-explained",
                "content": "This problem is similar to problem **46** and **51**, basically we need to go over all `n!` permutations and then check if it is correct and write function to draw this solution. Let us use `dfs(board, c1, c2, c3)` function here, where:\\n\\n1. `board` are positions of queen for the first, second and so on lines. Length of `board` is how many queens we already used.\\n2. `c1` is bit mask for columns, `c2` and `c3` for diagonals. Note, that we use `i-j+n` for one of the diagonals to avoid negative numbers.  Each time we try to take all possible positions and then check if we can put queen on this position.\\n\\n#### Complexity\\nTime and space complexity is `O(n!)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: self.ans += 1\\n            \\n           for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        self.ans = 0\\n        dfs([], 0, 0, 0, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111695,
                "title": "c-n-queens-variation",
                "content": "**Please upvote the post if you like it :)**\\n\\nSo, basically  we have been given `n` queens and we need to place those **queens** in the `board` such that  no **two** queens **attack** each other right?\\n\\nCool, so we know that the number of ways to place `N` **queens** on a `NxN` **board** can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... which eventually leads to an overall **time** **complexity** of `O(N^2N)`, which is extremely **high** and we can\\'t afford that.\\n\\nBut, simultaneously we also know that we don\\'t actually need to traverse all the `O(N^2)` options each time. \\nSo, we can place one **queen** in each **row** and then move to the next row.\\n\\nSo for each row, we will place one queen (if possible within the contraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the `isSafe` method to ensure that the queen is safe to `place` at **(i, j)**. Once, all `N` **queens** have been placed, we have got our first solution.\\n\\nFinally, to get all the other possible solutions, we will keep on removing the previously placed queen and try if its possible to place it at some other location, i.e, where we need to **backtrack**. This will give us all the possible combinations to place `N Queens` on the board as per the given constraints.\\n\\n****\\nVisualization if needed from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif)- \\n\\n\\n![image](https://assets.leetcode.com/users/images/6388c419-0494-4d56-9bc4-a710a3699862_1654316356.7472951.gif)\\n\\n\\n****\\n**Solution 1 - Backtracking Approach (C++) :** \\u2705\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\\n\\n****\\n**Time Complexity : O(N!)**, Since we have N choices in the first row, then N-1 choices in the second row and so on so the overall complexity become **O(N!)** \\n**Space Complexity: O(N*N)**, Just the `board` and recursive `stack` space\\n\\n****\\n**Solution 2 - (Backtracking Approach O(N) Space):** \\u2705\\nHere we only need the number of `distinct` solutions and not the exact board solutions themselves, so what we can do is that we can keep a track on `queen` placements on each `n` **columns**, `2n-1` **diagonals**,` 2n-1` **Anti-daigonals**, this way we can remove the `isSafe` function and reduce **space** size.\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n**Time Complexity : O(N!)**\\n**Space Complexity : O(N), for recursive stack and col, diag, anti_diag**\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t\\t// checking if any queen already placed on same column previously\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    // checking if all diagonals are safe -\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\t    board[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\t    count += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\t\\t// backtrack - remove previously placed queen and try for different columns\\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20046,
                "title": "share-my-java-code-beats-97-83-run-times",
                "content": "    /*\\n        \\u5e38\\u89c4n-queens\\u89e3\\u6cd5, \\u6570\\u7b54\\u6848\\u4e2a\\u6570.\\n        \\u7528column\\u6807\\u8bb0\\u6b64\\u884c\\u4e4b\\u524d\\u7684\\u54ea\\u4e9bcolumn\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94column\\u7684\\u7b2ccol\\u4f4d(LSB --> MSB, \\u4e0b\\u540c).\\n        \\u7528diag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u4e3b\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94diag\\u7684\\u7b2c(n - 1 + row - col)\\u4f4d.\\n        \\u7528antiDiag\\u6807\\u8bb0\\u6b64\\u4f4d\\u7f6e\\u4e4b\\u524d\\u7684\\u54ea\\u4e9b\\u526f\\u5bf9\\u89d2\\u7ebf\\u5df2\\u7ecf\\u653e\\u7f6e\\u4e86queen. \\u68cb\\u76d8\\u5750\\u6807(row, col)\\u5bf9\\u5e94antiDiag\\u7684\\u7b2c(row + col)\\u4f4d.\\n    */\\n    public class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }\\n        \\n        private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n            if (row == n) {\\n                ++count;\\n                return;\\n            }\\n            for (int i = 0; i < n; ++i) {\\n                boolean isColSafe = ((1 << i) & column) == 0;\\n                boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n                boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n                if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                    dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int count = 0;\\n        \\n        public int totalNQueens(int n) {\\n            dfs(0, n, 0, 0, 0);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237780,
                "title": "js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111513,
                "title": "python-solution-with-explanation",
                "content": "This problem is an extension on the yesterday\\'s daily challenge problem [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). Please refer the link to understand how **N-Queens** is implemented. \\n\\n\\nThe below code is just a slight modification on yesterday\\'s [solution](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation) that I had posted. In this, instead of returning the list of valid solutions, I am returning the count of number of valid solutions.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\\n\\nBut sometimes while building a solution for a problem that is an extension or similar to another problem, we might end up with similar solution with slight change. This is what I did in my above approach. We were already tracking valid solutions in [N-Queens](https://leetcode.com/problems/n-queens/discuss/2107719/python-solution-with-explanation). So instead of returning the list of valid solutions, I am returning count of the number of solutions in the list.\\n\\nIf you observe the exploration path that solution tree takes, you would notice that it starts at a different row each time. Each path it takes is unique. So instead of tracking the valid solutions. We can just track the count of valid solutions. Whenever we hit the required number of queens, we just add that path to overall tally.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```\\n\\n**Time - O(N!)** - In the solution tree, number of valid exploration paths from a node reduces by 2 at each level. In first level, we have `N` columns options to place the queen i.e `N` paths from the root node. In the next level, we have max `N-2` options available because we can\\'t place the queen in same column and same diagonal as previous queen. In the next level, it will be `N-4` because of two columns and two diagonals occupied by previous two queens. This will continue and give us a `O(N!)`Time. (Let me know if you think otherwise :) )\\n\\n**Space - O(N^2)** - recursive call stack to explore all possible solutions\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        state=[[\\'.\\'] * n for _ in range(n)]\\n\\t\\t\\n\\t\\t# for tracking the columns which already have a queen\\n        visited_cols=set()\\n\\t\\t\\n\\t\\t# This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        visited_diagonals=set()\\n\\t\\t\\n\\t\\t # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:\\n                res.add(map(\\'#\\'.join, map(\\'\\'.join, state))) # add a valid solution\\n                return\\n                        \\n            for c in range(n):\\n\\t\\t\\t # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)\\n                    state[r][c]=\\'Q\\'\\n                    backtrack(r+1)\\n                    \\n\\t\\t\\t\\t\\t# reset the exploration path for backtracking\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)\\n                    state[r][c]=\\'.\\'\\n                        \\n        backtrack(0)\\n        return len(res)\\n\\n```\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:                \\n        visited_cols=set()\\n        visited_diagonals=set()\\n        visited_antidiagonals=set()\\n        \\n        res=set()\\n        def backtrack(r):\\n            if r==n:  # valid solution state   \\n                return 1\\n                        \\n            cnt=0\\n            for c in range(n):\\n                if not(c in visited_cols or (r-c) in visited_diagonals or (r+c) in visited_antidiagonals):\\n                    visited_cols.add(c)\\n                    visited_diagonals.add(r-c)\\n                    visited_antidiagonals.add(r+c)                    \\n                    cnt+=backtrack(r+1) # count the overall tally from this current state\\n                    \\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(r-c)\\n                    visited_antidiagonals.remove(r+c)                    \\n            \\n            return cnt\\n        \\n        return backtrack(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20119,
                "title": "collection-of-solutions-in-java",
                "content": "This post is mainly for myself as I learnt a lot from all kinds of solutions posted under this question. The copyright goes to the original author :)\\n\\nClick on the title of each method and you can see the original author's explanations (if there is any).\\n\\n\\n#[Java accepted clean solutions, >98.73% by yunli2015][1]#\\n\\n    public class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }\\n        public void dfs(int[] pos,int step,int n) {\\n            if(step==n) {\\n                count++;\\n                return;\\n            }\\n            for(int i=0;i<n;i++) {\\n                pos[step]=i;\\n                if(isvalid(pos,step)) dfs(pos,step+1,n);\\n            }\\n        }\\n        public boolean isvalid(int[] pos, int step) {\\n            for(int i=0;i<step;i++) {\\n                if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            }\\n            return true;\\n        } \\n    }\\n\\nessentially the same one:\\n#[Share. Java, 3ms, recurrsion, backtracing, very easy to understand. by Yuan__Yuan][2]#\\n\\n    public class Solution {\\n        public int totalNQueens(int n) {\\n            if (n == 0)\\n                return 0;\\n            int[] q = new int[n];\\n            return track(q, 0);\\n        }\\n        \\n        private int track(int[] q, int row) {\\n            if (row == q.length)\\n                return 1;\\n            int solutions = 0;\\n            for (int i = 0; i < q.length; i++) {\\n                q[row] = i;\\n                if (isValid(q, row, i)) {\\n                    solutions += track(q, row + 1);\\n                }\\n            }\\n            return solutions;\\n        }\\n        \\n        private boolean isValid(int[] q, int row, int col) {\\n            for (int i = 0; i < row; i++) {\\n                if (q[i] == col || Math.abs(row - i) == Math.abs(col - q[i]))\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\n#[My own tedious code][3]#\\n\\n    public class Solution {\\n        private int counter = 0;\\n        public int totalNQueens(int N) {\\n            for(int i=0; i<N; i++) {\\n                char[][] board = new char[N][N];\\n                board[i][0] = 'Q';\\n                solve(board, N, 1);\\n            }\\n            return counter;\\n        }\\n        private boolean isSafe(char[][] board, int N, int row, int col) {\\n            for(int i=0; i<N; i++) {\\n                if(board[i][col]!=0) return false;\\n                if(board[row][i]!=0) return false;\\n            }\\n        \\n            int step = 1;\\n            step = 1;\\n            while(row-step>=0 && col-step>=0) {\\n                if(board[row-step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            step = 1;\\n            while(row+step<N && col-step>=0) {\\n                if(board[row+step][col-step]!=0) return false;\\n                ++step;\\n            }\\n            return true;\\n        }\\n        private boolean solve(char[][] board, int N, int col) {\\n            if(col==N) {\\n                ++counter; \\n                return false;\\n            }\\n            for(int i=0; i<N; i++) {\\n                if(isSafe(board, N, i, col)) {\\n                    board[i][col] = 'Q';\\n                    if(solve(board, N, col+1)) return true;\\n                    else {\\n                        board[i][col] = 0;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n#[Pretty simple JAVA solution by EvelynGuo][4]#\\n\\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n    \\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n      }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }\\n\\nSimilar idea as above but better implementation:\\n\\n#[Easiest Java Solution (1ms, 98.22%) by yavinci][5]#\\n\\n    public class Solution {\\n        int count = 0;\\n        public int totalNQueens(int n) {\\n            boolean[] cols = new boolean[n];     // columns   |\\n            boolean[] d1 = new boolean[2 * n];   // diagonals \\\\\\n            boolean[] d2 = new boolean[2 * n];   // diagonals /\\n            backtracking(0, cols, d1, d2, n);\\n            return count;\\n        }\\n    \\n        public void backtracking(int row, boolean[] cols, boolean[] d1, boolean []d2, int n) {\\n            if(row == n) count++;\\n    \\n            for(int col = 0; col < n; col++) {\\n                int id1 = col - row + n;\\n                int id2 = col + row;\\n                if(cols[col] || d1[id1] || d2[id2]) continue;\\n    \\n                cols[col] = true; d1[id1] = true; d2[id2] = true;\\n                backtracking(row + 1, cols, d1, d2, n);\\n                cols[col] = false; d1[id1] = false; d2[id2] = false;\\n            }\\n        }\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/60251/java-accepted-clean-solutions-98-73%25\\n  [2]: https://leetcode.com/discuss/72502/share-java-3ms-recurrsion-backtracing-very-easy-understand\\n  [3]: https://leetcode.com/discuss/80748/java-almost-same-as-n-queens-i\\n  [4]: https://leetcode.com/discuss/63709/pretty-simple-java-solution\\n  [5]: https://leetcode.com/discuss/69603/easiest-java-solution-1ms-98-22%25",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        int count=0;\\n        public int totalNQueens(int n) {\\n            dfs(new int[n],0,n);\\n            return count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1237813,
                "title": "n-queens-ii-easy-solution-using-backtracking-w-explanation-and-visualization",
                "content": "This is very similar to [N-Queens](https://leetcode.com/problems/n-queens/) problem, with the only difference being that we are required to return count instead of all the solution boards. But both the solutions are almost the same.\\n\\n\\u2714\\uFE0F ***Solution - I (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we dont need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, **on each row only one queen** can be placed and then we can move to the next row.\\n\\nSo for each row we will to place one queen without violating the constraint and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to placed at *`(i, j)`*. If all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place the queen on the same row at some other column, i.e, we need to **backtrack**. This will give us all the possible ways to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) of how this process works -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Space Complexity :*** **`O(N*N)`**. Required for board and recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Backtracking O(N) Space)***\\n\\nWe don\\'t need to simulate the exact board since we only require number of solutions and not the exact board solutions themselves. \\n\\nHere, we only keep track of queen placements on each of *`n`* columns, *`2n-1`* diagonals and *`2n-1`* anti-diagonals. This will eliminate the need to iterative *`check`* function and reduc space usage\\n\\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack and *`col`*, *`diag`*, *`anti_diag`*\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Backtracking + Bitset O(N))***\\n\\nSlight optimization using bitset in C++, although it won\\'t make much of difference in space usage since it\\'s dominated by recursive stack space usage.\\n\\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**, for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Backtracking + Bit-Manipulation)***\\n\\nDirect bit-manipulation instead of using bitset -\\n\\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src = https://assets.leetcode.com/users/images/abb6caae-6ffd-4062-8244-73bd3703cfb8_1622279017.2683792.png /></td></tr></table>\\n\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n}\\nbool check(vector<vector<bool>>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i <= row; i++) {\\n\\t\\tif(board[i][col]) return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking if all diagonals are safe -\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t}\\n\\treturn true;\\n}    \\nint solve(vector<vector<bool>>& board, int row) {\\n\\tif(row == size(board)) return 1;\\n\\tint count = 0;\\n\\tfor(int col = 0; col < size(board); col++)           \\n\\t\\tif(check(board, row, col)){          // check if we can place at (row, col)\\n\\t\\t\\tboard[row][col] = true;          // place the queen at (row, col)\\n\\t\\t\\tcount += solve(board, row + 1);  // explore for the next row. The function will return 1 if all N queens get placed for current combination\\n\\t\\t\\tboard[row][col] = false;         // backtrack - remove previously placed queen and try for different columns\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tvector<bool> col(n), diag(2*n-1), anti_diag(2*n-1);\\n\\treturn solve(col, diag, anti_diag, 0);\\n}\\n   \\nint solve(vector<bool>& col, vector<bool>& diag, vector<bool>& anti_diag, int row) {\\n\\tint n = size(col), count = 0;\\n    if(row == n) return 1;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){        // check if (row, column) is safe\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = true;      // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1);                                  // explore for the next row\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = false;     // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n) {\\n\\tbitset<17> col, diag, anti_diag;\\n\\treturn solve(col, diag, anti_diag, 0, n);\\n}  \\nint solve(bitset<17>& col, bitset<17>& diag, bitset<17>& anti_diag, int row, int n) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++)           \\n\\t\\tif(!col[column] && !diag[row + column] && !anti_diag[row - column + n - 1]){\\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 1;    // place at (row, column)\\n\\t\\t\\tcount += solve(col, diag, anti_diag, row + 1, n);                          // explore for the next row. \\n\\t\\t\\tcol[column] = diag[row + column] = anti_diag[row - column + n - 1] = 0;    // backtrack\\n\\t\\t}                                \\n\\treturn count;\\n}\\n```\n```\\nint totalNQueens(int n, int row = 0, int col = 0, int diag = 0, int anti_diag = 0) {\\n    if(row == n) return 1;\\n    int count = 0;\\n\\tfor(int column = 0; column < n; column++) {\\n        int col_mask = 1 << column, diag_mask = 1 << row + column, anti_diag_mask = 1 << row - column + n - 1;\\n        if(!(col & col_mask) && !(diag & diag_mask) && !(anti_diag & anti_diag_mask))\\n\\t\\t\\tcount += totalNQueens(n, row + 1, col | col_mask, diag | diag_mask, anti_diag | anti_diag_mask);\\n    }\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111854,
                "title": "java-branch-and-bound-method-easy-optimized-solu-faster-than-98",
                "content": "**Upvote if u find this solution good**\\n```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public void total(int row ,int n , boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol){\\n        if(row==n){\\n            count++;\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                total(row+1,n,cols,nDiagnol,rDiagnol);\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n     boolean[] cols = new boolean[n];\\n     boolean[] nDiagnol = new boolean[2*n-1];\\n     boolean[] rDiagnol = new boolean[2*n-1];\\n        total(0,n,cols,nDiagnol,rDiagnol);\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237781,
                "title": "n-queens-ii-js-python-java-c-easy-recursive-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n_(**Note**: This problem is an easier duplicate to the previous problem, [**51: N-Queens**](https://leetcode.com/problems/n-queens), except that it doesn\\'t require us to return the actual boards, just the count.)_\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the board.\\n\\nRather than store the whole board, we can save on **space complexity** if we only keep track of the different axes of attack in which a queen might be placed. Since a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity.\\n\\nThere are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nIf we successfully reach the end of the board without failing, we should increment our answer counter (**ans**).\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N)** for the recursion stack_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.0MB** (beats 100% / 99%).\\n```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **44ms / 13.9MB** (beats 90% / 99%).\\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 35.2MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar totalNQueens = function(N) {\\n    let ans = 0\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) ans++\\n        else for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def totalNQueens(self, N: int) -> int:\\n        self.ans = 0\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N: self.ans += 1\\n            else:\\n                for j in range(N):\\n                    vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                    if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                    place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            \\n        place(0,0,0,0)\\n        return self.ans\\n```\n```java\\nclass Solution {\\n    int ans;\\n    \\n    public int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n    \\nprivate:\\n    int ans;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551698,
                "title": "java-tc-o-n-n-sc-o-n-space-optimized-backtracking-using-bitset",
                "content": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other N-Queens questions on LeetCode:\\n- [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/1551695/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Space-Optimized-Backtracking-using-BitSet)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n\\n        return totalNQueensHelper(new BitSet(5 * n), 0, n);\\n    }\\n\\n    private int totalNQueensHelper(BitSet occupied, int row, int n) {\\n        if (row == n) {\\n            return 1;\\n        }\\n\\n        int count = 0;\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n\\n            count += totalNQueensHelper(occupied, row + 1, n);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111511,
                "title": "backtracking-and-bit-manipulation-explained",
                "content": "### Logic:\\nThis problem is essentially the original [N-Queens](https://leetcode.com/problems/n-queens/) problem but made simpler in that we don\\'t need to keep track of board state! Otherwise, the approach is identitical; attempt all valid board states through **backtracking**.\\n\\nSince the explanation still applies, I will use the same diagrammatic explanation as I did in the original N-Queens problem.\\n\\nFirst, we need to understand how a Queen moves and what constitutes a valid position. Queen\\'s can move in literally any straight-lined direction. \\n\\n![image](https://assets.leetcode.com/users/images/b51628d9-0917-45db-a2b7-823ece81a8c1_1654307228.4397633.png)\\n\\nIt\\'s possibe to place a Queen down if and only if:\\n* There exists no Queen on the current row.\\n* There exists no Queen on the current column.\\n* There exists no Queen on the current diagonal.\\n* There exists no Queen on the current anti-diagonal.\\n\\n> Backtracking: Try a promising Queen position, see how it goes. If it fails, undo that Queen and try again somewhere else.\\n\\n![image](https://assets.leetcode.com/users/images/ca380113-d402-4c1e-a21d-a632196a39fd_1654307245.1164281.png)\\n\\n\\nHopefull it\\'s now clear that we need some way to keep track of Queens on previous rows, columns and diagonals. We can take care of rows automatically by incrementing each queen placement by row. In other words, after each successful Queen placement, we move to the next row (since no two Queens can share the same row).\\nWe can keep track of previous columns just by their column indexes. What about the diagonals? Well here\\'s an interesting observation:\\n\\n![image](https://assets.leetcode.com/users/images/e88b8d70-250d-48bd-bf75-ce265e69b7d4_1654307264.8783712.png)\\n\\n\\n(the \"+N\" is to offset negative values. You will see why we do this in the next section). Now we have everything we need to keep track of previous Queens and start thinking about our algorithm! But just one more thing; let\\'s keep track of \"used\" columns and diagonals using bit masks.\\n\\n___\\n### Why Integer Bit Masks?\\nWe prefer integer bitmasks in this question for 2 main reasons:\\n1. Sets in Java are a slow datastructure. So keeping track of visited columns and diagonals using integers is much quicker through bit manipulation!\\n2. It\\'s slightly more space efficient since we\\'re only storing three integers instead of arrays or other datastructures. \\n\\n### Bit Manipulation Tricks\\n1. **Check the ith bit:** `x & (1 << i)`, where `1 << i` is shifting 1 to the left i number of times.\\n\\tFor example, if we want to check if a Queen exists at column 5, we can check if (cols & (1 << 5) != 0). Basically, if we haven\\'t seen a Queen at this column before, then the bitwise AND operation at that specific bit will be 0. Otherwise, it will be a non-zero value.\\n2. **Set the ith bit:** `x |= (1 << i)`. This performs a bitwise OR operation on the ith bit. This will always set the ith bit to 1. For example, if the ith bit in `cols` is currently 1, then 1 | 1 = 1. If it\\'s set to 0, then 0 | 0 is still = 1.\\n3. **Flip the ith bit:** `x ^= (1 << i)` To reverse the previous action, we use the inverse logic of an OR; a bitwise XOR (exclusive-OR).  The basic idea of XOR is that if two bits are the same (0,0) and (1,1), you will get 0. However if the two bits are different (1,0) or (0,1), you get 1. This is the exact opposite of OR, hence the name. \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n**Time Complexity:** `O(N!)` since we look for every valid board state.\\n**Space Complexity:** `O(N)` due to the recursive call stack.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```java\\nclass Solution {\\n\\tpublic int totalNQueens(int n) {\\n        return backtrack(0, 0, 0, 0, n);\\n    }\\n    \\n    private int backtrack(int row, int cols, int diags, int antiDiags, int N) {\\n\\t\\t// If we\\'re at row N, we\\'ve finished placing all N queens. Therefore, we\\'ve reached a new valid position.\\n        if (row == N) return 1;\\n        \\n        int total = 0;\\n        for (int col=0; col<N; col++) {\\n            int diag = row - col + N;\\n            int antiDiag = row + col;\\n            \\n\\t\\t\\t// Check if it\\'s possible to place a Queen at this point\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << diag)) != 0 || (antiDiags & (1 << antiDiag)) != 0) continue;\\n            \\n\\t\\t\\t// If so, apply changes to the columns and diagonals\\n            cols |= 1 << col;\\n            diags |= 1 << diag;\\n            antiDiags |= 1 << antiDiag;\\n            \\n\\t\\t\\t// Continue to the next row\\n            total += backtrack(row + 1, cols, diags, antiDiags, N);\\n            \\n\\t\\t\\t// Undo changes and try another position\\n            cols ^= 1 << col;\\n            diags ^= 1 << diag;\\n            antiDiags ^= 1 << antiDiag;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718314,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res = 0, stack = [(Array(repeating: 0, count: n), 0)]\\n        \\n        while !stack.isEmpty {\\n            var cur = stack.removeLast(), row = cur.0, idx = cur.1\\n            if idx == row.count { res += 1; continue }\\n            for i in 0..<n {\\n                row[idx] = i\\n                if !detect(idx) { stack.append((row, idx + 1)) }\\n            }\\n            func detect(_ i: Int) -> Bool {\\n                var idx = i - 1\\n                while idx >= 0 {\\n                    let lhs = row[idx], rhs = row[i]\\n                    if lhs == rhs || abs(lhs - rhs) == (i - idx) { return true }\\n                    idx -= 1\\n                }\\n                return false\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // There are two distinct solutions to the 4-queens puzzle as shown.\\n    func test0() {\\n        let value = solution.totalNQueens(4)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.totalNQueens(1)\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20094,
                "title": "a-classic-c-solution-using-bitwise-operations-0ms",
                "content": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "The code is very short and simple:\\n\\n    int next(int row, unsigned int vertMask, unsigned int leftMask, unsigned int rightMask, unsigned int rangeMask) {\\n        if (row == 0)\\n            return 1;\\n            \\n        unsigned int mask = rangeMask & ~(leftMask | rightMask | vertMask);\\n        int r = 0;\\n        while (mask) {\\n            unsigned int queenFlag = mask & -mask;\\n            r += next(\\n                    row-1, \\n                    (  vertMask | queenFlag ), \\n                    (  leftMask | queenFlag ) << 1, \\n                    ( rightMask | queenFlag ) >> 1, \\n                    rangeMask\\n                );\\n            mask ^= queenFlag;\\n        }\\n        return r;\\n    }\\n\\n    int totalNQueens(int n) {\\n        return next(n, 0, 0, 0, ((unsigned int)-1) >> (32-n));\\n    }\\n    \\n\\nThe main idea is each bit represent a position. If a bit is set to 1, it means this position is unavailable to put a queen into. So with 32-bit integer this way can solve no more than 32-queens problem. \\n\\nAssume current is first row, and N == 5. So rangeMask will be 0b 0001 1111. \\nThis line\\n\\nmask = rangeMask & ~(leftMask | rightMask | vertMask)\\n\\nmake available bits set to 1. So mask = 0b 0001 1111. mask & -mask is a trick to get the lowest 1-bit. Now set a queen at position queenFlag, and try next row.\\n\\nAssume row N has a queen at column 3. The arguments for next(N-1, ...) will be:\\n\\nTo shift left/right queenFlag by 1 will make the positions the queen could attack to set to 1. I set the masks' type to unsigned to avoid signed right shift could cause a bug when N = 32.",
                "codeTag": "Unknown"
            },
            {
                "id": 2114337,
                "title": "java-two-approaches-with-detailed-explanation",
                "content": "**Approach 1:**\\n\\n**Logic:**\\nN-Queens II is just an extension of N-Queens I rather much more easier I have just made a single change in my entire code which is rather than returning the ans array i returned the ans.size as the question asked for it..\\n**Do have a look at my N-Queens I soln which is explained in detail to understand this approach**\\nhttps://leetcode.com/problems/n-queens/discuss/2109925/java-backtracking-detailed-explanation-with-pictures-easycode\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\\n\\n**Approach 2:(More Optimized)**\\nHere we create three Sets for every used column index ,used 45degree angle and used 135 degree angle and for every valid position we update the position in the three sets \\n**Logic:**\\n* We continue the above stated idea till we found that the current row is equal to the number of rows in the board\\n* Firstly we iterate through every column if we find the current position of row,col is a valid position we continue the process\\n* We then update the three sets \\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\\n* Then we call the same function recursively and then remove the values which were added in the sets\\n\\n**Helper methods used-->**\\n**validCounter -->** places the queen at valid positions and then calls the validPosition function to check for validity and then update it in the set and recursively calls itself\\n**validPosition -->** checks whether the queen can be placed at that position or not\\n\\n**Code -->**\\n**Java**\\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans.size();\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\n```\\n\\tcolIndex with the col value\\n \\tdegree135 with the row-col value\\n\\tdegree45 with the row+col value\\n```\n```\\nclass Solution {\\n    \\n    private Set<Integer> colIndex = new HashSet<Integer>();\\n    private Set<Integer> degree45 = new HashSet<Integer>();\\n    private Set<Integer> degree135 = new HashSet<Integer>();\\n    \\n    private int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        validCounter(n,0);\\n        return count;\\n    }\\n    \\n    public void validCounter(int n, int row)\\n    {\\n        if(row == n)\\n        {\\n            count++;\\n            return;\\n        }\\n        else\\n        {\\n            for(int col=0;col<n;col++)\\n            {\\n                if(validPosition(row,col))\\n                {\\n                    colIndex.add(col);\\n                    degree135.add(row-col);\\n                    degree45.add(row+col);\\n                    \\n                    validCounter(n,row+1);  //recursive calling\\n                    \\n                    colIndex.remove(col);\\n                    degree135.remove(row-col);\\n                    degree45.remove(row+col);\\n                }\\n            }\\n        }\\n    }\\n    private boolean validPosition(int row,int col)\\n    {\\n        if(colIndex.contains(col) || degree135.contains(row-col) || degree45.contains(row+col))\\n            return false;\\n        else\\n            return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111563,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2411afa6-d051-4373-b850-dc589989c8bf_1654391362.3126545.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909458,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        var res: [[Int]] = []\\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path) }\\n            \\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                \\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.count\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367756,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }\\n        }\\n        placeQueen(n,Board,0);\\n        return cnt;\\n    }\\n    public void placeQueen(int n, char Board[][],int row)\\n    {\\n        //Base Case\\n        if(row==n)\\n        {\\n            cnt++;\\n            return;\\n        }\\n         for(int col=0;col<n;col++)\\n         {\\n             if(canPlaceQueen(n,Board,row, col))\\n             {\\n                 Board[row][col]=\\'Q\\';\\n                 placeQueen(n,Board,row+1);\\n                 Board[row][col]=\\'.\\';\\n             }\\n         }\\n        \\n    }\\n    public Boolean canPlaceQueen(int n,char Board[][],int row, int col)\\n    {\\n       // check all rows for the current column\\n        for (int i = 0; i < row; i++) \\n        {\\n            if (Board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //check for 45 degree positions\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        //check for 135 positions\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int cnt=0;\\n    public int totalNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 470018,
                "title": "c-100-speed-100-space-o-1-solution",
                "content": "\\tclass Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint cur=1<<i;\\n\\t\\t\\t\\tif((cur&r) || (cur&d1) || (cur&d2)) continue;\\n\\t\\t\\t\\tdfs(n,dep+1, (cur|r),(cur|d1)<<1,(cur|d2)>>1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tres=0;\\n\\t\\t\\tdfs(n,0,0,0,0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {  \\n\\tprivate:\\n\\t\\tint res;\\n\\tpublic:\\n\\t\\tvoid dfs(int n,int dep,int r,int d1, int d2){\\n\\t\\t\\tif(dep==n){\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1237765,
                "title": "python-backtracking-clean-concise-o-n",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(N!)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(c, rowSet, mainDiagSet, antiDiagSet):\\n            nonlocal ans\\n            if c == n:\\n                ans += 1\\n                return\\n            for r in range(n):\\n                if r not in rowSet and (r-c) not in mainDiagSet and (r+c) not in antiDiagSet:\\n                    rowSet.add(r)\\n                    mainDiagSet.add(r-c)\\n                    antiDiagSet.add(r+c)\\n                    backtrack(c + 1, rowSet, mainDiagSet, antiDiagSet)\\n                    rowSet.remove(r)\\n                    mainDiagSet.remove(r-c)\\n                    antiDiagSet.remove(r+c)\\n            \\n        ans = 0\\n        backtrack(0, set(), set(), set())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544297,
                "title": "javascript-48ms-backtracking",
                "content": "- Time Complexity: O(N!)\\n- Space Complexity: O(N)\\n```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set(),\\n          hills = new Set(),\\n          dales = new Set();\\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {boolean}\\n     */\\n    const isSafe = (row, col) => !(cols.has(col) || hills.has(row - col) || dales.has(row + col));\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const placeQueen = (row, col) => {\\n        cols.add(col), hills.add(row - col), dales.add(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} col\\n     * @return {void}\\n     */\\n    const removeQueen = (row, col) => {\\n        cols.delete(col), hills.delete(row - col), dales.delete(row + col);\\n    }\\n    \\n    /**\\n     * @param {number} row\\n     * @param {number} count\\n     * @return {number}\\n     */\\n    const backtrackQueen = (row, count) => {\\n        if (row === n) {\\n            return ++count;\\n        }\\n        for (let col = 0; col < n; col++) {\\n            if (isSafe(row, col)) {\\n                placeQueen(row, col);\\n                count = backtrackQueen(row + 1, count);\\n                removeQueen(row, col);\\n            }\\n        }\\n        return count;\\n    }\\n    return backtrackQueen(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111576,
                "title": "java-clean-easy-explained",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach ,\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* **COLUMN_WISE** FILLING = Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n*  **ROW_WISE** FILLING = Only upper part of the diagonals are checked as positions below of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n\\n\\n**UPVOTE IF HELPFUL**\\n```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/5dec5b54-2976-4bb0-9569-fea033425a49_1654392303.9171877.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    int count = 0;\\n    \\n    public int totalNQueens(int n) {\\n        dfs(0, n, 0, 0, 0);\\n        return count;\\n    }\\n    \\n    private void dfs(int row, int n, int column, int diag, int antiDiag) {\\n        if (row == n) {\\n            ++count;\\n            return;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            boolean isColSafe = ((1 << i) & column) == 0;\\n            boolean isDiagSafe = ((1 << (n - 1 + row - i)) & diag) == 0;\\n            boolean isAntiDiagSafe = ((1 << (row + i)) & antiDiag) == 0;\\n            if (isColSafe && isDiagSafe && isAntiDiagSafe) {\\n                dfs(row + 1, n, (1 << i) | column, (1 << (n - 1 + row - i)) | diag, (1 << (row + i)) | antiDiag);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413249,
                "title": "my-easy-understand-n-queens-solutions-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/n-queens/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n\\n## Problem\\n\\n> The n-queens puzzle is the problem of placing `n` queens on an `n\\xD7n` chessboard such that no two queens attack each other.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/rk4qd.jpg \"From LeetCode\")\\n\\n> Given an integer `n`, return all distinct solutions to the n-queens puzzle.\\n\\n> Each solution contains a distinct board configuration of the n-queens\\' placement, where `Q` and `.` both indicate a queen and an empty space respectively.\\n\\n**Note:** A queen can attack other queens that are at the same `row` or `column` or at the `diagonal` line.\\n\\n**Example:** \\n\\n```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nEnumerate all possible placements of queens on a `nxn` chessboard and check if each is valid.\\n\\n**Time:** `O(N^N)`\\n**Space:** `O(1)` if we do not consider the output list.\\n\\n\\n### Backtracking\\n\\nThe basic idea is to examine each row and use an array `attack` to restrict the possibilities in the future searching.\\n\\nCheck out the comments. Be careful about the following aspects:\\n\\n- Why will we stop? In other words, what is the base case?\\n- How do we make string generation more efficiently? `StringBuilder`\\n- Why should we initialize `attack` array with `int` type rather than `boolean`?\\n\\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\\n\\nThe graph is from LeetCode solution section.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1sasw.jpg)\\n\\nEach time we pick a queen `(i, j)` we need to update all the attacked positions below it, which include three cases as shown in the graph:\\n\\n- Left-Below positions\\n- Below positions\\n- Right-Below positions\\n\\nNotice that we cannot use `boolean` since some attacked positions might be overlapped.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/owjlb.png)\\n\\nIn the example above, when we restore attacked position for queen `B`, the orange position will be restored to no-attack state if we use `true/false`; however, it is still under attack by queen `A`.\\n\\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a2rtf.jpg)\\n\\n**Time:** `O(N x N!)`. There is `N` possibilities to put the first queen, then no more than `N(N-2)` to put the second one, and no more than `N(N-2)(N-4)` to put the third one, and so forth. In total, there are `N` layers. The number of calls of `backtracking` at each layer is upper bounded by `N!`. (not consider string construction)\\n**Space:** `O(N^2)` since there are call stacks and `attack` array (do not consider output).\\n\\nThe space complexity can be optimized by using `N`-size array `rows`, `dale`, and `hill`. Each element of them denotes a specific vertical line or diagonal line that a queen can attack.\\n\\nFrom LeetCode solution section:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/oujkh.jpg)\\n\\n\\n\\n\\n## N-Queens II\\n\\nReturns the number of solutions. Modify based on the above solution.\\n\\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20114,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }\\n        /** n:#-of-rows   row:current-#-of-row  solution:store-n-row's-col-index result:final result**/\\n        void help(int n, int row, vector<int>& solution, int& result){\\n            for(int i=0; i<n; i++){\\n                if(check(i, row, solution)){\\n                    if(row+1==n){\\n                        result++;\\n                        continue;\\n                    }\\n                    solution[row]=i;\\n                    help(n, row+1, solution, result);\\n                }\\n            }\\n        }\\n        /*** check the cur-col-choise is valid or not **/\\n        bool check(int col, int row, vector<int>& solution){\\n            for(int i=0; i<row; i++){\\n                if(col==solution[i] || abs(col-solution[i])==abs(row-i))  \\n                    return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int totalNQueens(int n) {\\n            int result=0;\\n            vector<int> solution(n);\\n            help(n, 0, solution, result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20128,
                "title": "shortest-c-solution-in-0ms",
                "content": "Idea is to  use vectors to keep track of invalid positions , so validity can be checked in O(1) and put a queen in each column\\n     \\n    #include<vector>\\n    using namespace std;\\n    class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }\\n            return sum;\\n        }\\n        int totalNQueens(int n) {\\n            vector<int>  rows(n),d1(2*n-1),d2(2*n-1);\\n            return find(n,n,0,0,rows,d1,d2);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int find(int n, int left, int i, int r, vector<int>&rows,vector<int>&d1,vector<int>&d2){\\n            if (left == 0)\\n                return 1;\\n            int j,sum=0;\\n                for (j=r; j<n; j++){\\n                    if (rows[j] || d1[i+j] || d2[n-1+i-j])\\n                        continue;\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=1;\\n                    sum += find(n, left-1, i+1, 0,rows,d1,d2 );\\n                    rows[j]=d1[i+j]=d2[n-1+i-j]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3315464,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```\\n\\n#   please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        res,col,pos,neg=0,set(),set(),set()\\n        def backtracking(r):\\n            if n==r:\\n                nonlocal res\\n                res+=1\\n            for c in range(n):\\n                if c in col or (c+r) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                backtracking(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n        backtracking(0)\\n        return res\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115356,
                "title": "c-backtracking-simple",
                "content": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114396,
                "title": "easy-recursive-solution",
                "content": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic int TotalNQueens(int n)\\n{\\n\\tint count = 0;\\n\\tvar rows = new bool[n];\\n\\tvar diag1 = new bool[2 * n];\\n\\tvar diag2 = new bool[2 * n];\\n\\n\\tHelper(0); // start with the first column\\n\\n\\treturn count;\\n\\n\\tvoid Helper(int col)\\n\\t{\\n\\t\\tif (col == n) count++; // successfully placed n queens\\n\\t\\t// in case col == n, we could return right away, but it is also alright to go on\\n\\n\\t\\tfor (int row = 0; row < n; row++)\\n\\t\\t{\\n\\t\\t\\tint a = row + col;\\n\\t\\t\\tint b = row - col + n;\\n\\n\\t\\t\\tif (rows[row] || diag1[a] || diag2[b]) continue; // unable to place a queen\\n\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = true;  // place a queen\\n\\t\\t\\tHelper(col + 1);                         // go to the next column\\n\\t\\t\\trows[row] = diag1[a] = diag2[b] = false; // remove the queen\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113239,
                "title": "easy-c-sol-backtracking-recursion-time-o-n-n",
                "content": "```\\nclass Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row = 0; row<n; row++){\\n            \\n            if(leftRow[row] == 0 && lowerDiagonal[row+col] == 0 && upperDiagonal[n-1+col-row] == 0){\\n                \\n                board[row][col] = \\'Q\\';\\n                leftRow[row] = 1;\\n                lowerDiagonal[row+col] = 1;\\n                upperDiagonal[n-1 + col - row] = 1;\\n                solve(col+1,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\\n                \\n                board[row][col] = \\'.\\';\\n                leftRow[row] = 0;\\n                lowerDiagonal[row+col] = 0;\\n                upperDiagonal[n-1+col-row] = 0;\\n                \\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n         vector<vector<string>> res;\\n        vector<string> board(n);\\n        \\n        string s(n,\\'.\\');\\n        \\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        \\n        vector<int> leftRow(n,0),upperDiagonal(2*n-1,0),lowerDiagonal(2*n-1,0);\\n        solve(0,board,res,leftRow,upperDiagonal,lowerDiagonal,n);\\n        \\n        int ans = res.size();\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {  //Time : O(N!*N)\\npublic:\\n    \\n     void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111570,
                "title": "backtracking-explained",
                "content": "**UPVOTE IF HELPFUL**\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652274,
                "title": "beats-99-20-32ms-clean-recursive-solution-in-python",
                "content": "This solution is basically the same as the solution introduced in the article, but I condensed it into 10 lines of code to look more compact.\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int: \\n        def rec(col, horizontal, diag, anti_diag):\\n            if col == n: return 1\\n            res = 0\\n            for row in range(n):\\n                if row not in horizontal and (row + col) not in diag and (row - col) not in anti_diag:\\n                    horizontal[row] = True; diag[row + col] = True; anti_diag[row - col] = True;\\n                    res += rec(col + 1, horizontal, diag, anti_diag)\\n                    del horizontal[row]; del diag[row + col]; del anti_diag[row - col];\\n            return res\\n        return rec(0, {}, {}, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20141,
                "title": "never-write-codes-like-this-lets-do-eval",
                "content": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Following codes got AC. But you should never write some codes like this. This is post is just for joking.\\n\\n    /**\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var totalNQueens = function(n) {\\n        var p = '', s = 0, l;\\n        for (var i = 0; i < n; i++) {\\n            l = '\\\\nfor (var s# = 0; s# < ' + n + '; s#++)';\\n            for (var j = 0; j < i; j++)\\n                l += 'if (s# !== s@ && Math.abs(s# - s@) !== (# - @)) '.replace(/@/g, j);\\n            p += l.replace(/#/g, i);\\n        }\\n        p += '\\\\ns++;\\\\ns';\\n        return eval(p);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3764197,
                "title": "backtracking-logic-solution",
                "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587899,
                "title": "striver-type-c-most-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115617,
                "title": "javascript-efficient-solution-meme",
                "content": "There is canonic solution with backtracking for the nQueen problem. You can read more on Wikepedia, or even find a video with detailed explanation, **my role here is rather give you a meme**.\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#9 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/6642a7a4-3d37-4a24-bcdd-6e3db52c05fd_1654456097.356457.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalNQueens = function(n) {\\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    let solutionCount = 0;\\n    \\n    function computePositionForRow(row) {\\n        if (row === n) {\\n            solutionCount += 1;\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            \\n            computePositionForRow(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n        }\\n    }\\n    \\n    computePositionForRow(0);\\n    \\n    return solutionCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111566,
                "title": "explanation-understandable",
                "content": "**UPVOTE IF HELPFUL**\\n\\nWe first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n**UPVOTE IF HELPFUL**\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```\\n![image](https://assets.leetcode.com/users/images/2626719c-e537-443c-90c8-afc1ae43d2e6_1654391433.2912345.jpeg)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> List[List[str]]:\\n        def validMove(board,row,col):\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        def solve(board,col):\\n            if (col==n):\\n                res[0]+=1\\n                return\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[0]\\n        board=[]\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441898,
                "title": "c-soln-backtracking",
                "content": "Same as N-Queens I \\njust return the size of the vector used to keep possible solution of board\\n\\n```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // this vector keeps possible board configurations\\n vector<vector<string>> res;\\n    \\n// checks whether the position is safe for queen or not\\n    bool is_Safe(vector<string>& board , int row , int column)\\n    {\\n        for(int index = row ; index >= 0 ; index--)\\n            if(board[index][column] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex >=0 ; index-- , jindex--)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        for(int index = row , jindex = column ; index >= 0 && jindex < board.size() ; index-- , jindex++)\\n            if(board[index][jindex] == \\'Q\\')\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    // checks all possible configurations by backtracking\\n    void placequeen(vector<string>& board , int row)\\n    {\\n        if(row == board.size())\\n        {\\n            res.push_back(board);\\n            return;\\n        }\\n        \\n        for(int index = 0 ; index < board.size() ; index++)\\n        {\\n            if(is_Safe(board , row , index))\\n            {\\n                \\n                board[row][index] = \\'Q\\';\\n                placequeen(board , row + 1);\\n                board[row][index] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    int totalNQueens(int n) {\\n\\n         if(n <= 0)\\n            return res.size();\\n        \\n        vector<string> board(n,string(n,\\'.\\'));\\n        placequeen(board,0);\\n        \\n        return res.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839035,
                "title": "clean-java-solution",
                "content": "The idea is that along the diagonals, the (row, col) tuple follows the sequence (i,j), (i+1, j+1), ..., so col - row is constant for a diagonal. Similarly, along cross diagonals, (row,col) tuple follows the sequence (i,j), (i+1, j-i), (i+2, j-2), hence row+col is constant for a cross diagonal. Using this idea, a valid position can be checked in constant time\\n```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    private int numSolutions = 0;\\n    public Solution() {        \\n    }\\n    public int totalNQueens(int n) { \\n        tryQueenPlacement(0, new ChessBoard(n));\\n        return numSolutions;\\n    }\\n    \\n    private void tryQueenPlacement(int i, ChessBoard board) {\\n        if(i == board.size()) {\\n            ++numSolutions;\\n            return;\\n        }\\n        for(int j = 0; j < board.size(); j++) {\\n            if(board.isValidQueenPosition(i, j)) {\\n                board.placeQueen(i, j);\\n                tryQueenPlacement(i+1, board);                                                   \\n                board.removeQueen(i, j);\\n            }                   \\n        }\\n    }\\n    \\n    class ChessBoard{\\n        private final int boardSize;\\n        private int[] cols;\\n        private int[] diagonals;\\n        private int[] crossDiagonals;\\n        ChessBoard(int n) {\\n            this.boardSize = n;            \\n            reset(n);\\n        }\\n        \\n        int size() {\\n            return boardSize;\\n        }\\n        \\n        void reset(int boardSize) {\\n            this.cols = new int[boardSize];\\n            this.diagonals = new int[2*boardSize - 1];\\n            this.crossDiagonals = new int[2*boardSize - 1];\\n        }\\n        \\n        boolean isValidQueenPosition(int i, int j) {\\n            if(cols[j] == 1 || diagonals[j-i + (boardSize - 1)] == 1 || crossDiagonals[j+i] == 1) {\\n                return false;\\n            } \\n            return true;\\n        }\\n    \\n        void placeQueen(int i, int j) {\\n            cols[j] = 1;\\n            diagonals[j-i + (boardSize - 1)] = 1;\\n            crossDiagonals[j+i] = 1;\\n        }\\n\\n        void removeQueen(int i, int j) {\\n            cols[j] = 0;\\n            diagonals[j-i + (boardSize - 1)] = 0;\\n            crossDiagonals[j+i] = 0;\\n        }                  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609947,
                "title": "not-the-fastest-in-leetcode-complier-but-the-simple-and-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int cnt = 0;\\n        vector<int> curPos;\\n\\n        totalNQueens(n, curPos, &cnt);\\n\\n        return cnt;\\n    }\\n    \\n    bool isColValid(vector<int>& curPos, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (curPos[row] == curCol) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPosValid(vector<int>& curPos, int curRow, int curCol) {\\n        for (int row = 0; row < curPos.size(); row++) {\\n            if (abs(curPos[row] - curCol) == abs(row - curRow) ) return false;\\n        }\\n        return true;\\n    }\\n    \\n    void totalNQueens(int n, vector<int>& curPos, int* cnt) {\\n        // BASE CASE\\n        if (curPos.size() == n) {\\n            *cnt += 1;\\n            return;\\n        }\\n        \\n        for (int col = 0; col < n; col++) {\\n            if (!isColValid(curPos, col)) continue;\\n            if (!isPosValid(curPos, curPos.size(), col)) continue;\\n            // Positions valid\\n            // and to the correct postions\\n            curPos.push_back(col);\\n            totalNQueens(n, curPos, cnt);\\n            // delete this position\\n            curPos.pop_back();\\n             \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243444,
                "title": "python-solution",
                "content": "We use the backtracking algorithm. Initialize the result `res = 0`. We use three sets `cols`, `diag` and `off_diag` to keep track of the columns, diagonals, and off-diagonals that have been occupied in the current state of the board. We define a recursive `backtrack` function which counts all valid configurations of the board, and increment `res` by `1` if a configuration is valid. More specifically, `backtrack(i)` enumerates all valid positions that the queen can be put in the `i`th row. For each valid position, we add the column, diagonal and off-diagonal occupied by the position to `cols`, `diag`, and `off_diag`, respectively, and recursively call `backtrack(i+1)`, until `i == n`, in which case we know that the current state of the board represents a valid configuration of the `n` queens, and we increment `res` by `1`. Finally, we return `res`.\\n\\nTime complexity: `O(n!)`, space complexity: `O(n)`. \\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def backtrack(i):\\n            if i == n:\\n                return 1\\n            res = 0\\n            for j in range(n):\\n                if j not in cols and i-j not in diag and i+j not in off_diag:\\n                    cols.add(j)\\n                    diag.add(i-j)\\n                    off_diag.add(i+j)\\n                    res += backtrack(i+1)\\n                    off_diag.remove(i+j)\\n                    diag.remove(i-j)\\n                    cols.remove(j)\\n            return res\\n       \\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        return backtrack(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807847,
                "title": "c-recursive-backtracking-bitmask-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a very classical problem; ans there is no math formula known to solve it!\\n\\n2 codes are given. One uses ordinary backtracking with boolean arrays.  The other uses bimasks insteads of boolean arrays.\\n\\nThe code solves the N-Queens problem by recursively placing queens on a chessboard. It uses backtracking and checks for valid positions to avoid conflicts. The solutions are stored in a vector and returned. The code initializes the chessboard, sets flags for occupied columns, diagonals, and anti-diagonals, and finds all valid solutions using a recursive function. \\n\\nSimilar question:\\n[51. N-Queens\\n](https://leetcode.com/problems/n-queens/solutions/3713298/c-recursive-backtracking-bool-vector-vs-bitmask-beasts-100/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)\\n\\n```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\\nvectors col, antidiag, and diag are used as boolean flags to keep track of occupied columns, anti-diagonals, and diagonals, respectively.\\n\\nHere\\'s a breakdown of each vector\\'s purpose:\\n\\ncol: This vector represents the occupied columns on the chessboard. Each element in the vector corresponds to a column on the board. If col[j] is true, it means that column j is already occupied by a queen. Otherwise, if col[j] is false, the column is available for placing a queen.\\n\\nantidiag: This vector represents the occupied anti-diagonals on the chessboard. An anti-diagonal is a diagonal line that runs from the top-right to the bottom-left of the chessboard. The length of the anti-diagonals is 2*n - 1, where n is the number of rows/columns. Each element in the vector corresponds to an anti-diagonal on the board. If antidiag[i+j] is true, it means that the anti-diagonal i+j is already occupied by a queen. If antidiag[i+j] is false, the anti-diagonal is available for placing a queen.\\n\\ndiag: This vector represents the occupied diagonals on the chessboard. A diagonal is a line that runs from the top-left to the bottom-right of the chessboard. Similar to the antidiag vector, the length of the diagonals is also 2*n - 1. Each element in the vector corresponds to a diagonal on the board. If diag[i+n-j-1] is true, it means that the diagonal i-j is already occupied by a queen (Note that i-j may be negative, shifting it to i+n-j-1 to ensure be non-negative ). If diag[i+n-j-1] is false, the diagonal is available for placing a queen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n!)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\\n# Code using Bit Mask\\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> col, diag, antidiag;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) {\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true;\\n                num+=find_sol(i+1, n);\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false;\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col.assign(n, false);\\n        diag.assign(2*n-1, false);\\n        antidiag.assign(2*n-1, false);\\n        return find_sol(0, n);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int col_mask, diag_mask, anti_diag_mask;\\n    int find_sol(int i, int n) {\\n        int num=0;\\n        if (i == n) \\n            return 1;\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0) \\n            {\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                num+=find_sol(i+1, n);\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n        return num;\\n    }\\n    int totalNQueens(int n) {\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        return find_sol(0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479663,
                "title": "fast-clean-concise-c-solution-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, res = 0;\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t\\t// count all the possible answers\\n            res++;\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    int totalNQueens(int num) {\\n        n = num;\\n\\t\\t// initializing vector with \".......n\"\\n        vector<string> ans(n);\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113635,
                "title": "c-backtracking-w-shifting-bits-and-a-cheat-version",
                "content": "For backtracking we can use 3 integers as bitmasks. We only need to shift them for the main and anti diagonal.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nSince the results never change and only depend on ```n``` we could even do something like:\\n\\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```\\n\\nWhich is likley considered cheating. :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        return bt(n, 0, 0, 0, 0);\\n    }\\n    \\nprivate:\\n    int bt(int n, int idx, int same, int main, int anti) {\\n        if (idx == n) return 1;\\n       \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t    const int mask = 1 << i;\\n            if (same & mask) continue;\\n            if (main & mask) continue;\\n            if (anti & mask) continue;\\n            \\n            ans += bt(n, idx + 1, same | mask, (main | mask) << 1, (anti | mask) >> 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```n```\n```\\n    int totalNQueens(int n) {\\n        static const int ans[] = {0, 1, 0, 0, 2, 10, 4, 40, 92, 352};\\n        return ans[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113550,
                "title": "simple-java-solution",
                "content": "```\\npublic class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }\\n    public void task(int x, int n, boolean[] k, boolean[] p, boolean[] a) {\\n        if (x==n) {\\n            s++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) \\n        {\\n            if(!k[i]&&!p[i+x]&&!a[n-1-x+i]) \\n            {\\n                k[i]=p[i+x]=a[n-1-x+i]=true;\\n                task(x+1,n,k,p,a);\\n                k[i]=p[i+x]=a[n-1-x+i]=false;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    int s=0;\\n    public int totalNQueens(int n) {\\n        boolean[] k=new boolean[n];\\n        boolean[] p= new boolean[2*n-1];\\n        boolean[] a=new boolean[2*n-1];\\n        task(0, n,k,p,a);\\n        return s;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2113344,
                "title": "accepted-c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col-1;i>=0 and j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\tfor(int i=row-1,j=col+1;i>=0 and j<n;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j]) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\n   \\n\\tvoid countNQueen(vector<vector<bool> > &grid, int curr_row, int n){\\n\\t\\tif(curr_row == n){ // We found a solution so we increment our count\\n\\t\\t\\tqueencount++;\\n\\t\\t\\t// display(grid,n);\\n\\t\\t\\t// cout<<\"\\\\n\\\\n\";\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(isItSafe(grid,curr_row,i,n)){\\n\\t\\t\\t\\tgrid[curr_row][i] = true;\\n\\t\\t\\t\\tcountNQueen(grid,curr_row+1,n);\\n\\t\\t\\t\\tgrid[curr_row][i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    int totalNQueens(int n) {\\n        vector<vector<bool> > grid(n, vector<bool>(n,false));\\n   \\n         countNQueen(grid,0,n); \\n        return queencount;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int queencount = 0;// to keep the total count\\n    bool isItSafe(vector<vector<bool> > &grid,int row,int col,int n) \\n\\t{\\n\\t\\tfor(int i=row-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][col]) return false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2113275,
                "title": "c-use-recursion-and-backtracking-explanation-through-comments-dlc-june-day-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) \\n    {\\n        int ans=0;                 //ans counts toatal no. of possible orders \\n        vector<string> board(n);   // create the board of n rows \\n        string s(n,\\'.\\');           // define column of the board size n=4 i.e. \"....\" \\n        \\n        for(int i=0;i<n;i++)       // define whole board as a empty string\\n        {\\n            board[i]=s;            //[\"....\",\"....\",\"....\",\"....\"]\\n        }\\n        \\n        // we are moving from left to right\\n        // so we need to check only left part of the current cell because all the cells after current cell (right part) will surely empty\\n        // we also can not check for upper and lower direction for current cell because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> leftrow(n,0);                      // maintaining an array left that will tell which row has already taken for placing queen\\n        vector<int> upperdiagonal(2*n-1,0);          // maintaiing an array upperdiagonal that will tell which upperdiagonal has already taken\\n        vector<int> lowerdiagonal(2*n-1,0);          // maintaiing an array lowerdiagonal that will tell which lowerdiagonal has already taken\\n        \\n        solve(0, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n        return ans;   \\n    }\\n    \\n    void solve(int col, vector<string> &board, int &ans, \\n               vector<int> &leftrow, vector<int> &lowerdiagonal, \\n               vector<int> &upperdiagonal, int n)\\n    {\\n        //when all columns are covered, we increase the count and return\\n        if(col == n) \\n        {\\n            ans++;\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++)\\n        {\\n            //condition for checking collision, if all satisfy means there is no collision\\n            if(leftrow[row]==0 && lowerdiagonal[row+col]==0 && \\n               upperdiagonal[n-1+row-col]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                leftrow[row]=1;\\n                lowerdiagonal[row+col]=1;\\n                upperdiagonal[n-1+row-col]=1;\\n                solve(col+1, board, ans, leftrow, lowerdiagonal, upperdiagonal, n);\\n                //backtracking\\n                board[row][col] = \\'.\\'; \\n                leftrow[row]=0;\\n                lowerdiagonal[row+col]=0;\\n                upperdiagonal[n-1+row-col]=0;\\n            }\\n        }\\n    }     \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800718,
                "title": "c-backtracking-beginner-friendly-solution-w-comments",
                "content": "DO \\u2B06\\uFE0FUPVOTE IF IT WAS HELPFUL\\t\\n\\t\\n\\tclass Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check left side\\n\\t\\t\\tint row=r,col=c;\\n\\t\\t\\twhile(row>=0 && col>=0){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col--;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check right side\\n\\t\\t\\trow=r,col=c;\\n\\t\\t\\twhile(row>=0 && col<n){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid helper(int r,vector<string> &v,int n){\\n\\t\\t\\t if(r==n){\\n\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t return ;\\n\\t\\t\\t }\\n\\t\\t\\tfor(int i=0;i<n;i++){ //fixing row and checking for column(each row can have only one queen)\\n\\t\\t\\t\\tif(issafe(r,i,v,n)){\\n\\t\\t\\t\\t\\tv[r][i]=\\'Q\\';\\n\\t\\t\\t\\t\\thelper(r+1,v,n);\\n\\t\\t\\t\\t\\tv[r][i]=\\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint totalNQueens(int n) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tstring s(n,\\'.\\');\\n\\t\\t\\tfor(int i=0;i<n;i++) v.push_back(s);\\n\\t\\t\\thelper(0,v,n);\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\t// vector<vector<string>> ans;\\n\\t\\tint count=0;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check\\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1138289,
                "title": "c-easy-clean-code-explained-with-comments-backtracking",
                "content": "***Generally we see that part 2 of any variant is a modification of part 1. But, here part is relatively simple as we have to only count the valid configurations of placing N Queens on an \"n x n\" board. So, here we go through the solution.***\\n\\n```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```\\n\\n# HAPPY CODING. PLEASE UPVOTE :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count = 0;\\n    bool isValid(int matrix[][9],int row,int col,int n) {\\n        \\n        // col check\\n        for(int r=0;r<row;r++) { \\n            if(matrix[r][col]==1) return false;\\n        }\\n        \\n        // left diagonal\\n        int i=row,j=col;\\n        while(i>=0 && j>=0) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j--;\\n        }\\n        // right diagonal \\n        i=row,j=col;\\n        while(i>=0 && j<n) {\\n            if(matrix[i][j]==1) return false;\\n            i--;j++;\\n        }\\n\\n        return true;\\n    }\\n    \\n    void solve(int matrix[][9],int row,int n){\\n       // if in all the rows queens are placed, that means we have reached the end, print the board \\n        if(row==n) { \\n            count++;\\n            return;\\n        }\\n      //  bool nextQueen=false; // \"assuming that next Queen\\'s placement is not decided YET\"\\n        for(int col=0;col<n;col++) { // moving into all the columns of \"row\" \\n            if(isValid(matrix,row,col,n)) { \\n               \\n                matrix[row][col] = 1; // if yes, mark it as 1\\n // now looking for next Queen\\'s placement, moving to the next row and calling this func Recursively.\\n                solve(matrix,row+1,n);\\n                matrix[row][col]=0; \\n//THIS IS WHERE ALL THE BACKTRACKING IS HAPPENING. IF WE GOT nextQueen as false, we will BACKTRACK BY SETTING THE CURRRENT POSITION TO 0 AGAIN, WE ARE LITERALLY MOVING \"BACK\" AND WILL LOOK FOR ANY OTHER LOCATION FOR THE PLACEMENT OF THE QUEEN\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        int matrix[9][9]={0}; // creating an 2d array of 9X9 since that is the max limit\\n        solve(matrix,0,n); // solve(matrix,starting row,max rows)\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861345,
                "title": "python3-backtracking-solution-with-detailed-comments-explanation",
                "content": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        # We only need three arrays; one for rows and two for left & right diagonals.\\n        # Since there can be only 1 queen in a row, col, & diagonals, we don\\'t need to consider\\n        # every cell/square on the board. We can just iterate over the columns.\\n        # We can use specific places in these arrays to mark off ENTIRE rows, columns, and diagonals,\\n        # since placing a queen makes the row, col, and diagonals its in invalid for placing any others.\\n        # The rows array takes care of marking off both the current row & column.\\n        # Ex. rows[2] marks off the entire third column, and the entire current row.\\n        \\n        rows = [0] * n         # There are n columns\\n        hills = [0] * (2*n-1)  # number of right diagonals (draw a board and count diagonals to verify)\\n        slopes = [0] * (2*n-1) # number of left diagonals\\n        \\n        # When placing a queen, also mark the row, column, and diagonals it attacks, since\\n        # we can\\'t place any other queens in those paths.\\n        # A queen\\'s right diagonal (hill) is: row - column.\\n        # A queen\\'s left diagonal (slope) is: row + column.\\n        def place_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 1\\n            hills[right_diag] = 1\\n            slopes[left_diag] = 1\\n            \\n        # For removing a queen, it\\'s much the same process: Unmark the row, column, and diagonals,\\n        # since removing a queen means they are no longer under attack.\\n        def remove_queen(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            rows[col] = 0\\n            hills[right_diag] = 0\\n            slopes[left_diag] = 0\\n        \\n        def not_under_attack(row, col):\\n            right_diag = row - col\\n            left_diag = row + col\\n            \\n            # In python, 0 is False and 1 is True.\\n            # So if we have rows[0] = 0, the boolean value of rows[0] is False, and not(rows[0]) returns True.\\n            # This is a simple check to see if all three of these spots contain 1\\'s or not.\\n            return not(rows[col] or hills[right_diag] or slopes[left_diag])\\n        \\n        # Start searching from the point (0,0).\\n        # (Saying row = 0, count = 0 in the function arguments is just the default value, if the function\\n        # gets called with nothing passed in. If the function DOES get called with values passed in,\\n        # the 0\\'s get overriden, and you\\'d be working with a different row & count).\\n        # Place a queen on the first open spot you find, check if the number of filled spots equals n,\\n        # and if it does, increase the total count of valid solutions.\\n        # The else clause here is what does the actual backtracking: it places a queen, calls the function again\\n        # and again with a new spot in the board, until we don\\'t hit the else clause anymore, at which point we\\n        # remove the queen at the new row, col, and resume our search by continuing the for loop.\\n        # Notice how row gets incremented each time the backtrack function gets called recursively.\\n        def backtrack(row = 0, count = 0):\\n            for col in range(n):\\n                if not_under_attack(row, col):\\n                    place_queen(row, col)\\n                    \\n                    if row+1 == n:\\n                        count += 1\\n                    else:\\n                        count = backtrack(row+1, count)\\n                        \\n                    remove_queen(row, col)\\n                    \\n            return count```",
                "codeTag": "Java"
            },
            {
                "id": 810361,
                "title": "c-4ms-heavily-commented-solution-clean-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            cnt++;\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n\\t\\t// return 0 if n <= 0\\n        if(n <= 0) return 0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472966,
                "title": "c-backtracking",
                "content": "For explanation: https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/\\n\\n```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "solutionTags": [],
                "code": "```\\nint totalNQueens(int n) {\\n    vector<int> row(n,0);\\n    vector<vector<int>> board(n, row); // board is n x n filled with 0\\'s (safe)\\n    return backtrackNQueens(board, n, 0, 0);\\n}\\n\\nint backtrackNQueens(vector<vector<int>> &board, int n, int row, int count){\\n    for(int col = 0; col < n; col++){\\n        if(board[row][col] == 0){ // 0 is safe\\n            vector<vector<int>> prevBoard = board; // this is where we will backtrack to\\n            placeQueen(board, n, row, col);\\n            if(row == n-1){\\n                count++;\\n            } else {\\n                count = backtrackNQueens(board, n, row + 1, count);\\n            }\\n            board = prevBoard; // backtrack the last queen\\n        } \\n    }\\n    return count;\\n}\\n\\nvoid placeQueen(vector<vector<int>> &board, int n, int row, int col){\\n    for(int i = 0; i < n; i++){\\n        board[i][col] = 1; // fill vertically\\n        board[row][i] = 1; // fill horizontally \\n        int j = row + col - i; // fill the NE diagonal \\n        if(j >=0 && j < n){\\n            board[i][j] = 1;\\n        }\\n        int k = row - col + i; // fill the SE diagonal\\n        if(k >=0 && k < n){\\n            board[k][i] = 1;\\n        } \\n    }\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374660,
                "title": "very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nclass Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        int[] queue = new int[n];\\n        backtrack(0,queue,n);\\n        return count;\\n    }\\n    \\n    private void backtrack(int row,int[] queue,int n){\\n        if(row==n){\\n            count++;\\n        }else{\\n            for(int i=0;i<n;i++){\\n                if(isOk(row,i,queue)){\\n                    queue[row]=i;\\n                    backtrack(row+1,queue,n);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isOk(int row,int col,int[] queue){\\n        int leftup=col-1,rightup=col+1;\\n        int n=queue.length;\\n        for(int i=row-1;i>=0;i--){\\n            if(queue[i]==col) return false;\\n            if(leftup>=0&&queue[i]==leftup) return false;\\n            if(rightup<n&&queue[i]==rightup) return false;\\n            leftup--;rightup++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20133,
                "title": "easy-java-python-recursive-iterative-backtracking-solutions",
                "content": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "For detail explanation see n-queens [solution][1]\\n\\n**Java recursive**\\n\\n    private int bt(boolean[] c, boolean[] f, boolean[] b, int row, int n) {\\n        if (row == n) return 1;\\n        int ans = 0;\\n        for (int col = 0; col < n; ++col) {\\n            int i = col + row, j = col - row + n;\\n            if (c[col] || f[i] || b[j]) continue;\\n            c[col] = f[i] = b[j] = true;\\n            ans += bt(c, f, b, row + 1, n);\\n            c[col] = f[i] = b[j] = false;\\n        }\\n        return ans;\\n    }\\n\\n    public int totalNQueens(int n) {\\n        return bt(new boolean[n], new boolean[2 * n], new boolean[2 * n], 0, n);\\n    }\\n\\n    // Runtime: 2ms\\n\\n**Java Iterative**\\n\\n    public int totalNQueens(int n) {\\n        int ans = 0;\\n        int[] queens = new int[n];\\n        boolean[] c = new boolean[n + 1];\\n        boolean[] f = new boolean[2 * n];\\n        boolean[] b = new boolean[2 * n];\\n        c[n] = true; //dummy boundary\\n        int col = 0, row = 0;\\n        while (true) {\\n            if (c[col] || f[col + row] || b[col - row + n]) {\\n                if (row == n || col == n) {\\n                    if (row == 0) return ans;\\n                    if (row == n) ans++;\\n                    col = queens[--row];\\n                    c[col] = f[col + row] = b[col - row + n] = false;\\n                }\\n                col++;\\n            } else {\\n                c[col] = f[col + row] = b[col - row + n] = true;\\n                queens[row++] = col;\\n                col = 0;\\n            }\\n        }\\n    }\\n    // Runtime: 4ms\\n\\n**Python iterative**\\n\\n    def totalNQueens(self, n):\\n        row = col = ans = 0\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n            else:\\n                if row == n or col == n:\\n                    if row == n:\\n                        ans += 1\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n    # Runtime: 60 ms\\n\\n\\n  [1]: https://leetcode.com/discuss/63710/ac-python-76-ms-iterative-backtracking-solution",
                "codeTag": "Python3"
            },
            {
                "id": 20131,
                "title": "pretty-simple-java-solution",
                "content": " In this problem, no need to keep track of the board content, just pay attention to column, diagonal.\\n   \\n    public class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }\\n      public void helper(int[] res, int n, int row){\\n        if(row==n){\\n            res[0]++;\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                if(col.contains(i) || diag1.contains(i+row) || diag2.contains(row-i)) continue;\\n                else{\\n                    col.add(i);\\n                    diag1.add(i+row);\\n                    diag2.add(row-i);\\n                    helper(res,n,row+1);\\n                    col.remove(i);\\n                    diag1.remove(i+row);\\n                    diag2.remove(row-i);\\n                }\\n             }\\n          }\\n       }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      Set<Integer> col = new HashSet<Integer>();\\n      Set<Integer> diag1 = new HashSet<Integer>();\\n      Set<Integer> diag2 = new HashSet<Integer>();\\n\\n      public int totalNQueens(int n) {\\n        int[] res = new int[1];\\n        helper(res,n,0);\\n        return res[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20164,
                "title": "my-concise-dfs-c-solution-using-three-unordered-map-int-bool",
                "content": "    class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }\\n            for (int i = 1; i <= n; i++) {\\n                if (!column[i] && !obliqueLeft[i + row] && !obliqueRight[i - row]) {\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = true;\\n                    NQueensHelper(row+1, n);\\n                    column[i] = obliqueLeft[i + row] = obliqueRight[i - row] = false;\\n                }\\n            }\\n        }\\n        int totalNQueens(int n) {\\n            column.clear();\\n            obliqueLeft.clear();\\n            obliqueRight.clear();\\n            total = 0;\\n            NQueensHelper(1, n);\\n            return total;\\n        }\\n    };\\n\\nEach unordered_map represents whether column/left oblique line/right oblique line is occupied before.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        unordered_map<int, bool> column, obliqueLeft, obliqueRight;\\n        int total;\\n        void NQueensHelper(int row, int n) {\\n            if (row == n+1) {\\n                total++;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4018184,
                "title": "cpp-easy-to-understand-backtracking-solution-with-line-by-line-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x; // A counter to keep track of the total number of solutions.\\n\\n    int totalNQueens(int n) {\\n        vector<string> temp(n, string(n, \\'.\\')); // Create an empty NxN chessboard represented by a vector of strings.\\n        helper(temp, 0, 0, n); // Start the recursive process to find solutions.\\n        return x; // Return the total number of solutions.\\n    }\\n\\n    void helper(vector<string>& temp, int row, int column, int n) {\\n        if (row == n) {\\n            x++; // If a valid solution is found, increment the solution counter.\\n            return;\\n        }\\n\\n        while (column < n) {\\n            if (isvalid(temp, row, column, n)) {\\n                temp[row][column] = \\'Q\\'; // Place a queen at the current position.\\n                helper(temp, row + 1, 0, n); // Recursively try to place queens in the next row.\\n                temp[row][column] = \\'.\\'; // Backtrack by removing the queen from the current position.\\n            }\\n            column++;\\n        }\\n    }\\n\\n    bool isvalid(vector<string>& temp, int row, int col, int n) {\\n        // Check if it\\'s valid to place a queen at the current position without conflicts.\\n        for (int i = 0; i < row; i++) {\\n            if (temp[i][col] == \\'Q\\') {\\n                return false; // Check for conflicts in the same column.\\n            }\\n        }\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-left diagonal.\\n            }\\n        }\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (temp[i][j] == \\'Q\\') {\\n                return false; // Check for conflicts in the upper-right diagonal.\\n            }\\n        }\\n        return true; // No conflicts found, it\\'s a valid placement.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839385,
                "title": "juggad-solution-beats-100-please-see-once-easiest-and-funniest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2||n==3)\\n        return 0;\\n        if(n==4)\\n        return 2;\\n        if(n==5)\\n        return 10;\\n        if(n==6)\\n        return 4;\\n        if(n==7)\\n        return 40;\\n        if(n==8)\\n        return 92;\\n        return 352;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553872,
                "title": "swift-tc-100-sc-100-backtracking-bit-manipulation",
                "content": "\\n# Approach\\nHere we use bit manipulation technique to keep track of visited nodes instead of using **sets**. Thus, improved TC and SC. But SC is still $$O(n)$$ due to the recursion call stack.\\n\\n# Complexity\\n- Time complexity: $$O(n!)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalNQueens(_ n: Int) -> Int {\\n        func backtrack(_ row: Int, _ cols: Int, _ diagonals: Int, _ antidiagonals: Int) -> Int {\\n            if row == n { return 1 }\\n\\n            var solution = 0\\n            for col in 0..<n {\\n                let currentDiagonal = 1 << (row - col + n)\\n                let currentAntiDiagonal = 1 << (row + col)\\n                let currCol = 1 << col\\n\\n                if  (cols & currCol) != 0 || \\n                    (diagonals & currentDiagonal) != 0 || \\n                    (antidiagonals & currentAntiDiagonal) != 0 { \\n                        continue \\n                }\\n                var cols = cols, diagonals = diagonals, antidiagonals = antidiagonals\\n                cols ^= currCol\\n                diagonals ^= currentDiagonal\\n                antidiagonals ^= currentAntiDiagonal\\n\\n                solution += backtrack(row + 1, cols, diagonals, antidiagonals)\\n            }\\n            return solution\\n        }\\n\\n        return backtrack(0, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470773,
                "title": "backtracking-c-with-diagonals",
                "content": "# Intuition\\nTrack which column and diagonals are used by using 3 bool arrays.\\n\\n# Approach\\nIntroduce 3 arrays which track which columns and diagonals are occupied. Map diagonal indices using the following mapping:\\n\\n```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\\n\\nThey need to be positive, so move them up by another N-1.\\n\\n# Code\\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\n/*\\ndiagonal1:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  0   1   2   3\\n   1 | -1   0   1   2\\n   2 | -2  -1   0   1\\n   3 | -3  -2  -1   0\\n\\nD1(row, col) = col - row\\n\\ndiagonal2:\\n     |r=0   1   2   3\\n-----+---------------\\n c=0 |  3   2   1   0\\n   1 |  2   1   0  -1\\n   2 |  1   0  -1  -2\\n   3 |  0  -1  -2  -3\\n\\nD2(row, col) = N-1 - col - row\\n*/\\n```\n```\\nclass Solution {\\n  static constexpr int SIZE = 9;\\n\\n  bool column_occupied[SIZE] = {};\\n  bool diagonal1_occupied[2*SIZE] = {};\\n  bool diagonal2_occupied[2*SIZE] = {};\\n\\npublic:\\n  int totalNQueens(int n) {\\n    return solve(n, 0);\\n  }\\n\\nprivate: \\n  int solve(int n, int row) {\\n    if (row == n) return 1; // found a valid solution!\\n\\n    int sum = 0;\\n    for (int col = 0; col < n; col++) {\\n      bool &column_used = column_occupied[col];\\n      bool &diagonal1_used = diagonal1_occupied[n-1 + col - row];\\n      bool &diagonal2_used = diagonal2_occupied[2*(n-1) - col - row];\\n\\n      if (!column_used && !diagonal1_used && !diagonal2_used) {\\n        column_used = diagonal1_used = diagonal2_used = true;\\n        sum += solve(n, row+1);\\n        column_used = diagonal1_used = diagonal2_used = false;\\n      }\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270721,
                "title": "python3-backtracking-easy-solution-beats-98",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        ans=0\\n        left,upleft,lowleft=[0]*n,[0]*(2*n-1),[0]*(2*n-1)\\n        def solve(col,board):\\n            nonlocal ans\\n            if col==n:\\n                ans+=1\\n                return \\n            for row in range(n):\\n                if not left[row] and not upleft[row+col] and not lowleft[n-1+row-col]:\\n                    board[row][col]=\"Q\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=1,1,1\\n                    solve(col+1,board)\\n                    board[row][col]=\".\"\\n                    left[row],upleft[row+col],lowleft[n-1+row-col]=0,0,0\\n        board=[[\".\" for i in range(n)] for _ in range(n)]\\n        solve(0,board)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209817,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n\\tvector<vector<bool>> board(n, vector<bool>(n, false));\\n\\treturn solve(board, 0);\\n    }\\n    bool isSafe(vector<vector<bool>>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i <= row; i++) {\\n\\t\\t    if(board[i][col]) return false; \\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i]) return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i]) return false;\\n\\t    }\\n\\t    return true;\\n    }    \\n    int solve(vector<vector<bool>>& board, int row) {\\n\\t    if(row == size(board)) return 1;\\n\\t    int count = 0;\\n\\t    for(int col = 0; col < size(board); col++)           \\n\\t\\t    if(isSafe(board, row, col)){          \\n\\t\\t\\t    board[row][col] = true;          \\n\\t\\t\\t    count += solve(board, row + 1);  \\n\\t\\t\\t    board[row][col] = false;         \\n\\t\\t    }                                \\n\\t    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938038,
                "title": "very-very-easy-solution-in-0-1-time-java-100",
                "content": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalNQueens(int n) {\\n        if(n == 1)\\n            return 1;\\n        if(n < 4)\\n            return 0;\\n        if(n == 4)\\n            return 2;\\n        if(n == 5)\\n            return 10;\\n        if(n == 6)\\n            return 4;\\n        if(n == 7)\\n            return 40;\\n        if(n == 8)\\n            return 92;\\n        return 352;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859048,
                "title": "java-n-queens-2-using-recursion-easy-understanding",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int totalNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        helper(board,0,n);\\n        return count;\\n    }\\n    public boolean isSafe(char[][] board,int row,int col)\\n\\t{\\n\\t\\t//Vertical\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[row][i]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Horizontal\\n\\t\\tfor(int i=0;i<board.length;i++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][col]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Left\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Top-Right\\n\\t\\tfor(int i=row,j=col;i>=0 && j<board.length;i--,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Left\\n\\t\\tfor(int i=row,j=col;i<board.length && j>=0;i++,j--)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Bottom-Right\\n\\t\\tfor(int i=row,j=col;i<board.length && j<board.length;i++,j++)\\n\\t\\t{\\n\\t\\t\\tif(board[i][j]==\\'Q\\')\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n    \\n    public void helper(char[][] board,int col,int row )\\n\\t{\\n\\t\\tfor(int i=0;i<row;i++)\\n\\t\\t{\\n\\t\\t\\tif(col==row)\\t\\n\\t\\t\\t{\\n                count++;\\n                return;\\n\\t\\t\\t}\\n\\t\\t\\tif(isSafe(board,i,col))\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i][col] = \\'Q\\';\\n\\t\\t\\t\\thelper(board,col+1,row);\\t\\n\\t\\t\\t\\tboard[i][col] = \\' \\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798719,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    int totalNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797884,
                "title": "java-o-n-n-n-87-faster-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll use the concept of **Backtracking** for this problem.\\nNow, the basic approach that one can think of would be to check each cell that is it a potential position for the queen to be placed.. !!\\n\\n*Well, we\\'ll implement the above approach itself but it in a more optimised manner using backtracking.*\\n\\nSteps to be followed ->\\n\\n - For each row of the ```chess```, we\\'ll place the queen at a specific column and will recursively check that is the remaining part of the grid able to place rest queens or not..\\n - For eg, for row or ```currLevel=0```, we first place the queen at column ```i=0``` and then will recursively call the next level or row. \\n - Now, we\\'ll check that is it safe for the queen to be placed at ```chess[currLevel][i]``` using ```isSafeForQueen(currLevel, i)```. If the position is valid, we place the queen, and similarly pass to the next level.\\n - In case, the queen doesn\\'t find any appropriate position for the ```currLevel```, we\\'ll fallback to previous level and **will *remove (backtracking)* the queen present in previous row and will try the next position.**\\n - Now, if we reach to the condition ```currLevel = n```, it means we have successfully encountered a ```way``` and hence, we return ```1``` corresponding to that way.\\n\\nFollowing above steps, we can easily frame the solution.\\n\\n# Complexity\\n- Time complexity: $$O(n^n*n)$$ - **(Beats 87%)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$Kindly$$ $$upvote$$ $$if$$ $$you$$ $$understood$$ $$the$$ $$solution.. :)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking"
                ],
                "code": "```chess```\n```currLevel=0```\n```i=0```\n```chess[currLevel][i]```\n```isSafeForQueen(currLevel, i)```\n```currLevel```\n```currLevel = n```\n```way```\n```1```\n```\\nclass Solution {\\n\\n    static int[][] chess;\\n    public int totalNQueens(int n) {\\n        chess = new int[n][n];\\n        return solveNQueensHelper(n, 0);\\n    }\\n    public static int solveNQueensHelper(int n, int currLevel) {\\n        if(currLevel == n){\\n            return 1;\\n        }\\n        int ways = 0;\\n        for(int i = 0; i < n; i++){\\n            if(isSafeForQueen(currLevel, i)){\\n                chess[currLevel][i] = 1;\\n                ways += solveNQueensHelper(n, currLevel+1);\\n                chess[currLevel][i] = 0;\\n            }\\n        }\\n        return ways;\\n    }\\n\\n    public static boolean isSafeForQueen(int r, int c) { \\n        //col\\n        for(int i = r-1; i >= 0; i--){\\n            if(chess[i][c] == 1) return false;\\n        }\\n        //right dia\\n        for(int i = r-1, j = c+1; i >= 0 && j < chess.length; i--, j++){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        //left dia\\n        for(int i = r-1, j = c-1; i >= 0 && j >= 0; i--, j--){\\n            if(chess[i][j] == 1) return false;\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720473,
                "title": "java-easy-code-recursion-backtracking",
                "content": "Solved using a Boolean Matrix of N size. \\nIn recusive calls it will check if putting the Queen is Safe if not Backtrack.\\n\\n\\n\\n\\n\\n\\n        \\n    class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }\\n    int queens(boolean[][] board,int row)\\n\\t{\\n\\t\\tif(row==board.length){\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        // Placing Queens and Checking for every row and column\\n        for(int col=0;col<board.length;col++){\\n            //place queen if Safe\\n            if(isSafe(board,row,col)){\\n                board[row][col] = true;\\n                count += queens(board,row+1); //Recursive call\\n                board[row][col] = false;    // Backtrack\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    boolean isSafe(boolean[][] board, int row ,int col){\\n        \\n        // Vertical row\\n        for(int i=0;i<row;i++){\\n            if(board[i][col])\\n                return false;\\n        }\\n        \\n        // Left diagonal\\n        int maxLeft = Math.min(row,col);\\n        for(int i=1;i<=maxLeft;i++){\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        \\n        // Right diagonal\\n        int maxRight = Math.min(row,board.length-col-1);\\n        for(int i=1;i<=maxRight;i++){\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n      boolean[][] board = new boolean[n][n];\\n      return queens(board,0);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2559395,
                "title": "java-solution-using-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n       boolean[][] board = new boolean[n][n];\\n       return queens(board,0);\\n    }\\n\\tstatic int queens(boolean[][] board,int row){\\n        if(row == board.length){\\n            return 1;\\n        }\\n        int count = 0;\\n        //placing the queens and checking for every row and col\\n        for(int col = 0;col< board.length;col++){\\n            //place the queen if it is safe\\n            if(issafe(board,row,col)){\\n                board[row][col]=true;\\n                count += queens(board,row+1);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n    //checks all pssible safe blocks for the queens\\n    static boolean issafe(boolean[][] board,int row,int col){\\n        //check vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col]){\\n                return false;\\n            }\\n        }\\n        //check for diagonal left\\n        int maxleft = Math.min(row,col);\\n        for (int i = 1; i <= maxleft; i++) {\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        //checks for diagonal rigth\\n        int maxright = Math.min(row,board.length-col-1);\\n        for (int i = 1; i <= maxright; i++) {\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115816,
                "title": "just-1-line-solution-check-once",
                "content": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}[n];\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   int totalNQueens(int n) \\n   {\\n       return array<int, 13>{0,1,0,0,2,10,4,40,92,352,724,2680,14200}",
                "codeTag": "Java"
            },
            {
                "id": 2115112,
                "title": "java-backtracking-comment-added",
                "content": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n   int answer;\\n    public int totalNQueens(int n) {\\n        \\n        answer = 0;\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            answer++; // valid configuration found\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114767,
                "title": "java-easy-understand-stack",
                "content": "\\nWe can check the board usign below \\n1. First one is to add the both row and column values (Which is stored in Positive digonal stack)\\n2. Second is to subract and store them in the Negative Digonal stack\\n3. Store each coulmn value in another stack\\n4. These stack helps in verifying the Queen\\'s position\\n\\n```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\\n\\nFrom above diagram we can observe that all the additon value in the diagonal are same and  subracted values are same. \\nWe use this login and Push and pop the elements based on our traversal\\n\\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Stack"
                ],
                "code": "```\\n        0                  1       2      3 \\n0   (0+0=0) ,(0-0=0)    (0,-1)  (0,-2)  (0,-3)\\n1   (1,1)               (2,0)   (3,-1)  (4,-2)\\n2   ( 2, 2 )            (3,1)   (4,0)   (5,-1)\\n3   (3,3)               (4,2)   (5,1)   (6,0)\\n```\n```\\n\\nclass Solution {\\n     int ans = 0;\\n     Stack<Integer> positiveDiagonal = new Stack<>();\\n     Stack<Integer> negativeDiagonal = new Stack<>();\\n\\n    public  int totalNQueens(int n) {\\n        int[][] board = new int[n][n];\\n        Stack<Integer> row = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            row.push(i);\\n            positiveDiagonal.push(i);\\n\\t\\t\\t// Inserting the value of diagonol\\n            negativeDiagonal.push(-i);\\n            solve(1, row, n-1,n);\\n\\t\\t\\t//Checking the board for each position in the first place then traverse the remaining  place\\n            positiveDiagonal.pop();\\n            negativeDiagonal.pop();\\n            row.pop();\\n        }\\n        return ans;\\n    }\\n\\n    public  void solve(int start, Stack<Integer> row, int size, int n) {\\n\\n        if (size==0) {\\n            ans += 1;\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n\\t\\t// Check each element if that postion is good or not\\n            if (verifyPosition(start, i, row)) {\\n                row.push(i);\\n                positiveDiagonal.push(start + i);\\n                negativeDiagonal.push(start - i);\\n                solve(start + 1, row, size-1,n);\\n                positiveDiagonal.pop();\\n                negativeDiagonal.pop();\\n                row.pop();\\n            }\\n        }\\n    }\\n\\n    public  boolean verifyPosition(int start, int i, Stack<Integer> row) {\\n\\n        return !(row.contains(i) || positiveDiagonal.contains(start + i) || negativeDiagonal.contains(start - i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114708,
                "title": "c-efficient-code",
                "content": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }\\n      \\n      for(int row=0;row<n;row++)\\n      {\\n          if(left[row]==0 && lowerDiagnol[row+col]==0 && upperDiagnol[n-1+col-row]==0)\\n          {\\n              left[row]=1;\\n              lowerDiagnol[row+col]=1;\\n              upperDiagnol[n-1+col-row]=1;\\n              solve(col+1,left,upperDiagnol,lowerDiagnol,n);\\n              left[row]=0;\\n              lowerDiagnol[row+col]=0;\\n              upperDiagnol[n-1+col-row]=0;\\n              \\n              \\n          }\\n      }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<int> left(n,0);\\n        vector<int> upperDiagnol(2*n-1,0);\\n        vector<int> lowerDiagnol(2*n-1,0);\\n        \\n        solve(0,left,upperDiagnol,lowerDiagnol,n);\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int count=0;\\n    \\n    void  solve(int col,vector<int> &left,vector<int> &upperDiagnol,vector<int> &lowerDiagnol,int n)\\n    {\\n         if(col==n)\\n         {\\n             count++; \\n             return;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2113019,
                "title": "c-extension-of-n-queens-just-one-line-change",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int col, int n, vector<vector<string>>& ans , vector<string>& board, vector<int>& left, vector<int>& upperDigonal ,vector<int>& lowerDigonal)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row=0;row<n;row++)\\n        {\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[col-row+n-1]==0)\\n            {\\n                board[row][col] = \\'Q\\';\\n                left[row] = 1;\\n                upperDigonal[row+col] = 1;\\n                lowerDigonal[col-row+n-1] = 1;\\n                \\n                helper(col+1,n,ans,board,left,upperDigonal,lowerDigonal);\\n                \\n                board[row][col] = \\'.\\';\\n                left[row] = 0;\\n                upperDigonal[row+col] = 0;\\n                lowerDigonal[col-row+n-1] = 0;\\n            }\\n        }\\n    }\\n        \\n    int totalNQueens(int n) \\n    {\\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        helper(0,n,ans,board,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112855,
                "title": "all-we-need-to-do-is-to-return-ans-size-c",
                "content": "\\u27A1 If you have solved N-queens problem: \\n ***All we need to do is to return ans.size() [2d string vector of N-Queens]. As there in N-Queens problem we have returned distinct solutions to the N-queens puzzle ,i.e., all possible solution string Vector.***\\n\\n1. **N-Queens** [https://leetcode.com/problems/n-queens/](http://)\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\\n\\n2. **N-Queens ||** [https://leetcode.com/problems/n-queens-ii/](http://)\\nSolution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```\\n\\n**Upvote++ if it helped** \\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n\\n    vector < vector < string >> solveNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans;\\n    }\\n};\\n    \\n```\n```\\nclass Solution {\\npublic:\\n    bool isSafe1(int row, int col, vector < string > board, int n) {\\n      int duprow = row;\\n      int dupcol = col;\\n\\n      while (row >= 0 && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row--;\\n        col--;\\n      }\\n\\n      col = dupcol;\\n      row = duprow;\\n      while (col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        col--;\\n      }\\n\\n      row = duprow;\\n      col = dupcol;\\n      while (row < n && col >= 0) {\\n        if (board[row][col] == \\'Q\\')\\n          return false;\\n        row++;\\n        col--;\\n      }\\n      return true;\\n    }\\n    void solve(int col, vector < string > & board, vector < vector < string >> & ans, int n) {\\n      if (col == n) {\\n        ans.push_back(board);\\n        return;\\n      }\\n      for (int row = 0; row < n; row++) {\\n        if (isSafe1(row, col, board, n)) {\\n          board[row][col] = \\'Q\\';\\n          solve(col + 1, board, ans, n);\\n          board[row][col] = \\'.\\';\\n        }\\n      }\\n    }\\n    int totalNQueens(int n) {\\n      vector < vector < string >> ans;\\n      vector < string > board(n);\\n      string s(n, \\'.\\');\\n      for (int i = 0; i < n; i++) {\\n        board[i] = s;\\n      }\\n      solve(0, board, ans, n);\\n      return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112815,
                "title": "java-100-loophole-solution-correct-solution",
                "content": "I used switch case instead of if-else, and since we already know the number of queens per case, I output that.\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\\n\\n### **Talking about the correct way of solving:**\\n**What\\'s Backtracking?**\\nBacktracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem. \\n\\nIn this problem,\\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        switch ( n)\\n        {\\n            case 1: return 1;\\n            case 2: return 0;\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            default: return 352;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int count=0;\\n    public int totalNQueens(int n) {\\n        System.out.println(solveNQueens(n));\\n        return count;\\n    } \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        solve(0,board,ans,n);\\n        return ans;\\n    }\\n\\n    private  void solve(int col, char[][] board, List<List<String>> ans, int n) {\\n        if(col==n){\\n            // ans.add(construct(board));\\n            count++;\\n            return;\\n        }\\n        for(int row=0;row< board.length;row++){\\n            if(valid(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    private  boolean valid(int row, int col, char[][] board) {\\n        int duprow=row;\\n        int dupcol=col;\\n\\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;\\n            col--;\\n        }\\n\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row =duprow;\\n        col=dupcol;\\n        while(col>=0 && row< board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112338,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }\\n    //check whether other queen is present in diagonally upper left position or not\\n        int row=r,col=c;\\n        while(row>=0&&col>=0){\\n         \\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col--;\\n        }\\n        //check whether other queen is present in diagonally upper right position or not\\n        row=r;col=c;\\n        while(row>=0&&c<n){\\n            if(v[row][col]==\\'Q\\') return false;\\n            row--;col++;\\n        }\\n        return true;\\n        //if no the queen is present in column and diagonally upper left and diagonally upper right positions return true(or is safe)\\n    }\\n    \\n    void solve(int r,vector<string>&v,int n){\\n        if(r==n){   \\n            ans.push_back(v);\\n            return;\\n        }\\n        //now fix the row and move over the column and check for safe position\\n        for(int i=0;i<n;i++){\\n            if(issafe(r,i,v,n)){\\n                v[r][i]=\\'Q\\';\\n                solve(r+1,v,n); \\n                v[r][i]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        //we required a board of size n*n to store n number of queens\\n        \\n        vector<string>v(n,string (n,\\'.\\'));\\n        // create a board with all non queen index\\n        solve(0,v,n); \\n        // to palce n number of queens on there safe position call solve() function with row 0 \\n        \\n        return ans.size();\\n    }\\n    \\n};\\n\\n//Up-Vote if you like\\n//Thankyou",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //create ans vector to store all possible solutions\\n    vector<vector<string>>ans;\\n    \\n    //check whether other queen is present in column or not\\n    bool issafe(int r,int c,vector<string>&v,int n){\\n        for(int i=0;i<=r;i++){\\n            //if present return false\\n            if(v[i][c]==\\'Q\\') return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2111826,
                "title": "c-solution-o-1-solution-very-easy",
                "content": "May god bless you to see this O(1) solution.\\nThis is not cheating my boi. Because the constraints are very small. 1 to 9 so for only 9 solutions i first coded up the main NQueen problem and from there, i found out the possible solutions and stored them in an array. BOOM!! you got O(1) Solution.\\n\\n```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint totalNQueens(int n){\\n    int ar[9]={1,0,0,2,10,4,40,92,352};\\n    return ar[n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111606,
                "title": "c-0ms-short-easy-to-understand",
                "content": "In this problem, we can go row by row, and in each position, we need to check if the column, the left diagonal and the right diagonal had a queen before.\\n```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int N,ans;\\n    bool board[9][9]={0};\\n    bool isValid(int row,int col){\\n        for(int i=0;i<row;i++) if(board[i][col])return 0; //check the column\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) if(board[i][j])return 0; //check the left digonal\\n        for(int i=row-1,j=col+1;i>=0 && j<N;i--,j++) if(board[i][j])return 0;  //check the right digonal\\n        return 1;\\n    }\\n    void nQueen(int row){\\n        if(row==N){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<N;i++){\\n           if(isValid(row,i)){\\n              board[row][i]=1;\\n              nQueen(row+1);\\n              board[row][i]=0;\\n           }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        N=n;ans=0;\\n        nQueen(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111575,
                "title": "c-fast-solution",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }\\n\\nprivate:\\n    int ans;\\n\\n    void place(int i, int vert, int ldiag, int rdiag, int N) {\\n        if (i == N) ans++;\\n        else for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask, N);\\n        }\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int N) {\\n        ans = 0;\\n        place(0,0,0,0,N);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2111495,
                "title": "python-back-tracking",
                "content": "This is similar to the problem of N-Queens (yesterday\\'s daily challange). This video (https://www.youtube.com/watch?v=Ph95IHmRp5M) helped me understand N-Queens problem.\\nFor this problem, instead of appending the answer to an array, just increase the answer by one for a valid position. \\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```\\nHappy coding! Thanks.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        col = set()\\n        negDiag = set() ## row - column is constant\\n        posDiag = set() ## row + column is constant\\n        \\n        board = [[\\'.\\']*n for _ in range(n)]\\n        ans = 0\\n        \\n        def backtrack(r):\\n            nonlocal ans\\n            if r == n:\\n                ans += 1\\n                return\\n            for c in range(n):\\n                if c not in col and (r+c) not in posDiag and (r-c) not in negDiag:\\n                    col.add(c)\\n                    negDiag.add(r-c)\\n                    posDiag.add(r+c)\\n                    board[r][c] = \\'Q\\'\\n                    \\n                    backtrack(r+1)\\n                    \\n                    col.remove(c)\\n                    negDiag.remove(r-c)\\n                    posDiag.remove(r+c)\\n                    board[r][c] = \\'.\\'\\n        \\n        backtrack(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111001,
                "title": "python-o-1-solution-just-kidding-this-is-cheating",
                "content": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def totalNQueens(self, n: int) -> int:\\n        ans = [1, 0, 0, 2, 10, 4, 40, 92, 352]\\n        return ans[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946703,
                "title": "c-backtracking-self-explainable-code",
                "content": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isSafe(int row,int col,vector<string>& board){\\n        //row traversal\\n        for(int i=row;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal left\\n        for(int i=row,j=col;i>=0&&j>=0;i--,j--){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //diagonal right\\n        for(int i=row,j=col;i>=0&&j<board.size();i--,j++){\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    void helper(int row,int& ans,vector<string>& board){\\n        if(row==board.size()){\\n            ans++;\\n            return;\\n        }\\n        /*\\n        put the queen \\n        call for other rows\\n        backtrack i.e remove the queen\\n        */\\n        for(int j=0;j<board.size();j++){\\n            if(isSafe(row,j,board)){\\n                board[row][j]=\\'Q\\';\\n                helper(row+1,ans,board);\\n                board[row][j]=\\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    int totalNQueens(int n) {\\n        vector<string> board(n,string(n,\\'.\\'));\\n        int ans=0;\\n        helper(0,ans,board);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764025,
                "title": "c-backtracking-faster-than-90-percent-space-optimised",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int chessboard[9][9];\\n        memset(chessboard, -1, sizeof(chessboard));\\n        \\n        int total = 0;\\n        int row = 0;\\n        NQueens(chessboard, n, row, total);\\n        \\n        return total;\\n    }\\n    \\n    void NQueens(int chessboard[][9], int n, int row, int &total) {\\n        if(row == n) {\\n            total++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(chessboard, row, col, n) == true) {\\n                chessboard[row][col] = 0;\\n                NQueens(chessboard, n, row + 1, total);\\n                chessboard[row][col] = -1;\\n            }\\n        }\\n    }\\n    \\n    bool IsQueenSafe(int chessboard[][9], int row, int col, int n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(chessboard[i][j] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732593,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        visitedCol = set()\\n        posDig = set() \\n        negDig = set() \\n        res = 0 \\n        def backtrack(row):\\n            if row == n: \\n                nonlocal res \\n                res += 1 \\n                return\\n            for col in range(n): \\n                if col in visitedCol or (row+col) in posDig or(row-col) in negDig: \\n                    continue \\n                visitedCol.add(col) \\n                negDig.add(row-col) \\n                posDig.add(row+col) \\n                backtrack(row+1) \\n                visitedCol.remove(col) \\n                negDig.remove(row-col) \\n                posDig.remove(row+col) \\n        backtrack(0)    \\n \\xA0 \\xA0 \\xA0 \\xA0return res",
                "codeTag": "Java"
            },
            {
                "id": 1691037,
                "title": "fastest-c-solution-0ms-100",
                "content": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint ans=0;\\n    void solve(int n, vector<bool>& cols, vector<bool>& d1, vector<bool>& d2, int i)\\n    {\\n        if(i==n) //last row: solution found\\n        {\\n            ans++;\\n        }\\n        for(int j=0; j<n; j++)\\n        {\\n            int id1=j-i+n;\\n            int id2=i+j;\\n            if(cols[j] || d1[id1] || d2[id2]) continue; //present in column, diagonal 1, diagonal 2\\n            \\n            cols[j]=true;\\n            d1[id1]=true;\\n            d2[id2]=true;\\n            solve(n, cols, d1, d2, i+1); //solve for next row\\n            cols[j]=false;\\n            d1[id1]=false;\\n            d2[id2]=false;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        vector<bool> cols(n, false), d1(2*n, false), d2(2*n, false);\\n        solve(n, cols, d1, d2, 0);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1606350,
                "title": "faster-than-96-7-python-solutions",
                "content": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "Very similar to the N-Queens Hard problem. The key difference is that we don\\'t have to maintain the board here instead just increment the count value everytime we find a solution (row==n)\\n```class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        cols = set()\\n        diag = set() # signifies (r+c)\\n        anti_diag = set() #signifies (r-c)\\n        board = [[\\'.\\' for i in range(n)] for j in range(n)]\\n        self.count=0\\n    \\n        def backtrack(row):\\n            if row==n:\\n                self.count+=1\\n                return \\n            \\n            for col in range(n):\\n                if col in cols or (row+col) in diag or (row-col) in anti_diag:\\n                    continue\\n                #the queen can now be placed at this (row,col)\\n                \\n                cols.add(col)\\n                diag.add(row+col)\\n                anti_diag.add(row-col)\\n                \\n                #call backtrack function for next row\\n                backtrack(row+1)\\n                \\n                #remove the queen from this position (we backtrack from here because in the iteration part of the recursion we realized that this position is not going to return us the final answer)\\n                \\n                cols.remove(col)\\n                diag.remove(row+col)\\n                anti_diag.remove(row-col)\\n        backtrack(0)\\n        return self.count\\n",
                "codeTag": "Java"
            },
            {
                "id": 1568714,
                "title": "n-queens-ii-using-backtracking-algorithm",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nint bt=0;\\nvector<vector<int> > result;\\n\\nbool isSafe(vector<vector<int> > board,int row, int col)\\n{\\n\\tint i, j;\\n\\tint N = board.size();\\n\\tfor (i = 0; i < col; i++)\\n\\t\\tif (board[row][i])\\n\\t\\t\\treturn false;\\n\\tfor (i = row, j = col; i >= 0 && j >= 0; i--, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\tfor (i = row, j = col; j >= 0 && i < N; i++, j--)\\n\\t\\tif (board[i][j])\\n\\t\\t\\treturn false;\\n\\n\\treturn true;\\n}\\nbool solveNQUtil(vector<vector<int> >& board, int col)\\n{\\n\\tint N = board.size();\\n\\tif (col == N) {\\n\\t\\tvector<int> v;\\n\\t\\tfor (int i = 0; i < N; i++) {\\n\\t\\t\\tfor (int j = 0; j < N; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 1)\\n\\t\\t\\t\\t\\tv.push_back(j + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.push_back(v);\\n\\t\\treturn true;\\n\\t}\\n\\tbool res = false;\\n\\tfor (int i = 0; i < N; i++) {\\n\\t\\tif (isSafe(board, i, col)) {\\n\\t\\t\\tboard[i][col] = 1;\\n\\t\\t\\tres = solveNQUtil(board, col + 1) || res;\\n\\n\\t\\t\\tboard[i][col] = 0;\\n\\t\\t    bt++;\\n\\t\\t    \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\nvector<vector<int> > nQueen(int n)\\n{\\n\\tresult.clear();\\n\\tvector<vector<int> > board(n, vector<int>(n, 0));\\n\\n\\tif (solveNQUtil(board, 0) == false) {\\n\\t    cout << \"\\\\n\\\\nSolution for n = \" << n << \" does not exist\";\\n\\t\\treturn {};\\n\\t}\\n\\n\\tsort(result.begin(), result.end());\\n\\treturn result;\\n}\\n\\nint main()\\n{\\n\\tint n;\\n\\tcout << \"Enter the value of n = \";\\n\\tcin >> n;\\n\\t{\\n\\t int count=0;   \\n\\t vector<vector<int> > v = nQueen(n);\\n     cout << \"\\\\n\\\\nPossible solutions for n = \" << n;   \\n\\t for (auto ar : v) {\\n\\t\\tcout << \"\\\\n[\";\\n\\t\\tfor (auto it : ar)\\n\\t\\t\\tcout << it << \" \";\\n\\t\\tcout << \"]\";\\n\\t\\tcount++;\\n\\t}\\n\\tcout << \"\\\\n\\\\nThus total possible solutions of N Queen problem for N = \" << n << \" are \" << count;\\n\\tcout << \"\\\\n\\\\nTotal no. of backtracks = \" << bt;\\n\\t}\\n\\n\\treturn 0;\\n}\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1555851,
                "title": "python-recursive-solution-24-28ms-98",
                "content": "This was just a simplification of my solution for the preceding problem, [N-Queens](https://leetcode.com/problems/n-queens/discuss/1555836/Python-recursive-solution-28-32ms-(less~99)), so I found it interesting that the problems are presented in this order.\\n\\nIt led me to realize, however, that I don\\'t need to track the locations of queens (2D array) to generate the solutions for N-Queens (though it\\'s faster). The location of the queens can be inferred from the state of the three arrays (e.g. are the current square\\'s column and two diagonals all non-vacant?).\\n\\n```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n  def recurse(self, n, row, cols, diagsA, diagsB):\\n    if row == n:\\n      return 1\\n    r = 0\\n    for col in range(0, n):\\n      if cols[col] or diagsA[col + row] or diagsB[col - row]:\\n        continue\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = True\\n      r += self.recurse(n, row + 1, cols, diagsA, diagsB)\\n      cols[col] = diagsA[col + row] = diagsB[col - row] = False\\n    return r\\n\\n\\n  def totalNQueens(self, n):\\n    cols = [0] * n\\n    diagsA = [0] * (n * 2 - 1)\\n    diagsB = [0] * (n * 2 - 1)\\n    return self.recurse(n, 0, cols, diagsA, diagsB)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524746,
                "title": "java-tc-o-n-2-sc-o-1-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    public int totalNQueens(int n) {\\n        boolean[] row = new boolean[n];\\n        boolean[] col = new boolean[n];\\n        boolean[] diagonal = new boolean[n + n - 1];\\n        boolean[] antiDiagonal = new boolean[n + n - 1];\\n        \\n        return totalNQueens(n, 0, row, col, diagonal, antiDiagonal);\\n    }\\n    \\n    public static int totalNQueens(int n, int r, boolean[] row, boolean[] col, boolean[] diagonal, boolean[] antiDiagonal) {\\n        if(r == n) return 1;\\n        \\n        int count = 0;\\n        for(int c = 0; c < n; c++) {\\n            if(!row[r] && !col[c] && !diagonal[r + c] && !antiDiagonal[r - c + n - 1]) {\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = true;\\n                count += totalNQueens(n, r + 1, row, col, diagonal, antiDiagonal);\\n                row[r] = col[c] = diagonal[r + c] = antiDiagonal[r - c + n - 1] = false;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383450,
                "title": "c-hint",
                "content": "You gotta do just a small lil\\' change in the NQueens util function.\\n```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint NQueensSolve(int column, vector<vector<int>> &mat, int n){\\n        if (column==n)\\n            return 1;\\n        int counter = 0;\\n        for (int row=0;row<n;row++)\\n            if (isSafe(row, column, mat, n)){\\n                mat[row][column] = 1;\\n                counter += NQueensSolve(column+1, mat, n);\\n                mat[row][column] = 0;\\n            }\\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1343553,
                "title": "java-recursion-backtracking-1ms-faster-than-85",
                "content": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count;\\n    public int totalNQueens(int n) {\\n        boolean[][] queen = new boolean[n][n];\\n        count = 0;\\n        helper(0, n, queen);\\n        return count;\\n    }\\n    public void helper(int l, int n, boolean[][] queen){\\n        if(l == n){\\n            count++;\\n            return;\\n        }\\n        \\n        for(int i = 0; i < queen.length; i++){\\n            if(isSafe(l, i, queen)){\\n                queen[l][i] = true;\\n                helper(l + 1, n, queen);\\n                queen[l][i] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] queen){\\n        int r = i - 1, c = j;\\n        while(r >= 0)\\n            if(queen[r--][c])\\n                return false;\\n        r = i - 1;\\n        c = j - 1;\\n        while(r >= 0 && c >= 0)\\n            if(queen[r--][c--])\\n                return false;\\n        r = i - 1;\\n        c = j + 1;\\n        while(r >= 0 && c < queen.length) \\n            if(queen[r--][c++])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304705,
                "title": "java-branch-and-bound-100-time",
                "content": "Here we will bound the attacking spots by the queen which is being placed currently. And will do work for only those spots which are not attacked by any queen. I am iterating on rows in recursion so i will make arrays of Column, Diagonal1, Diagonal2. \\n\\nMark the cloumn array and the diagonal array accordingly (which falls under attacking spots).\\n\\n```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public static int solve(boolean[] colArr, boolean[] d1, boolean[] d2, int i) {\\n        \\n        if(i == colArr.length) {            \\n            return 1;\\n        }\\n        int sum = 0;\\n        for(int col = 0; col < colArr.length; col++) {\\n            if(!colArr[col] && !d1[i + col] && !d2[i - col + colArr.length - 1]) {\\n                colArr[col] = true;\\n                d1[i + col] = true;\\n                d2[i - col + colArr.length - 1] = true;\\n                sum += solve( colArr, d1, d2, i + 1);\\n                colArr[col] = false;\\n                d1[i + col] = false;\\n                d2[i - col + colArr.length - 1] = false;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public int totalNQueens(int n) {\\n        return solve(new boolean[n], new boolean[2*n - 1], new boolean[2*n - 1], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240241,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    bool isSafe(vector<vector<int> >v1,int col,int row)\\n{\\n    int n=v1.size();\\n \\n    for(int i=0;i<row;i++){\\n       if(v1[i][col]==1)\\n           return false;\\n     }\\n   \\n     for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n       if(v1[i][j])\\n       return false;\\n \\n    for(int i=row-1,j=col+1;j<n&&i>=0;i--,j++)\\n     if(v1[i][j])\\n     return false;\\n     \\nreturn true;\\n}\\nvoid NQueen(vector<vector<int> >&v1,int row)\\n{\\n   \\n    if(row==v1.size()){\\n        count++;\\n      return;}\\n      for(int i=0;i<v1.size();i++)\\n      {\\n          if(isSafe(v1,i,row))\\n          {\\n              v1[row][i]=1;\\n              NQueen(v1,row+1);\\n            v1[row][i]=0;\\n          }\\n      }\\n      return ;\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int> >v1;\\n    \\n    for(int i=0;i<n;i++){\\n        vector<int>v2(n,0);\\n    v1.push_back(v2);}\\n    \\n    NQueen(v1,0);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239159,
                "title": "c-backtracking-easy-to-understand-no-need-to-form-chess-board",
                "content": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    A simple approach will be the same as N Queens problem. Instead of returning all the configurations of board (vector<vector<string>>),\\n    here we return the count of total configurations. Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Backtracking/N-Queens.cpp\\n    \\n    But, you don\\'t need to form boards and configurations to count the total configurations. See the solution below.\\n*/\\nclass Solution {\\npublic:\\n    int count = 0;\\n    unordered_set<int> cols;\\n    unordered_set<int> diags;\\n    unordered_set<int> antiDiags;\\n    void dfs(int row, int n) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        \\n        for(int col = 0; col<n; col++) {\\n            int d  = row-col;\\n            int ad = row+col;\\n            \\n            if(cols.count(col) || diags.count(d) || antiDiags.count(ad))\\n                continue;\\n            \\n            cols.insert(col);\\n            diags.insert(d);\\n            antiDiags.insert(ad);\\n            \\n            dfs(row+1, n);\\n            \\n            cols.erase(col);\\n            diags.erase(d);\\n            antiDiags.erase(ad);\\n            \\n        }\\n    }\\n    vector<vector<string>> result;\\n    int totalNQueens(int n) {\\n        count = 0;\\n        if(n == 1)\\n            return 1;\\n        if(n <= 3)\\n            return count;\\n        \\n        dfs(0, n);\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238410,
                "title": "c-easily-understandable-solution-derived-from-n-queens-hinglish-comments",
                "content": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }\\n    \\n      void recurse( vector<vector<string>> &vec ,vector<string> &board , int row , int &n)\\n    {\\n        \\n        if(row == n)\\n        {\\n            vec.push_back(board);\\n            return;\\n        }\\n        \\n        //ek particular row to already selected h and now for each cell we have to traverse through column \\n        \\n        \\n        for(int col = 0 ; col < n ; col++)\\n        {\\n             if(isValid(board,row,col,n))\\n            {\\n                 board[row][col] = \\'Q\\';\\n                 /*ek baar uss place pe Q ko rakh ke aage proceed kiya agar ispe se koi answer derive ho paega to vo apne aap end me base condition ki vajah se answer(vec) me pushback ho jaega ab backtrack karne ke baad iss postion se queen ko hatana bhi to padega taaki multiple configurations try kar sake   */\\n                 recurse(vec,board,row+1,n); // Recursing row by row\\n                 board[row][col] = \\'.\\';// yahan pe q ko hataya h \\n            }\\n        }    \\n    }\\n    \\n    \\n    bool isValid(vector<string> &board ,int &row , int &col , int &n  )\\n    {\\n        \\n        for(int i=0;i<row;++i) // If column has queen already\\n        {\\n            if(board[i][col] == \\'Q\\')\\n                return false;\\n        } \\n        \\n        // If left diagonals have queen already \\n        for(int i=1;row-i>=0&&col-i>=0;++i)\\n        {\\n            if(board[row-i][col-i] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        // If right diagonal have queen already\\n        for(int i=1;row-i>=0&&col+i<n;++i)\\n        {\\n            if(board[row-i][col+i] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<string>> vec;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        recurse(vec,board,0,n);\\n        return vec.size();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1237841,
                "title": "python-short-recursion-easy-crisp",
                "content": "# N-Queens II\\n\\n**Complexity**\\n* Time Complexity -> `O(n!)` *(Since we have to check all possible permutations)*\\n* Space Complexity -> `O(n)` *(only set size of diagonals and columns)*\\n\\n\\n**[Note]**  *tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))*\\n\\nIn the above line I have incremented **row** by 1 and used **set\\'s union method(Operator |)**  to include diagonals and columns . For eg let\\'s take n=2, *[[00, 01], [10, 11]]*, then for diagonal 1 (col-row) -> *[[0, 1], [-1, 0]]* so it gives **diag1** set `{0, 1, -1}` and for diagonal 2 (col+row) -> *[[0, 1], [1, 2]]* it gives **diag2** `set {0, 1, 2}` , and for columns **cols** `set {0, 1}`\\n\\n\\n*Please upvote if you like the solution and comment if have any queries* .\\n\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        def soln(row, diag1, diag2, cols):\\n            #if passing all the rows and columns of the grid then return 1 i.e. possible answer\\n            if row==n:\\n                return 1\\n            \\n            tot = 0\\n            for col in range(n):\\n                #checking for the grid of queen not in same diagonals and same columns \\n                if ((col-row) in diag1) or ((col+row) in diag2) or (col in cols):\\n                    continue\\n                 \\n                #if passed above condition then including this grid in diagonals and columns for next row\\n                tot += soln(row+1, diag1|set([col-row]), diag2|set([col+row]), cols|set([col]))\\n            \\n            #Finally returning total no. of soluntions\\n            return tot\\n         \\n        #taking starting from row 0 sets of diagonal1 , diagonal2, columns\\n        return soln(0, set(), set(), set())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237750,
                "title": "n-queens-ii-c",
                "content": "The code written here is similar to the code, I gave before to the 1st part of it.\\nOnly the difference is here we want to count the number, so whenever we find a possible arrangement of queens we do ``ans++`` and finally return ans\\nMy previous post to the 1st part : https://leetcode.com/discuss/explore/may-leetcoding-challenge-2021/1223128/n-queens-c-backtracking\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n\\t\\t\\t\\t\\n        // we do not need to check column clashes as we place queens in different columns only\\n\\t\\t\\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)\\n        {\\n            ans++;   \\n            return;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);\\n                board[i][col]=\".\";\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224223,
                "title": "easy-to-understand-n-queens2-soln",
                "content": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n      char[][] board;\\n    List<List<String>> res;\\n    public int totalNQueens(int n) {\\n        solveNQueens(n);\\n      return res.size(); \\n    }\\n   List<List<String>> solveNQueens(int n) {\\n         board = new char[n][n];\\n         res = new ArrayList<List<String>>();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        solveRec(0);\\n        return res;\\n    }\\n    List<String> construct() {\\n        List<String> res = new LinkedList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n\\tvoid solveRec(int col) {\\n\\t\\tint N = board.length;\\n\\t\\tif(col==N) {\\n          res.add(construct());\\n            return;\\n        }\\n\\t\\tfor(int i=0;i<N;i++) {\\n\\t\\t\\tif(isSafe(i,col)) {\\n\\t\\t\\t\\tboard[i][col]=\\'Q\\';\\n\\t\\t\\t\\tsolveRec(col+1);\\n\\t\\t\\t\\tboard[i][col]=\\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tboolean isSafe(int row,int col) {\\n\\t\\tfor(int i=0;i<col;i++) {\\n\\t\\t\\tif(board[row][i]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i>=0 && j>=0;i--,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\tfor(int i=row,j=col;i< board.length&& j>=0;i++,j--) {\\n\\t\\t\\tif(board[i][j]==\\'Q\\') return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223291,
                "title": "plain-backtracking-simple-c-code",
                "content": "Same as N-queen solution : \\nhttps://leetcode.com/problems/n-queens/discuss/1223282/Plain-Backtracking-Simple-C%2B%2B-code-with-comments\\n```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool isRowFree(vector<string> &board, int row){\\n        int n = board.size();\\n        for(int col = 0; col < n; col++)\\n            if(board[row][col] == \\'Q\\') return false;\\n        return true;\\n    }\\n    bool isDiagonalFree(vector<string> &board, int row, int col){\\n        int n = board.size();\\n        int i = row, j = col;\\n        \\n        //Only need to check left side diagonals\\n        while(i >= 0 && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i--, j--;\\n        }\\n        i = row, j = col;\\n        while(i < n && j >= 0){\\n            if(board[i][j] == \\'Q\\') return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    void solve(vector<string> &board, int curr_col,int &ans){\\n        int n = board.size();\\n        \\n        if(curr_col == n){\\n            ans++;\\n            return;\\n        } \\n        \\n        //Check for valid row for curr_col where queen can be placed\\n        for(int curr_row = 0; curr_row < n; curr_row++){\\n            if(isRowFree(board, curr_row)  &&                \\n               isDiagonalFree(board, curr_row, curr_col))\\n            {\\n                board[curr_row][curr_col] = \\'Q\\';\\n                solve(board,curr_col+1,ans);\\n                board[curr_row][curr_col] = \\'.\\';   //backtrack step\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        vector<string> board (n ,string(n,\\'.\\'));\\n        int ans=0;\\n        \\n        solve(board, 0, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147551,
                "title": "c-backtracking-4ms-memory-99-9",
                "content": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0};\\n    int cnt=0;\\n    bool isvalid( int i, int j, int n){\\n        int x = i -1;\\n        while(x>=0){\\n            if(vis[x][j]){\\n                return false;\\n            }\\n            x--;\\n        }\\n        x = i -1;\\n        int y= j -1;\\n        while(x>=0 && y>=0){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y--;\\n        }\\n        x = i-1;\\n        y = j+1;\\n        while(x>=0 && y<n){\\n            if(vis[x][y]){\\n                return false;\\n            }\\n            x--;y++;\\n        }\\n        return true;\\n    }\\n    \\n    void countNQ(int r, int n){\\n        if(r == n){\\n            cnt++;\\n            return;\\n        }\\n\\n        for(int c= 0; c<n; c++){\\n            if(isvalid(r, c,n)){\\n                vis[r][c] = 1;\\n                countNQ(r+1, n);\\n                vis[r][c] = 0;\\n            }\\n        }\\n    }\\n    \\n    int totalNQueens(int n) {\\n        // vector<vector<int>>vis(n, vector<int>(n));\\n        countNQ(0,n);\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int vis[9][9] ={0}",
                "codeTag": "Java"
            },
            {
                "id": 916375,
                "title": "python-easy-solution-with-comments-95-7-faster",
                "content": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "class Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        \\n        \\n        #initializing the variables column, left digonal, right digonal, result\\n        col=[0]*(n+1); left_diag=[0]*(50); right_diag=[0]*(50);self.result=0\\n        \\n        #here is the main function\\n        def nqueen(c,n,ans):\\n            \\n            #if all columns are filled return True\\n            if c>=n: return True\\n            \\n            #traversing through every row\\n            for r in range(n):\\n                \\n                #if it is safe\\n                if col[r]!=1 and left_diag[r-c+n-1]!=1 and right_diag[r+c]!=1:\\n                    \\n                    #then we will update corresponding values to 1\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=1\\n                    \\n                    #if the the total board is filled then we will make result+1\\n                    if nqueen(c+1,n,ans): self.result+=1\\n                        \\n                    #if there was no way to fill backtrack and set all values to 0\\n                    col[r]=left_diag[r-c+n-1]=right_diag[r+c]=ans[r][c]=0\\n        \\n        #here we are creating the empty grid\\n        grid=[[0]*n for i in range(n)]\\n        #calling main function\\n        nqueen(0,n,grid)\\n        \\n        return self.result",
                "codeTag": "Java"
            },
            {
                "id": 827234,
                "title": "go-backtracking-solution",
                "content": "This is an easier version of #51.\\n\\nMore Go LC solutions:\\nhttps://github.com/phea/leetcode-go\\n\\n```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc totalNQueens(n int) int {\\n\\tcol := make([]int, n)\\n\\tdiag := make([]int, n*2)\\n\\tdiag2 := make([]int, n*2)\\n\\tvar count int\\n\\tvar search func(y int)\\n\\tsearch = func(y int) {\\n\\t\\tif y == n {\\n\\t\\t\\tcount++\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tfor x := 0; x < n; x++ {\\n\\t\\t\\tif col[x] != 0 || diag[x+y] != 0 || diag2[x-y+n-1] != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 1, 1, 1\\n\\t\\t\\tsearch(y + 1)\\n\\t\\t\\tcol[x], diag[x+y], diag2[x-y+n-1] = 0, 0, 0\\n\\t\\t}\\n\\t}\\n\\n\\tsearch(0)\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760728,
                "title": "java-backtracking-solution",
                "content": "If you found the solution helpful, kindly upvote. :)\\n\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n           \\tList<List<Integer>> result= new ArrayList<List<Integer>>();\\n    \\tsolveNQueens(result, n, 0, new ArrayList<Integer>());\\n    \\treturn result.size();\\n    }\\n\\n\\tprivate static void solveNQueens(List<List<Integer>> result, int n, int row, ArrayList<Integer> colPlacement)\\n\\t{\\n\\t\\tif(row==n)\\n\\t\\t\\tresult.add(new ArrayList<Integer>(colPlacement));\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tfor(int col=0; col<n; col++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcolPlacement.add(col);\\n\\t\\t\\t\\tif(placementIsValid(colPlacement))\\n\\t\\t\\t\\t\\tsolveNQueens(result, n, row+1, colPlacement);\\n\\t\\t\\t\\tcolPlacement.remove(colPlacement.size()-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static boolean placementIsValid(ArrayList<Integer> colPlacement) \\n\\t{\\n\\t\\tint row= colPlacement.size()-1;\\n\\t\\tfor(int i=0; i<row; i++)\\n\\t\\t{\\n\\t\\t\\tint diff= Math.abs(colPlacement.get(i)-colPlacement.get(row));\\n\\t\\t\\tif(diff==0 || diff==(row-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503671,
                "title": "swift-dsf-solution-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var total:Int = 0\\n    \\n    func totalNQueens(_ n: Int) -> Int{\\n        var arr:[Int] = Array(repeating: 0, count: n)\\n        helper(&arr, 0)\\n        return total\\n    }\\n    \\n    func helper(_ arr: inout [Int],_ current: Int) {\\n        if current == arr.count{\\n            total += 1\\n            return\\n        }\\n        for i in 0..<arr.count{\\n            if !hasConflict(&arr, current, i){\\n                arr[current] = i\\n                helper(&arr, current+1)\\n            }\\n        }\\n    }\\n    \\n    func hasConflict(_ arr:inout[Int],_ row:Int,_ col:Int)->Bool{\\n        for i in 0..<row {\\n            if arr[i] == col || arr[i] + i == col + row || arr[i] - i == col - row {\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 480337,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nSame as [51. N-Queens](https://leetcode.com/problems/n-queens/discuss/480335/Javascript-and-C%2B%2B-solutions) except for the return value.  Instead of returning string reprenstations of the solutions, return the count of solutions.\\n\\n*Javascript*\\n```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = (N, cnt = 0) => {\\n    let A = Array(N).fill(-1); // index is the row and value is the column of each queen\\n    let ok = (i, j) => {\\n        if (A[i] > -1 || A.some(col => col == j) || A.some((col, row, A) => col > -1 && Math.abs(row - i) == Math.abs(col - j)))\\n            return false; // invalid row, col, or diag\\n        return true;\\n    };\\n    let dfs = (i = 0) => {\\n        if (i == N) {\\n            ++cnt;\\n            return;\\n        }\\n        for (let j = 0; j < N; ++j) {\\n            if (!ok(i, j))\\n                continue;\\n            A[i] = j,\\n            dfs(i + 1),\\n            A[i] = -1;            \\n        }\\n    };\\n    dfs();\\n    return cnt;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int totalNQueens(int N, VVI ans = {}, int cnt = 0) {\\n        VI A(N, -1); // row is index and col is value of each queen\\n        return dfs(A, ans);\\n    }\\nprivate:\\n    bool ok(VI& A, int i, int j) {\\n        if (A[i] > -1 || find(A.begin(), A.end(), j) != A.end())\\n            return false;\\n        for (auto row = 0; row < A.size(); ++row) {\\n            auto col = A[row];\\n            if (col > -1 && abs(row - i) == abs(col - j))\\n                return false;\\n        }\\n        return true;\\n    };\\n    int dfs(VI& A, VVI& ans, int i = 0, int cnt = 0) {\\n        auto N = A.size();\\n        if (i == N) {\\n            ans.push_back(A);\\n            return 1;\\n        }\\n        for (auto j = 0; j < N; ++j) {\\n            if (!ok(A, i, j))\\n                continue;\\n            A[i] = j;\\n            cnt += dfs(A, ans, i + 1);\\n            A[i] = -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386070,
                "title": "javascript",
                "content": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar totalNQueens = function(n) {\\n    let res = 0;\\n    let board = [];\\n    function backtrack(r) {\\n        if(r === n) {\\n            res++;\\n            return;\\n        }\\n        for(let c = 0 ; c < n ; c++) {\\n            if(!board.some((bc, br) => \\n                          bc === c || bc - br === c - r || bc + br === c + r)) {\\n                board.push(c);\\n                backtrack(r + 1);\\n                board.pop();\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368847,
                "title": "java-backtracking-solution-traditional-and-clean",
                "content": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    \\u5BF9\\u4E8E\\u8FD9\\u7C7B\\u95EE\\u9898\\uFF0C\\u6CA1\\u6709\\u592A\\u7B80\\u4FBF\\u7684\\u65B9\\u6CD5\\uFF0C\\u53EA\\u80FD\\u4F7F\\u7528\\u7A77\\u4E3E\\u6CD5\\uFF0C\\u5C31\\u662F\\u5C1D\\u8BD5\\u6240\\u6709\\u7684\\u7EC4\\u5408\\uFF0C\\u6BCF\\u653E\\u7F6E\\u4E00\\u4E2A\\u65B0\\u7684\\u7687\\u540E\\u7684\\u65F6\\u5019\\uFF0C\\u5FC5\\u987B\\u8981\\u4FDD\\u8BC1\\u8DDF\\u4E4B\\u524D\\u7684\\u6240\\u6709\\u7687\\u540E\\u4E0D\\u80FD\\u51B2\\u7A81\\uFF0C\\u82E5\\u53D1\\u751F\\u4E86\\u51B2\\u7A81\\uFF0C\\u8BF4\\u660E\\u5F53\\u524D\\u4F4D\\u7F6E\\u4E0D\\u80FD\\u653E\\uFF0C\\u8981\\u91CD\\u65B0\\u627E\\u5730\\u65B9\\uFF0C\\u8FD9\\u4E2A\\u903B\\u8F91\\u975E\\u5E38\\u9002\\u5408\\u7528\\u9012\\u5F52\\u6765\\u505A\\u3002\\n    \\u6240\\u8C13\\u9012\\u5F52\\u56DE\\u6EAF\\uFF0C\\u672C\\u8D28\\u4E0A\\u662F\\u4E00\\u79CD\\u679A\\u4E3E\\u6CD5\\u3002\\u8FD9\\u79CD\\u65B9\\u6CD5\\u4ECE\\u68CB\\u76D8\\u7684\\u7B2C\\u4E00\\u884C\\u5F00\\u59CB\\u5C1D\\u8BD5\\u6446\\u653E\\u7B2C\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u6446\\u653E\\u6210\\u529F\\u540E\\uFF0C\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u518D\\u9075\\u5FAA\\u89C4\\u5219\\u5728\\u68CB\\u76D8\\u7B2C\\u4E8C\\u884C\\u6765\\u6446\\u653E\\u7B2C\\u4E8C\\u4E2A\\u7687\\u540E\\u3002\\u5982\\u679C\\u5F53\\u524D\\u4F4D\\u7F6E\\u65E0\\u6CD5\\u6446\\u653E\\uFF0C\\u5219\\u5411\\u53F3\\u79FB\\u52A8\\u4E00\\u683C\\u518D\\u6B21\\u5C1D\\u8BD5\\uFF0C\\u5982\\u679C\\u6446\\u653E\\u6210\\u529F\\uFF0C\\u5219\\u7EE7\\u7EED\\u9012\\u5F52\\u4E00\\u5C42\\uFF0C\\u6446\\u653E\\u7B2C\\u4E09\\u4E2A\\u7687\\u540E......\\n    \\u5982\\u679C\\u67D0\\u4E00\\u5C42\\u770B\\u904D\\u4E86\\u6240\\u6709\\u683C\\u5B50\\uFF0C\\u90FD\\u65E0\\u6CD5\\u6210\\u529F\\u6446\\u653E\\uFF0C\\u5219\\u56DE\\u6EAF\\u5230\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\uFF0C\\u8BA9\\u4E0A\\u4E00\\u4E2A\\u7687\\u540E\\u53F3\\u79FB\\u4E00\\u683C\\uFF0C\\u518D\\u8FDB\\u884C\\u9012\\u5F52\\u3002\\u5982\\u679C\\u516B\\u4E2A\\u7687\\u540E\\u90FD\\u6446\\u653E\\u5B8C\\u6BD5\\u4E14\\u7B26\\u5408\\u89C4\\u5219\\uFF0C\\u90A3\\u4E48\\u5C31\\u5F97\\u5230\\u4E86\\u5176\\u4E2D\\u4E00\\u79CD\\u6B63\\u786E\\u7684\\u89E3\\u6CD5\\u3002\\n    */\\n    int results = 0;\\n    public int totalNQueens(int n) {\\n        if (n <= 0) {\\n            return 0;\\n        }\\n        \\n        List<Integer> queenPos = new ArrayList<>();\\n        search(queenPos, n);\\n        return results;\\n    }\\n    \\n    /*\\n     * results store all of the chessboards\\n     * queenPos store the column indices or the position of queens for each row\\n     */\\n    private void search(List<Integer> queenPos,\\n                        int n) {\\n        \\n        // there are already n queens in the list, \\n        // which means every row has been assigned a queen\\n        if (queenPos.size() == n) {\\n            results++;\\n            return;\\n        }\\n        \\n        for (int colIndex = 0; colIndex < n; colIndex++) {\\n            if (!isValid(queenPos, colIndex)) {\\n                continue;\\n            }\\n            queenPos.add(colIndex);\\n            search(queenPos, n);\\n            // backtracking, and explore if the queen can be placed into the next column\\n            queenPos.remove(queenPos.size() - 1);\\n        }\\n    }\\n    \\n    private boolean isValid(List<Integer> queenPos, int column) {\\n        int row = queenPos.size();\\n        for (int rowIndex = 0; rowIndex < row; rowIndex++) {\\n            int preQueenPos = queenPos.get(rowIndex);\\n            // same column, fail\\n            if (preQueenPos == column) {\\n                return false;\\n            }\\n            // left diagonal or right diagonal, fail\\n            if (rowIndex + preQueenPos == row + column \\n                || rowIndex - preQueenPos == row - column) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305056,
                "title": "c-99-beaten-using-backtracking-basic-hacking-code-the-road-coderz-codez",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```\\n\\nGG",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        \\n        int aCol[n + 1];\\n        \\n        return countQueens(n, aCol, 0); \\n    }\\n    \\n    int countQueens(int n, int *pCol, int pIndex) {\\n        \\n        if (pIndex >= n) { return 1; }\\n        \\n        int aCount = 0;\\n        \\n        for (int i=0;i<n;i++) {\\n            \\n            bool aBlocked = false;\\n            \\n            for (int aBack=pIndex-1;aBack>=0;aBack--) {\\n                \\n                if (pCol[aBack] == i) { aBlocked = true; }\\n                \\n                int aDiff = pCol[aBack] - i;\\n                if (aDiff < 0) { aDiff = -aDiff; }\\n                \\n                if ((pIndex - aBack) == aDiff) {\\n                    aBlocked = true;\\n                }\\n            }\\n            if (aBlocked) { continue; }\\n            \\n            pCol[pIndex] = i;\\n            \\n            aCount += countQueens(n, pCol, pIndex + 1);   \\n        }\\n        return aCount;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299715,
                "title": "java-clean-bitwise-implementation-beats-100-0ms",
                "content": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  \\n  private int size;\\n  private int count;\\n\\n  private void solve(int row, int ld, int rd) {\\n    if (row == size) {\\n      count++;\\n      return;\\n    }\\n    int pos = size & (~(row | ld | rd));\\n    while (pos != 0) {\\n      int p = pos & (-pos);\\n      pos -= p;\\n      solve(row + p, (ld + p) << 1, (rd + p) >> 1);\\n    }\\n  }\\n  \\n  public int totalNQueens(int n) {\\n    count = 0;\\n    size = (1 << n) - 1;\\n    solve(0, 0, 0);\\n    return count;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196627,
                "title": "c-using-bit-manipulation",
                "content": "Need to consider the bit size.  \\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row, int cols, int pie, int na, int &n, int &count) {\\n        if (row >= n) {\\n            count++;\\n            return;\\n        }\\n\\n        int bits = ~(cols | pie | na) & (1 << n - 1);\\n        while (bits) {\\n            int x = bits & -bits;\\n            dfs(row + 1, cols | x, (pie | x) << 1, (na | x) >> 1, n, count);\\n            bits ^= x;\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if (n < 1) {\\n            return 0;\\n        }\\n\\n        int ret = 0;\\n        dfs(0, 0, 0, 0, n, ret);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152108,
                "title": "a-nice-hack-might-be-very-informative-specially-for-new-users",
                "content": "For those who don\\'t know, this site can be of very much use.\\nThere\\'s this site: https://oeis.org/ (The online encyclopedia of integer sequence) which has all popular integer sequences. Number of solutions of NQueens is one among them.\\n\\nJust search for nQueen, you can see it here: https://oeis.org/search?q=nqueen&language=english&go=Search\\n\\nNow coming to the code\\n```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```\\n:P\\n",
                "solutionTags": [],
                "code": "```cpp\\nint totalNQueens(int n) {\\n    int ans[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104, 666090624};\\n    return ans[n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123480,
                "title": "java-beats-100-love-u-all",
                "content": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int res[] = {1, 0, 0, 2, 10, 4, 40, 92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512, 95815104};\\n\\n    public int totalNQueens(int n) {\\n        if (n >= 1) {\\n            return res[n - 1];\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20064,
                "title": "beat-me-fastest-c-15-queens-1000ms",
                "content": "15 queens ~ 1000ms\\n```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint N, NF;\\nint put(int n, int nw, int ne){\\n        if(n==NF)return 1;\\n        int res=0;\\n        nw>>=1;ne<<=1;\\n        int mask=( ~(n|nw|ne) ) & ( (1<<N) -1 );\\n        while(mask){\\n                int i=(mask&-mask);\\n                res+=put(n^i,nw^i,ne^i);\\n                mask-=i;\\n        }\\n        return res;\\n}\\nint totalNQueens(int n) {\\n        N=n;\\n        NF=(1<<N)-1;\\n        int i=1<<((N-1)/2);\\n        int mid=put(i,i,i);\\n        int res=mid;\\n        for(i>>=1;i;i>>=1){\\n                res+=put(i,i,i);\\n        }\\n        res+=res;\\n        if(N&1)res-=mid;\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20096,
                "title": "java-ac-bit-m-over-98-low-space",
                "content": "public class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }\\n    \\n    void helper(int row, int ld, int rd){  \\n        if (row != upperlim)  \\n        {  \\n            int pos = upperlim & ~(row | ld | rd);   \\n            while (pos>0)\\n            {  \\n                int p = pos & -pos;                                                \\n      \\n                pos -= p;                             \\n                \\n                helper(row + p, (ld + p) << 1, (rd + p) >> 1);                                \\n            }  \\n        }else{\\n            sum++;\\n        }  \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    \\n    int sum = 0, upperlim = 1;\\n    \\n    public int totalNQueens(int n) {\\n        upperlim = (upperlim << n) - 1; \\n        helper(0,0,0);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20090,
                "title": "11-line-python-solution-easy-to-understand",
                "content": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def totalNQueens(self, n):\\n        def dfs(board, row):\\n            if row == n: return 1\\n            count = 0\\n            for x in set_n - set(board):\\n                # check diagonal conflict\\n                if all(row - i != abs(x - y) for i, y in enumerate(board[:row])):\\n                    board[row] = x\\n                    count += dfs(board, row + 1)\\n                    board[row] = '.'\\n            return count\\n\\n        set_n = {i for i in xrange(n)}\\n        return dfs(['.'] * n, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 20086,
                "title": "java-easy-version-to-understand",
                "content": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic static boolean checkOk(int[] columnNumber, int row) {\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif (columnNumber[row] == columnNumber[i]\\n\\t\\t\\t\\t\\t|| Math.abs(i - row) == Math.abs(columnNumber[i] - columnNumber[row]))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tpublic static void DFS(int n, int row, int[] columnNumber, int[] count) {\\n\\t\\tif (row == n)\\n\\t\\t\\tcount[0]++;\\n\\t\\telse {\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tcolumnNumber[row] = i;\\n\\t\\t\\t\\tif (checkOk(columnNumber, row))\\n\\t\\t\\t\\t\\tDFS(n, row + 1, columnNumber, count);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static int totalNQueens(int n) {\\n\\t\\tif (n <= 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint[] columnNumber = new int[n];\\n\\t\\tint[] count = { 0 };\\n\\t\\tDFS(n, 0, columnNumber, count);\\n\\t\\treturn count[0];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 20137,
                "title": "java-accepted-clean-solutions-98-73",
                "content": "    public class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }\\n    public void dfs(int[] pos,int step,int n) {\\n        if(step==n) {\\n            \\n            count++;\\n            return;\\n        }\\n        for(int i=0;i<n;i++) {\\n            pos[step]=i;\\n            if(isvalid(pos,step)) {\\n                dfs(pos,step+1,n);\\n            }\\n        }\\n    }\\n    public boolean isvalid(int[] pos, int step) {\\n        for(int i=0;i<step;i++) {\\n            if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            \\n        }\\n        return true;\\n    }\\n   \\n   \\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int count=0;\\n    public int totalNQueens(int n) {\\n        \\n        \\n        dfs(new int[n],0,n);\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20139,
                "title": "short-c-solution-representing-board-as-vector-int",
                "content": "The basic idea is to represent the board as a vector of int, where each index is a column of the board, and each value is the row the queen is on. We can do this because all solutions have exactly one queen on every column. Then, for each column, we place a queen on each row and check if the board is valid. If it is, we recurse on the next column. Checking if the board is valid is straightforward - we just check the row and diagonals of the newest queen against the existing queens:\\n\\n    class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n    \\n        int totalNQueens(vector<int>& columns, int col) {\\n            if (col == columns.size()) {\\n                return 1;\\n            }\\n            int total = 0;\\n            for (int row = 0; row < columns.size(); ++row) {\\n                columns[col] = row;\\n                if (isValid(columns, col)) {\\n                    total += totalNQueens(columns, col + 1);\\n                }\\n            }\\n            return total;\\n        }\\n    \\n        int totalNQueens(int n) {\\n            vector<int> columns(n, 0);\\n            return totalNQueens(columns, 0);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValid(const vector<int>& columns, int col) {\\n            for (int c = 0; c < col; ++c) {\\n                if ((columns[c] == columns[col])\\n                    || (col - c == columns[col] - columns[c])\\n                    || (col - c == columns[c] - columns[col])) {\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 20169,
                "title": "accepted-backtracking-python-solution-very-similar-to-the-solution-to-n-queens-i",
                "content": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return an integer\\n        def totalNQueens(self, n):\\n            self.num = 0\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.num\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                self.num += 1\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True\\n\\nJust changed from appending all possible boards to self.result to incrementing self.num by 1 every time when a possible board is found.",
                "codeTag": "Java"
            },
            {
                "id": 4076593,
                "title": "easy-fast-solution-using-backtracking-and-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        return queens(board, 0);\\n    }\\n    static int queens(boolean [][] board,int row) {\\n\\t\\tif(row == board.length) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\tint count=0;\\n        for (int col = 0; col < board.length; col++) {\\n\\t\\t    if(isSafe(board,row,col)) {\\n\\t\\t\\t    board[row][col] = true;\\n\\t\\t\\t    count += queens(board, row+1);\\n\\t\\t\\t    board[row][col] = false;\\n\\t\\t    }\\n\\t    }\\n\\t\\treturn count;\\n\\t}\\n\\tstatic boolean isSafe(boolean[][] board, int row, int col) {\\n\\t\\t\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tif(board[i][col]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxLeft = Math.min(row, col);\\n\\t\\tfor(int i= 1 ;i<=maxLeft;i++) {\\n\\t\\t\\tif (board[row-i][col-i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint maxRight = Math.min(row, board.length-col-1);\\n\\t\\tfor (int i = 1; i <= maxRight; i++) {\\n\\t\\t\\tif(board[row-i][col+i]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018517,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n    boolean[][] board = new boolean[n][n];\\n        List<List<String>> solutions = new ArrayList<>();\\n       return solve(board, 0, solutions);\\n       \\n        \\n    }\\n     static int solve(boolean[][] board, int row, List<List<String>> solutions) {\\n        if (row == board.length) {\\n            solutions.add(display(board));\\n            return 1;\\n        }\\n            int count = 0;\\n        for (int col = 0; col < board.length; col++) {\\n            if (isSafe(board, row, col)) {\\n                board[row][col] = true;\\n               count+=solve(board, row + 1, solutions);\\n                board[row][col] = false;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private static boolean isSafe(boolean[][] board, int row, int col) {\\n        for (int i = 0; i < row; i++) {\\n            if (board[i][col]) {\\n                return false;\\n            }\\n        }\\n        int maxLeft = Math.min(row, col);\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if (board[row - i][col - i]) {\\n                return false;\\n            }\\n        }\\n        int maxRight = Math.min(row, board.length - col - 1);\\n        for (int i = 1; i <= maxRight; i++) {\\n            if (board[row - i][col + i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private static ArrayList<String> display(boolean[][] board) {\\n        ArrayList<String> list = new ArrayList<>();\\n        for (boolean[] arr : board) {\\n            StringBuilder row = new StringBuilder();\\n            for (boolean num : arr) {\\n                if (num) {\\n                    row.append(\"Q\");\\n                } else {\\n                    row.append(\".\");\\n                }\\n            }\\n            list.add(row.toString());\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929358,
                "title": "2-approaches-100-faster-o-1-lookup-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    // bool isSafe(int r, int c, vector<vector<int>> &board){\\n    //     //Upper\\n    //     for(int i = r-1; i >= 0; --i){\\n    //         if(board[i][c]) return false;\\n    //     }\\n\\n    //     //UL\\n    //     for(int i = r-1, j = c-1; i >= 0 && j >= 0; --i, --j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     //UR\\n    //     for(int i = r-1, j = c+1; i >= 0 && j < n; --i, ++j){\\n    //         if(board[i][j]) return false;\\n    //     }\\n\\n    //     return true;\\n    // }\\n    // int f(int row, vector<vector<int>> &board){\\n    //     if(row == n) return 1;\\n\\n    //     int count = 0;\\n    //     for(int i = 0; i < n; ++i){\\n    //         if(isSafe(row, i, board)){\\n    //             board[row][i] = 1;\\n    //             count += f(row+1, board);\\n    //             board[row][i] = 0;\\n    //         }\\n    //     }\\n    //     return count;\\n    // }\\n    int f(int row, vector<bool> &u, vector<bool> &ul, vector<bool> &ur){\\n        if(row == n) return 1;\\n        int count = 0;\\n        for(int col = 0; col < n; ++col){\\n            if(u[col] && ul[n-1+row-col] && ur[row+col]){\\n                u[col] = false;\\n                ul[n-1+row-col] = false;\\n                ur[row+col] = false;\\n                count += f(row+1, u, ul, ur);\\n                u[col] = true;\\n                ul[n-1+row-col] = true;\\n                ur[row+col] = true;\\n            }\\n        }\\n        return count;\\n    }\\n    int totalNQueens(int N) {\\n        n = N;\\n        // vector<vector<int>> board(n, vector<int>(n, 0));\\n        vector<bool> u(n, true), ul(2*n-1, true), ur(2*n-1, true);\\n        return f(0, u, ul, ur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876811,
                "title": "beats-100-commented-bet-easiest-to-understand-used-safe-state-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool safe(int *place,int row,int col){\\n               for(int i=0;i<row;i++){\\n                   if(place[i]==col) return false;\\n                   if(abs(row-i)==abs(col-place[i])) return false;\\n               }\\n               return true;\\n    }\\n    void nqueen(int n,int row,int *place,int *sum){\\n                  for(int i=0;i<n;i++){\\n                if(safe(place,row,i)){\\n                   place[row]=i;\\n                   if(row==n-1) (*sum)+=1;\\n                   else nqueen(n,row+1,place,sum);\\n                }     \\n                \\n                \\n           }\\n    }\\n    int totalNQueens(int n) {\\n        int place[n];\\n        int sum=0;\\nnqueen(n,0,place,&sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862732,
                "title": "simplest-solution-100-sc-tc-using-recursion-backtracking",
                "content": "# Intuition\\nWe improve this from the N Quuens 1 by taking the advantage that we do not need the whole board, we just need to know the location of queens. We use a vector of pairs to store the location of our queens. We simply follow the recursive approach.\\n\\n# Approach\\nWe store the queens in a vector of pairs & increase the value of the counter whenever we get the size of the queens vector = n. To check the validity of placing queens we simply check if they\\'re in the same row or same column. Or check the mod of the difference between the row and previous rows & col and previous columns.\\n\\n# Complexity\\n- Time complexity:\\nO( N * 2^N ) - Because recursion is 2^N & our check function is N.\\n\\n# Space complexity:\\nO(N) - Because we just use a 1 dimensional vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int count = 0;\\n        vector<pair<int , int>> queens;\\n        int col = 0;\\n        compute( col, queens, count, n);\\n\\n        return count;\\n    }\\n\\n    void compute( int col, vector<pair<int , int>>& queens, int& count, int n){\\n\\n        if( queens.size() == n){\\n            count++;\\n            return;\\n        }\\n\\n        for( int row = 0; row<n; row++ ){\\n            if( check( row, col, queens, n) ){\\n                queens.push_back({row, col});\\n                compute( col+ 1, queens, count, n);\\n                queens.pop_back();\\n            }\\n        }\\n\\n    }\\n\\n    bool check( int row, int col, vector<pair<int , int>>& queens, int n){\\n\\n        for( int i = 0; i< queens.size(); i++){\\n            int prow = queens[i].first;\\n            int pcol = queens[i].second;\\n\\n            if( pcol == col || abs(pcol - col) == abs(prow - row) || prow == row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862026,
                "title": "python-96-52-faster-two-approaches",
                "content": "**Brute Force Approch:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\\n**Optimized Approach:**\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```\\n**An upovte will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,board):\\n            i,j=row,col\\n            while i>=0 and j>=0: # for diagonaly upwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i-=1\\n                j-=1\\n            i,j=row,col\\n            while i<n and j>=0: # for diagonaly downwards direction in left\\n                if board[i][j]==\\'Q\\':\\n                    return False\\n                i+=1\\n                j-=1\\n            while col>=0: # for checking the same column\\n                if board[row][col]==\\'Q\\':\\n                    return False\\n                col-=1\\n            return True\\n        \\n        def solve(c,board):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,board):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    solve(c+1,board)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        ans=[]\\n        solve(0,board)\\n        return len(ans)       \\n```\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def safe(row,col,same_row,left_up,left_down):\\n            if row in same_row:\\n                return False\\n            if (n-1+col-row) in left_up:\\n                return False\\n            if (row+col) in left_down:\\n                return False\\n            return True\\n        \\n        def solve(c,board,same_row,left_up,left_down):\\n            if c==n:\\n                ans.append(board[:])\\n                return \\n            for i in range(n):\\n                if safe(i,c,same_row,left_up,left_down):\\n                    board[i]=board[i][:c]+\\'Q\\'+board[i][c+1:]\\n                    same_row.add(i)\\n                    left_up.add(n-1+c-i)\\n                    left_down.add(i+c)\\n                    solve(c+1,board,same_row,left_up,left_down)\\n                    same_row.remove(i)\\n                    left_up.remove(n-1+c-i)\\n                    left_down.remove(i+c)\\n                    board[i]=board[i][:c]+\\'.\\'+board[i][c+1:]\\n                    \\n        board=[\\'.\\'*n for _ in range(n)]\\n        same_row=set()\\n        left_up=set()\\n        left_down=set()\\n        ans=[]\\n        solve(0,board,same_row,left_up,left_down)\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847808,
                "title": "similar-n-queens-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public boolean issafe(int row,int col,char board[][]){\\n           //horizantal\\n           for(int j=0;j<board.length;j++){\\n               if(board[row][j]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //vertical\\n           for(int i=0;i<board[0].length;i++){\\n               if(board[i][col]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperleft\\n           int r=row;\\n           for(int c=col;c>=0&&r>=0;c--,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //upperright\\n            r=row;\\n           for(int c=col;c<board.length&&r>=0;c++,r--){\\n               if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerleft\\n            r=row;\\n           for(int c=col;c>=0&&r<board[0].length;c--,r++){\\n                if(board[r][c]==\\'Q\\'){\\n                   return false;\\n               }\\n           }\\n           //lowerright\\n           return true;\\n       }\\n    public void combine(List<List<String>> list,char board[][]){\\n        List<String> currboard=new ArrayList<>();\\n        for(int row=0;row<board.length;row++){\\n            String curr=\"\";\\n            for(int col=0;col<board[0].length;col++){\\n                if(board[row][col]==\\'Q\\'){\\n                    curr+=\\'Q\\';\\n                }\\n                else{\\n                    curr+=\\'.\\';\\n                }\\n            }\\n            currboard.add(curr);\\n        }\\n        list.add(currboard);\\n    }\\n    public void solve(List<List<String>> list,char board[][],int col){\\n        if(col==board.length){\\n            combine(list,board);\\n            return ;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(issafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                solve(list,board,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public int totalNQueens(int n) {\\n        List<List<String>> list=new ArrayList<>();\\n        char board[][]=new char[n][n];\\n        solve(list,board,0);\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764769,
                "title": "100-easy-fast-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n// IF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!\\n\\n![download.png](https://assets.leetcode.com/users/images/1e5393d0-c496-46d8-a339-1d7e7241754f_1689346738.066668.png)\\n```\\nclass Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }\\n      int queens(boolean[][]board,int row)\\n    {   if(row == board.length)  return 1;\\n        int count=0;\\n        // place the queen and check row and colum\\n        for(int col=0;col<board.length;col++)\\n         // place the queen if it is safe\\n        if(isSafe(board,row,col))\\n        { board[row][col]=true;\\n          count+=queens(board,row + 1);\\n          board[row][col]=false;\\n         }\\n          return count;\\n    }   \\n  boolean isSafe(boolean [][] board,int row,int col)\\n  { // checking verticle \\n    for(int i=0;i<row;i++)\\n    if(board[i][col]) return false;\\n     // checking left digonal\\n    int maxLeft=Math.min(row,col);\\n    for(int i=1;i<=maxLeft;i++)\\n    if(board[row -i][col -i]) return false;\\n    // checking right digonal\\n    int maxRight=Math.min(row,board.length - col -1);\\n    for( int i=1;i<=maxRight;i++)\\n    if(board[row - i][col + i]) return false;\\n     // if none of the check is false, means ans is true\\n     return true;\\n   }\\n }\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int totalNQueens(int n) {\\n        boolean board[][]=new boolean[n][n];\\n        return queens(board,0);    }",
                "codeTag": "Java"
            },
            {
                "id": 3700252,
                "title": "c-follows-from-n-queens-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<string>& temp,int i,int j){\\n        for(int k=0;k<temp.size();k++){\\n            if(temp[k][j]==\\'Q\\' || temp[i][k]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int a=i,b=j;\\n        while(a>=0 && b<temp.size()){\\n            if(temp[a][b]==\\'Q\\'){\\n                return false;\\n            }\\n            a--;b++;\\n        }\\n        int c=i,d=j;\\n        while(c>=0 && d>=0){\\n            if(temp[c][d]==\\'Q\\'){\\n                return false;\\n            }\\n            c--;\\n            d--;\\n        }\\n        return true;\\n    }\\n    bool helper(int i, vector<string>& temp, vector<vector<string>>& store){\\n        //base case\\n        if(i==temp.size()){\\n            store.push_back(temp);\\n            return false;\\n        }\\n        //recursive case\\n        for(int j=0;j<temp.size();j++){\\n            if(isValid(temp,i,j)){\\n                temp[i][j]=\\'Q\\';\\n                bool remaining= helper(i+1,temp,store);\\n                if(remaining==true){\\n                    return true;\\n                }\\n                temp[i][j]=\\'.\\';\\n            }\\n        }\\n        return false;\\n    }\\n    int totalNQueens(int n) {\\n        int ans1;\\n        vector<vector<string>> store;\\n        vector<string> temp;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n            ans += \".\";\\n        }\\n        for(int i=0;i<n;i++){\\n            temp.push_back(ans);\\n        }\\n        int i=0;\\n        helper(i,temp,store);\\n        ans1=store.size();\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629401,
                "title": "c-backtracking-solution-explained",
                "content": "# Intuition\\nWe need to place the queens such that they cannot cross eachother.\\n# Approach\\nWe keep check each row for a position where we can place a queen, then place it there and call recursion to place the queens in the other rows and then backtrack to find the other possibilities. \\nIf we get to the last row and are able to place a queen in that row, that means we have a possible combination, so we increment the total number of possible combinations by 1\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count;\\n    bool checkValid(vector<string> &board, int row, int col, int size){\\n\\n        // check top up\\n        for(int i = row-1;i>=0; i--){\\n            if(board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n\\n        // check diagonal\\n        for(int i = 1; i<=row; i++){\\n            if(col-i>=0){\\n                // left diagonal\\n                if(board[row-i][col-i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n            if(col+i <size){\\n                // right diagonal\\n                if(board[row-i][col+i] == \\'Q\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    void helper(vector<string> &board, int row, int size){\\n        if(row == size){\\n            count++;\\n            return;\\n        }\\n\\n        for(int i = 0; i<size; i++){\\n            if(checkValid(board, row, i, size)){\\n                board[row][i] = \\'Q\\';\\n                helper(board, row+1, size);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        string str;\\n        str.append(n, \\'.\\');\\n        vector<string> board(n, str);\\n        count = 0;\\n        helper(board, 0, n);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624735,
                "title": "n-queens-bitmasking-0-ms-beats-100",
                "content": "x means safe position\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n, int row, int colMask, int leftDiagMask, int rightDiagMask) {\\n        if (row == n) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        int rowState = (colMask | leftDiagMask | rightDiagMask) & ((1 << n) - 1);\\n        int x = rowState ^ ((1 << n) - 1);\\n        while (x) {\\n            int queenPos = x & (-x);\\n            x -= queenPos;\\n            if (!(queenPos & rowState)) {\\n                ans += solve(n, row + 1, colMask | queenPos, (leftDiagMask | queenPos) << 1, (rightDiagMask | queenPos) >> 1);\\n            }\\n        }\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solve(n, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481133,
                "title": "c-using-recursion-backtracking-t-c-o-n-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(n!)\\n        Space Complexity : O(n^2) + O(2*n) + O(n)\\n    */\\n    \\nprivate:\\n    vector<int> upperLeftDiagnal;\\n    vector<int> upperRightDiagnal;\\n    vector<int> upperCol;\\n    \\n    int res = 0;\\n    vector<string> board;\\n    \\n    void helper(int row, int size){\\n        if(row == size){\\n            res++;\\n            return;\\n        }\\n        \\n        for(int col=0; col<size; col++){\\n            if(upperCol[col]==0 and\\n               upperLeftDiagnal[row+col]==0 and\\n               upperRightDiagnal[(size-1)+col-row]==0\\n              ){\\n                board[row][col] = \\'Q\\';\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 1;\\n                helper(row+1, size);\\n                upperCol[col] = upperLeftDiagnal[row+col] = upperRightDiagnal[(size-1)+col-row] = 0;\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int totalNQueens(int n) {\\n        upperLeftDiagnal.resize(2*n-1, 0);\\n        upperRightDiagnal.resize(2*n-1, 0);\\n        upperCol.resize(n, 0);\\n        \\n        board.resize(n);\\n        string s(n, \\'.\\');\\n        \\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        \\n        //row, size\\n        helper(0, n);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447118,
                "title": "o-1-c-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        switch(n) {\\n            case 1: return 1;\\n            case 2:\\n            case 3: return 0;\\n            case 4: return 2;\\n            case 5: return 10;\\n            case 6: return 4;\\n            case 7: return 40;\\n            case 8: return 92;\\n            case 9: return 352;\\n            default: return 0;                \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384665,
                "title": "easy-solution-using-bitset",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bitset<30> col, d1, d2;\\n\\n    int solve(int i, int n) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int cunt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !d1[i - j + n - 1] && !d2[i + j]) {\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 1;\\n                cunt += solve(i + 1, n);\\n                col[j] = d1[i - j + n - 1] = d2[i + j] = 0;  \\n            }\\n        }\\n        return cunt;\\n    }\\n\\n    int totalNQueens(int n) {\\n        int ans = solve(0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346300,
                "title": "easiest-python-solution-beating-81-66",
                "content": "![image.png](https://assets.leetcode.com/users/images/a11c8897-726f-4336-9fa6-f93d594eed71_1679893956.642597.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def search(queens, dif, sum):\\n            l = len(queens)\\n            if l == n:\\n                self.ans += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and l-q not in dif and l+q not in sum:\\n                    search(queens+[q], dif+[l-q], sum+[l+q])\\n        \\n        self.ans = 0\\n        search([],[],[])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309809,
                "title": "space-o-n-easy-understand-short-sweet-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n    int totalNQueens(int n) {\\n        return solveNQueens(n).size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283759,
                "title": "cpp-backtracking-o-1-diagnol-check-beats-100",
                "content": "The N-Queen problem is one of the classic Backtracking problem out there.\\n\\nSince we have N queens, we place a queen in **each row of the board** and then move to the next row.\\n\\nIn each row, we have a queen placed in a column. To keep a track of the columns used, **We can use an array, where each index denotes a row and queens[i] is the coloumn used**.\\n\\nFor no queen to attack each other : \\n- No 2 queens should we on the same row\\n*Since we are placing one queen in each row this doesn\\'t require a check*\\n\\n- No 2 queens should be on the same column\\n*We can check this simply by queens array if any previous element of the array has the same value as our current candidate column for placing the queen.*\\n\\n- No 2 queens must be present on the same diagnol\\n*A diagnol on a chesboard is either 45 degrees or 135 degrees, i.e the sloped is 1 or -1. We can also say the slope is abs(1)*\\n**Calculating slope:** \\n**abs(previous_col - curr_col) / abs(previous_row - curr_row)**\\n*Thus a O(1) check*\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int row, int col, vector<int> &queens, int &n){\\n        for(int i = 0; i < row; i++){\\n            int prev_row = i;\\n            int prev_col = queens[i];\\n\\n            if(prev_col == col || abs(row-prev_row) == abs(col - prev_col)){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n\\n    int solve(int level, int &n, vector<int> &queens){\\n\\n        if(level == n){\\n            return 1;\\n        }\\n       int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            if(check(level, col, queens, n)){\\n                queens[level] = col;\\n                ans += solve(level + 1, n, queens);\\n                queens[level] = -1;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n\\n    int totalNQueens(int n) {\\n        vector<int> queens(n,-1);\\n        int res = solve(0, n, queens);\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207915,
                "title": "python-fast-backtracking-horizontal-symmetry-97-39",
                "content": "# Intuition\\nTry to check all possible combinations with backtracking.\\nE.g.\\nFind a row where you can put a queen in the first column. \\nFind a row where you can put a queen in the second column.\\n...\\nIf it\\'s not last column, but you can\\'t put queen. Then go back to the previous column and find the next row where you can put queen.\\n... \\nIf it\\'s a last column and you found a row where you can put queen - you have plus one possible solution.\\n\\n# Approach\\n\\nNaive aproach would be to store state of a board in an array of arrays, where `False` empty cell and `True` is a cell with a queen. However, in this case you would need to check all placed queens, to verify position of the next queen.\\n\\nIt easier and more effective to store ocupied rows and diagonals separatly. Columns are not stored as backtracking goes from 1st to n-th one by one.\\n\\nThe easiest logical optimization would be to find solutions with a queen in the first column and first half or rows. For the second half of rows solutions are horizontaly symetric. And don\\'t forget about midde row. It would make any solution almost 2 times faster.\\nYou can go further and think of vertical symetry, and rotation symetry.\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        rows = [0 for _ in range(n)]\\n        ldiags = [0 for _ in range(2 * n + 1)]\\n        rdiags = [0 for _ in range(2 * n + 1)]\\n        total = 0\\n\\n        def backtrack(i, j_range=None):\\n            nonlocal rows\\n            nonlocal ldiags\\n            nonlocal rdiags\\n            nonlocal total\\n\\n            for j in range(*j_range) if j_range else range(n):\\n                if not (\\n                    rows[j] or rdiags[(r := i + j)] or ldiags[(l := i - j + n - 1)]\\n                ):\\n                    if i + 1 == n:\\n                        total += 1\\n                    else:\\n                        rows[j] = 1\\n                        ldiags[l] = 1\\n                        rdiags[r] = 1\\n                        backtrack(i + 1)\\n                        rows[j] = 0\\n                        ldiags[l] = 0\\n                        rdiags[r] = 0\\n\\n        backtrack(0, (0, n // 2))\\n        total *= 2\\n        if n % 2:\\n            backtrack(0, (n // 2, n // 2 + 1))\\n\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199663,
                "title": "python-recursive-backtracking-just-print-the-length",
                "content": "# Code\\n```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def IsSafe(self,row,column,n,board):\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    def solveQueens(self,column,n,board,result):\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            return\\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n        return\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176316,
                "title": "52-n-queens-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- In this solution, we use depth first search (dfs) to find all solutions to the N-Queens problem\\n- The queens list keeps track of the row number for each column, where queens[i] represents the row number for the ith column.\\n- The dif list keeps track of the difference between the row number and the column number, where dif[i] = p - q and p is the row number and q is the column number.\\n- The sum list keeps track of the sum of the row number and the column number, where sum[i] = p + q and p is the row number and q is the column number.\\n- For each iteration, we check if the column q has not been used in the current solution and if the diagonal represented by dif[i] and the diagonal represented by sum[i] have not been used. If both conditions are met, we add q to the current solution and continue the search.\\n- If the length of the queens list is equal to n, it means we have found a solution and we increment the result by 1.\\n- Finally, we return the result which represents the number of solutions to the N-Queens problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                self.result += 1\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        \\n        self.result = 0\\n        dfs([],[],[])\\n        return self.result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158572,
                "title": "backtracking-and-bitmasking-better-than-backtracking-c",
                "content": "# Backtracking O(N! * N)\\n```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Bitmasking O(N!)\\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```\\n\\nThe algorithm works as follows:\\n\\nIf row is equal to n, it means all n rows have been filled, and a possible solution has been found, so res is incremented.\\n\\nFor each column c from 0 to n-1:\\n\\nIf the column, diagonal, and anti-diagonal corresponding to the current row and column are not occupied (represented by the values in col, dg, and udg being 0), the current position is marked as occupied and the algorithm continues to the next row by calling solveNQueens recursively.\\n\\nAfter the recursive call returns, the current position is marked as unoccupied to backtrack to previous positions.\\n\\nThis algorithm has a time complexity of O(n!).\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans;\\nbool is_valid(vector<string> &board, int row, int col){\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans++;\\n            return;\\n        }\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                board[row][i] = \\'Q\\';\\n                dfs(board,row+1);\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        if(n <= 0) return 0;\\n        ans=0;\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int totalNQueens(int n) {\\n        int res = 0;\\n        vector<int> col(n, 0), dg(2 * n, 0), udg(2 * n, 0);\\n        // Start the backtracking function from the first row\\n        solveNQueens(res, col, dg, udg, 0, n);\\n        return res;\\n    }\\n    void solveNQueens(int& res, vector<int>& col, vector<int>& dg,\\n                      vector<int>& udg, int row, int& n) {\\n        // If we have reached the last row, it means a valid solution is found\\n        if (row == n) {\\n            ++res; // Increment the number of solutions\\n            return;\\n        }\\n        for (int c = 0; c < n; ++c) {\\n            // Check if the current column, current diagonal (row + column) \\n            // and current anti-diagonal (n + row - column) are all empty\\n            if (!col[c] && !dg[row + c] && !udg[n + row - c]) {\\n                col[c] = dg[row + c] = udg[n + row - c] = 1;\\n                // Move to the next row and repeat the process\\n                solveNQueens(res, col, dg, udg, row + 1, n);\\n                col[c] = dg[row + c] = udg[n + row - c] = 0;\\n                // Backtrack to try other columns in the current row\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131987,
                "title": "0ms-100-faster-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isSafe(vector<string> &board, int row, int col, vector<int> &lowerDiagonal, vector<int> &upperDiagonal, vector<int>&leftSideRow, int n) {\\n        if(upperDiagonal[n-1+col-row]!=1 && leftSideRow[row]!=1 && lowerDiagonal[row+col]!=1) return true;\\n        return false;\\n    }\\n\\n    void backtrack(int col, vector<string>&board, int&ans, int n, vector<int>&lowerDiagonal, vector<int>&upperDiagonal, vector<int>& leftSideRow) {\\n        if(col==n) {\\n            ans++;\\n            return;\\n        }\\n        for(int i=0; i<n; i++) {\\n            if(isSafe(board, i, col, lowerDiagonal, upperDiagonal, leftSideRow, n)) {\\n                board[i][col] = \\'Q\\';\\n                lowerDiagonal[i+col] = 1;\\n                upperDiagonal[n-1+col-i] = 1;\\n                leftSideRow[i] = 1;\\n                backtrack(col+1, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n                board[i][col] = \\'.\\';\\n                lowerDiagonal[i+col] = 0;\\n                upperDiagonal[n-1+col-i] = 0;\\n                leftSideRow[i] = 0;\\n            }\\n        }\\n    }\\n    int totalNQueens(int n) {\\n        int ans = 0;\\n        vector<string> board(n);\\n        vector<int> lowerDiagonal(2*n-1, 0);\\n        vector<int> upperDiagonal(2*n-1,0);\\n        vector<int> leftSideRow(n,0);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++) {\\n            board[i] = s;\\n        }\\n        backtrack(0, board, ans, n, lowerDiagonal, upperDiagonal, leftSideRow);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085407,
                "title": "100-fastest-solution-using-the-back-tracking-and-recursion",
                "content": "# Intuition\\nTake a intution that the queen attacks only when either they are present in the same row,col or diagonally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe try to make diagonal rl and lr and  lrow which ensures that the queen must be placed in different diagonal; and row respectively.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```\\nPls \\uD83D\\uDE4F\\uD83D\\uDE4FUpvote if u find this helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint c=0;\\n    void rec( vector<string>&board, vector<int>&lrow, vector<int>&lr, vector<int>&rl,int col,int n){\\n         if(col==n){\\n             c++;\\n              return;\\n         }\\n         for(int row=0;row<n;row++)\\n       {  \\n           if(lrow[row]==0 && lr[row+col]==0 && rl[n-1+col-row]==0){\\n             board[row][col]=\\'Q\\';\\n             lrow[row]=1;\\n             lr[row+col]=1;\\n             rl[n-1+col-row]=1;\\n            rec(board,lrow,lr,rl,col+1,n);\\n              board[row][col]=\\'.\\';\\n             lrow[row]=0;\\n             lr[row+col]=0;\\n             rl[n-1+col-row]=0;\\n          }\\n       }\\n    }\\n    int totalNQueens(int n) {\\n          vector<int>lrow(n,0),lr(2*n-1,0),rl(2*n-1,0);\\n       string s(n,\\'.\\');\\n       vector<string>board;\\n       for(int i=0;i<n;i++){\\n           board.push_back(s);\\n       }\\n        rec(board,lrow,lr,rl,0,n);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049726,
                "title": "begineer-friendly-code-to-understand-backtracking-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        board = [[\\'\\' for i in range(n)] for j in range(n)]\\n        self.queens = n\\n        # self.placed = 0\\n        self.ans = 0\\n        # self.queen_pos = []\\n        self.place(0,board)\\n        return self.ans\\n    \\n    def place(self,i,board,queens=None,placed=0):\\n        if placed == self.queens:\\n            self.ans += 1\\n            return\\n        if i>= self.queens:\\n            return\\n        if not queens:\\n            queens = []\\n        for j in range(self.queens):\\n            if not self.intersect(queens+[[i,j]],placed,board):\\n                board[i][j] = \\'Q\\'\\n                self.place(i+1,board,queens+[[i,j]],placed+1)\\n                board[i][j] = \\'\\'\\n    \\n    def intersect(self,queens,placed,board):\\n        if placed < 1:\\n            return False\\n        for queen in queens:\\n            q_x,q_y = queen[0],queen[1]\\n            for i in range(self.queens):\\n                if board[i][q_y] == \\'Q\\' and i!=q_x:\\n                    return True\\n                if board[q_x][i] == \\'Q\\' and i!=q_y:\\n                    return True\\n                \\n            # right down diagonal check\\n            while q_x+1<self.queens and q_y+1<self.queens:\\n                q_x,q_y = q_x+1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left down diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y+1<self.queens:\\n                q_x,q_y = q_x-1,q_y+1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # right up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x+1<self.queens and q_y-1>=0:\\n                q_x,q_y = q_x+1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n                \\n            # left up diagonal check\\n            q_x,q_y = queen[0],queen[1]\\n            while q_x-1>=0 and q_y-1>=0:\\n                q_x,q_y = q_x-1,q_y-1\\n                if board[q_x][q_y] == \\'Q\\':\\n                    return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010025,
                "title": "n-queens-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int row , int col , vector<vector<int>> &board , int n){\\n    //check for same row\\n    int x = row;\\n    int y = col;\\n    \\n    while(y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n    }\\n    \\n    //no need to check for columns as we are adding one queen in one column\\n    \\n    //check for diagonals\\n    //check for North West(NW) diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x>=0 && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x--;\\n    }\\n    \\n    //check for SW diagonal\\n    x = row;\\n    y = col;\\n    \\n    while(x<n && y >= 0){\\n        if(board[x][y] == 1)\\n            return false;\\n        y--;\\n        x++;\\n    }\\n    //no need to check for NE and SE diagonals as queen hasn\\'t been added to the right.\\n    return true;\\n}\\n\\n    void solve(int col , vector<vector<int>> &ans , vector<vector<int>> &board , int n , int &count){\\n    //base case\\n    if(col == n){\\n        count++;\\n        return ;\\n    }\\n    \\n    //solve for 1 column, rest recursion will take care\\n    for(int row = 0 ; row < n ; row++){\\n        if(isSafe(row,col,board,n)){\\n            board[row][col] = 1;\\n            solve(col+1 , ans , board , n , count);\\n            //backtrack\\n            board[row][col] = 0;\\n        }\\n    }\\n}\\n\\n    int totalNQueens(int n) {\\n        vector<vector<int>> board(n , vector<int>(n,0));\\n        vector<vector<int>> ans;\\n        int count = 0;\\n        \\n        solve(0 , ans , board , n , count);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565873,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1569403,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1567140,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1565828,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1997219,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571127,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1571126,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1983949,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1792088,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 1576678,
                "content": [
                    {
                        "username": "hongshaoyang",
                        "content": "How is this question different from #51? By backtracking and generating the solutions you generate the count as well.\\n"
                    },
                    {
                        "username": "firezdog",
                        "content": "non-constructive vs. constructive solution?  if there were a way to calculate the number of solutions without generating them, it could potentially be faster..."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) yes bro"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "when life gives you lemons make lemonade, also when life gives you lemonade drink that damn lemonade"
                    },
                    {
                        "username": "Goldenchest",
                        "content": "Obviously not contributing anything meaningful, but I thought this was amusing. Anyone wanna try to beat me for slowest accepted answer? :P\\n\\n![image](https://assets.leetcode.com/users/goldenchest/image_1547649143.png)\\n"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@zenitsu_v31](/zenitsu_v31) hey monjiro !! why cmnting in zenitsu\\'s name ? \\uD83D\\uDE21"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "now i can die peacefully"
                    },
                    {
                        "username": "Msey",
                        "content": "haha"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "YidaGoo",
                        "content": "Should we exclude rotations and reflections of the chessboard?\\n\\nFor instance, consider the 2 solutions of 4-queens in N-Queen. Actually you can get the 2nd solution by rotating the 1st solution 180-degree clockwise.\\n\\nLikewise, if we exclude rotations and reflections, 8-queens actually has 12 distinct solutions instead of 92."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "why would you exclude them? When was the last time you saw two chess players turning the chessboard around because, oh well, this is really the same position after all? :p\nI don't think it's really a question you're asking, more of a way to show that you know more than the problem needs you to"
                    },
                    {
                        "username": "sanjana1127",
                        "content": "I think you mean 180-degree reflection. Because, 180-degree rotation of the the first board results into the first board itself and not the second board."
                    },
                    {
                        "username": "anwendeng",
                        "content": "A film demo how the backtracking works for 8 queens problem\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "flyfy1",
                        "content": "Hi there.. I've solved this problem with a bit of hack: just hard-code a list of answers, (0-14), and just return upon query. and I got ACed.\\n\\nI don't really think this is the correct implementation.. but I'm quite curious, what's your solution?"
                    },
                    {
                        "username": "Fluxcy",
                        "content": "bruh\\n"
                    },
                    {
                        "username": "krzysztof",
                        "content": "Is there any polynomial solution?\\nIf not - can someone show proof that it's not in P?"
                    },
                    {
                        "username": "katarni",
                        "content": "I think it\\'s not hard. It\\'s just backtraking. \\u0420\\u0435\\u043A\\u0443\\u0440\\u0441\\u0438\\u0432\\u043D\\u044B\\u0439 \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440 \\u0441 \\u0440\\u0430\\u0437\\u0432\\u0440\\u0430\\u0442\\u043E\\u043C"
                    },
                    {
                        "username": "nikalinov",
                        "content": "speak English bruv"
                    },
                    {
                        "username": "tlu22",
                        "content": "I wonder if there is an efficient solution like using dp and time complexity would be less then n!(at least make it exponential?)"
                    },
                    {
                        "username": "legendoftemple",
                        "content": "![image](https://assets.leetcode.com/users/images/437dc9a6-36cc-49f0-aad5-6ff4a5df89f8_1651002207.2060695.png)\\n"
                    }
                ]
            },
            {
                "id": 2064843,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2029585,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2016375,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 2000586,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1991597,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1981878,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1883948,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1841509,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1823866,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            },
            {
                "id": 1808779,
                "content": [
                    {
                        "username": "bborcic",
                        "content": "Solutions equivalent through board symmetries like the above, shouldn\\'t count as distinct, srsly."
                    },
                    {
                        "username": "layyy",
                        "content": "just add a count as well in the N-queen problem"
                    },
                    {
                        "username": "WAECZK",
                        "content": "so I need to learn chess before working on leetcode?"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "Same as 51. Lol. maybe even easier since you dont have to generate the actual board in a string answer."
                    },
                    {
                        "username": "ankitjangir001",
                        "content": "Why will the following C++ code not work? Why is it resulting into way larger result?\\n\\n```\\nclass Solution {\\n    int ways = 0;\\n\\n    void dfs(vector<vector<int>>& valid, int& n, int cnt, int i, int j){\\n        if(cnt == n){\\n            ways++;\\n            return;\\n        }\\n\\n        //make all cols, rows and diagonals invalid\\n        valid[i][j] = 0;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = 0;\\n            valid[i][x] = 0;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 0;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 0;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 0;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 0;\\n        }\\n\\n        for(int x=0; x<n; x++){\\n            for(int y=0; y<n; y++){\\n                if(valid[x][y] == 1){\\n                    dfs(valid, n, cnt+1, x, y);\\n                }\\n            }\\n        }\\n\\n        //make all cols, rows and diagonals valid back\\n        valid[i][j] = 1;\\n        for(int x = 0; x < n; x++){\\n            valid[x][j] = valid[i][x] = 1;\\n            if(i+x < n && j+x < n) valid[i+x][j+x] = 1;\\n            if(i-x >= 0 && j-x >= 0) valid[i-x][j-x] = 1;\\n            if(i+x < n && j-x >= 0) valid[i+x][j-x] = 1;\\n            if(i-x >= 0 && j+x < n) valid[i-x][j+x] = 1;\\n        }\\n    }\\n\\npublic:\\n    int totalNQueens(int n) {\\n        vector<vector<int>> valid(n, vector<int>(n, 1));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(valid[i][j]){\\n                    dfs(valid, n, 1, i, j);\\n                }\\n            }\\n        }\\n\\n        return ways;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "user0642J",
                        "content": "Why is this even a problem T_T ?"
                    },
                    {
                        "username": "Sicx0",
                        "content": "I don\\'t understand why this is not n-Queens I, I destroyed myself to do that, and now, this is a lot easier."
                    },
                    {
                        "username": "OMPRATIK",
                        "content": "//please help the output am getting on offline code editor is different(which is the correct output) from the leetcode compiler \\n\\nclass Solution {\\n    static int count = 0;\\n    public int totalNQueens(int n) {\\n        int chess[][] = new int[n][n];\\n        nQueens(n,chess,0);\\n        return count;\\n    }\\n    public void nQueens(int n,int chess[][],int row) {\\n        if(row == n) {\\n            count++;\\n            return;\\n        }\\n        for(int j=0;j<n;j++) {\\n            if(isSafe(n,chess,row,j)){\\n                chess[row][j] = 1;\\n                nQueens(n,chess,row+1);\\n                chess[row][j] = 0;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int n,int chess[][],int row,int col) {\\n        for(int i=row-1;i>=0;i--) {\\n            if(chess[i][col]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col+1;i>=0 && j<n;i--,j++) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {\\n            if(chess[i][j]==1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Hint: Look at the constraints..."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Simple Backtracking</span> (8 line solution)\n```\ndef backtrack(row, col_blacklist, diag_blacklist, antidiag_blacklist):\n    if row == n: self.ans += 1\n    for col in range(n):\n        if col in col_blacklist or row-col in diag_blacklist or row+col in antidiag_blacklist: continue\n        backtrack(row+1, col_blacklist | {col}, diag_blacklist | {row-col}, antidiag_blacklist | {row+col})\nself.ans = 0\nbacktrack(0, set(), set(), set())\nreturn self.ans\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Product Subarray",
        "question_content": "<p>Given an integer array <code>nums</code>, find a <span data-keyword=\"subarray-nonempty\">subarray</span> that has the largest product, and return <em>the product</em>.</p>\n\n<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,-2,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [2,3] has the largest product 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,0,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 48230,
                "title": "possibly-simplest-solution-with-o-n-time-complexity",
                "content": "```\\nint maxProduct(int A[], int n) {\\n    // store the result that is the max we have found so far\\n    int r = A[0];\\n\\n    // imax/imin stores the max/min product of\\n    // subarray that ends with the current number A[i]\\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\\n        // multiplied by a negative makes big number smaller, small number bigger\\n        // so we redefine the extremums by swapping them\\n        if (A[i] < 0)\\n            swap(imax, imin);\\n\\n        // max/min product for the current number is either the current number itself\\n        // or the max/min by the previous number times the current one\\n        imax = max(A[i], imax * A[i]);\\n        imin = min(A[i], imin * A[i]);\\n\\n        // the newly computed max value is a candidate for our global result\\n        r = max(r, imax);\\n    }\\n    return r;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProduct(int A[], int n) {\\n    // store the result that is the max we have found so far\\n    int r = A[0];\\n\\n    // imax/imin stores the max/min product of\\n    // subarray that ends with the current number A[i]\\n    for (int i = 1, imax = r, imin = r; i < n; i++) {\\n        // multiplied by a negative makes big number smaller, small number bigger\\n        // so we redefine the extremums by swapping them\\n        if (A[i] < 0)\\n            swap(imax, imin);\\n\\n        // max/min product for the current number is either the current number itself\\n        // or the max/min by the previous number times the current one\\n        imax = max(A[i], imax * A[i]);\\n        imin = min(A[i], imin * A[i]);\\n\\n        // the newly computed max value is a candidate for our global result\\n        r = max(r, imax);\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183483,
                "title": "java-c-python-it-can-be-more-simple",
                "content": "# **Intuition**\\nSeem to be a problem of 2014.\\nIs it too late to write one in 2018?\\n<br>\\n\\n# **Explanation**\\nCalculate prefix product in `A`.\\nCalculate suffix product in `A`.\\nReturn the max.\\n<br>\\n\\n**Python**\\n```python\\n    def maxProduct(self, A):\\n        B = A[::-1]\\n        for i in range(1, len(A)):\\n            A[i] *= A[i - 1] or 1\\n            B[i] *= B[i - 1] or 1\\n        return max(A + B)\\n```\\n\\n**Also wrote in C++ version**\\nO(N) time O(1) space\\n```cpp\\n    int maxProduct(vector<int> A) {\\n        int n = A.size(), res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l ? l : 1) * A[i];\\n            r =  (r ? r : 1) * A[n - 1 - i];\\n            res = max(res, max(l, r));\\n        }\\n        return res;\\n    }\\n```\\n\\n**Also wrote in Java version**\\nO(N) time O(1) space\\n```java\\n    public int maxProduct(int[] A) {\\n        int n = A.length, res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l == 0 ? 1 : l) * A[i];\\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\\n            res = Math.max(res, Math.max(l, r));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxProduct(self, A):\\n        B = A[::-1]\\n        for i in range(1, len(A)):\\n            A[i] *= A[i - 1] or 1\\n            B[i] *= B[i - 1] or 1\\n        return max(A + B)\\n```\n```cpp\\n    int maxProduct(vector<int> A) {\\n        int n = A.size(), res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l ? l : 1) * A[i];\\n            r =  (r ? r : 1) * A[n - 1 - i];\\n            res = max(res, max(l, r));\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxProduct(int[] A) {\\n        int n = A.length, res = A[0], l = 0, r = 0;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l == 0 ? 1 : l) * A[i];\\n            r =  (r == 0 ? 1 : r) * A[n - 1 - i];\\n            res = Math.max(res, Math.max(l, r));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1608862,
                "title": "java-3-solutions-detailed-explanation-using-image",
                "content": "**Intution:** Since we have to find the contiguous subarray having maximum product then your approach should be combination of following three cases :\\n* **Case1 :- All the elements are positive :** Then your answer will be product of all the elements in the array.\\n* **Case2 :- Array have positive and negative elements both :**\\n\\t1. \\tIf the number of negative elements is even then again your answer will be complete array because on multiplying all the negative numbers it will become positive.\\n\\t2. \\tIf the number of negative elements is odd then you have to remove just one negative element and for that u need to check your subarrays to get the max product.\\n* **Case3 :- Array also contains 0 :** Then there will be not much difference...its just that your array will be divided into subarray around that 0. What u have to so is just as soon as your product becomes 0 make it 1 for the next iteration, now u will be searching new subarray and previous max will already be updated.\\n*(These cases are much clear in approach 3)\\n\\n\\n** As it is said \"Talk is Cheap, Show me the Code\", so based on above discussion we can frame our code in many different ways, out of which I have mentioned 3 intutive approaches.\\n\\n**Approach 1:** For each index i keep updating the max and min. We are also keeping min because on multiplying with any negative number your min will become max and max will become min. So for every index i  we will take max of (i-th element, prevMax * i-th element, prevMin * i-th element).\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int temp = max;  // store the max because before updating min your max will already be updated\\n            \\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\\n            \\n            if (max > ans) {\\n                ans = max;\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\n**Approach 2:** Just the slight modification of previous approach. As we know that on multiplying with negative number max will become min and min will become max, so why not as soon as we encounter negative element, we swap the max and min already.\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        int n = nums.length;\\n        \\n        for (int i = 1; i < n; i++) {\\n        \\n\\t\\t\\t// Swapping min and max\\n            if (nums[i] < 0){\\n                int temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n                \\n\\n\\n            max = Math.max(nums[i], max * nums[i]);\\n            min = Math.min(nums[i], min * nums[i]);\\n\\n\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\n**Approach 3:** Two pointer Approach\\nExplanation : \\n1.) Through intution explanation we know that if all the elements are positive or the negative elements are even then ur answer will be product of complete array which u will get in variable l and r at the last iteration.\\n2.) But if negative elements are odd then u have to remove one negative element and it is sure that it will be either right of max prefix product or left of max suffix product. So u need not to modify anything in your code as u are getting prefix product in l and suffix prduxt in r.\\n3.) If array also contains 0 then your l and r will become 0 at that point...then just update it to 1(or else u will keep multiplying with 0)  to get the product ahead making another subarray.\\n\\n![image](https://assets.leetcode.com/users/images/2ce0da10-9355-4018-a256-cba3a41af56d_1638500369.5001783.jpeg)\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        int l=1,r=1;\\n        int ans=nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n\\t\\t\\t//if any of l or r become 0 then update it to 1\\n            l = l==0 ? 1 : l;\\n            r = r==0 ? 1 : r;\\n            \\n            l *= nums[i];   //prefix product\\n            r *= nums[n-1-i];    //suffix product\\n            \\n            ans = Math.max(ans,Math.max(l,r));\\n            \\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\\n\\nThanks for giving it a read...I hope it helped u!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int temp = max;  // store the max because before updating min your max will already be updated\\n            \\n            max = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\\n            min = Math.min(Math.min(temp * nums[i], min * nums[i]), nums[i]);\\n            \\n            if (max > ans) {\\n                ans = max;\\n            }\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = nums[0], min = nums[0], ans = nums[0];\\n        int n = nums.length;\\n        \\n        for (int i = 1; i < n; i++) {\\n        \\n\\t\\t\\t// Swapping min and max\\n            if (nums[i] < 0){\\n                int temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n                \\n\\n\\n            max = Math.max(nums[i], max * nums[i]);\\n            min = Math.min(nums[i], min * nums[i]);\\n\\n\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int n = nums.length;\\n        int l=1,r=1;\\n        int ans=nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n\\t\\t\\t//if any of l or r become 0 then update it to 1\\n            l = l==0 ? 1 : l;\\n            r = r==0 ? 1 : r;\\n            \\n            l *= nums[i];   //prefix product\\n            r *= nums[n-1-i];    //suffix product\\n            \\n            ans = Math.max(ans,Math.max(l,r));\\n            \\n        }\\n        \\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48252,
                "title": "sharing-my-solution-o-1-space-o-n-running-time",
                "content": "    public int maxProduct(int[] A) {\\n        if (A.length == 0) {\\n            return 0;\\n        }\\n        \\n        int maxherepre = A[0];\\n        int minherepre = A[0];\\n        int maxsofar = A[0];\\n        int maxhere, minhere;\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            maxsofar = Math.max(maxhere, maxsofar);\\n            maxherepre = maxhere;\\n            minherepre = minhere;\\n        }\\n        return maxsofar;\\n    }\\n\\n\\n\\nNote:\\nThere's no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them.\\n\\nThere's a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar.",
                "solutionTags": [],
                "code": "    public int maxProduct(int[] A) {\\n        if (A.length == 0) {\\n            return 0;\\n        }\\n        \\n        int maxherepre = A[0];\\n        int minherepre = A[0];\\n        int maxsofar = A[0];\\n        int maxhere, minhere;\\n        \\n        for (int i = 1; i < A.length; i++) {\\n            maxhere = Math.max(Math.max(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            minhere = Math.min(Math.min(maxherepre * A[i], minherepre * A[i]), A[i]);\\n            maxsofar = Math.max(maxhere, maxsofar);\\n            maxherepre = maxhere;\\n            minherepre = minhere;\\n        }\\n        return maxsofar;\\n    }\\n\\n\\n\\nNote:\\nThere's no need to use O(n) space, as all that you need is a minhere and maxhere. (local max and local min), then you can get maxsofar (which is global max) from them.\\n\\nThere's a chapter in Programming Pearls 2 that discussed the MaxSubArray problem, the idea is similar.",
                "codeTag": "Unknown"
            },
            {
                "id": 3321410,
                "title": "c-kadane-s-algo-full-explanation",
                "content": "# Intuition\\nThe Brute force method says we can simply apply 2 loops for calculaing all sub-arrays and finding the max product.\\n\\nBut, the Optizimed way to solve this problem is using Kadane\\'s Algorithm.\\n\\n# Approach\\nThe Approach to this question is exactly same as Kadane\\'s Algo the only differece is, we will be traversing the array from both sides i.e left to right ( lets say the max prod is maxi1 ) and from right to left ( say max prod is maxi2 ), now the final answer will we max of maxi1 and maxi2.\\n\\nQues : Why do we have a need to traverse from right to left ??\\nAns : lets take an example \\n    arr {-8,5,3,1,6}\\n\\n    // By traversing left to right we have an answer maxi1.\\n    maxi1 = -720 , which is clearly not the max prod value.\\n\\n**-> The whole concept lies in this statement -** **As we can see that there is only 1 negative no. ( if we consider that no. then the final answer can never be positive ), therefore to avoid this situation we also traverse from right to left to get the final maximum prod.**\\n\\n# Complexity\\n- Time complexity:\\nO(N) + O(N) = O(N), where N is size of array.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int prod=1;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          prod*=nums[i];\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n          prod*=nums[i];\\n\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpg](https://assets.leetcode.com/users/images/ccc42d19-25d4-4441-9a37-8c5df943c6c9_1679339757.323656.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int prod=1;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          prod*=nums[i];\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n          prod*=nums[i];\\n\\n          maxi=max(prod,maxi);\\n          if(prod==0)\\n           prod=1;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48302,
                "title": "2-passes-scan-beats-99",
                "content": "Here are my observations:\\n1. it's really about odd negative numbers or even negative numbers, if it's odd, either the left end one or the right end one should be counted, so it will be revealed by scanning from left and from right in 2 passes.\\n2. 0 is a kind of delimiter, product accumulation will be reset to 1\\n\\n\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, product = 1;\\n        int len = nums.length;\\n\\n        for(int i = 0; i < len; i++) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        product = 1;\\n        for(int i = len - 1; i >= 0; i--) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "Here are my observations:\\n1. it's really about odd negative numbers or even negative numbers, if it's odd, either the left end one or the right end one should be counted, so it will be revealed by scanning from left and from right in 2 passes.\\n2. 0 is a kind of delimiter, product accumulation will be reset to 1\\n\\n\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, product = 1;\\n        int len = nums.length;\\n\\n        for(int i = 0; i < len; i++) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        product = 1;\\n        for(int i = len - 1; i >= 0; i--) {\\n            max = Math.max(product *= nums[i], max);\\n            if (nums[i] == 0) product = 1;\\n        }\\n\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48330,
                "title": "simple-java-code",
                "content": "Loop through the array, each time remember the max and min value for the previous product, the most important thing is to update the max and min value: we have to compare among max * A[i], min * A[i] as well as A[i], since this is product, a negative * negative could be positive.\\n\\n    public class Solution {\\n        public int maxProduct(int[] A) {\\n            if (A == null || A.length == 0) {\\n                return 0;\\n            }\\n            int max = A[0], min = A[0], result = A[0];\\n            for (int i = 1; i < A.length; i++) {\\n                int temp = max;\\n                max = Math.max(Math.max(max * A[i], min * A[i]), A[i]);\\n                min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]);\\n                if (max > result) {\\n                    result = max;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxProduct(int[] A) {\\n            if (A == null || A.length == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 203013,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "Before jumping to the full solution, let\\'s take a step back and consider simpler versions of this problem (Please scroll to the bottom of this post for the full solution):\\n\\n* If the array only consisted of positive integers, the solution would be trivial: product of the entire array. We can implement this by calculating a _running_ product like so:\\n```\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    runningProduct *= n;\\n}\\nreturn runningProduct;\\n```\\n\\n* If we add zeroes to the mix, now we have to get a bit smarter. As we loop over the array, if the current number `n` is zero, then `runningProduct` would be zero and be stuck there. So, we need to reset it. Intuitively, whenever `runningProduct` is less than the current number `n`, we start considering a new sub-array that starts from the current number. Since `runningProduct` will be reset, we will also need a variable to hold the max `runningProduct` that we have encountered. Enough said, let\\'s see how we can code this:\\n```\\nint best = INT_MIN;\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    // Pick the larger of current number and the result of the multiplication\\n    // Picking n means we start considering a new sub-array\\n    runningProduct = max(runningProduct * n, n);\\n    // Keep track of the max runningProduct that we find\\n    best = max(runningProduct, best);\\n}\\nreturn best;\\n```\\n\\n* Above, we only cared about the maximum value we can achieve and started a new sub-array using `max` whenever we encountered a zero. Finally, let\\'s also consider negative numbers to find the general solution to the given problem. Consider the array `1, -2, -3, 4`. When we are at the second element, our runningProduct becomes `-2`. But at the third element it becomes `6`. So, as we encounter negative numbers they change the sign of our product. Our product can become really small but then really big depending on the sign of the current number. To accomodate for this, we can have two running products: `maxProd` and `minProd`. `maxProd` will track the maximum product that we can achieve and will reset whenever the current number is greater, just as above. `minProd`, on the other hand, will track the minimum product that we can achieve and will reset whenever the current number is smaller. Finally, whenever we encounter a negative number, we will swap `maxProd` and `minProd` because if `a <= b` then `-b <= -a`. This makes sure that `maxProd` and `minProd` are still the max and min products after multiplied by a negative number. And, with that, we have the following solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // Return early if input is empty\\n        if (nums.empty()) return 0;\\n\\t\\t\\n        int best = INT_MIN;\\n        // Running products\\n        int maxProd = 1;\\n        int minProd = 1;\\n        \\n        for (int n: nums) {\\n            if (n < 0) {\\n                // Swap max and min\\n                swap(maxProd, minProd);\\n            }\\n            // Reset to current value if smaller or larger than it\\n            // (intuitively means that we start considering a new sub-array)\\n            maxProd = max(maxProd*n, n);\\n            minProd = min(minProd*n, n);\\n            // Update the best\\n            best = max(best, maxProd);\\n        }\\n        \\n        return best;\\n    }\\n};\\n```\\n\\nI hope this helps and happy coding!",
                "solutionTags": [],
                "code": "```\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    runningProduct *= n;\\n}\\nreturn runningProduct;\\n```\n```\\nint best = INT_MIN;\\nint runningProduct = 1;\\nfor (int n: nums) {\\n    // Pick the larger of current number and the result of the multiplication\\n    // Picking n means we start considering a new sub-array\\n    runningProduct = max(runningProduct * n, n);\\n    // Keep track of the max runningProduct that we find\\n    best = max(runningProduct, best);\\n}\\nreturn best;\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // Return early if input is empty\\n        if (nums.empty()) return 0;\\n\\t\\t\\n        int best = INT_MIN;\\n        // Running products\\n        int maxProd = 1;\\n        int minProd = 1;\\n        \\n        for (int n: nums) {\\n            if (n < 0) {\\n                // Swap max and min\\n                swap(maxProd, minProd);\\n            }\\n            // Reset to current value if smaller or larger than it\\n            // (intuitively means that we start considering a new sub-array)\\n            maxProd = max(maxProd*n, n);\\n            minProd = min(minProd*n, n);\\n            // Update the best\\n            best = max(best, maxProd);\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48276,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Maximum Product Subarray** https://leetcode.com/problems/maximum-product-subarray/?tab=Description\\n\\n1. https://www.quora.com/How-do-I-solve-maximum-product-subarray-problems\\n2. Use an example: [2,-3,4,-8,0]\\n3. Insights: \\n**What if the array has just positive numbers including zero**?\\n A solution of this will maintain max_prod[i] where max_prod[i] is the maximum subarray product ending at i. Then max_prod[i+1] = max(max_prod[i] * nums[i+1], nums[i+1]). \\n **Now how do we change the solution when we allow negative numbers**? \\n Imagine that we have both max_prod[i] and min_prod[i] i.e. max prod ending at i and min prod ending at i. Now if we have a negative number at nums[i+1] and if min_prod[i] is negative, then the product of the two will be positive and can potentially be largest product. Key point is to maintain both max_prod and min_prod such that at iteration i, they refer to the max and min prod ending at index i -1.\\n\\nYou have three choices to make at any position in array.\\n1. You can get maximum product by multiplying the current element with \\n    maximum product calculated so far.  (might work when current \\n    element is positive).\\n2. You can get maximum product by multiplying the current element with \\n    minimum product calculated so far. (might work when current \\n    element is negative).\\n3.  Current element might be a starting position for maximum product sub\\n     array\\n\\t\\t \\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_prod, min_prod, ans = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            x = max(nums[i], max_prod*nums[i], min_prod*nums[i])\\n            y = min(nums[i], max_prod*nums[i], min_prod*nums[i])            \\n            max_prod, min_prod = x, y\\n            ans = max(max_prod, ans)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_prod, min_prod, ans = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            x = max(nums[i], max_prod*nums[i], min_prod*nums[i])\\n            y = min(nums[i], max_prod*nums[i], min_prod*nums[i])            \\n            max_prod, min_prod = x, y\\n            ans = max(max_prod, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608800,
                "title": "c-discussion-in-detail-easy-to-understand",
                "content": "There can be Mutliple ways to frame the solution once we get the intuition right !! So, what should the intuition be ? Let\\'s discuss that out !\\n\\n***Let\\'s consider array to have no 0s*** (for the moment)...... \\nSo, on what factor does the answer depends now ?? It surely depends on the count of negative numbers in the array !!\\n\\n**There are 2 possibilities** - *either the count of -ve numbers is even or odd*.... --->>>\\n1. If the count is **even**, then obviously we would want to include all of them(in fact the whole array) to maximise the product. As multiplying an even number of -ve numbers would make the result +ve.\\n2. If the count is **odd**, then we would want to exclude  one -ve number from our product, so that the product gets maximised. So, now the question is, which -ve number to exclude? Example ---> arr={-2,-3,-1,-4,-5} which number should be excluded ? On observing it , we should get one fact clear, that the number which is going to get ignored is either going to be the first one or the last one.\\n\\n   *  Note that, we cannot exclude a -ve number that is not the first or the last, because, if we do so, we will need to exclude all(because you are breaking the product at this point) other -ve nums following that -ve number and then that needn\\'t result in the maximum product.\\n   *  Having said all that, now the question is whether to exclude the first -ve num or the last -ve num in the array. We can only know the answer by trying both.\\n   *  So, firstly we will take the product from the beginning of the array and we will include the first -ve number and will leave out the last one !!\\n   *  And will do the vice-versa for checking the other scenario !!\\n   *  So , in that example we would leave the first -ve number... (-2 and then total_product will be product of rest of the numbers in array) or we would leave the last number...(-5) ... And maximum of those 2 cases will be the answer !!\\n   \\n Now, ***what if array has zeroes?***  Well, it changes nothing much to be honest, we can consider the part on both the side of 0 as the subarrays and the maximum product that way will be the max(subarray1_ans, subarray2_ans) .... And how to mark the division point ? How do we seperate the subarrays????...\\nThats pretty simple and we have done it in kadane\\'s algo, just make the curr_ongoing_prod=1 !! And maintain one maxm_prod variable seperately ....\\n\\n**Example** -->>>  arr={-2,1,4,5,0,-3,4,6,1,-2} .... so we can consider subarray1={-2,1,4,5} and subarray2={-3,4,6,-2} and then the max_ans(subarray1,subarray2) will be our answer !!\\n \\n Let\\'s have a look on our code now ....\\n \\n**2-pass solution(for better understanding)** \\n ```\\n class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int curr_product = 1, res = INT_MIN;\\n        \\n        for (auto i: nums) {\\n            curr_product = curr_product * i;\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n        \\n        curr_product = 1;\\n        \\n        for (int i = nums.size()-1; i>=0; i--) {\\n            curr_product = curr_product * nums[i];\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }      \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n* But wait, you might be thinking, why we are still continuing to multiply even beyond the last -ve number in forward iteration and beyond the first -ve number in the forward iteration.\\n\\n* That\\'s all actually is waste in case of array with odd count of -ve numbers, as the product is only going to increase in negativity beyond those points. The maximum is already updated, so this doesn\\'t affect at all.\\n* And in case of even count of -ve numbers ... we do need to multiply all the way through... So it is must in that case !!\\n\\n\\n\\n***code can obviously be made more crisp and cane be done in one-pass***\\nWe will make both the iterations, forward and the backward one simultaneously and will appoint 2-pointer at the front and the backend (mentioning it by l(left_prod, it will leave the last -ve number out) and r(right_prod , it will leave the first -ve number out))....will compare the result everytime with both the products(left and right) and will update it with the maximum value encountered till then.... \\nand will do the same thing here too, updating the left_prod and right_prod by 1 whenever they become 0 !!\\n**1-pass optimal solution(2-pointer)** \\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), res = nums[0], l = 1, r = 1;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l) * nums[i];\\n            r =  (r) * nums[n - 1 - i];\\n            res = max(res, max(l, r));\\n            if(l==0)l=1;\\n            if(r==0)r=1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Thanks for reading it out, I hope you got something out of it !!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int curr_product = 1, res = INT_MIN;\\n        \\n        for (auto i: nums) {\\n            curr_product = curr_product * i;\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n        \\n        curr_product = 1;\\n        \\n        for (int i = nums.size()-1; i>=0; i--) {\\n            curr_product = curr_product * nums[i];\\n            res = max(curr_product, res);\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }      \\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), res = nums[0], l = 1, r = 1;\\n        for (int i = 0; i < n; i++) {\\n            l =  (l) * nums[i];\\n            r =  (r) * nums[n - 1 - i];\\n            res = max(res, max(l, r));\\n            if(l==0)l=1;\\n            if(r==0)r=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847520,
                "title": "thought-process-and-useful-strategy",
                "content": "The following documents my thought process for solving the question, shared to illuminate a possible strategy for approaching problems such as this one.\\n\\nFirst, come up with a brute-force solution with `~O(N^2)` running time:\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i <n; i++) {\\n            int cur = 1;\\n\\n            for (int j = i; j < n; j++) {\\n                cur = cur * nums[j];\\n                ans = Math.max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nThen, thinking about Kadane\\'s algorithm used to solve [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), we can come up with the following optimization.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int cur = nums[0];\\n        int ans = nums[0];\\n    \\n        for (int i = 1; i < n; i++) {\\n            cur = Math.max(nums[i]*cur, nums[i]);\\n            ans = Math.max(ans, cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nOnly, it fails test cases in which two negative numbers produce a maximum sum. An example is `[-2,3,-4]`. Therefore, it only works for an input with no more than one negative number.\\n\\nFor me, I was stuck at this point until I saw that the question was tagged with \"Dynamic Programming\". In the interview setting, the interviewer might give you this hint.\\n\\nWith the hint, we can procede to keep track of the subproblem solutions. Since we observed that negative values can produce the maximum product, we keep track of both maximum product and the minimum product. The minimum product, when multiplied by another negative number, can produce a possible answer. The following solution passes.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        int[] maxVal = new int[n];\\n        int[] minVal = new int[n];\\n        \\n        maxVal[0] = nums[0];\\n        minVal[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxVal[i] = Math.max(maxVal[i-1]*nums[i], Math.max(minVal[i-1]*nums[i], nums[i]));\\n            minVal[i] = Math.min(maxVal[i-1]*nums[i], Math.min(minVal[i-1]*nums[i], nums[i]));\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        for (int num : maxVal) {\\n            ans = Math.max(ans, num);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIt is a good idea to check for space optimization for a DP solution. In this case, we observe that we only ever need to keep track of the subproblem solution immediately preceding our current subproblem. Hence we can avoid allocating an array, and improve the space complexity from `~O(N)` to `~O(1)`.\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int curMax = nums[0];\\n        int curMin = nums[0];\\n        int ans = curMax;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int tmp = curMax;\\n            curMax = Math.max(tmp*nums[i], Math.max(curMin*nums[i], nums[i]));\\n            curMin = Math.min(tmp*nums[i], Math.min(curMin*nums[i], nums[i]));\\n            \\n            ans = Math.max(ans, curMax);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        \\n        for (int i = 0; i <n; i++) {\\n            int cur = 1;\\n\\n            for (int j = i; j < n; j++) {\\n                cur = cur * nums[j];\\n                ans = Math.max(ans, cur);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int cur = nums[0];\\n        int ans = nums[0];\\n    \\n        for (int i = 1; i < n; i++) {\\n            cur = Math.max(nums[i]*cur, nums[i]);\\n            ans = Math.max(ans, cur);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        int[] maxVal = new int[n];\\n        int[] minVal = new int[n];\\n        \\n        maxVal[0] = nums[0];\\n        minVal[0] = nums[0];\\n        \\n        for (int i = 1; i < n; i++) {\\n            maxVal[i] = Math.max(maxVal[i-1]*nums[i], Math.max(minVal[i-1]*nums[i], nums[i]));\\n            minVal[i] = Math.min(maxVal[i-1]*nums[i], Math.min(minVal[i-1]*nums[i], nums[i]));\\n        }\\n        \\n        int ans = Integer.MIN_VALUE;\\n        for (int num : maxVal) {\\n            ans = Math.max(ans, num);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int curMax = nums[0];\\n        int curMin = nums[0];\\n        int ans = curMax;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int tmp = curMax;\\n            curMax = Math.max(tmp*nums[i], Math.max(curMin*nums[i], nums[i]));\\n            curMin = Math.min(tmp*nums[i], Math.min(curMin*nums[i], nums[i]));\\n            \\n            ans = Math.max(ans, curMax);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176155,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n         int maxi = nums[0];\\n        int mini = nums[0];\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.size();i++){\\n            if(nums[i] < 0){\\n                swap(maxi,mini);\\n            }\\n            maxi = max(nums[i],maxi*nums[i]);\\n            mini = min(nums[i],mini*nums[i]);\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom math import inf\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        p = 0\\n        \\n        first_neg = 0\\n        first_neg_excluded = False\\n        \\n        p_max = -inf\\n        \\n        for x in nums:\\n            \\n            if x == 0:\\n                p = 0\\n                first_neg = 0\\n                first_neg_excluded = False\\n            \\n            elif x > 0:\\n                \\n                if p == 0:\\n                    p = x\\n                    \\n                else:\\n                    p *= x\\n                \\n                    if p < 0:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            else:\\n                p = p * x if p != 0 else x\\n                \\n                if p < 0:\\n                \\n                    if first_neg == 0:\\n                        first_neg = p\\n                    \\n                    elif first_neg_excluded:\\n                        p *= first_neg\\n                        first_neg_excluded = False\\n                    \\n                    else:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            if p > p_max:\\n                p_max = p\\n        \\n        return p_max\\n```\\n\\n```Java []\\nclass Solution {\\n  public int maxProduct(int[] nums) {\\n    int ans = nums[0];\\n    int dpMin = nums[0];\\n    int dpMax = nums[0];\\n\\n    for (int i = 1; i < nums.length; ++i) {\\n      final int num = nums[i];\\n      final int prevMin = dpMin;\\n      final int prevMax = dpMax;\\n      if (num < 0) {\\n        dpMin = Math.min(prevMax * num, num);\\n        dpMax = Math.max(prevMin * num, num);\\n      } else {\\n        dpMin = Math.min(prevMin * num, num);\\n        dpMax = Math.max(prevMax * num, num);\\n      }\\n      ans = Math.max(ans, dpMax);\\n    }\\n    return ans;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n         int maxi = nums[0];\\n        int mini = nums[0];\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.size();i++){\\n            if(nums[i] < 0){\\n                swap(maxi,mini);\\n            }\\n            maxi = max(nums[i],maxi*nums[i]);\\n            mini = min(nums[i],mini*nums[i]);\\n            ans = max(ans,maxi);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nfrom math import inf\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        p = 0\\n        \\n        first_neg = 0\\n        first_neg_excluded = False\\n        \\n        p_max = -inf\\n        \\n        for x in nums:\\n            \\n            if x == 0:\\n                p = 0\\n                first_neg = 0\\n                first_neg_excluded = False\\n            \\n            elif x > 0:\\n                \\n                if p == 0:\\n                    p = x\\n                    \\n                else:\\n                    p *= x\\n                \\n                    if p < 0:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            else:\\n                p = p * x if p != 0 else x\\n                \\n                if p < 0:\\n                \\n                    if first_neg == 0:\\n                        first_neg = p\\n                    \\n                    elif first_neg_excluded:\\n                        p *= first_neg\\n                        first_neg_excluded = False\\n                    \\n                    else:\\n                        p //= first_neg\\n                        first_neg_excluded = True\\n            \\n            if p > p_max:\\n                p_max = p\\n        \\n        return p_max\\n```\n```Java []\\nclass Solution {\\n  public int maxProduct(int[] nums) {\\n    int ans = nums[0];\\n    int dpMin = nums[0];\\n    int dpMax = nums[0];\\n\\n    for (int i = 1; i < nums.length; ++i) {\\n      final int num = nums[i];\\n      final int prevMin = dpMin;\\n      final int prevMax = dpMax;\\n      if (num < 0) {\\n        dpMin = Math.min(prevMax * num, num);\\n        dpMax = Math.max(prevMin * num, num);\\n      } else {\\n        dpMin = Math.min(prevMin * num, num);\\n        dpMax = Math.max(prevMax * num, num);\\n      }\\n      ans = Math.max(ans, dpMax);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609493,
                "title": "c-simple-solution-w-explanation-optimization-from-brute-force-to-dp",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe can simply check for each subarray and return the subarray which gives the maximum product\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) \\n            for(int j = i; j < size(A); j++)\\n                ans = max(ans, accumulate(begin(A)+i, begin(A)+j+1, 1, multiplies<>()));\\n        return ans;\\n    }\\n};\\n```\\n\\nOr a slightly better version of brute-force -\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) {\\n            int curProd = 1;\\n            for(int j = i; j < size(A); j++)\\n                curProd *= A[j],\\n                ans = max(ans, curProd);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Time Complexity :*** <code>O(N<sup>3</sup>) / O(N<sup>2</sup>)</code> for the 1st version and 2nd version respectively.\\n***Space Complexity :*** <code>O(1)</code>, only constant extra space is used.\\n\\n---\\n\\n\\u274C ***Solution - II (Recursive)***\\n\\nWe can recursively calculate the maximum product of subarray as well. Here, we start at index `0` and recursively calculate the maximum subarray product starting at each index and return the one yielding the maximum overall product.\\n\\nBut we must first realize that maximum subarray product starting at index `i` is not always `A[i]*maxProduct(A[i+1:])` and can also be `A[i]*minProduct(A[i+1:])`. This is because when `A[i] >= 0`, multiplying it with maximum product after `i` will yield the largest overall product. However, when `A[i] < 0`, we need to multiply it with minimum possible product after `i` to get the largest overall product (try with some examples if you didnt get this).\\n\\nSo, whenever `A[i] >= 0`, we call a function which returns maximum product of subarray starting from `i+1` (`dfsMax` in the below code) and whenever `A[i] < 0`, we call function which returns minimum product of subarray starting from `i+1` (`dfsMin` in below code).\\n\\nIn the below solution, I have also passed another boolean parameter `mustPick` which denotes if every element from now on must be picked or not. This helps ensure that we pick a subarray and not a subsequence. If `A[i]` is picked, for every index `j > i`, we must either pick every element `A[j]` after that or end the recursion at any index `j` by return 1.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) { \\n        return dfsMax(A, 0, false); \\n    }\\n\\t// finds maximum subarray product starting at i\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;     // if mustPick remains false till end, the no element is chosen so return -\\u221E denoting invalid case\\n        if (mustPick)\\n            return max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));                 // either end recursion by returning 1 or recurse by picking A[i]. Choose whichever gives max product\\n        return max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));  // either pick A[i] or recurse for next index without picking. Choose whichever gives max product\\n    }\\n\\t// finds minimum subarray product starting at i\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        return A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** <code>O(N)</code>, required by implicit recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Memoization)***\\n\\nWe can observe a lot of repeated calculations if we draw out the recursive tree for above solution. The maximum product of subarray starting at `i` will always remain the same and there\\'s no need to calculate it again and again. These redundant calculations can be eliminated if we store the results for a given state and reuse them later whenever required rather than recalculating them over and over again. \\n\\nThus, we can use memoization technique here to make our solution more efficient. Here, we use `dpMax` and `dpMin` arrays where `dpMax[i][mustPick]` denotes the maximum product subarray starting from `i` and `mustPick` denotes whether the current element must be compulsorily picked or we have an choice between picking and not picking it. Similarly, `dpMin[i]` denotes the minimum product subarray starting from `i`. Each element of `dpMax` and `dpMin` is initialized to `INT_MIN` denoting they haven\\'t been computed yet.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dpMin;\\n    vector<vector<int>> dpMax;\\n    int maxProduct(vector<int>& A) { \\n        dpMin.resize(size(A), INT_MIN);\\n        dpMax.resize(size(A), vector<int>(2, INT_MIN));\\n        return dfsMax(A, 0, false); \\n    }\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;\\n        if(dpMax[i][mustPick] != INT_MIN) return dpMax[i][mustPick];\\n        if (mustPick)\\n            return dpMax[i][mustPick] = max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n        return dpMax[i][mustPick] = max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n    }\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        if(dpMin[i] != INT_MIN) return dpMin[i];\\n        return dpMin[i] = A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we calculate `dpMax[i]` for each `0 <= i < N` only once and return the stored result for every future call.\\n***Space Complexity :*** <code>O(N)</code>, required by dp arrays and recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can solve this iteratively as well using DP. Here, we again use `dpMax` and `dpMin` arrays where `dpMax[i]` denotes maximum subarray product ending at `i` and `dpMin[i]` denotes minimum subarray product ending at `i`. \\n\\nAt each index `i`, we will update `dpMin[i]` as minimum of `A[i]` (denotes forming new subarray by choosing current element) and `min(A[i] * dpMin[i-1], A[i] * dpMax[i-1])` (denotes expanding previous subarray product by including current element). We do it similarly for `dpMax[i]` as well. Finally, the maximum product subarray will be the maximum value in `dpMax` array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        vector<int> dpMin(A), dpMax(A);\\n        int ans = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            dpMin[i] = min(A[i], A[i] * (A[i] >= 0 ? dpMin[i-1] : dpMax[i-1]));\\n            dpMax[i] = max(A[i], A[i] * (A[i] >= 0 ? dpMax[i-1] : dpMin[i-1]));\\n            ans = max(ans, dpMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(N)</code>\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Space-Optimized Dynamic Programming)***\\n\\nIn the above solution, `dpMax[i]` and `dpMin[i]` only depended on previous index and thus we can optimize space by not storing the entire array but only two variables `dpMax` and `dpMin` and update them iteratively based on their previous value in the same way as done above.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = A[0], dpMin = A[0], dpMax = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            auto prevDpMin = dpMin, prevDpMax = dpMax;\\n            dpMin = min(A[i], A[i] * (A[i] >= 0 ? prevDpMin : prevDpMax));\\n            dpMax = max(A[i], A[i] * (A[i] >= 0 ? prevDpMax : prevDpMin));\\n            ans = max(ans, dpMax);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(1)</code>\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) \\n            for(int j = i; j < size(A); j++)\\n                ans = max(ans, accumulate(begin(A)+i, begin(A)+j+1, 1, multiplies<>()));\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = INT_MIN;\\n        for(int i = 0; i < size(A); i++) {\\n            int curProd = 1;\\n            for(int j = i; j < size(A); j++)\\n                curProd *= A[j],\\n                ans = max(ans, curProd);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) { \\n        return dfsMax(A, 0, false); \\n    }\\n\\t// finds maximum subarray product starting at i\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;     // if mustPick remains false till end, the no element is chosen so return -\\u221E denoting invalid case\\n        if (mustPick)\\n            return max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));                 // either end recursion by returning 1 or recurse by picking A[i]. Choose whichever gives max product\\n        return max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));  // either pick A[i] or recurse for next index without picking. Choose whichever gives max product\\n    }\\n\\t// finds minimum subarray product starting at i\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        return A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dpMin;\\n    vector<vector<int>> dpMax;\\n    int maxProduct(vector<int>& A) { \\n        dpMin.resize(size(A), INT_MIN);\\n        dpMax.resize(size(A), vector<int>(2, INT_MIN));\\n        return dfsMax(A, 0, false); \\n    }\\n    long dfsMax(vector<int>& A, int i, bool mustPick) {\\n        if (i >= size(A)) return mustPick ? 1 : INT_MIN;\\n        if(dpMax[i][mustPick] != INT_MIN) return dpMax[i][mustPick];\\n        if (mustPick)\\n            return dpMax[i][mustPick] = max(1l, A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n        return dpMax[i][mustPick] = max(dfsMax(A, i+1, false), A[i] * (A[i] >= 0 ? dfsMax(A, i+1, true) : dfsMin(A, i+1)));\\n    }\\n    long dfsMin(vector<int>& A, int i) {\\n        if (i >= size(A)) return 1;\\n        if(dpMin[i] != INT_MIN) return dpMin[i];\\n        return dpMin[i] = A[i] * (A[i] >= 0 ? dfsMin(A, i+1) : dfsMax(A, i+1, true));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        vector<int> dpMin(A), dpMax(A);\\n        int ans = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            dpMin[i] = min(A[i], A[i] * (A[i] >= 0 ? dpMin[i-1] : dpMax[i-1]));\\n            dpMax[i] = max(A[i], A[i] * (A[i] >= 0 ? dpMax[i-1] : dpMin[i-1]));\\n            ans = max(ans, dpMax[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int ans = A[0], dpMin = A[0], dpMax = A[0];\\n        for(int i = 1; i < size(A); i++) {\\n            auto prevDpMin = dpMin, prevDpMax = dpMax;\\n            dpMin = min(A[i], A[i] * (A[i] >= 0 ? prevDpMin : prevDpMax));\\n            dpMax = max(A[i], A[i] * (A[i] >= 0 ? prevDpMax : prevDpMin));\\n            ans = max(ans, dpMax);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48243,
                "title": "in-python-revised",
                "content": "```python\\ndef maxProduct(nums):\\n\\tmaximum = big = small =nums[0]\\n\\tfor n in nums[1:]:\\n\\t\\tbig, small = max(n, n*big, n*small), min(n, n*big, n*small)\\n\\t\\tmaximum = max(maximum, big)\\n\\treturn maximum\\n```\\t\\n\\t\\t\\n**UPDATE 2020-08-12:**\\nNow I started to appreciate readability:\\n```python\\ndef maxProduct(nums: List[int]) -> int:\\n\\tmini, maxi, res = 1, 1, -math.inf\\n\\tfor n in nums:\\n\\t\\ta = mini * n\\n\\t\\tb = maxi * n\\n\\t\\tmini = min(a, b, n)\\n\\t\\tmaxi = max(a, b, n)\\n\\t\\tres = max(res, maxi)\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxProduct(nums):\\n\\tmaximum = big = small =nums[0]\\n\\tfor n in nums[1:]:\\n\\t\\tbig, small = max(n, n*big, n*small), min(n, n*big, n*small)\\n\\t\\tmaximum = max(maximum, big)\\n\\treturn maximum\\n```\n```python\\ndef maxProduct(nums: List[int]) -> int:\\n\\tmini, maxi, res = 1, 1, -math.inf\\n\\tfor n in nums:\\n\\t\\ta = mini * n\\n\\t\\tb = maxi * n\\n\\t\\tmini = min(a, b, n)\\n\\t\\tmaxi = max(a, b, n)\\n\\t\\tres = max(res, maxi)\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 490459,
                "title": "unofficial-solution-intuitive-explanations-o-n-two-different-approaches",
                "content": "Let\\'s summarize this question into our own words: given an array of integers (negative, zeros, positive inclusive), what is the maximum consecutive subarray? What starting point and ending point within the array has the largest product sum?\\n\\nThinking about simplifying the problem is helpful: specifically think about the easier version of the problem, maximum sum subarray that is solved with kadane\\'s algorithm.\\n\\n**Approach #1 Brute Force**\\nWe try every possible starting and ending point pair within the array, done easily with two for loops.\\n\\nComplexity\\nTime: O(n^2)\\nSpace: O(1)\\n\\nThere are two approaches to the optimal solution, and they are slightly different. Instead of summing up elements, we multiply. Think about the properties of multiplication - any multiplication with a positive number will increase our max, anything by zero will zero us out, and multiplication by an EVEN amount of negative numbers will increase us also. \\n\\nRecall kadane\\'s algorithm - in our one pass, we either extend our subarray to end at the nth item, or we start over at n.\\n\\n**Approach #2 Kadane\\'s algorithm** (Dynamic programming) track both max and mins\\n\\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prev_max = nums[0] # max from previous iteration\\n        prev_min = nums[0] # min from previous iteration\\n        max_to_n = nums[0] # max this iteration\\n        min_to_n = nums[0] # min this iteration\\n        ans = nums[0]\\n        \\n        for i in nums[1:]\\n\\t\\t\\t# use previous max/min*current i or restart from i. The absolute value of the min could be larger so we store it.\\n\\t\\t\\tmax_to_n = max(max(prev_max*i, prev_min*i), i)\\n            min_to_n = min(min(prev_max*i, prev_min*i), i)\\n            prev_max = max_to_n\\n            prev_min = min_to_n\\n            ans = max(ans, max_to_n)\\n        return ans\\n```\\nThe key intuition here is that when we can come upon a negative number, our current max can suddenly becomes a min but is still a max by absolute value. Following the next negative number, our min can become a max again. Therefore keeping track of min is useful.\\n\\n\\n\\nComplexity\\nTime: O(n)\\nSpace: O(1)\\n\\n**Approach #3 Ad hoc** Linear algorithm without DP\\n\\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = nums[0]\\n        current = 1\\n\\t\\t# left to right pass. Captures all potential subarrays containing first odd n negative numbers\\n        for i in nums:\\n            current*=i\\n            ans = max(ans, current)\\n\\t\\t\\t# zero is a delimiter, restart at 1. This is optimal since zero multiplied on is still zero.\\n            if current == 0:\\n                current = 1\\n        current = 1\\n\\t\\t# right to left pass capturing all potential subarrays containing last odd n negative numbers\\n        for i in reversed(nums):\\n            current*=i\\n            ans = max(ans, current)\\n            if current == 0:\\n                current = 1\\n        return ans\\n```\\n\\nAs we described above, positive numbers don\\'t matter, we always \\'take\\' them and continue on and don\\'t consider starting on them. Any array of positive, zero, and negative numbers can be thought of as zeros and negative numbers. Our answer will include an even number of negatives.\\n\\nFor example, [-3 -1, -10]. We can either take [-3, -1] or [-1, -10]. The former gives us 10 which is the maximum.\\n\\nThe positives don\\'t exactly matter. [-3, 5, -3, 5, -10]. The max answer is different, but we could compress this array with positives into [-3, -1, -10] and assume we take/include positive numbers in between and skip onto the next negative number.\\n\\nThe zeros matter because they act like delimiters. Zero times anything = zero. You can think of this algorithm as splitting one array into subarrays delimited by zero, and picking the best even number of negatives. When you reach a zero, you need to restart. Imagine now you have an array with no zeros. If you have 3 negative numbers, pick the first two or the last two. If you have 5 negative numbers, the first four or the last four.\\n\\nThe elegant way to implement this is two passes - one from the left and one from the right. On the left pass, your cumulative multiply and check against your running max. This guarantees checking the first 3 or 5 or first n odd number of negative numbers. But the better answer could be [-1, -10] rather than [-3, -1]. If we pass from right to left, or traverse our array in reverse, we guarantee we also consider the last n odd number of negative numbers.\\n\\nHow do we deal with the zeros? When we hit a zero, we set our current local max back to 1. \\n\\nComplexity\\nTime: O(n)\\nSpace: O(1)\\n\\n\\nAny feedback on these explanations is welcome.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prev_max = nums[0] # max from previous iteration\\n        prev_min = nums[0] # min from previous iteration\\n        max_to_n = nums[0] # max this iteration\\n        min_to_n = nums[0] # min this iteration\\n        ans = nums[0]\\n        \\n        for i in nums[1:]\\n\\t\\t\\t# use previous max/min*current i or restart from i. The absolute value of the min could be larger so we store it.\\n\\t\\t\\tmax_to_n = max(max(prev_max*i, prev_min*i), i)\\n            min_to_n = min(min(prev_max*i, prev_min*i), i)\\n            prev_max = max_to_n\\n            prev_min = min_to_n\\n            ans = max(ans, max_to_n)\\n        return ans\\n```\n```\\ndef maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = nums[0]\\n        current = 1\\n\\t\\t# left to right pass. Captures all potential subarrays containing first odd n negative numbers\\n        for i in nums:\\n            current*=i\\n            ans = max(ans, current)\\n\\t\\t\\t# zero is a delimiter, restart at 1. This is optimal since zero multiplied on is still zero.\\n            if current == 0:\\n                current = 1\\n        current = 1\\n\\t\\t# right to left pass capturing all potential subarrays containing last odd n negative numbers\\n        for i in reversed(nums):\\n            current*=i\\n            ans = max(ans, current)\\n            if current == 0:\\n                current = 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1608907,
                "title": "python3-dynamic-programming-explained",
                "content": "Subproblem for the DP here would be: What is the maximum and minimum product we can get for a contiguous sub-array starting from the `0`th to the current element? Why do we need to maintain the minimum product while we are asked for a maximum? The fact is that elements in `nums` can be negative, so it possible that for some negative element the previous min possible product can turn the current product into a greater value.\\n\\nTime: **O(n)** - scan\\nSpace: **O(1)** \\n\\nRuntime: 44 ms, faster than **98.89%** of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than **36.06%** of Python3 online submissions for Maximum Product Subarray.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax, curMin = 1, 1\\n        res = nums[0]\\n        \\n        for n in nums:\\n            vals = (n, n * curMax, n * curMin)\\n            curMax, curMin = max(vals), min(vals)\\n\\t\\t\\t\\n            res = max(res, curMax)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax, curMin = 1, 1\\n        res = nums[0]\\n        \\n        for n in nums:\\n            vals = (n, n * curMax, n * curMin)\\n            curMax, curMin = max(vals), min(vals)\\n\\t\\t\\t\\n            res = max(res, curMax)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48261,
                "title": "share-my-dp-code-that-got-ac",
                "content": "    public class Solution {\\n      public int maxProduct(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int[] f = new int[A.length];\\n        int[] g = new int[A.length];\\n        f[0] = A[0];\\n        g[0] = A[0];\\n        int res = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            f[i] = Math.max(Math.max(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]);\\n            g[i] = Math.min(Math.min(f[i - 1] * A[i], g[i - 1] * A[i]), A[i]);\\n            res = Math.max(res, f[i]);\\n        }\\n        return res;\\n      }\\n    }\\n\\n> f[i] means maximum product that can be achieved ending with i\\n> \\n> g[i] means minimum product that can be achieved ending with i",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int maxProduct(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3186637,
                "title": "best-c-2-solution-dp-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Two Nested Loops). Brute Force Approach.\\n2. Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2\\n    which creates the time complexity.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=i; j<n; j++){\\n                product *= nums[j];\\n                if(product > maxProduct){\\n                    maxProduct = product;\\n                }\\n            }\\n        }\\n        return maxProduct;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the Array(nums). Here we are traversing each element of Array\\n    (nums) which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int minProduct = 1;\\n        int maxProduct = 1;\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < 0){\\n                swap(maxProduct, minProduct);\\n            }\\n            maxProduct = max(maxProduct*nums[i], nums[i]);\\n            minProduct = min(minProduct*nums[i], nums[i]);\\n            ans = max(ans, maxProduct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2\\n    which creates the time complexity.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=i; j<n; j++){\\n                product *= nums[j];\\n                if(product > maxProduct){\\n                    maxProduct = product;\\n                }\\n            }\\n        }\\n        return maxProduct;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of the Array(nums). Here we are traversing each element of Array\\n    (nums) which creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int minProduct = 1;\\n        int maxProduct = 1;\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] < 0){\\n                swap(maxProduct, minProduct);\\n            }\\n            maxProduct = max(maxProduct*nums[i], nums[i]);\\n            minProduct = min(minProduct*nums[i], nums[i]);\\n            ans = max(ans, maxProduct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416395,
                "title": "javascript-solution-w-explanation",
                "content": "#### The idea\\nThis is something I would never come up by myself, so I\\'m using this discussion as an oppotunity to both reinforce the knowledge for myself and possibly share some insights with others.\\n\\nThe intuition is that we store the information about our previous maximum product, and as we iterate through the array, we keep using our previous maximum to calculate the new maximum product. \\nThe tricky part of this problem is that negative numbers exist in the input array. This causes situations where the smallest previous product (a negative number) can become the largest product if the next number in line is also a negative number.\\nSince the minimum product may have a chance to become the maximum, we need to store the information about the previous minimum as well and take it into account when we are calculating our maximum product.\\n\\n#### Code Time\\n``` javascript\\nvar maxProduct = function(nums) {\\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let result = nums[0];\\n    for (let i=1;i<nums.length;i++) {\\n        // given the new number, the new maximun can have 3 conditions\\n        // 1. number(+) * prevMax(+) is the largest\\n        // 2. number(+) it self is the largest\\n        // 3. number(-) * prevMin(-) is the largest \\n        curMax = Math.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);\\n        \\n        curMin = Math.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);\\n\\n\\t\\t// updating the prevMax & prevMin, these two may swap locations\\n        prevMax = curMax\\n        prevMin = curMin\\n\\n        result = Math.max(curMax, result);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar maxProduct = function(nums) {\\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let result = nums[0];\\n    for (let i=1;i<nums.length;i++) {\\n        // given the new number, the new maximun can have 3 conditions\\n        // 1. number(+) * prevMax(+) is the largest\\n        // 2. number(+) it self is the largest\\n        // 3. number(-) * prevMin(-) is the largest \\n        curMax = Math.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);\\n        \\n        curMin = Math.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);\\n\\n\\t\\t// updating the prevMax & prevMin, these two may swap locations\\n        prevMax = curMax\\n        prevMin = curMin\\n\\n        result = Math.max(curMax, result);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48404,
                "title": "accepted-java-solution",
                "content": "    public int maxProduct(int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n    \\n      int ans = a[0], min = ans, max = ans;\\n      \\n      for (int i = 1; i < a.length; i++) {\\n        if (a[i] >= 0) {\\n          max = Math.max(a[i], max * a[i]);\\n          min = Math.min(a[i], min * a[i]);\\n        } else {\\n          int tmp = max;\\n          max = Math.max(a[i], min * a[i]);\\n          min = Math.min(a[i], tmp * a[i]);\\n        }\\n        \\n        ans = Math.max(ans, max);\\n      }\\n      \\n      return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int maxProduct(int[] a) {\\n      if (a == null || a.length == 0)\\n        return 0;\\n    \\n      int ans = a[0], min = ans, max = ans;\\n      \\n      for (int i = 1; i < a.length; i++) {\\n        if (a[i] >= 0) {\\n          max = Math.max(a[i], max * a[i]);\\n          min = Math.min(a[i], min * a[i]);\\n        } else {\\n          int tmp = max;\\n          max = Math.max(a[i], min * a[i]);\\n          min = Math.min(a[i], tmp * a[i]);\\n        }\\n        \\n        ans = Math.max(ans, max);\\n      }\\n      \\n      return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 691867,
                "title": "python-easily-understandable-solution-using-kadanes-algorithm",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : KADANES ALGORITHM ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # 1. Edge Case : Negative * Negative = Positive\\n        # 2. So we need to keep track of minimum values also, as they can yield maximum values.\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        for num in nums[1:]:\\n            curr_min = min(prev_max*num, prev_min*num, num)\\n            curr_max = max(prev_max*num, prev_min*num, num)\\n            global_max= max(global_max, curr_max)\\n            prev_max = curr_max\\n            prev_min = curr_min\\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : KADANES ALGORITHM ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # 1. Edge Case : Negative * Negative = Positive\\n        # 2. So we need to keep track of minimum values also, as they can yield maximum values.\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        for num in nums[1:]:\\n            curr_min = min(prev_max*num, prev_min*num, num)\\n            curr_max = max(prev_max*num, prev_min*num, num)\\n            global_max= max(global_max, curr_max)\\n            prev_max = curr_max\\n            prev_min = curr_min\\n        return global_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48418,
                "title": "share-c-code-with-dp-o-1-space-o-n-time",
                "content": "    int maxProduct(int A[], int n) {\\n        if(n==1) return A[0];\\n        int pMax=0, nMax=0, m = 0;\\n        for(int i=0; i<n; i++){\\n            if(A[i]<0) swap(pMax, nMax);\\n            pMax = max(pMax*A[i], A[i]);\\n            nMax = min(nMax*A[i], A[i]);\\n            m = max(m, pMax);\\n        }\\n        return m;\\n    }",
                "solutionTags": [],
                "code": "    int maxProduct(int A[], int n) {\\n        if(n==1) return A[0];\\n        int pMax=0, nMax=0, m = 0;\\n        for(int i=0; i<n; i++){\\n            if(A[i]<0) swap(pMax, nMax);\\n            pMax = max(pMax*A[i], A[i]);\\n            nMax = min(nMax*A[i], A[i]);\\n            m = max(m, pMax);\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3227249,
                "title": "c-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\n**KEY POINTS:**\\n1. currMaxProductSubarr : This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n2. currMinProductSubarr : This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n3. maxProductAns : This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n4. The maximum product of a subarray can be obtained by considering three possibilities:\\n     - The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n     - The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n     - The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n1. The minimum product of a subarray can be obtained by considering three possibilities:\\n    - The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n    - The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n    - The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n\\n**See C++ detailed explanation code with intuition.**\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Initialize three variables currMaxProductSubarr, currMinProductSubarr, maxProductAns to the first element of the input array.\\n2. Traverse the input array from index 1 to n-1.\\n3. For each element at index i, update the currMaxProductSubarr and currMinProductSubarr by taking maximum and minimum of the following three values: (i) nums[i], (ii) currMaxProductSubarrnums[i], (iii) currMinProductSubarrnums[i].\\n4. Update the maxProductAns as the maximum of maxProductAns and currMaxProductSubarr.\\n5. Return maxProductAns as the final answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        //currMaxProductSubarr: This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMaxProductSubarr = nums[0];\\n        //currMinProductSubarr: This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMinProductSubarr = nums[0];\\n        //maxProductAns: This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            //The maximum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n            currMaxProductSubarr = max({nums[i], currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]});\\n            //The minimum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n            currMinProductSubarr = min({nums[i], temp * nums[i], currMinProductSubarr * nums[i]});\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        int currMaxProductSubarr = nums[0];\\n        int currMinProductSubarr = nums[0];\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            currMaxProductSubarr = Math.max(nums[i], Math.max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]));\\n            currMinProductSubarr = Math.min(nums[i], Math.min(temp * nums[i], currMinProductSubarr * nums[i]));\\n            maxProductAns = Math.max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        currMaxProductSubarr = nums[0]\\n        currMinProductSubarr = nums[0]\\n        maxProductAns = nums[0]\\n        for i in range(1, n):\\n            temp = currMaxProductSubarr\\n            currMaxProductSubarr = max(nums[i], max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]))\\n            currMinProductSubarr = min(nums[i], min(temp * nums[i], currMinProductSubarr * nums[i]))\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr)\\n        return maxProductAns\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the length of the input array, as we are traversing the array only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, as we are using constant extra space to store the variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        //currMaxProductSubarr: This variable keeps track of the maximum product of a subarray that ends at the current index. For each element in the input array, we update the value of currMaxProductSubarr based on the maximum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMaxProductSubarr = nums[0];\\n        //currMinProductSubarr: This variable keeps track of the minimum product of a subarray that ends at the current index. As with currMaxProductSubarr, we update the value of currMinProductSubarr at each index based on the minimum product that can be obtained by considering the current element and the maximum and minimum product of the subarray that ends at the previous index.\\n        int currMinProductSubarr = nums[0];\\n        //maxProductAns: This variable keeps track of the maximum product obtained so far. At each index, we compare the value of currMaxProductSubarr with the current value of maxProductAns and update maxProductAns if currMaxProductSubarr is greater than the current value of maxProductAns. By doing so, we ensure that maxProductAns always stores the maximum product obtained from any subarray in nums up to the current index.\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            //The maximum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the maximum product. In this case, the maximum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., currMaxProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the maximum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n            currMaxProductSubarr = max({nums[i], currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]});\\n            //The minimum product of a subarray can be obtained by considering three possibilities:\\n                //The current element nums[i] alone forms a subarray with the minimum product. In this case, the minimum product of the subarray that ends at the current index is simply nums[i].\\n                //The current element nums[i] is positive and can be added to the existing subarray that ends at the previous index with the minimum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the minimum product of the subarray that ends at the previous index, i.e., currMinProductSubarr * nums[i].\\n                //The current element nums[i] is negative and can be added to the existing subarray that ends at the previous index with the maximum product. In this case, the minimum product of the subarray that ends at the current index is the product of the current element nums[i] and the maximum product of the subarray that ends at the previous index, i.e., temp * nums[i].\\n            currMinProductSubarr = min({nums[i], temp * nums[i], currMinProductSubarr * nums[i]});\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        int currMaxProductSubarr = nums[0];\\n        int currMinProductSubarr = nums[0];\\n        int maxProductAns = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int temp = currMaxProductSubarr;\\n            currMaxProductSubarr = Math.max(nums[i], Math.max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]));\\n            currMinProductSubarr = Math.min(nums[i], Math.min(temp * nums[i], currMinProductSubarr * nums[i]));\\n            maxProductAns = Math.max(maxProductAns, currMaxProductSubarr);\\n        }\\n        return maxProductAns;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        currMaxProductSubarr = nums[0]\\n        currMinProductSubarr = nums[0]\\n        maxProductAns = nums[0]\\n        for i in range(1, n):\\n            temp = currMaxProductSubarr\\n            currMaxProductSubarr = max(nums[i], max(currMaxProductSubarr * nums[i], currMinProductSubarr * nums[i]))\\n            currMinProductSubarr = min(nums[i], min(temp * nums[i], currMinProductSubarr * nums[i]))\\n            maxProductAns = max(maxProductAns, currMaxProductSubarr)\\n        return maxProductAns\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48448,
                "title": "a-o-n-solution-though-not-as-great-as-answer-provided-by-leetcode",
                "content": "I feel this is a bit more intuitive way to approach; here is my thought:\\n\\n 1. given an array of integers, the max product ignoring sign (i.e., absolute\\n    value) is simply the product of all the elements, as long there is\\n    no 0. put another way, the more elements, the bigger.\\n 2. but we have to consider the sign. so if product is negative, we have odd number of negatives; then\\n    the max product is the bigger of: \\n\\n    a) product of all excluding elements on the left, up to the first negative element.\\n\\n    b) product of all excluding elements on the right, up to the last negative element.\\n\\n\\nso the solution is calculate product, first from left to right, then from right to left; during the process we are guaranteed to encounter the max product; and whenever 0 is encountered, reset product to 1 and continue.\\n\\n\\n    public int maxProduct(int[] A) {\\n        // edge case\\n        if (A == null || A.length == 0)\\n            return 0;\\n            \\n        int max = Integer.MIN_VALUE;\\n        int product = 1;\\n        // first go from left to right\\n        for (int i = 0; i < A.length; i++) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n        \\n        // then go from right to left\\n        product = 1;\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n    \\n        return max;\\n    }\\n\\nsince this requires 2 iterations, it's not as optimal as solution provided by Leetcode, of course.",
                "solutionTags": [],
                "code": "I feel this is a bit more intuitive way to approach; here is my thought:\\n\\n 1. given an array of integers, the max product ignoring sign (i.e., absolute\\n    value) is simply the product of all the elements, as long there is\\n    no 0. put another way, the more elements, the bigger.\\n 2. but we have to consider the sign. so if product is negative, we have odd number of negatives; then\\n    the max product is the bigger of: \\n\\n    a) product of all excluding elements on the left, up to the first negative element.\\n\\n    b) product of all excluding elements on the right, up to the last negative element.\\n\\n\\nso the solution is calculate product, first from left to right, then from right to left; during the process we are guaranteed to encounter the max product; and whenever 0 is encountered, reset product to 1 and continue.\\n\\n\\n    public int maxProduct(int[] A) {\\n        // edge case\\n        if (A == null || A.length == 0)\\n            return 0;\\n            \\n        int max = Integer.MIN_VALUE;\\n        int product = 1;\\n        // first go from left to right\\n        for (int i = 0; i < A.length; i++) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n        \\n        // then go from right to left\\n        product = 1;\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            product *= A[i];\\n            if (product > max)\\n                max = product;\\n            if (product == 0)\\n                product = 1; // reset if encounter 0\\n        }\\n    \\n        return max;\\n    }\\n\\nsince this requires 2 iterations, it's not as optimal as solution provided by Leetcode, of course.",
                "codeTag": "Unknown"
            },
            {
                "id": 841167,
                "title": "c-super-simple-clean-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n\\t\\t// empty array case\\n\\t\\tif (nums.size() == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t    // maxSub and minSub will hold the products till nums[i]\\n        int maxSub = nums[0];   \\n        int minSub = nums[0];\\n        int maxProductSub = nums[0];\\n        \\n        for (size_t i = 1; i < nums.size(); i++)\\n        {\\n            // element is negative so we swap max and min\\n            // because when multiplying negative with a negative, number becomes positive so minimum negative number will become the maximum number\\n            if (nums[i] < 0)\\n                swap(minSub, maxSub);\\n      \\n            // update all the sub values\\n\\t\\t\\tmaxSub = max(maxSub * nums[i], nums[i]); \\n            minSub = min(minSub * nums[i], nums[i]); \\n            // choose max product to be the max between the maxProduct till now and maxSub\\n\\t\\t\\tmaxProductSub = max(maxProductSub, maxSub); \\n        }\\n\\t\\t\\n        return maxProductSub;\\n    }\\n   \\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n\\t\\t// empty array case\\n\\t\\tif (nums.size() == 0)\\n\\t\\t\\treturn 0;\\n\\t\\t\\t\\n\\t    // maxSub and minSub will hold the products till nums[i]\\n        int maxSub = nums[0];   \\n        int minSub = nums[0];\\n        int maxProductSub = nums[0];\\n        \\n        for (size_t i = 1; i < nums.size(); i++)\\n        {\\n            // element is negative so we swap max and min\\n            // because when multiplying negative with a negative, number becomes positive so minimum negative number will become the maximum number\\n            if (nums[i] < 0)\\n                swap(minSub, maxSub);\\n      \\n            // update all the sub values\\n\\t\\t\\tmaxSub = max(maxSub * nums[i], nums[i]); \\n            minSub = min(minSub * nums[i], nums[i]); \\n            // choose max product to be the max between the maxProduct till now and maxSub\\n\\t\\t\\tmaxProductSub = max(maxProductSub, maxSub); \\n        }\\n\\t\\t\\n        return maxProductSub;\\n    }\\n   \\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328132,
                "title": "simple-and-easy-c-code-with-explanation",
                "content": "In the naive solution, we traverse over every contiguous sub arrays, find the product of every sub array and return the maximum product from all sub arrays. But it has time complexity of O(n\\xB2).\\n\\n**Efficient Approach:**\\nThe approach is to traverse the array by maintaining two variables **min_so_far** and **max_so_far**. Now while traversing if the present element at **i**th index is negative we ***swap*** the **min_so_far** and **max_so_far** so that by multiplying negative number with  minimum value gives a maximum value.\\nThe **max_so_far** depends on the maximum of ***current element*** and ***the product of current element with previous max_so_far***.\\nThe **min_so_far** depends on the minimum of ***current element*** and ***the product of current element with previous min_so_far***.\\nAnother variable **max_product** is maintained to find maximum product of sub arrays upto that iteration and max_product is finally returned after all iterations.\\nThis approach is of time complexity **O(n)** and space complexity of **O(1)**.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int max_so_far = nums[0], min_so_far = nums[0], max_product = nums[0];\\n        int n = nums.size();\\n        \\n        for(int i=1;i<n;i++){\\n            if(nums[i]<0) swap(max_so_far, min_so_far);\\n            max_so_far = max(nums[i], nums[i]*max_so_far);\\n            min_so_far = min(nums[i], nums[i]*min_so_far);\\n            // At each iteration max_product is calculated as the maximum of previous maxproduct and max_so_far at that iteration.\\n            max_product = max(max_product, max_so_far);\\n        }\\n        return max_product;\\n    }\\n};\\n```\\nLet us take an example array **nums[ ] = {-8,5,-3,0,30};**\\nThe change at each iteration is as follows:\\n![image](https://assets.leetcode.com/users/images/3a5f0b66-2c9b-42d4-810c-e7645110e38d_1625895684.9695432.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int max_so_far = nums[0], min_so_far = nums[0], max_product = nums[0];\\n        int n = nums.size();\\n        \\n        for(int i=1;i<n;i++){\\n            if(nums[i]<0) swap(max_so_far, min_so_far);\\n            max_so_far = max(nums[i], nums[i]*max_so_far);\\n            min_so_far = min(nums[i], nums[i]*min_so_far);\\n            // At each iteration max_product is calculated as the maximum of previous maxproduct and max_so_far at that iteration.\\n            max_product = max(max_product, max_so_far);\\n        }\\n        return max_product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48339,
                "title": "c-solution-4ms-explained",
                "content": "    int maxProduct(vector<int>& nums) {\\n        if(nums.empty()) {\\n            return 0;\\n        }\\n        int currentMax = nums[0];\\n        int currentMin = nums[0];\\n        int maxProduct = nums[0];\\n        \\n        for(size_t i = 1; i < nums.size(); ++i) {\\n            //calculate our new possibilities for this round\\n            int p1 = currentMax * nums[i];\\n            int p2 = currentMin * nums[i];\\n            //our currentMax will be either p1 or p2 or nums[i] whichever is bigger\\n            currentMax = max(nums[i], max(p1, p2));\\n            //our currentMin will be either p1 or p2 or nums[i] whichever is smaller\\n            currentMin = min(nums[i], min(p1, p2));\\n            //our maxProduct will be our currentMax or our maxProduct, whichever is bigger.\\n            maxProduct = currentMax > maxProduct ? currentMax : maxProduct;\\n        }\\n        return maxProduct;\\n    }\\n\\nSo all you care about is keeping track of the highest possible max so far.\\n\\nApart from that you need to keep track of your highest possible in the subarray. Lookup kadanes algorithm for this.\\n\\nSince we can have negative numbers you need to keep track of your lowest possible in the subarray.\\nThis is because your lowest which might be negative can become your highest when multiplied by a negative number.\\n\\nBy keeping track of these both you have your highest and lowest which can invert themselves.",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int maxProduct(vector<int>& nums) {\\n        if(nums.empty()) {\\n            return 0;\\n        }\\n        int currentMax = nums[0];\\n        int currentMin = nums[0];\\n        int maxProduct = nums[0];\\n        \\n        for(size_t i = 1; i < nums.size(); ++i) {\\n            //calculate our new possibilities for this round\\n            int p1 = currentMax * nums[i];\\n            int p2 = currentMin * nums[i];\\n            //our currentMax will be either p1 or p2 or nums[i] whichever is bigger\\n            currentMax = max(nums[i], max(p1, p2));\\n            //our currentMin will be either p1 or p2 or nums[i] whichever is smaller\\n            currentMin = min(nums[i], min(p1, p2));\\n            //our maxProduct will be our currentMax or our maxProduct, whichever is bigger.\\n            maxProduct = currentMax > maxProduct ? currentMax : maxProduct;\\n        }\\n        return maxProduct;\\n    }\\n\\nSo all you care about is keeping track of the highest possible max so far.\\n\\nApart from that you need to keep track of your highest possible in the subarray. Lookup kadanes algorithm for this.\\n\\nSince we can have negative numbers you need to keep track of your lowest possible in the subarray.\\nThis is because your lowest which might be negative can become your highest when multiplied by a negative number.\\n\\nBy keeping track of these both you have your highest and lowest which can invert themselves.",
                "codeTag": "Unknown"
            },
            {
                "id": 1094388,
                "title": "python-easy-sol-with-explanation-o-n",
                "content": "\\'\\'\\'Success\\nDetails \\nRuntime: 44 ms, faster than 98.96% of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than 41.20% of Python3 online submissions for Maximum Product Subarray\\'\\'\\'\\n\\nUsing Kadane\\'s algorithm. Basically we are storing max and min product and the storing the max_pro in results at each iteration and checking which is the max the current result or the current max_pro. The reason behind taking so the min_pro so that we know which is the min one. You can modify this code according to your wish.\\n\\n        if len(nums)==0:\\n            return 0\\n        \\n        max_pro , min_pro = nums[0], nums[0]\\n            \\n        #result will store the final max product\\n        result = max_pro\\n            \\n        for i in range(1, len(nums)):\\n            current = nums[i]\\n            \\n            temp_max = max( current ,  max_pro*current, current*min_pro)\\n            \\n            min_pro = min( current ,  max_pro*current, current*min_pro)\\n            \\n            max_pro = temp_max\\n            \\n            result = max(result, max_pro)\\n        \\n        return result\\n\\t\\t\\nIf you find it helpful please upvote.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'Success\\nDetails \\nRuntime: 44 ms, faster than 98.96% of Python3 online submissions for Maximum Product Subarray.\\nMemory Usage: 14.5 MB, less than 41.20% of Python3 online submissions for Maximum Product Subarray\\'\\'\\'\\n\\nUsing Kadane\\'s algorithm. Basically we are storing max and min product and the storing the max_pro in results at each iteration and checking which is the max the current result or the current max_pro. The reason behind taking so the min_pro so that we know which is the min one. You can modify this code according to your wish.\\n\\n        if len(nums)==0:\\n            return 0\\n        \\n        max_pro , min_pro = nums[0], nums[0]\\n            \\n        #result will store the final max product\\n        result = max_pro\\n            \\n        for i in range(1, len(nums)):\\n            current = nums[i]\\n            \\n            temp_max = max( current ,  max_pro*current, current*min_pro)\\n            \\n            min_pro = min( current ,  max_pro*current, current*min_pro)\\n            \\n            max_pro = temp_max\\n            \\n            result = max(result, max_pro)\\n        \\n        return result\\n\\t\\t\\nIf you find it helpful please upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 841176,
                "title": "python-dp-solution-explained",
                "content": "Let `dp1[i]` be the maximum product which ends with `i`-th index and `dp2[i]` be the minimum product which ends with `i`-the index. Why we need both maximum and minimum? Because we can have big negative number, which then multiplied by negative will give big positive number.\\n\\nSo, let us traverse all numbers and update our `dp1` and `dp2`:\\n1. If `nums[k] > 0`, then biggest number `dp1[k]` can be found as maximum of `dp1[k-1] * nums[k]` and `nums[k]`. The smallest number `dp2[k]` is equal to minimum of `dp2[k-1] * nums[k] and nums[k]`\\n2. If `nums[k] <= 0`, then the biggest number is maximum of `dp2[k-1] * nums[k]` and `nums[k]`  and the smalles number `dp2[k]` is minimum of  `dp1[k-1] * nums[k]` and `nums[k]`\\n3. Finally, we return maximum of `dp1`.\\n\\n**Complexity**: both time and space is `O(n)`. Space complexity can be improved to `O(1)`, because we always use only previous elements in our `dp1` and `dp2` tables.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        N = len(nums)\\n        dp1 = [0] * N\\n        dp2 = [0] * N\\n        dp1[0] = dp2[0] = nums[0]\\n        \\n        for k in range(1, N):\\n            if nums[k] > 0:\\n                dp1[k] = max(dp1[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp2[k-1] * nums[k], nums[k])\\n            else:\\n                dp1[k] = max(dp2[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp1[k-1] * nums[k], nums[k])\\n        \\n        return max(dp1)      \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        N = len(nums)\\n        dp1 = [0] * N\\n        dp2 = [0] * N\\n        dp1[0] = dp2[0] = nums[0]\\n        \\n        for k in range(1, N):\\n            if nums[k] > 0:\\n                dp1[k] = max(dp1[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp2[k-1] * nums[k], nums[k])\\n            else:\\n                dp1[k] = max(dp2[k-1] * nums[k], nums[k])\\n                dp2[k] = min(dp1[k-1] * nums[k], nums[k])\\n        \\n        return max(dp1)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118574,
                "title": "modification-of-kadane-s-algorithim-java-time-o-n-and-space-o-1",
                "content": "Idea is very similar to [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/discuss/1108980/Thought-Process-and-O(N)-java-solution) i.e either start subarray from myself or be a part of previous subarray. but here we are looking for product and negative*negative became Positive. So Little modification in Kadane\\'s Algorithm is needed here:\\n\\nIdea is to maintain maximum positive product and minimum negative product till previous .It will help us to find maximum positive product (as neg*neg = Positive) . and keep update omax and mpp and mnp.\\n**mpp: maximum** positive product\\n**mnp:minimum** negative product\\nomax: overall maximum\\n\\n2. now If I am positive value \\n 2.1 mpp = Math.max(val,mpp* val)\\n 2.2 mnp=Math.min(val,mnp* val)\\n\\n3.If I am negative value so mpp will be updated by mnp* current val\\n 3.1 mpp=Math.max(val,mnp* val);\\n 3.2 mnp=Math.min(val,mpp* val);  // **keep in mind that u have updated mpp** in previous step and you want mpp till previous. will handle that part in code\\n\\nyou have some idea now **Code will give you more clearity** :) \\n```\\n public int maxProduct(int[] nums) {\\n        int mpp=nums[0]; // mpp: maximum Positive Product\\n        int mnp=nums[0]; // mnp: Minimum Negative Product\\n        int omax=nums[0]; // overall maximum Product\\n        \\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int val=nums[i];\\n            if(val<0){\\n                int temp1=mnp;\\n                int temp2=mpp;\\n              mpp=Math.max(val,temp1*val);\\n              mnp=Math.min(val,temp2*val);  \\n            }else{\\n               mpp=Math.max(val,val*mpp);\\n               mnp=Math.min(val,val*mnp); \\n            }\\n            omax=Math.max(mpp,omax);\\n            \\n        }\\n        \\n        return omax;\\n        \\n    }\\n```\\n**Time :O(N) and Space:O(1)**\\nPlease **Upvote** if found it helpful:)\\n\\n###### Advice for you :\\n###### 1.Confirm your interviewer that array is containing negative values or not .(If he/she told no then ask what about zero..)\\n###### 2.can Product of number can exceed the Integer.MAX value ?\\n###### 3.Don\\'t just rush to coding part without Clarifying these things else you may get rejection even after solving the question in most optmised way.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int maxProduct(int[] nums) {\\n        int mpp=nums[0]; // mpp: maximum Positive Product\\n        int mnp=nums[0]; // mnp: Minimum Negative Product\\n        int omax=nums[0]; // overall maximum Product\\n        \\n        \\n        for(int i=1;i<nums.length;i++){\\n            \\n            int val=nums[i];\\n            if(val<0){\\n                int temp1=mnp;\\n                int temp2=mpp;\\n              mpp=Math.max(val,temp1*val);\\n              mnp=Math.min(val,temp2*val);  \\n            }else{\\n               mpp=Math.max(val,val*mpp);\\n               mnp=Math.min(val,val*mnp); \\n            }\\n            omax=Math.max(mpp,omax);\\n            \\n        }\\n        \\n        return omax;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48245,
                "title": "my-python-code-for-maximum-product-subarray",
                "content": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def maxProduct(self, A):\\n        MinTemp = A[0]\\n        MaxTemp = A[0]\\n        Max = A[0]\\n        for i in xrange(1, len(A)):\\n            MinTemp, MaxTemp = min(A[i], A[i] * MaxTemp, A[i] * MinTemp), max(A[i], A[i] * MaxTemp, A[i] * MinTemp)\\n            Max = max(Max, MaxTemp)\\n        return Max\\n\\nSave Min value and Max value at each node and the result works out.",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A, a list of integers\\n    # @return an integer\\n    def maxProduct(self, A):\\n        MinTemp = A[0]\\n        MaxTemp = A[0]\\n        Max = A[0]\\n        for i in xrange(1, len(A)):\\n            MinTemp, MaxTemp = min(A[i], A[i] * MaxTemp, A[i] * MinTemp), max(A[i], A[i] * MaxTemp, A[i] * MinTemp)\\n            Max = max(Max, MaxTemp)\\n        return Max\\n\\nSave Min value and Max value at each node and the result works out.",
                "codeTag": "Java"
            },
            {
                "id": 759813,
                "title": "c-easy-solution-o-1-space-and-o-n-time-complexity",
                "content": "We can solve it using dynamic programming. If it was a maximum sum problem, we would have stored the minimum sum seen so far and subtract that from the current sum to get the maximum sum at that index.\\n\\nFor finding the maximum product, since all the numbers are integer, so we know that the product would be maximum when either we multiply the negative number with a negative number or positive number with a positive number. \\n\\nIf the negative number comes, then we should swap our maximum productn with minimum, because it will now make the maximum more less. For example, maxi=4 and mini=-2 and nums[i]=-2., then the larger number would now become smaller then smaller number.\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n     int r=nums[0];\\n     int maxi=r;\\n     int mini=r;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int temp=maxi;\\n                maxi=mini;\\n                mini=temp;\\n            }\\n            maxi=max(nums[i],nums[i]*maxi);\\n            mini=min(nums[i],nums[i]*mini);\\n            r=max(r,maxi);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n     int r=nums[0];\\n     int maxi=r;\\n     int mini=r;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                int temp=maxi;\\n                maxi=mini;\\n                mini=temp;\\n            }\\n            maxi=max(nums[i],nums[i]*maxi);\\n            mini=min(nums[i],nums[i]*mini);\\n            r=max(r,maxi);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361537,
                "title": "java-readable-solution-time-o-n-beats-99-space-o-1-beats-100",
                "content": "```\\n/*\\nidea is to keep 3 variables\\n1. max -> maximum product ending at a[i]\\n2. min -> minimum product ending at a[i]\\n3. ans -> maximum product subarray\\n\\nEx.\\nnum = [3, 2, -1,   5, -2]\\nmin = [3, 2, -6, -30, -2]\\nmax = [3, 6, -1,   5, 60]\\nans = [3, 6,  6,   6, 60]\\n*/\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums==null||nums.length==0) return 0;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int ans = nums[0];\\n        int temp;\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i]<0) {\\n                temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n            max = Integer.max(nums[i],nums[i]*max);\\n            min = Integer.min(nums[i],nums[i]*min);\\n            ans = Integer.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nidea is to keep 3 variables\\n1. max -> maximum product ending at a[i]\\n2. min -> minimum product ending at a[i]\\n3. ans -> maximum product subarray\\n\\nEx.\\nnum = [3, 2, -1,   5, -2]\\nmin = [3, 2, -6, -30, -2]\\nmax = [3, 6, -1,   5, 60]\\nans = [3, 6,  6,   6, 60]\\n*/\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums==null||nums.length==0) return 0;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int ans = nums[0];\\n        int temp;\\n        for(int i=1;i<nums.length;i++) {\\n            if(nums[i]<0) {\\n                temp = max;\\n                max = min;\\n                min = temp;\\n            }\\n            max = Integer.max(nums[i],nums[i]*max);\\n            min = Integer.min(nums[i],nums[i]*min);\\n            ans = Integer.max(ans,max);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781113,
                "title": "kadane-s-algo-for-maximum-product-subarray",
                "content": "# First I  thought \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to max sum subarray using kadane\\'s algo. So i used the following code \\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         int currentPro=Integer.MIN_VALUE;\\n        int prevPro=1;\\n\\n        for(int i =0; i<nums.length; i++){\\n            prevPro*=nums[i];\\n          \\n            if(prevPro> currentPro){\\n                currentPro=prevPro;\\n            }\\n            if(prevPro<0){\\n                prevPro=1;\\n            }\\n        }\\n      \\n        return currentPro;\\n    }\\n}\\n```\\n\\n# But failed because \\n\\nTwo negative numbers are added to make negative number but if two negative numbers are multiplied to make a positive number\\n\\n# Thus, I need\\n\\nTo take care of the current product (which is maximum product now) and the previous product (which became minimum product)\\n\\nif negative number comes say -1 and suppose if current product =4 (max) and previous product = -2 (min) \\n\\nthen 4 * (-1) = - 4 and -2 * (-1) = 2 \\n\\nDue to negative number, minproduct becomes max and maxproduct becomes minimum. \\n\\nIf I use this maxproduct (which has became minimum) then the answer will be wrong because I want maximum product to update the answer \\n\\nThus, I need to swap the min and max products so that the minimum product will give me the maximum value and I can use this value to update the answer. \\n\\n**So, technically while explaining to interviewer, you can say that this is the variation of Kadane\\'s algo. But the difference is that for max-sum subarray we were taking care of the maxsum but here, we need to take care of maxproduct as well as minproduct because minproduct helps to eliminate the problem of (-)  * (-) = (+) in the array**\\n\\nTC= O(n) and SC=O(1)\\n # Code\\n ```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxPro=nums[0];\\n        int minPro=nums[0];\\n        int answer = nums[0];\\n\\n        for(int i =1; i<nums.length; i++){\\n            if(nums[i]<0){\\n                // if next is -1 and maxpro=4 then 4 x -1 = -4 which is minimum \\n                // thus swap maxPro and minPro\\n                int temp=maxPro;\\n                maxPro=minPro;\\n                minPro=temp;  \\n            }\\n    // maxproduct \\n             maxPro= Math.max( maxPro*nums[i],   nums[i]);\\n    // minimum product \\n             minPro= Math.min( minPro*nums[i], nums[i]);\\n             \\n             answer=Math.max(answer, maxPro);\\n             \\n        }\\n      \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         int currentPro=Integer.MIN_VALUE;\\n        int prevPro=1;\\n\\n        for(int i =0; i<nums.length; i++){\\n            prevPro*=nums[i];\\n          \\n            if(prevPro> currentPro){\\n                currentPro=prevPro;\\n            }\\n            if(prevPro<0){\\n                prevPro=1;\\n            }\\n        }\\n      \\n        return currentPro;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxPro=nums[0];\\n        int minPro=nums[0];\\n        int answer = nums[0];\\n\\n        for(int i =1; i<nums.length; i++){\\n            if(nums[i]<0){\\n                // if next is -1 and maxpro=4 then 4 x -1 = -4 which is minimum \\n                // thus swap maxPro and minPro\\n                int temp=maxPro;\\n                maxPro=minPro;\\n                minPro=temp;  \\n            }\\n    // maxproduct \\n             maxPro= Math.max( maxPro*nums[i],   nums[i]);\\n    // minimum product \\n             minPro= Math.min( minPro*nums[i], nums[i]);\\n             \\n             answer=Math.max(answer, maxPro);\\n             \\n        }\\n      \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304366,
                "title": "javascript-beats-99-intuition-behind-how-to-solve-this-problem-explained-as-clearly-as-possible",
                "content": "Code is at the bottom.\\n\\n**TLDR** Keep track of both the maximum and minimum products, since at any point, a `negative number * negative number` = `positive number`. So you can\\'t just keep track of the max positive product and not care about the negative - maybe that negative can become positive too, and claim the throne.\\n\\nAlso, since this problem is asking for a **contiguous subarray**, we can\\'t use the usual `m x n` DP array method, because you would end up keeping track of a **subset**, which is disconnected/disjointed, and not contiguous.\\n\\nFor example, for `[2, 3, -2, 4]`, you cannot *selfishly hold onto 2*3 = 6*, then somehow multiply by the very last `4` to get a final answer of `24`. Too bad. i.e. you can\\'t do the product of `[2, 3, _, 4]`.\\n\\nIn this problem you don\\'t even need to use an array to keep track of values. The problem boils down to the following: as I step through the array, every new number I see presents me with **THREE CHOICES**:\\n\\na) the previous max * the current number\\nb) the previous min * the current number\\nc) the current number\\n\\nThus, the current max, and the current min, will be determined based off:\\n- max(a, b, c)\\n- min(a, b, c)\\n\\nAnd the `maxSoFar`, the answer we will eventually return, is simply the max of the two numbers above.\\n\\nNote that a) and b) might swap - a big number multipled by a negative number ends up a big negative number. Things can switch between night and day at the snap of a finger.\\n\\nTo be even more clear, this is an Excel chart to see what happens for `[2, 3, -2, 4]`:\\n![image](https://assets.leetcode.com/users/lcgt/image_1559513982.png)\\nHow to read this: go down and right. We are iterating through the array downwards on column A; column B shows us the 3 choices a, b, and c).\\n\\n**EXPLANATION BELOW IS A BIT WORDY AND CONVOLUTED**\\n\\nSo for example, the \"6, 2, 2\" when current num = 3 is because:\\na) `prevMax * currentNum` = `2 * 3` = `6`\\nb) `currentNum` = `3`\\nc) `prevMin * currentNum` = `2 * 3` = `6`.\\nNothing weird here. We proclaim `6` the current max, `2` the current min. Max so far is `6`.\\n\\nBut for the next iteration (currentNum = -2), things are a little different. What happens is that:\\na) `prevMax * currentNum` = `6 * -2` = `-12`\\nb) `currentNum` = `-2`\\nc) `prevMin * currentNum` = `2 * -2` = `-4`.\\n\\nSuddenly, our proclaimed previous max now ends up as the lowest number, `-12`! That\\'s terrible. But this number could still be useful **if we ever see another negative number again**, because then the `-12` would turn positive again and become the biggest number we will see. OR, it might not - still, we must keep hope. **So that\\'s the intution behind the question - you must keep hope on both the positive and negative side.**\\n\\nAnd in some cases, maybe the current number is the best you\\'ll ever get.\\n\\nIn this iteration, its obvious that the numbers are all really low - so its best that we keep our `maxSoFar` of `6`. We are not allowed to multiply `maxSoFar` with any current number or value, otherwise that would be going back to a non-contiguous solution. `prevMax` now takes on `-2`, since `-12` is way too low - `prevMin` will hold onto `-12` instead.\\n\\nFinally, we see in the last iteration that \\na) `prevMax * currentNum` = `-2 * 4` = `-8`\\nb) `currentNum` = `4`\\nc) `prevMin * currentNum` = `-12 * 4` = `-48`.\\n\\nNotice that the `prevMax` was previously set to the lesser of the negatives. However, `-8` is still low. The highest number of these 3 choices is actually `4`. Unfortunately, it still doesn\\'t outshine our previous max product - `2*3=6`.\\n\\nSo the final answer is `6`.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function(nums) {\\n    \\n    if(!nums && !nums.length) return nums;\\n    \\n    const n = nums.length;\\n    \\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let maxSoFar = nums[0];\\n    \\n    for(let i=1; i<n; i++){\\n        // choices: 1) prevMax * nums[i], 2) nums[i], 3) prevMin * nums[i]\\n        let localMax = Math.max(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        let localMin = Math.min(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        \\n        // max and min could have swapped\\n        prevMax = Math.max(localMax, localMin);\\n        prevMin = Math.min(localMax, localMin);\\n        \\n        maxSoFar = Math.max(maxSoFar, prevMax);\\n    }\\n    \\n    return maxSoFar;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function(nums) {\\n    \\n    if(!nums && !nums.length) return nums;\\n    \\n    const n = nums.length;\\n    \\n    let prevMax = nums[0];\\n    let prevMin = nums[0];\\n    let maxSoFar = nums[0];\\n    \\n    for(let i=1; i<n; i++){\\n        // choices: 1) prevMax * nums[i], 2) nums[i], 3) prevMin * nums[i]\\n        let localMax = Math.max(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        let localMin = Math.min(prevMax * nums[i], nums[i], prevMin * nums[i]);\\n        \\n        // max and min could have swapped\\n        prevMax = Math.max(localMax, localMin);\\n        prevMin = Math.min(localMax, localMin);\\n        \\n        maxSoFar = Math.max(maxSoFar, prevMax);\\n    }\\n    \\n    return maxSoFar;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48389,
                "title": "my-concise-dp-o-n-java-solution-with-o-1-extra-space",
                "content": "    public int maxProduct(int[] A) {\\n       int min;\\n       int res = A[0], max = min = A[0]; // max, min means max and min product among the subarrays whose last element is A[i].\\n       for (int i = 1; i < A.length; i++) {\\n    \\t   if (A[i] > 0) {\\n    \\t\\t   max = Math.max(max * A[i], A[i]);\\n    \\t\\t   min = Math.min(min * A[i], A[i]);\\t\\t\\t   \\n    \\t   }\\n    \\t   else {\\n    \\t\\t   int lastMax = max;\\n    \\t\\t   max = Math.max(min * A[i], A[i]);\\n    \\t\\t   min = Math.min(lastMax * A[i], A[i]);\\t\\t\\t   \\t\\t\\t   \\n    \\t   }\\n    \\t   res = Math.max(res, max);\\n       }\\n       return res;\\n    }",
                "solutionTags": [],
                "code": "    public int maxProduct(int[] A) {\\n       int min;\\n       int res = A[0], max = min = A[0]; // max, min means max and min product among the subarrays whose last element is A[i].\\n       for (int i = 1; i < A.length; i++) {\\n    \\t   if (A[i] > 0) {\\n    \\t\\t   max = Math.max(max * A[i], A[i]);\\n    \\t\\t   min = Math.min(min * A[i], A[i]);\\t\\t\\t   \\n    \\t   }\\n    \\t   else {\\n    \\t\\t   int lastMax = max;\\n    \\t\\t   max = Math.max(min * A[i], A[i]);\\n    \\t\\t   min = Math.min(lastMax * A[i], A[i]);\\t\\t\\t   \\t\\t\\t   \\n    \\t   }\\n    \\t   res = Math.max(res, max);\\n       }\\n       return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48403,
                "title": "simple-c-solution-in-8-lines",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 0) return 0;\\n            long long curmax = nums[0], curmin = nums[0], res = nums[0];\\n            for(int i=1; i<nums.size(); ++i){\\n                long long premax = curmax;\\n                curmax = max(curmax*nums[i], max(curmin*nums[i], (long long)nums[i]));\\n                curmin = min(premax*nums[i], min(curmin*nums[i], (long long)nums[i]));\\n                res = max(res, curmax);\\n            }\\n            return int(res);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 0) return 0;\\n            long long curmax = nums[0], curmin = nums[0], res = nums[0];\\n            for(int i=1; i<nums.size(); ++i){\\n                long long premax = curmax;\\n                curmax = max(curmax*nums[i], max(curmin*nums[i], (long long)nums[i]));\\n                curmin = min(premax*nums[i], min(curmin*nums[i], (long long)nums[i]));\\n                res = max(res, curmax);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609230,
                "title": "intuition-explained-two-approaches-c",
                "content": "The Brute force approach for the given problem will be, to generate all the possible subarrays and calculate the maximum product.\\n<a href=\"https://ibb.co/NmgStmr\"><img src=\"https://i.ibb.co/b2jJQ2F/1.jpg\" alt=\"1\" border=\"0\"></a>\\nThe code for the above approach will be:\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans = nums[0], mul;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mul= nums[i];\\n            ans = max(ans,mul);\\n            for(int j= i+1;j<nums.size();j++)\\n            {\\n                mul *= nums[j];\\n                ans= max(ans,mul);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime complexity : O(N^2)\\nAux. space : O(1)\\n\\n<b>Optimized approach:</b>\\nFirst of all, Let\\'s think about all the patterns that we can observe in this problem.\\n1) If all the numbers are positive the product is always increasing.\\nBut when it comes to negative numbers, It gets alot more tricky as the product of two negatives, is a positive.\\nWhen we have a vector of all negatives, the signs of the product will be alternating.\\neg. {-1,-2,-3,-4,-5} => -1, 2, -6, 24, -120\\n\\n<a href=\"https://ibb.co/tKX2QCg\"><img src=\"https://i.ibb.co/C829m0g/Screenshot-417.png\" alt=\"Screenshot-417\" border=\"0\"></a>\\n\\nso, to find maximum in such case, we need to track both maximum and minimum.\\nexample, in {-1,-2,-3} max of first two elements will be 2 and min will be -2\\nbut when combined with the third element -3, our min will become -2*-3 = 6 which is our desired answer.\\nI hope the reason of storing minimum is pretty clear now.\\n```\\nclass Solution {\\npublic:\\nint maxProduct(vector& nums) {\\n// declared ans to store the final max value till the iteraterd element of the array\\nint ans = nums[0];\\n// n is the size of the array\\nint n = nums.size();\\n// imax is the maximum product value till the iteraterd element of the array\\nint imax = ans;\\n\\n    // imin is the minimum product value till the iteraterd element of the array\\n    int imin = ans;\\n    \\n    for(int i=1;i<n;i++) {\\n        // If the array element is negative then is multiplied with the max product till now change it to minimum value and min product valu so far to maximum value. Thus swap the max and min value so far \\n        if(nums[i]<0)\\n            swap(imax,imin);\\n        imax = max(nums[i], imax*nums[i]);\\n        imin = min(nums[i], imin*nums[i]);\\n        ans = max(ans, imax);\\n    }\\n    // return the answer\\n    return ans;\\n}\\n};\\n```\\nTime Complexity: O(n) \\nAuxiliary Space: O(1)\\n\\n<b>Please upvote if it helped! :) </b>\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans = nums[0], mul;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mul= nums[i];\\n            ans = max(ans,mul);\\n            for(int j= i+1;j<nums.size();j++)\\n            {\\n                mul *= nums[j];\\n                ans= max(ans,mul);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint maxProduct(vector& nums) {\\n// declared ans to store the final max value till the iteraterd element of the array\\nint ans = nums[0];\\n// n is the size of the array\\nint n = nums.size();\\n// imax is the maximum product value till the iteraterd element of the array\\nint imax = ans;\\n\\n    // imin is the minimum product value till the iteraterd element of the array\\n    int imin = ans;\\n    \\n    for(int i=1;i<n;i++) {\\n        // If the array element is negative then is multiplied with the max product till now change it to minimum value and min product valu so far to maximum value. Thus swap the max and min value so far \\n        if(nums[i]<0)\\n            swap(imax,imin);\\n        imax = max(nums[i], imax*nums[i]);\\n        imin = min(nums[i], imin*nums[i]);\\n        ans = max(ans, imax);\\n    }\\n    // return the answer\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024596,
                "title": "my-recursive-to-memorized-dp-solution",
                "content": "**At every step we have 3 choices**\\n**1**. Take the number and multiply with the previous calculated value (continue calculation).\\n**2**. Do not take the previous calculated value, start the calculation from the current value (start new calculation).\\n**3**. Take the pre. calculated value and stop the calculation now (stop calculation).\\n\\nNow compare these 3 returned val from these 3 steps and return the max value.\\n\\n```\\nclass Solution {\\n    HashMap<String, Integer> dp;\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        dp = new HashMap();\\n        if(n == 0) return 0;\\n        return util(nums, n, 0, 1);\\n    }\\n    int util(int[] nums, int n, int index, int t){\\n        if(index == n) return t;\\n        String key = \"\"+index+t;\\n        if(dp.containsKey(key)) return dp.get(key);       \\n        \\n\\t\\t// choice 1\\n        int x = util(nums, n, index+1, t*nums[index]);\\n\\t\\t// choice 2\\n        int y = util(nums, n, index+1, nums[index]);\\n        if(index == 0){\\n            t = nums[0];\\n        }\\n\\t\\t// keep the t (previous cal. value) and compare -> choice 3\\n        int ans = Math.max(t, Math.max(x, y));\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> dp;\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n        dp = new HashMap();\\n        if(n == 0) return 0;\\n        return util(nums, n, 0, 1);\\n    }\\n    int util(int[] nums, int n, int index, int t){\\n        if(index == n) return t;\\n        String key = \"\"+index+t;\\n        if(dp.containsKey(key)) return dp.get(key);       \\n        \\n\\t\\t// choice 1\\n        int x = util(nums, n, index+1, t*nums[index]);\\n\\t\\t// choice 2\\n        int y = util(nums, n, index+1, nums[index]);\\n        if(index == 0){\\n            t = nums[0];\\n        }\\n\\t\\t// keep the t (previous cal. value) and compare -> choice 3\\n        int ans = Math.max(t, Math.max(x, y));\\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48348,
                "title": "share-simple-java-solution-with-explanation",
                "content": "Why do we need min value ? Because min value multiplies another min value will yield a possibly max value. That's why we need to keep track of min value as well. Otherwise, it will be no different than maximum subarray problem which we keep track of max value only. \\n\\n    public int maxProduct(int[] A) {\\n       if (A.length == 0) return 0;\\n       int max = A[0], min = A[0], totalMax = A[0];\\n       for (int i = 1; i < A.length; i++) {\\n           int tempMax = A[i] * max;\\n           int tempMin = A[i] * min;\\n           max = Math.max(Math.max(tempMax,tempMin), A[i]);\\n           min = Math.min(Math.min(tempMax,tempMin), A[i]);\\n           totalMax = Math.max(totalMax, max);\\n       }\\n       return totalMax;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Why do we need min value ? Because min value multiplies another min value will yield a possibly max value. That's why we need to keep track of min value as well. Otherwise, it will be no different than maximum subarray problem which we keep track of max value only. \\n\\n    public int maxProduct(int[] A) {\\n       if (A.length == 0) return 0;\\n       int max = A[0], min = A[0], totalMax = A[0];\\n       for (int i = 1; i < A.length; i++) {\\n           int tempMax = A[i] * max;\\n           int tempMin = A[i] * min;\\n           max = Math.max(Math.max(tempMax,tempMin), A[i]);\\n           min = Math.min(Math.min(tempMax,tempMin), A[i]);\\n           totalMax = Math.max(totalMax, max);\\n       }\\n       return totalMax;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48405,
                "title": "o-n-time-o-1-space-solution-within-one-scan",
                "content": "Using dp and keep a record of current max product together with current min product.\\n\\n    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def maxProduct(self, nums):\\n            i = 0\\n            currentMax, currentMin, ans = nums[0], nums[0], nums[0]\\n            for i in range(1, len(nums)):\\n                n = nums[i]\\n                tmp = currentMax\\n                currentMax = max(n, n*currentMax, n*currentMin)\\n                currentMin = min(n, n*tmp, n*currentMin)\\n                ans = max(ans, currentMax)\\n            return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 1290196,
                "title": "c-two-pass-0-ms-faster-than-100-00",
                "content": "# kaden\\'s algo || two pass\\n```\\nclass Solution {\\npublic:\\n    \\n    //we are using kaden\\'s algo logic\\n    //we are here using two pass method so that we can get ultimate max\\n    \\n    int maxProduct(vector<int>& nums) {\\n        \\n        int prod=1;\\n        int max_val=INT_MIN;\\n        \\n        //left to right traversal\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prod==0)//if prod becomes 0, prod is reset to 1\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod); \\n        }\\n        \\n        //right to left\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(prod==0)\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod);\\n        }\\n        \\n        return max_val;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //we are using kaden\\'s algo logic\\n    //we are here using two pass method so that we can get ultimate max\\n    \\n    int maxProduct(vector<int>& nums) {\\n        \\n        int prod=1;\\n        int max_val=INT_MIN;\\n        \\n        //left to right traversal\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(prod==0)//if prod becomes 0, prod is reset to 1\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod); \\n        }\\n        \\n        //right to left\\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(prod==0)\\n                prod=1;\\n            \\n            prod=prod*nums[i];\\n            max_val=max(max_val,prod);\\n        }\\n        \\n        return max_val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520026,
                "title": "how-to-come-up-with-a-dp-solution",
                "content": "Not to take anything away from all the top rated DP solutions, they are all brilliant. However I think they missed the opportunity to elaborate on their thought process behind how the arrived at their solutions. So I am going to show how I approached the problem, and I hope you might find it useful.\\n\\nConsider an input array [2,-3,2,-4]. So how can we find a recursive pattern? i.e. how do we build a global maximum product based on previous  products? Let\\'s list all products of current number and previous numbers as we loop through the array.\\n\\n```\\n1st iteration   2nd iteration  3rd iteration  4th iteration\\n[2]             [-3]           [2]            [-4]\\n1 * 2 = 2       1 * -3 = -3    1 * 2 = 2      1 * -4 = -4\\n                2 * -3 = -6    -3 * 2 = -6    2 * -4 = -8\\n                               -6 * 2 = -12   -6 *- 4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                  -12 * -4 = 48\\n```\\nWe can introduce two variables local_maximum and global_maximum to **rember** our current progress,\\n```\\n1st iteration         2nd iteration     3rd iteration    4th iteration\\n[2]                   [-3]              [2]              [-4]\\n1 * 2 = 2 (lm, gm)    1 * -3 = -3 (lm)  1 * 2 = 2 (lm)   1 * -4 = -4\\n                      2 * -3 = -6       -3 * 2 = -6      2 * -4 = -8\\n                                        -6 * 2 = -12     -6 * -4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                             -12 * -4 = 48 (lm, gm)\\nlm = local maximum\\ngm = global maximum\\n```\\nThis is in fact the recursive relationship we\\'re looking for. We could use a data structure (e.g. an array list of array lists) to hold all products we calculated at previous iterations, this will help us identify local maximum and find global maximum ( gm = max(lm, gm) ). But....\\n\\nCan we optimise the solution? It looks like there\\'re a lot of products we have remembered! If we pause for a moment and ask ourselves, do we need to store all previous products? No! We only need the largest and smallest products from every iteration, any products between the largest and smallest will not produce a larger/smaller product. With this in mind, let\\'s change our calculations.\\n\\n```\\n1st iteration         2nd iteration     3rd iteration      4th iteration\\n[2]                   [-3]              [2]                [-4]\\n1 * 2 = 2 (s, l, m)   1 * -3 = -3 (l)   1 * 2 = 2 (l)      1 * -4 = -4\\n                      2 * -3 = -6 (s)   -3 * 2 = -6        2 * -4 = -8 (s)\\n                                        -6 * 2 = -12 (s)   -12 * -4 = 48 (l, m)\\n\\t\\t\\t\\t\\t\\t\\t                             \\ns = smallest\\nl = largest\\nm = maximum\\n```\\nYou will notice the space is constant O(1) (3 variables to maintain our progress). The rumtime is linear O(n), where n is the size of input array. To put everything in code,\\n\\n```\\nint MaxProduct(int[] nums)\\n{\\n    // Constraints:\\n    // 1 <= nums.length <= 2 * 10^4\\n    // -10 <= nums[i] <= 10\\n\\t// The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\n\\t\\t\\n\\tint s = nums[0]; // smallest\\n\\tint l = s; // largest\\n\\tint m = s; // max\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tint num = nums[i];\\n\\n\\t\\tint s1 = s * num;\\n\\t\\tint l1 = l * num;\\n\\n        // largest and smallest can swap places if we counter a negative number\\n\\t\\ts = Math.Min(Math.Min(s1, num), l1);\\n\\t\\tl = Math.Max(Math.Max(s1, num), l1);\\n\\n\\t\\tm = Math.Max(m, l);\\n\\t}\\n\\n\\treturn m;\\n}\\n```\\n\\nHope it helps!\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n1st iteration   2nd iteration  3rd iteration  4th iteration\\n[2]             [-3]           [2]            [-4]\\n1 * 2 = 2       1 * -3 = -3    1 * 2 = 2      1 * -4 = -4\\n                2 * -3 = -6    -3 * 2 = -6    2 * -4 = -8\\n                               -6 * 2 = -12   -6 *- 4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                  -12 * -4 = 48\\n```\n```\\n1st iteration         2nd iteration     3rd iteration    4th iteration\\n[2]                   [-3]              [2]              [-4]\\n1 * 2 = 2 (lm, gm)    1 * -3 = -3 (lm)  1 * 2 = 2 (lm)   1 * -4 = -4\\n                      2 * -3 = -6       -3 * 2 = -6      2 * -4 = -8\\n                                        -6 * 2 = -12     -6 * -4 = 24\\n\\t\\t\\t\\t\\t\\t\\t                             -12 * -4 = 48 (lm, gm)\\nlm = local maximum\\ngm = global maximum\\n```\n```\\n1st iteration         2nd iteration     3rd iteration      4th iteration\\n[2]                   [-3]              [2]                [-4]\\n1 * 2 = 2 (s, l, m)   1 * -3 = -3 (l)   1 * 2 = 2 (l)      1 * -4 = -4\\n                      2 * -3 = -6 (s)   -3 * 2 = -6        2 * -4 = -8 (s)\\n                                        -6 * 2 = -12 (s)   -12 * -4 = 48 (l, m)\\n\\t\\t\\t\\t\\t\\t\\t                             \\ns = smallest\\nl = largest\\nm = maximum\\n```\n```\\nint MaxProduct(int[] nums)\\n{\\n    // Constraints:\\n    // 1 <= nums.length <= 2 * 10^4\\n    // -10 <= nums[i] <= 10\\n\\t// The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\n\\t\\t\\n\\tint s = nums[0]; // smallest\\n\\tint l = s; // largest\\n\\tint m = s; // max\\n\\tfor (int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tint num = nums[i];\\n\\n\\t\\tint s1 = s * num;\\n\\t\\tint l1 = l * num;\\n\\n        // largest and smallest can swap places if we counter a negative number\\n\\t\\ts = Math.Min(Math.Min(s1, num), l1);\\n\\t\\tl = Math.Max(Math.Max(s1, num), l1);\\n\\n\\t\\tm = Math.Max(m, l);\\n\\t}\\n\\n\\treturn m;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48259,
                "title": "understanding-why-you-need-to-keep-track-of-just-the-min-and-max-previous-values",
                "content": "Most of other solutions here basically just state that you need to keep track of the min and max of the previous `i`, but it wasn't clear to me why that is the case. Here's how I figured it out for `nums = [-2, 1, 2, -3, 1, 3]`:\\n\\nFirst write out a matrix with all of the possible subarrays and their products like this:\\n\\n```text\\nExample of how to calculate a column:\\n-2   1   2  -3   1   3\\n----------------------\\n-2*1*2*-3 = 12\\n   1*2*-3 = -6\\n     2*-3 = -6\\n       -3 = -3\\n\\nFull matrix:\\n----------------------\\n-2   1   2  -3   1   3\\n----------------------\\n-2  -2  -4  12  12  36\\n     1   2  -6  -6  18\\n         2  -6  -6  18\\n            -3  -3  -9\\n                 1   3\\n                     3\\n```\\nFrom here, it is easy to convince yourself that the product of the max product subarray ending at column `i` is either:\\n* just `nums[i]` (eg, the second column subarray is just `[1]`)\\n* the product `nums[i] * min[i-1]` (eg, fourth column is `[-2,1,2,-3]`)\\n* the product `nums[i] * max[i-1]` (eg, third column is `[1,2]`)\\n\\nAnd from there, you have the recurrence relationship that the other solutions are using.",
                "solutionTags": [],
                "code": "```text\\nExample of how to calculate a column:\\n-2   1   2  -3   1   3\\n----------------------\\n-2*1*2*-3 = 12\\n   1*2*-3 = -6\\n     2*-3 = -6\\n       -3 = -3\\n\\nFull matrix:\\n----------------------\\n-2   1   2  -3   1   3\\n----------------------\\n-2  -2  -4  12  12  36\\n     1   2  -6  -6  18\\n         2  -6  -6  18\\n            -3  -3  -9\\n                 1   3\\n                     3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1609300,
                "title": "how-to-approach-product-sum-of-subarray-problems",
                "content": "**BRUTE FORCE SOLUTION**\\n\\nIf you want to compare all subarrays, and find your solution, you can use two for loops. However this approach results into` o(n^2)` complexity.\\n\\n**PREFIX SUM / PRODUCT CONCEPT**\\n\\nWhen you hear \"product / sum of subarray\" the first idea that can help you to build your solution, is a concept of `prefix sum`.\\nSo if the array is `1 2 3 4`,\\nPrefix sum would be: \\n`i = 0` prefixSum = `1`\\n`i = 1` prefixSum = `3`\\n`i = 2` prefixSum = `6`\\n`i = 3` prefixSum = `10`\\nOr if you are looking for a product of `1 2 3 4` instead of sum:\\n`i = 0` prefixProduct = `1`\\n`i = 1` prefixProduct = `2`\\n`i = 2` prefixProduct = `6`\\n`i = 3` prefixProduct = `24`\\n\\n**Sum of subarray**\\nUsing this concept you can easily calculate the sum/prefix of subarray[i, j]:\\n`Sum of subarray[i, j] = prefixSum[j] - prefixSum[i - 1]` <- O(1) instead of O(n) \\uD83D\\uDE01\\nFor example,  if the array is `1 2 3 4`, sum[2, 3] = 3 + 4 = prefixSum[3] - prefixSum[1] = 10 - 3 = 7\\n\\n**Product of subarray**\\nOr `Product of subarray[i, j] = prefixProduct[j] / prefixProduct[i - 1]` \\nFor example,  if the array is `1 2 3 4`, product[2, 3] = 3 * 4 = prefixProduct[3] / prefixProduct[1] = 24 /  2 = 12\\n\\n**Array or variable?**\\nYou can keep prefix array for each index in an `array`, or keep min/max/curResult in a `single variable`.\\n\\n\\n**BUILDING THE SOLUTION**\\n\\n**Positive Integers**\\nWe need to find the maxProduct of subarray. If the array consisted only of positive integers, the maximum would be just the product of all numbers.\\n\\n**What if we encounter 0?**\\nIf we find 0, the array is essentially divided, cause 0 makes the product of each subarray including 0 equals to 0. So we need to start all over again.\\n\\n**What if we encounter a negative number?**\\nYes my friend that\\'s the danger \\uD83D\\uDE08!  Essentially if we got a negative number, all our multiplication result turns negative and turns from max to min. Here is where the concept of prefixProduct could help. We would keep the `first  negative product` that we encountered. If we result in negative product ever again  in this sequance, to find the maximum, we just `divide` it to the `first negative product`.\\n\\n**CODE**\\n\\n```\\nvar maxProduct = function(nums) {\\n    if (nums.length == 1) {\\n        return nums[0];\\n    }\\n    // 1 is a number \"neutral\" to multiplication\\n    let firstNegative = 1; // No negatives yet\\n    let curPrefix = 1; // Empty yet\\n    let maxProduct = 0; // In case we found 0\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        curPrefix *= nums[i];\\n        maxProduct = Math.max(curPrefix, maxProduct);\\n        \\n        if (curPrefix < 0) { // divide to the first negative\\n            maxProduct = Math.max(curPrefix / firstNegative, maxProduct);\\n            // set the first negative product, if it wasn\\'t set yet\\n            firstNegative = firstNegative == 1? curPrefix : firstNegative;\\n            \\n        } else if (curPrefix == 0) { // start all over again\\n            curPrefix = 1;\\n            firstNegative = 1;\\n        }\\n    }\\n    return maxProduct;\\n};\\n```\\n\\n**What problems I can solve using prefix array?**\\nCheck out product without curent index - https://leetcode.com/problems/product-of-array-except-self/\\nMaximum subarray - https://leetcode.com/problems/maximum-subarray/\\nMaximum absolute sum - https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/ \\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxProduct = function(nums) {\\n    if (nums.length == 1) {\\n        return nums[0];\\n    }\\n    // 1 is a number \"neutral\" to multiplication\\n    let firstNegative = 1; // No negatives yet\\n    let curPrefix = 1; // Empty yet\\n    let maxProduct = 0; // In case we found 0\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        curPrefix *= nums[i];\\n        maxProduct = Math.max(curPrefix, maxProduct);\\n        \\n        if (curPrefix < 0) { // divide to the first negative\\n            maxProduct = Math.max(curPrefix / firstNegative, maxProduct);\\n            // set the first negative product, if it wasn\\'t set yet\\n            firstNegative = firstNegative == 1? curPrefix : firstNegative;\\n            \\n        } else if (curPrefix == 0) { // start all over again\\n            curPrefix = 1;\\n            firstNegative = 1;\\n        }\\n    }\\n    return maxProduct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841796,
                "title": "python-simple-solution-explained-video-code-91-faster",
                "content": "[](https://www.youtube.com/watch?v=IOMjN6r7ju8)\\nhttps://www.youtube.com/watch?v=IOMjN6r7ju8\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        B = nums[::-1]\\n        \\n        for x in range(1,len(nums)):\\n            if nums[x - 1] != 0:\\n                nums[x] *= nums[x - 1]\\n                \\n            if B[x - 1] != 0:\\n                B[x] *= B[x - 1]\\n                \\n        return max(nums + B)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        B = nums[::-1]\\n        \\n        for x in range(1,len(nums)):\\n            if nums[x - 1] != 0:\\n                nums[x] *= nums[x - 1]\\n                \\n            if B[x - 1] != 0:\\n                B[x] *= B[x - 1]\\n                \\n        return max(nums + B)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791257,
                "title": "dynamic-programming-and-constant-space-solution-easily-explained-with-video-must-watch",
                "content": "Link to Video :- https://youtu.be/4kbWVhMAx6U\\n\\n\\n\\n\\n\\n\\n**Code In c++:-\\nUsing DP O(N) Time and O(N) Space:-**\\n\"\"\"\\n\\n\\n    int maxProduct(vector< int>& nums) {\\n        vector<int> max_dp(nums.size());\\n        vector<int> min_dp(nums.size());\\n      \\n        max_dp[0]=nums[0];\\n        min_dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<0){\\n                max_dp[i]=max(nums[i],nums[i] * min_dp[i-1]);\\n                min_dp[i]=min(nums[i],nums[i]*  max_dp[i-1]);\\n            }\\n            else{\\n                max_dp[i]= max(nums[i],nums[i] * max_dp[i-1]);\\n                min_dp[i]= min(nums[i],nums[i] * min_dp[i-1]);\\n            }\\n        }\\n       \\n        return *max_element(max_dp.begin(),max_dp.end());}\\n\\n\"\"\"\\n\\n**Using Constant space and linear time optimized approach:-**\\n\\n\"\"\"\\n\\n int maxProduct(vector< int>& nums) {\\n int max_curr=nums[0] , min_curr=nums[0] , res = nums[0];\\n        \\n        if(nums.size()==0){\\n           return -1;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            int c1 = max_curr * nums[i];\\n            int c2 = min_curr * nums[i];\\n            max_curr = max(nums[i],max(c2,c1));\\n            min_curr = min(nums[i],min(c1,c2));\\n            res =max(max_curr,res);\\n            \\n        }\\n        return res;\\n    }\\n\\n\"\"\"\\n**DO UPVOTE IF IT HELPED YOU !! :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Link to Video :- https://youtu.be/4kbWVhMAx6U\\n\\n\\n\\n\\n\\n\\n**Code In c++:-\\nUsing DP O(N) Time and O(N) Space:-**\\n\"\"\"\\n\\n\\n    int maxProduct(vector< int>& nums) {\\n        vector<int> max_dp(nums.size());\\n        vector<int> min_dp(nums.size());\\n      \\n        max_dp[0]=nums[0];\\n        min_dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<0){\\n                max_dp[i]=max(nums[i],nums[i] * min_dp[i-1]);\\n                min_dp[i]=min(nums[i],nums[i]*  max_dp[i-1]);\\n            }\\n            else{\\n                max_dp[i]= max(nums[i],nums[i] * max_dp[i-1]);\\n                min_dp[i]= min(nums[i],nums[i] * min_dp[i-1]);\\n            }\\n        }\\n       \\n        return *max_element(max_dp.begin(),max_dp.end());}\\n\\n\"\"\"\\n\\n**Using Constant space and linear time optimized approach:-**\\n\\n\"\"\"\\n\\n int maxProduct(vector< int>& nums) {\\n int max_curr=nums[0] , min_curr=nums[0] , res = nums[0];\\n        \\n        if(nums.size()==0){\\n           return -1;\\n        }\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            \\n            int c1 = max_curr * nums[i];\\n            int c2 = min_curr * nums[i];\\n            max_curr = max(nums[i],max(c2,c1));\\n            min_curr = min(nums[i],min(c1,c2));\\n            res =max(max_curr,res);\\n            \\n        }\\n        return res;\\n    }\\n\\n\"\"\"\\n**DO UPVOTE IF IT HELPED YOU !! :)**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 201223,
                "title": "python-code",
                "content": "\\u52A8\\u6001\\u89C4\\u5212\\u7B97\\u6CD5\\u7684\\u5178\\u578B\\u56DB\\u4E2A\\u6B65\\u9AA4\\u5982\\u4E0B\\uFF1A\\n1. \\u5148\\u4ECE\\u5B9E\\u9645\\u4F8B\\u5B50\\u4E2D\\u89C2\\u5BDFnums\\u7684\\u6700\\u5927\\u5B50\\u5E8F\\u5217\\u7684\\u7279\\u5F81\\u3002\\u4E3E\\u4F8B\\u5B50\\uFF1Anums[0], nums[0:2], nums[0:3] ......\\uFF08\\u5982\\u4E0B\\u56FE\\uFF09\\n2. \\u7136\\u540E\\u53EF\\u5F52\\u7EB3\\u51FA\\u4E00\\u4E2A\\u9012\\u63A8\\u8868\\u8FBE\\u5F0F\\u3002\\uFF08\\u5982\\u4E0B\\u56FE\\uFF09\\n3. \\u6700\\u540E\\u6C42\\u89E3\\u3002\\u4E66\\u5199\\u4EE3\\u7801\\u5982\\u4E0B\\u3002\\n4. \\u6784\\u9020\\u89E3\\u3002\\u8FD9\\u9053\\u9898\\u6CA1\\u8981\\u6C42\\u8F93\\u51FA\\u5B50\\u5E8F\\u5217\\uFF0C\\u53EF\\u7701\\u53BB\\u3002\\n\\n\\u518D\\u603B\\u7ED3\\u4E0B\\uFF1A\\n1. \\u52A8\\u6001\\u89C4\\u5212\\u7B97\\u6CD5\\u7684\\u6838\\u5FC3\\u5C31\\u662F\\u9012\\u63A8\\u5173\\u7CFB\\u7684\\u6784\\u9020\\u4E86\\u3002\\n2. \\u66F4\\u52A0\\u7B80\\u5316\\u7684\\u65B9\\u6CD5\\u662F\\u7528`O(1) space`\\u65B9\\u6CD5\\u6765\\u505A\\u3002\\u4F46\\u4E24\\u4E2A\\u6570\\u7EC4\\u7B26\\u5408DP\\u7B97\\u6CD5\\u7684\\u601D\\u8003\\u8FC7\\u7A0B\\uFF0C\\u66F4\\u5BB9\\u6613\\u7406\\u89E3\\uFF0C\\u4ECE`O(n) space`\\u5230`O(1) space`\\u7684\\u8F6C\\u5316\\u4E5F\\u662F\\u7B80\\u5355\\u7684\\u3002\\n3. \\u96BE\\u60F3\\u5230\\u7684\\u5C31\\u662F\\u9700\\u8981\\u628A\\u6BCF\\u6B65\\u7684\\u6700\\u5C0F\\u503C\\u8BB0\\u5F55\\uFF0C\\u4F46\\u901A\\u8FC7\\u5F52\\u7EB3\\u603B\\u7ED3\\u4E5F\\u80FD\\u770B\\u51FA\\u6765\\u3002\\n```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r = nums[0]\\n        Max = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5927\\u4E58\\u79EF\\n        Min = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5C0F\\u4E58\\u79EF\\n        \\n        for i, num in enumerate(nums[1:]): ## i \\u5B9E\\u9645\\u7684\\u4F4D\\u7F6E\\u662Fnum\\u5728nums\\u6570\\u7EC4\\u4E2D\\u4E0B\\u6807\\u7684\\u4E0A\\u4E00\\u4E2A\\u5143\\u7D20\\u4E0B\\u6807\\u3002\\n            if num >= 0:\\n                Max.append(max(num, Max[i] * num))\\n                Min.append(min(num, Min[i] * num))               \\n            else:\\n                Max.append(max(num, Min[i] * num))\\n                Min.append(min(num, Max[i] * num))        \\n        return max(Max)\\n```\\n\\u7279\\u5F81\\u89C2\\u5BDF\\n![image](https://assets.leetcode.com/users/sucsliu34/image_1543918598.png)\\n\\u9012\\u63A8\\u516C\\u5F0F\\n![image](https://assets.leetcode.com/users/sucsliu34/image_1543918625.png)\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        r = nums[0]\\n        Max = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5927\\u4E58\\u79EF\\n        Min = [r] ##\\u8BB0\\u5F55\\u6BCF\\u4E2A\\u5143\\u7D20\\u4F5C\\u4E3A\\u6700\\u540E\\u4E00\\u4E2A\\u5B50\\u5E8F\\u5217\\u5143\\u7D20\\u6240\\u80FD\\u6784\\u6210\\u7684\\u6700\\u5C0F\\u4E58\\u79EF\\n        \\n        for i, num in enumerate(nums[1:]): ## i \\u5B9E\\u9645\\u7684\\u4F4D\\u7F6E\\u662Fnum\\u5728nums\\u6570\\u7EC4\\u4E2D\\u4E0B\\u6807\\u7684\\u4E0A\\u4E00\\u4E2A\\u5143\\u7D20\\u4E0B\\u6807\\u3002\\n            if num >= 0:\\n                Max.append(max(num, Max[i] * num))\\n                Min.append(min(num, Min[i] * num))               \\n            else:\\n                Max.append(max(num, Min[i] * num))\\n                Min.append(min(num, Max[i] * num))        \\n        return max(Max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890564,
                "title": "python-with-detailed-explanation-faster-than-96-52",
                "content": "#### The trick is \\n1.  Unlike maximum sum, for max product the current negetive minimum value could be max in future when multiplied by another -ve value --> so we need to keep track of minimum_value too\\n2. We need to keep track of maximum value --> obviously \\n3. We need to keep track of over_all maximum value \\n\\n\\nstep 1--> cumulative_min_product = minimum of ( cumulative_max_product*cur_value, cumulative_min_product*cur_value, cur_value) \\n            step 2 --> cumulative_max_product = maximum of ( cumulative_max_product*cur_value, cumulative_min_product*cur_value, cur_value)\\n            step 3 - As the maximum subbaray cloud happen in the middel, we need to keep track of it \\n                --> max_so_far = max(cumulative_max_prod, max_so_far)\\n                --> Pit fall : save cumlative_min_product before updating it for use at step 2\\n                --> return max_so_far\\n```\\n    def maxProduct(self, nums):\\n        cumltv_max = cumltv_min= max_sofar = nums[0]\\n        for i, num in enumerate(nums[1:], start=1):\\n            # save the last cumulative min before updating it for later calculating cumulative max \\n            prv_cumltv_min = cumltv_min  \\n            # compare these and take the minimum --> cur_value, last cumlative min x cur_value and last cum max x cuv_value\\n            cumltv_min = min( cumltv_min*num, cumltv_max*num, num)\\n            cumltv_max = max( prv_cumltv_min*num, cumltv_max*num, num) \\n            max_sofar = max(cumltv_max, max_sofar)\\n        return max_sofar\\n```\\n\\n*        2nd idea Using DP table: creating a table  O(n) space O(n) time\\n            : Keep track of the maxium and minimum cumulative at each index \\n            step 1 : cumltv_min[i] = min( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i])\\n            step 2 : cumltv_max[i] = max( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i])\\n            step 3 retun max(cumltv_max)\\n\\t\\t\\t\\n```\\n    def maxProduct(self, nums):\\n        cumltv_min = [0]*len(nums)\\n        cumltv_max = [0]*len(nums)\\n        cumltv_min[0] = cumltv_max[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            # compare the minimum of min(cur_val*prev_min, cur_val) and min(cur_val*prev_max, cur_val)\\n            cumltv_min[i] = min( cumltv_min[i-1]*nums[i] , cumltv_max[i-1]*nums[i], nums[i])\\n            # compare the maximum of max(cur_val*prev_min, cur_val) and max(cur_val*prev_max, cur_val)\\n            cumltv_max[i] = max ( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i] )\\n        return max(cumltv_max)\\n```\\n#### If this solution/explanation helps you, don\\'t forget to upvote as appreciation",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProduct(self, nums):\\n        cumltv_max = cumltv_min= max_sofar = nums[0]\\n        for i, num in enumerate(nums[1:], start=1):\\n            # save the last cumulative min before updating it for later calculating cumulative max \\n            prv_cumltv_min = cumltv_min  \\n            # compare these and take the minimum --> cur_value, last cumlative min x cur_value and last cum max x cuv_value\\n            cumltv_min = min( cumltv_min*num, cumltv_max*num, num)\\n            cumltv_max = max( prv_cumltv_min*num, cumltv_max*num, num) \\n            max_sofar = max(cumltv_max, max_sofar)\\n        return max_sofar\\n```\n```\\n    def maxProduct(self, nums):\\n        cumltv_min = [0]*len(nums)\\n        cumltv_max = [0]*len(nums)\\n        cumltv_min[0] = cumltv_max[0] = nums[0]\\n        for i in range(1,len(nums)):\\n            # compare the minimum of min(cur_val*prev_min, cur_val) and min(cur_val*prev_max, cur_val)\\n            cumltv_min[i] = min( cumltv_min[i-1]*nums[i] , cumltv_max[i-1]*nums[i], nums[i])\\n            # compare the maximum of max(cur_val*prev_min, cur_val) and max(cur_val*prev_max, cur_val)\\n            cumltv_max[i] = max ( cumltv_min[i-1]*nums[i], cumltv_max[i-1]*nums[i], nums[i] )\\n        return max(cumltv_max)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 699929,
                "title": "comparison-with-53-maximum-subarray",
                "content": "This problem looks similar with [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), except we want max product instead of max sum. \\n\\nFor max sum:\\n```C++\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum = max(nums[i], currSum * nums[i]);\\n\\t\\t\\t\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```\\nThe max-sum of subarrays ended at `nums[i]` is either:\\n- `nums[i]` + the max-sum of subarrays ended at `nums[i-1]`, or\\n- `nums[i]`, if the max-sum of subarrays ended at `nums[i-1]` is negative.\\n\\nIn the code above, we use `currSum` to keep track of max-sum ended at `nums[i-1]` and make our decision.\\n\\nMax-product is more complicated: the product of two negative values is positive. But we still have: The max-product of subarrays ended at `nums[i]` is either:\\n- case 1: `nums[i]` * the max-product of subarrays ended at `nums[i-1]`, or\\n- case 2: `nums[i]` * the min-product of subarrays ended at `nums[i-1]`, or\\n- case 3: `nums[i]` itself.\\n\\nCase 1 happens when `nums[i]` and max-product ended at `nums[i-1]` are positive; Case 2 happens when `nums[i]` and min-product ended at `nums[i-1]` are negative; Case 3 happens when `nums[i]` is positve, but the max-product of subarrays ended at `nums[i-1]` is negative, or when `nums[i]` is negative, and the min-product of subarrays ended at `nums[i-1]` is positive.\\n\\nWe can use two variables `maxProdAtPrev` and `minProdAtPrev` to keep track of the above information.\\n\\nSo we easily have the following code:\\n```C++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 1;\\n        \\n        int maxProd = nums[0];\\n        int maxProdAtPrev = maxProd, minProdAtPrev = maxProd;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t    if (nums[i] < 0) swap(maxProdAtPrev, minProdAtPrev);\\n\\t\\t\\tmaxProdAtPrev = max(nums[i], maxProdAtPrev * nums[i]);\\n\\t\\t\\tminProdAtPrev = min(num[i], minProdAtPrev * nums[i]);\\n\\t\\t\\t\\n            maxProd = max(maxProd, maxProdAtPrev);\\n        }\\n        return maxProd;\\n    }\\n};\\n```\\nThe logic in each iteration is almost the same as Maximum Subarray.\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            currSum = max(nums[i], currSum * nums[i]);\\n\\t\\t\\t\\n            maxSum = max(maxSum, currSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 1;\\n        \\n        int maxProd = nums[0];\\n        int maxProdAtPrev = maxProd, minProdAtPrev = maxProd;\\n        for (int i = 1; i < nums.size(); i++) {\\n\\t\\t    if (nums[i] < 0) swap(maxProdAtPrev, minProdAtPrev);\\n\\t\\t\\tmaxProdAtPrev = max(nums[i], maxProdAtPrev * nums[i]);\\n\\t\\t\\tminProdAtPrev = min(num[i], minProdAtPrev * nums[i]);\\n\\t\\t\\t\\n            maxProd = max(maxProd, maxProdAtPrev);\\n        }\\n        return maxProd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941882,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProduct(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        var ans = nums[0]\\n        var maxSoFar = nums[0]\\n        var minSoFar = nums[0]\\n\\n        for i in 1..<nums.count {\\n            let curr = nums[i]\\n\\n            let tmpMax = max(curr, maxSoFar * curr, minSoFar * curr)\\n            minSoFar = min(curr, maxSoFar * curr, minSoFar * curr)\\n            maxSoFar = tmpMax\\n\\n            ans = max(ans, maxSoFar)\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func maxProduct(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n\\n        var ans = nums[0]\\n        var maxSoFar = nums[0]\\n        var minSoFar = nums[0]\\n\\n        for i in 1..<nums.count {\\n            let curr = nums[i]\\n\\n            let tmpMax = max(curr, maxSoFar * curr, minSoFar * curr)\\n            minSoFar = min(curr, maxSoFar * curr, minSoFar * curr)\\n            maxSoFar = tmpMax\\n\\n            ans = max(ans, maxSoFar)\\n        }\\n\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232048,
                "title": "o-n-easy-explained",
                "content": "// basic idea is to keep track of current maximum  , current minimum and global maximum\\n//current minimum may result in maximum value too if both the number multiplied are negative \\n\\n\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\t\\t\\tint max = nums[0] , curMax = nums[0] ,curMin = nums[0] , temp,i;\\n\\t\\t\\t\\t\\tfor(i=1;i<nums.length;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp =curMax;\\n\\t\\t\\t\\t\\t\\tcurMax = Math.max(nums[i] , Math.max(nums[i]*curMax , nums[i]*curMin));\\n\\t\\t\\t\\t\\t\\tcurMin = Math.min(nums[i] , Math.min(nums[i]*temp , nums[i]*curMin));\\n\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max , curMax);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn max;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n// this is the extension to kadens algo if you find any dificulty then ask in comment ....thankyou\\n//if you find this helpful please upvote too",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\t\\t\\tint max = nums[0] , curMax = nums[0] ,curMin = nums[0] , temp,i;\\n\\t\\t\\t\\t\\tfor(i=1;i<nums.length;i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ttemp =curMax;\\n\\t\\t\\t\\t\\t\\tcurMax = Math.max(nums[i] , Math.max(nums[i]*curMax , nums[i]*curMin));\\n\\t\\t\\t\\t\\t\\tcurMin = Math.min(nums[i] , Math.min(nums[i]*temp , nums[i]*curMin));\\n\\n\\t\\t\\t\\t\\t\\tmax = Math.max(max , curMax);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 48400,
                "title": "python-solutions-with-different-space-costs-o-2-n-o-1",
                "content": "\\n    # O(2*n) space\\n    def maxProduct1(self, nums):\\n        if not nums:\\n            return \\n        locMin = [0] * len(nums)\\n        locMax = [0] * len(nums)\\n        locMin[0] = locMax[0] = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                locMax[i] = max(locMin[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMax[i-1]*nums[i], nums[i])\\n            else:\\n                locMax[i] = max(locMax[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMin[i-1]*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax[i])\\n        return gloMax\\n    \\n    # O(1) space    \\n    def maxProduct2(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                tmp = locMax\\n                locMax = max(locMin*nums[i], nums[i])\\n                locMin = min(tmp*nums[i], nums[i])\\n            else:\\n                locMax = max(locMax*nums[i], nums[i])\\n                locMin = min(locMin*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n     \\n    # O(1) space    \\n    def maxProduct(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            tmp = locMin\\n            locMin = min(locMin*nums[i], nums[i], locMax*nums[i])\\n            locMax = max(tmp*nums[i], nums[i], locMax*nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n\\t\\t\\n\\tdef maxProduct(self, nums):\\n        locMin = locMax = glo = nums[0]\\n        for num in nums[1:]:\\n            locMin, locMax= min(locMin*num, num, locMax*num), max(locMin*num, num, locMax*num)\\n            glo = max(glo, locMax)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    # O(2*n) space\\n    def maxProduct1(self, nums):\\n        if not nums:\\n            return \\n        locMin = [0] * len(nums)\\n        locMax = [0] * len(nums)\\n        locMin[0] = locMax[0] = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                locMax[i] = max(locMin[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMax[i-1]*nums[i], nums[i])\\n            else:\\n                locMax[i] = max(locMax[i-1]*nums[i], nums[i])\\n                locMin[i] = min(locMin[i-1]*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax[i])\\n        return gloMax\\n    \\n    # O(1) space    \\n    def maxProduct2(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            if nums[i] < 0:\\n                tmp = locMax\\n                locMax = max(locMin*nums[i], nums[i])\\n                locMin = min(tmp*nums[i], nums[i])\\n            else:\\n                locMax = max(locMax*nums[i], nums[i])\\n                locMin = min(locMin*nums[i], nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n     \\n    # O(1) space    \\n    def maxProduct(self, nums):\\n        if not nums:\\n            return \\n        locMin = locMax = gloMax = nums[0]\\n        for i in xrange(1, len(nums)):\\n            tmp = locMin\\n            locMin = min(locMin*nums[i], nums[i], locMax*nums[i])\\n            locMax = max(tmp*nums[i], nums[i], locMax*nums[i])\\n            gloMax = max(gloMax, locMax)\\n        return gloMax\\n\\t\\t\\n\\tdef maxProduct(self, nums):\\n        locMin = locMax = glo = nums[0]\\n        for num in nums[1:]:\\n            locMin, locMax= min(locMin*num, num, locMax*num), max(locMin*num, num, locMax*num)\\n            glo = max(glo, locMax)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 3121702,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n\\n        int max = Integer.MIN_VALUE, temp = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        temp = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n\\n        int max = Integer.MIN_VALUE, temp = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        temp = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            temp *= nums[i];\\n            max = Math.max(temp, max);\\n            if (temp == 0)\\n                temp = 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540883,
                "title": "simple-solution-by-breaking-and-analyzing-the-problem",
                "content": "So, the problem asks us to find the maximum subarray product. The only challenge here is that the array contains negatives!!!\\n\\nIf the array doesn\\'t contain any negatives we can simply multiply all the elements and we are done. However, when there\\'re negatives, the problem is split into two cases:\\n\\n* case a) the number of negatives is even\\n* case b) the number of negatives is odd\\n\\nin case a) we can also simply multiply all the elements and we will have a positive number, so **done**.\\n\\nin case b) we can say, that there\\'s one negative that converts our answer from positive to negative, for example: \\n\\n[2, **-3**, **-2**, 4, **-4**, **-5**, 2, 7, **-1**, 12]\\n\\nhere we have 5 negatives, since they are odd, we have to remove one, and since we are dealing with subarrays, it\\'s illogical to delete one that is bounded between two negatives, because in this case we are losing all the numbers after it (or before it)\\n\\nso the only candidate negatives that are causing the problem are the first one (**-3**), and the last one (**-1**). So we are now left with two options, either we exelude **-3** or we **-1** and this will lead us into 4 different subarrays:\\n\\npossibility 1) [**0**:  **first negative number index**)\\npossibility 2) [**0** :  **second negative number index**)\\npossibility 3) [**first negative number index + 1** : **arr.length**)\\npossibility 4) [**second negative number index + 1** : **arr.length**)\\n\\nBy this we covered all the possible cases of excluding the first negative or the last negative!\\n\\nBut this is already too much, and coding it in a literal way would be ugly, the trick here is that possibility **1** and **2** can be done in a single loop from left to right and while keep taking the maximum and possibility **3** and **4** can be done the same way but from right to left! Actually by this we also cover the case of even number of negatives :)!\\n\\nCode: Java\\n```\\n    public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n       \\n        int max = Integer.MIN_VALUE;\\n        \\n        int prod = 1;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        prod = 1;\\n        \\n        for(int i = nums.length -1 ; i>= 0 ; i--){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\nI didn\\'t mention the 0, because whenever we encounter the 0, we can imagine that we enountered a new different array.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0){\\n            return 0;\\n        }\\n        \\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n       \\n        int max = Integer.MIN_VALUE;\\n        \\n        int prod = 1;\\n        \\n        int result = 0;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        prod = 1;\\n        \\n        for(int i = nums.length -1 ; i>= 0 ; i--){\\n            prod *= nums[i];\\n            result = Math.max(result, prod);\\n            if(prod == 0){\\n                prod = 1;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384555,
                "title": "python-solution-dp",
                "content": "Similar to [Problem 53 Maximum Subarray](https://leetcode.com/problems/maximum-subarray/), global maximum is the larger one between a local maximum and the previous global maximum. And attention should also be paid to the sign of local maximum. Here, `max_so_far` and `min_so_far` are introduced to track both maximum and minimum at certain index. Specifically, `max_so_far` at index `i` is the maximum among these three: `min_so_far*nums[i]`, `max_so_far*nums[i]` and `nums[i]` while `min_so_far` is the corresponding minimum. Finally, the global maximum `max_global` is the larger one between`max_so_far` and `max_global`.\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        min_so_far, max_so_far, max_global = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            max_so_far, min_so_far = max(min_so_far*nums[i], max_so_far*nums[i], nums[i]), min(min_so_far*nums[i], max_so_far*nums[i], nums[i])\\n            max_global = max(max_global, max_so_far)\\n        \\n        return max_global\\n```\\n\\n**Notice**:\\n* The `max_so_far` and `min_so_far` should be updated simoutaneously to avoid error.\\n* Use two varibles (e.g. `temp1`,`temp2`) to take the updated `max_so_far` and `min_so_far` if the Python syntax `A, B = C, D` is not used.",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        min_so_far, max_so_far, max_global = nums[0], nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            max_so_far, min_so_far = max(min_so_far*nums[i], max_so_far*nums[i], nums[i]), min(min_so_far*nums[i], max_so_far*nums[i], nums[i])\\n            max_global = max(max_global, max_so_far)\\n        \\n        return max_global\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48358,
                "title": "java-2-ms-solution-using-sliding-window-with-explanation",
                "content": "The maximum product subarray would be the whole array unless two factors:\\n\\n 1. any `0` numbers that turn the product to `0`\\n 1. the total number of negative numbers that turn result to negative in case this number is odd\\n\\nIf we take these factors into account we can create simple sliding window solution that runs in `O(n)` and uses the least number of mathematical operations. \\n\\nAll possible products are hidden in ranges between `0` numbers - so we need to expand window only in these ranges. As soon as we meet `0` we just drop current product and lower pointer and proceed until non `0` number is met that means the start of new window. The only additional complication is factor 2): as soon as we reached the end of window (whether this is `0` or end of array) we need to check negativeness of total product. If it's negative - we need to increase lower pointer `lo` (and divide current product on `nums[lo]`) until the product becomes positive that can be only when lower pointer passes negative number.\\n\\nSo the whole algorithm:\\n\\n- initially `hi` and `lo` variables point at `0`\\n- we expand `hi` until `nums[hi] == 0` or the end of array is met. While expanding we recalculate current product and maximum product.\\n- if `0` is met and current product is **negative** - that means that current range contains odd number of negative numbers and we need to decrease range from left (and recalculate the product) until product becomes positive\\n- if `0` is met and current product is **positive** - just drop current product and lower pointer and start new window\\n- after the loop we need to check negativeness of the product again\\n\\n__________\\n    public int maxProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int lo = 0, hi = 0, N = nums.length;\\n        long max = Integer.MIN_VALUE, curr = 1;\\n\\n        while (hi < N) {\\n            if (nums[hi] == 0 && curr < 0 && lo < hi - 1) {\\n                curr /= nums[lo++];\\n                max = Math.max(curr, max);\\n            }\\n            else if (nums[hi] == 0) {\\n                max = Math.max(0, max);\\n                lo = ++hi;\\n                curr = 1;\\n            } else {\\n                curr *= nums[hi++];\\n                max = Math.max(curr, max);\\n            }\\n        }\\n        for (; curr < 0 && lo < N - 1; lo++) {\\n            curr /= nums[lo];\\n            max = Math.max(curr, max);\\n        }\\n\\n        return (int)max;\\n        }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "The maximum product subarray would be the whole array unless two factors:\\n\\n 1. any `0` numbers that turn the product to `0`\\n 1. the total number of negative numbers that turn result to negative in case this number is odd\\n\\nIf we take these factors into account we can create simple sliding window solution that runs in `O(n)` and uses the least number of mathematical operations. \\n\\nAll possible products are hidden in ranges between `0` numbers - so we need to expand window only in these ranges. As soon as we meet `0` we just drop current product and lower pointer and proceed until non `0` number is met that means the start of new window. The only additional complication is factor 2): as soon as we reached the end of window (whether this is `0` or end of array) we need to check negativeness of total product. If it's negative - we need to increase lower pointer `lo` (and divide current product on `nums[lo]`) until the product becomes positive that can be only when lower pointer passes negative number.\\n\\nSo the whole algorithm:\\n\\n- initially `hi` and `lo` variables point at `0`\\n- we expand `hi` until `nums[hi] == 0` or the end of array is met. While expanding we recalculate current product and maximum product.\\n- if `0` is met and current product is **negative** - that means that current range contains odd number of negative numbers and we need to decrease range from left (and recalculate the product) until product becomes positive\\n- if `0` is met and current product is **positive** - just drop current product and lower pointer and start new window\\n- after the loop we need to check negativeness of the product again\\n\\n__________\\n    public int maxProduct(int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int lo = 0, hi = 0, N = nums.length;\\n        long max = Integer.MIN_VALUE, curr = 1;\\n\\n        while (hi < N) {\\n            if (nums[hi] == 0 && curr < 0 && lo < hi - 1) {\\n                curr /= nums[lo++];\\n                max = Math.max(curr, max);\\n            }\\n            else if (nums[hi] == 0) {\\n                max = Math.max(0, max);\\n                lo = ++hi;\\n                curr = 1;\\n            } else {\\n                curr *= nums[hi++];\\n                max = Math.max(curr, max);\\n            }\\n        }\\n        for (; curr < 0 && lo < N - 1; lo++) {\\n            curr /= nums[lo];\\n            max = Math.max(curr, max);\\n        }\\n\\n        return (int)max;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1608768,
                "title": "c-super-simple-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0)\\n                swap(min_save, max_save);\\n            min_save = min(nums[i], min_save*nums[i]);\\n            max_save = max(nums[i], max_save*nums[i]);\\n            max_pro = max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0)\\n                swap(min_save, max_save);\\n            min_save = min(nums[i], min_save*nums[i]);\\n            max_save = max(nums[i], max_save*nums[i]);\\n            max_pro = max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481299,
                "title": "java-easy-to-understand-0ms-100-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = Integer.MIN_VALUE,temp=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        temp=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        return max;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        \\n        int max = Integer.MIN_VALUE,temp=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        temp=1;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            temp *= nums[i];\\n            max = Math.max(temp,max);\\n            if(temp == 0 )\\n                temp=1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450150,
                "title": "simple-0ms-c-solution-kadane-s-algorithm-perfect-explaination",
                "content": "This question is the advance form of Maximum sum subarray(https://leetcode.com/problems/maximum-subarray/).\\n\\nIf you haven\\'t done this already then go give it a try\\n\\nIn this we take two variable maxVal and minVal which repersent then maximum possible value at any index and vice-versa for minVal intially both are equal to first value of given array and one more variable Product which has maximum Product intially is also equal to first value of array. \\n\\nThis is the description of solution now have a look on solution\\n```\\nint maxProduct(vector<int>& nums) {\\n       if(nums.size()==1) return nums[0];\\n       int MinVal=nums[0],MaxVal=nums[0];\\n       int Product=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           int ref=MaxVal;\\n           MaxVal=max(nums[i],max(nums[i]*MaxVal,nums[i]*MinVal));\\n           MinVal=min(nums[i],min(ref*nums[i],nums[i]*MinVal));\\n           Product=max(MaxVal,Product);\\n       }\\n        return Product;\\n    }\\n\\t\\n\\t```\\n\\t**I think this solution deserve a upvote. Thankyou!!**",
                "solutionTags": [],
                "code": "```\\nint maxProduct(vector<int>& nums) {\\n       if(nums.size()==1) return nums[0];\\n       int MinVal=nums[0],MaxVal=nums[0];\\n       int Product=nums[0];\\n       for(int i=1;i<nums.size();i++){\\n           int ref=MaxVal;\\n           MaxVal=max(nums[i],max(nums[i]*MaxVal,nums[i]*MinVal));\\n           MinVal=min(nums[i],min(ref*nums[i],nums[i]*MinVal));\\n           Product=max(MaxVal,Product);\\n       }\\n        return Product;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074041,
                "title": "c-simply-explained-with-example-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are taking 3 variables as maxi , mini and res. Which means maxi stores the maximum product till now, mini stores minimum product till now and res stores our answer in it.\\n\\nSo when we iterate over the array we are checking first for maximum product as it was asked in the question, then we are also checking for minimum product because let say we have negative values in our array. lets understand this with an example\\nmini = -10 right now and maxi = 4\\nand next element in the array is -2\\nafter this maxi = -10 * -2 = 20\\nso to get this we are maintaing minimum product also.\\n\\nThen in res we are storing the maximum value among the 3 variables which we used and return it.\\n\\nHope You get this.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int maxi =1 , mini=1, res = INT_MIN;\\n\\n        for(int i =0;i<n;i++){\\n            int temp = maxi;\\n    // storing maxi in temp as it\\'s value will change in next line \\n            maxi = max({nums[i], maxi*nums[i], mini*nums[i]});\\n            mini = min({nums[i], temp*nums[i], mini*nums[i]});\\n\\n            res = max({maxi,mini,res});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int maxi =1 , mini=1, res = INT_MIN;\\n\\n        for(int i =0;i<n;i++){\\n            int temp = maxi;\\n    // storing maxi in temp as it\\'s value will change in next line \\n            maxi = max({nums[i], maxi*nums[i], mini*nums[i]});\\n            mini = min({nums[i], temp*nums[i], mini*nums[i]});\\n\\n            res = max({maxi,mini,res});\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841349,
                "title": "maximum-product-subarray-python-dp-explained",
                "content": "Approach:\\nCase 1: If the array  has only positive elements ( 0 not included ) , product of all the elements will be  returned as result.\\nCase 2: If the array has 0 in the array , the continuity will break , the subarray  with max product will be  returned.\\nIn this question we are dealing with negative numbers as well.\\nAt each element we need to maintain  two values \\n* **maximum positive product till the ith position** :  max ( ( **the current element** ) nums[i] ,\\n( **product of current element and the largest product calculated till now** ) max[i-1] * nums[i] , (**product of current element and the smallest product calculated till now** ) min[i-1] * nums[i] ) \\n* **maximum negative product till ith position**  : min ( ( **the current element** ) nums[i] ,\\n( **product of current element and the largest product calculated till now** ) max[i-1] * nums[i] , (**product of current element and the smallest product calculated till now** ) min[i-1] * nums[i] ) \\n\\nSolution:\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        m=[0]*len(nums)\\n        n=[0]*len(nums)\\n        m[0]=nums[0]\\n        n[0]=nums[0]\\n        for i in range(1,len(nums)):\\n            m[i]=max(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n            n[i]=min(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n        return max(m)\\n```\\n            \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        m=[0]*len(nums)\\n        n=[0]*len(nums)\\n        m[0]=nums[0]\\n        n[0]=nums[0]\\n        for i in range(1,len(nums)):\\n            m[i]=max(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n            n[i]=min(nums[i],m[i-1]*nums[i],nums[i]*n[i-1])\\n        return max(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311193,
                "title": "c-o-n-time-dp-solution",
                "content": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& a) {\\n        \\n        int i,n=a.size();\\n        \\n        int mini[n];\\n        int maxi[n];\\n        \\n        mini[0]=a[0];\\n        maxi[0]=a[0];\\n        \\n        int maxpro = a[0];\\n        for(i=1;i<n;i++) \\n        {\\n            if(a[i]>0)\\n            {\\n                maxi[i] = max(maxi[i-1]*a[i], a[i]);\\n                mini[i] = min(mini[i-1]*a[i], a[i]);\\n            }\\n            else\\n            {\\n                maxi[i] = max(mini[i-1]*a[i], a[i]);\\n                mini[i] = min(maxi[i-1]*a[i], a[i]);\\n            }\\n            maxpro = max(maxpro, maxi[i]);\\n        }\\n\\n        return maxpro;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& a) {\\n        \\n        int i,n=a.size();\\n        \\n        int mini[n];\\n        int maxi[n];\\n        \\n        mini[0]=a[0];\\n        maxi[0]=a[0];\\n        \\n        int maxpro = a[0];\\n        for(i=1;i<n;i++) \\n        {\\n            if(a[i]>0)\\n            {\\n                maxi[i] = max(maxi[i-1]*a[i], a[i]);\\n                mini[i] = min(mini[i-1]*a[i], a[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48419,
                "title": "easy-understand-java-solution-o-n",
                "content": "public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0)\\n            return 0;\\n            \\n        int max_p = Integer.MIN_VALUE;\\n        int p = 1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n            \\n        }\\n        p = 1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n        } \\n        return max_p;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int maxProduct(int[] nums) {\\n        \\n        if(nums == null || nums.length == 0)\\n            return 0;\\n            \\n        int max_p = Integer.MIN_VALUE;\\n        int p = 1;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n            \\n        }\\n        p = 1;\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            p *= nums[i];\\n            max_p = Math.max(max_p, p);\\n            if(nums[i] == 0)\\n                p = 1;\\n        } \\n        return max_p;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48402,
                "title": "simpler-solution-with-6-lines-code-o-n-complexity",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            int b=1, f=1, res=INT_MIN;\\n            for(int i=0; i<n; i++){\\n                res=max(res, max(b*=A[i],f*=A[n-1-i]));\\n                if(b==0) b=1; if(f==0) f=1;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            int b=1, f=1, res=INT_MIN;\\n            for(int i=0; i<n; i++){\\n                res=max(res, max(b*=A[i],f*=A[n-1-i]));\\n                if(b==0) b=1; if(f==0) f=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3324218,
                "title": "8-lines-of-code-logic-dp",
                "content": "\\n\\n# Dynamic Programming\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        out=max(nums)\\n        cmax=cmin=1\\n        for n in nums:\\n            temp=cmax*n\\n            cmax=max(cmin*n,cmax*n,n)\\n            cmin=min(temp,cmin*n ,n)\\n            out=max(out,cmax)\\n        return out\\n//please upvote me it would encourage me alot\\n\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        out=max(nums)\\n        cmax=cmin=1\\n        for n in nums:\\n            temp=cmax*n\\n            cmax=max(cmin*n,cmax*n,n)\\n            cmin=min(temp,cmin*n ,n)\\n            out=max(out,cmax)\\n        return out\\n//please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382169,
                "title": "easy-solution-using-kadane-s-algorithm",
                "content": "**Kadane\\'s Algorithm**\\nThe simple idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array. And keep track of the maximum sum contiguous segment among all positive segments. The moment we find m as 0, reset m.\\n\\nI am traversing from right to left too. To understand this, lets take test case as [3,-1,4]. When we traverse from left to right, we will get ans as 3 whereas when we traverse from right to left, we will get ans as 4 which is the required ans. I hope this makes sense.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n**Code in Java**\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int m = 1;\\n        for(int i=0; i< nums.length; i++){\\n            m*=nums[i];\\n            ans = Math.max(m, ans);\\n            if(m == 0) m=1;\\n        }\\n        int n = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            n*=nums[i];\\n            ans = Math.max(n, ans);\\n            if(n == 0) n=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int m=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m*=nums[i];\\n            ans=max(ans,m);\\n            if(m==0) m=1;\\n        }\\n        int n=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            n*=nums[i];\\n            ans=max(ans,n);\\n            if(n==0) n=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if found helpful**\\n*Happy Coding :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int m = 1;\\n        for(int i=0; i< nums.length; i++){\\n            m*=nums[i];\\n            ans = Math.max(m, ans);\\n            if(m == 0) m=1;\\n        }\\n        int n = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            n*=nums[i];\\n            ans = Math.max(n, ans);\\n            if(n == 0) n=1;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int m=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m*=nums[i];\\n            ans=max(ans,m);\\n            if(m==0) m=1;\\n        }\\n        int n=1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            n*=nums[i];\\n            ans=max(ans,n);\\n            if(n==0) n=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993675,
                "title": "java-easy-to-undetrstand-0ms-kaden-s-algorithm",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint localProduct = 1;\\n\\t\\t\\tint maxProduct=nums[0];\\n\\t\\t\\tfor(int  i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct < localProduct){\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(localProduct==0)\\n\\t\\t\\t\\t\\tlocalProduct = 1;\\n\\t\\t\\t}\\n\\t\\t\\tlocalProduct = 1;\\n\\t\\t\\tfor(int i = nums.length-1; i>=0;i--){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct<localProduct)\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\tif(localProduct == 0)\\n\\t\\t\\t\\t\\tlocalProduct =1;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxProduct;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint localProduct = 1;\\n\\t\\t\\tint maxProduct=nums[0];\\n\\t\\t\\tfor(int  i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tlocalProduct *= nums[i];\\n\\t\\t\\t\\tif(maxProduct < localProduct){\\n\\t\\t\\t\\t\\tmaxProduct = localProduct;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1915658,
                "title": "why-kadane-s-solution-works-java-o-n-time-o-1-space",
                "content": "A Variation of Kadane\\'s Algorithm.\\n```\\nclass Solution{\\n\\tpublic int maxProduct(int[] nums) {\\n\\t\\tint pro=1, msf=nums[0];\\n\\t\\tint n=nums.length;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\tpro=1;\\n\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\treturn msf;\\n\\t}\\n}\\n\\n```\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n**Why this solution works?**\\nThis solution works because it says that maximum product subarray possible for any array will include either the `0th` index or `(n-1)th` index or both for sure (Not considering 0 values as elements of array as of now). This is because an array will either have even or odd count of negatives.\\n\\nIf array has even count of `-ve` values, Max product will be the entire array.\\n\\nIf array has odd count of `-ve` values say `k`, then `(k-1)` will be even so considering `k-1` negative values will give us max product. Thus, we can consider first `k-1` negatives starting from left side of array or starting from right side of array. Therefore, i said either the  `0th` index or `(n-1)th` index will be part of answer for sure.\\nDidn\\'t get this? Do a dry run over this approach. Hint:  The `msf` variable will monitor how to consider only `k-1` negative values.\\n\\nFor 0 values as elements of array, we can reset the `pro` variable calculating product to 1 once again. Thus zeroes also get handled.\\n\\nHope you understand the solution. Do upvote if you did.\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n\\tpublic int maxProduct(int[] nums) {\\n\\t\\tint pro=1, msf=nums[0];\\n\\t\\tint n=nums.length;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\tpro=1;\\n\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\tpro*=nums[i];\\n\\t\\t\\tif(pro>msf)\\n\\t\\t\\t\\tmsf=pro;\\n\\t\\t\\tif(pro==0)\\n\\t\\t\\t\\tpro=1;\\n\\t\\t}\\n\\t\\treturn msf;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495612,
                "title": "c-recursion-using-dp-maximum-product-subarray",
                "content": "```\\nclass Solution {\\npublic:\\n    int max_=INT_MIN;\\n    map<int,map<int,long int>> dp;\\n    int solve(int temp,vector<int>& nums,int i)\\n    {\\n        if(i==nums.size()-1)\\n        {\\n            return max(max_,temp*nums[i]);\\n        }\\n        if(dp[temp][i]!=0)return dp[temp][i];\\n        int res1=solve(temp*nums[i],nums,i+1);\\n        int res2=solve(1,nums,i+1);\\n        max_=max(max(temp*nums[i],res1),max(max_,res2));\\n        return dp[temp][i]=max_;\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        return solve(1,nums,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int max_=INT_MIN;\\n    map<int,map<int,long int>> dp;\\n    int solve(int temp,vector<int>& nums,int i)\\n    {\\n        if(i==nums.size()-1)\\n        {\\n            return max(max_,temp*nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1025771,
                "title": "linear-time-constant-space-modified-kadane-explained-c-code",
                "content": "Folllowing are the possible cases:\\n1. Number is **+ve** -> Simply take it into the product subarray as it will increase the product.\\n2. Number is **0** -> In this case we need to restart our calculation. As taking this element into our subarray will make the product 0. It basically divides our subarray into parts. \\n3. Number of **-ve** elements are odd-> \\n**(This is the tricky part)**\\n\\nWe know a -ve number multiplied with another -ve number gives a positive number. eg. ((-2)x(-3) = 6)\\nSo if we have a subarray whose product is -ve then a new -ve number can be multiplied which will make the product positive. And this subarray can be our answer. Hence, we **also need to consider the minimum subarray** so far while finding our best subarray.\\nFor better understanding try solving this **test case** ->\\n[1, -6, -1, 3, 4, -1, 0]\\nIf minimum_prod_so_far is not considered,  the answer becomes 12 but it should be (-1*-6*3*4 = 72).\\n\\nWe can **modify Kadane\\'s Algorithm** for this.\\nWe need to consider four factors at every iteration:\\n1. nums[i]                           (*the present element as it can alone be greater than our best subarray so far and can be our answer*) \\n2. maximum_prod_so_far  (*the maximum subarray product so far*)\\n3. minimum_prod_so_far   (*the minimum subarray product so far*)\\n4. overall_max                    (*the answer*)\\n\\nAt any iteration **maximum_prod_so_far has three possible values.**\\na) Taking the present number into the product.\\nb) Present number alone can be our answer.\\nc) minimum_prod_so_far when multiplied with present number might give a better product.\\nSo we have to take the maximum of these 3.\\n\\nOur **answer will be** the maximum of all maximum_prod_so_far. And **when iterator is pointing to 0** then maximum of maximum_prod_so_far and 0 ( as 0 can also be our answer if maximum_prod_so_far is -ve).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int overall_max = nums[0];\\n        int max_prod_so_far = nums[0];\\n        int min_prod_so_far = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i] == 0) {\\n                overall_max = max (overall_max, 0);\\n                max_prod_so_far = 1;\\n                min_prod_so_far = 1;\\n            }\\n            else {\\n                int temp = max_prod_so_far;\\n                max_prod_so_far = max(max_prod_so_far * nums[i], max (min_prod_so_far * nums[i], nums[i]));\\n                min_prod_so_far = min(min_prod_so_far * nums[i], min (temp * nums[i], nums[i]));\\n                \\n                overall_max = max (overall_max, max_prod_so_far);\\n            }\\n        }\\n        \\n        return overall_max;\\n    }\\n};\\n```\\n\\nThis code iterates once throughout the array hence **takes O(n) time**. And doesn\\'t needs any extra space or works in **constant space**.\\n\\n*Still stuck? Ask me in the comment box.\\nHave a better solution? Would love to know. :-)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int overall_max = nums[0];\\n        int max_prod_so_far = nums[0];\\n        int min_prod_so_far = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums[i] == 0) {\\n                overall_max = max (overall_max, 0);\\n                max_prod_so_far = 1;\\n                min_prod_so_far = 1;\\n            }\\n            else {\\n                int temp = max_prod_so_far;\\n                max_prod_so_far = max(max_prod_so_far * nums[i], max (min_prod_so_far * nums[i], nums[i]));\\n                min_prod_so_far = min(min_prod_so_far * nums[i], min (temp * nums[i], nums[i]));\\n                \\n                overall_max = max (overall_max, max_prod_so_far);\\n            }\\n        }\\n        \\n        return overall_max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841691,
                "title": "c-fresh-approach-extremely-easy-o-n-implementation-can-be-translated-to-c-java",
                "content": "If there is no zero in an array, the solution is always one of the cumulative products starting from each ends. i.e.\\nFor -2,3,3,-1,-5 :\\nCumulative products from left end: -2,-6,-18,18,-90\\nSame from right end: -5,5,15,45,-90\\nAns: max of all = 45\\n\\nWe need to do this for each segment devided by one or more zeroes.\\n\\n```\\npublic class Solution {\\n    public int MaxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int n = nums.Count();\\n        int p = 1, q=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t    // reset to 1 when the product becomes zero\\n            p = (p==0?1:p)*nums[i];\\n            q = (q==0?1:q)*nums[n-1-i];\\n            ans = Math.Max(ans,Math.Max(p,q));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int n = nums.Count();\\n        int p = 1, q=1;\\n        for(int i=0;i<n;i++){\\n\\t\\t    // reset to 1 when the product becomes zero\\n            p = (p==0?1:p)*nums[i];\\n            q = (q==0?1:q)*nums[n-1-i];\\n            ans = Math.Max(ans,Math.Max(p,q));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352038,
                "title": "easy-5-line-python-dp-solution-o-n-time-o-1-space",
                "content": "```\\n    def maxProduct(self, nums):\\n        prev_min = prev_max = global_max = nums[0]\\n        for num in nums[1:]:\\n            minn, maxx = min(num, prev_max*num, prev_min*num), max(num, prev_max*num, prev_min*num)\\n            prev_min, prev_max, global_max = minn, maxx, max(global_max, maxx)\\n        return global_max\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def maxProduct(self, nums):\\n        prev_min = prev_max = global_max = nums[0]\\n        for num in nums[1:]:\\n            minn, maxx = min(num, prev_max*num, prev_min*num), max(num, prev_max*num, prev_min*num)\\n            prev_min, prev_max, global_max = minn, maxx, max(global_max, maxx)\\n        return global_max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 119171,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction maxProduct(nums) {\\n  let res = -Number.MAX_VALUE;\\n  let min = 1;\\n  let max = 1;\\n  for (let num of nums) {\\n    [min, max] = [\\n      Math.min(num, min * num, max * num),\\n      Math.max(num, min * num, max * num),\\n    ];\\n    res = Math.max(res, max);\\n  }\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction maxProduct(nums) {\\n  let res = -Number.MAX_VALUE;\\n  let min = 1;\\n  let max = 1;\\n  for (let num of nums) {\\n    [min, max] = [\\n      Math.min(num, min * num, max * num),\\n      Math.max(num, min * num, max * num),\\n    ];\\n    res = Math.max(res, max);\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608870,
                "title": "kind-of-an-intriguing-and-well-documented-approach-o-n-time-o-1-space-with-recursion",
                "content": "# Intuition\\nSo basically I divided all the possible cases into 3 criteria:\\n1. When the number of negative numbers is even and there are no zero in the given array.\\n2. When the number of negative numbers is odd and there are no zero in the given array.\\n3. When the array contains one or more zeroes. \\n\\nAccording to each criterion I handled the cases accordingly which you can see in the code as I handled 3 cases according to whether the product of the entire is positive, negative or zero. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn the maxProduct(), I simply calculate the product of all the elements of the array and call the helper() with parameters that is easily understandable. This takes O(n) time.\\n\\n1. If the product is positive then I simply return it as the largest product.\\n2. If the product is negative then it is obvious that the subarray has negative numbers count is odd. In case of the array having size 1 and that single element being a negative number then that number is simply returned.\\n\\n    In other cases I simply calculate 2 products. First one is the product of all the numbers after the first negative number and the second product is the product of all the numbers before the last negative number.\\n\\n    If you think about it there is no other possible subarray that could have the largest product in case of a odd count of negative numbers. \\n\\n    Hence I simply return the larger of these two. This takes O(n) time and in case of no zeroes the execution ends here with the complexity upto O(2n) and constant space.\\n3. Now we come to the case where there are zeroes in the array. I dealt with this case by fragmenting the array into subarrays bordered by zeroes. Each subarray is executed again with recursion(now the start & end variables become relevant) and since these subarrays don\\'t contain zeroes themselves, therefore the third case in any recursion call is never executed and the recursion stack has the max size of 1. For each fragmented subarray the helper function is called and the maximum product is stored. \\n    If the maximum is negative then zero is returned, otherwise the calculated maximum is returned. \\n\\n    Since the recursion stack has the max size of 1, therefore the function uses constant space and as far as time is considered O(n) is used for traversing the array for zeroes and O(n) is used for traversing the subarrays in worst case of all the subarrays having odd count of negative numbers. Thus the worst case time complexity is O(3n). \\n\\nHope this clarifies everything\\uD83D\\uDE42.\\n    \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(3n) ~ O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int start, int end, int prod){\\n\\n        if(prod>0)\\n            return prod;\\n\\n        else if(prod<0){\\n            if(start==end)\\n                return prod;\\n            //calculate the product after first negative number\\n            int i=start;\\n            int fprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    fprod*=nums[i];\\n                    break;\\n                }\\n\\n                fprod*=nums[i];\\n                i++;\\n            }\\n            //calculate the product before last negative number\\n            i=end;\\n            int bprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    bprod*=nums[i];\\n                    break;\\n                }\\n\\n                bprod*=nums[i];\\n                i--;\\n            }\\n\\n            int contd1 = prod/fprod;\\n            int contd2 = prod/bprod;\\n\\n            return contd1>contd2 ? contd1:contd2;\\n        }\\n\\n        else {\\n            int i=0;\\n            int start=0;\\n            int big = INT_MIN;\\n            int temprod = 1;\\n            while(i<nums.size()){\\n                //for dealing with consecutive zeroes or the original array has nums[0]=0\\n                if(start==i && nums[i]==0){\\n                    start++;\\n                    i++;\\n                } \\n                //Recursion call made for subarray bordered by zeroes\\n                else if(nums[i]==0 && start!=i){\\n                    int contd = helper(nums, start, i-1, temprod);\\n                    start = i+1;\\n                    temprod = 1;\\n                    if(contd > big)\\n                        big = contd;\\n                    i++;\\n                }\\n                //Recursion call made for subarray after the last zero\\n                else if(i==nums.size()-1){\\n                    temprod = temprod * nums[i];\\n                    int contd = helper(nums, start, i, temprod);\\n                    if(contd > big)\\n                        big = contd;\\n                    temprod = 1;\\n                    i++;\\n                } else {\\n                    temprod = temprod * nums[i];\\n                    i++;\\n                }\\n            }\\n\\n            if(big<0)\\n                return 0;\\n            \\n            return big;\\n        }\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.size();i++){\\n            prod*=nums[i];\\n        }\\n        return helper(nums, 0, nums.size()-1, prod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int start, int end, int prod){\\n\\n        if(prod>0)\\n            return prod;\\n\\n        else if(prod<0){\\n            if(start==end)\\n                return prod;\\n            //calculate the product after first negative number\\n            int i=start;\\n            int fprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    fprod*=nums[i];\\n                    break;\\n                }\\n\\n                fprod*=nums[i];\\n                i++;\\n            }\\n            //calculate the product before last negative number\\n            i=end;\\n            int bprod=1;\\n            while(true){\\n                if(nums[i]<0){\\n                    bprod*=nums[i];\\n                    break;\\n                }\\n\\n                bprod*=nums[i];\\n                i--;\\n            }\\n\\n            int contd1 = prod/fprod;\\n            int contd2 = prod/bprod;\\n\\n            return contd1>contd2 ? contd1:contd2;\\n        }\\n\\n        else {\\n            int i=0;\\n            int start=0;\\n            int big = INT_MIN;\\n            int temprod = 1;\\n            while(i<nums.size()){\\n                //for dealing with consecutive zeroes or the original array has nums[0]=0\\n                if(start==i && nums[i]==0){\\n                    start++;\\n                    i++;\\n                } \\n                //Recursion call made for subarray bordered by zeroes\\n                else if(nums[i]==0 && start!=i){\\n                    int contd = helper(nums, start, i-1, temprod);\\n                    start = i+1;\\n                    temprod = 1;\\n                    if(contd > big)\\n                        big = contd;\\n                    i++;\\n                }\\n                //Recursion call made for subarray after the last zero\\n                else if(i==nums.size()-1){\\n                    temprod = temprod * nums[i];\\n                    int contd = helper(nums, start, i, temprod);\\n                    if(contd > big)\\n                        big = contd;\\n                    temprod = 1;\\n                    i++;\\n                } else {\\n                    temprod = temprod * nums[i];\\n                    i++;\\n                }\\n            }\\n\\n            if(big<0)\\n                return 0;\\n            \\n            return big;\\n        }\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.size();i++){\\n            prod*=nums[i];\\n        }\\n        return helper(nums, 0, nums.size()-1, prod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545220,
                "title": "c-java-python-javascript-space-o-1-clean-concise-easy-to-understand",
                "content": "# Intuition:\\nThe Solution aims to find the maximum product of a subarray within the given vector of integers. To achieve this, the code maintains three variables: `ans`, `maxp`, and `minp`. The variable `ans` keeps track of the maximum product found so far, `maxp` represents the maximum product ending at the current element, and `minp` represents the minimum product ending at the current element.\\n\\n# Approach:\\n1. The code initializes `ans`, `maxp`, and `minp` with the first element of the `nums` vector.\\n2. It then iterates over the elements of `nums` starting from the second element.\\n3. For each element at index `i`, the code calculates the maximum product considering three possibilities:\\n   - The current element alone (`nums[i]`).\\n   - The maximum product ending at the previous element (`maxp`) multiplied by the current element (`maxp * nums[i]`).\\n   - The minimum product ending at the previous element (`minp`) multiplied by the current element (`minp * nums[i]`).\\n4. The code updates `maxp` to the maximum value among the three possibilities using the `max` function.\\n5. Similarly, it updates `minp` to the minimum value among the three possibilities using the `min` function.\\n6. It updates `ans` to the maximum value between `maxp` and the current `ans`.\\n7. After iterating through all the elements, the code returns `ans`, which represents the maximum product of a subarray within `nums`.\\n\\n# Complexity:\\n- The time complexity of the code is O(n), where n is the size of the input vector `nums`. This is because the code iterates through all the elements once.\\n\\n- The space complexity of the code is O(1) since it only uses a constant amount of additional space to store the variables `ans`, `maxp`, and `minp`.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int ans=nums[0], maxp = nums[0], minp = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            int temp = max({nums[i],maxp*nums[i],minp*nums[i]});\\n            minp = min({nums[i],maxp*nums[i],minp*nums[i]});\\n            maxp = temp;\\n            ans = max(maxp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int maxp = nums[0];\\n        int minp = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = Math.max(nums[i], Math.max(maxp * nums[i], minp * nums[i]));\\n            minp = Math.min(nums[i], Math.min(maxp * nums[i], minp * nums[i]));\\n            maxp = temp;\\n            ans = Math.max(maxp, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        ans = maxp = minp = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            temp = max(nums[i], maxp * nums[i], minp * nums[i])\\n            minp = min(nums[i], maxp * nums[i], minp * nums[i])\\n            maxp = temp\\n            ans = max(maxp, ans)\\n        \\n        return ans\\n\\n```\\n# JavaScript\\n```\\nvar maxProduct = function(nums) {\\n    var ans = nums[0];\\n    var maxp = nums[0];\\n    var minp = nums[0];\\n    \\n    for (var i = 1; i < nums.length; i++) {\\n        var temp = Math.max(nums[i], maxp * nums[i], minp * nums[i]);\\n        minp = Math.min(nums[i], maxp * nums[i], minp * nums[i]);\\n        maxp = temp;\\n        ans = Math.max(maxp, ans);\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int ans=nums[0], maxp = nums[0], minp = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            int temp = max({nums[i],maxp*nums[i],minp*nums[i]});\\n            minp = min({nums[i],maxp*nums[i],minp*nums[i]});\\n            maxp = temp;\\n            ans = max(maxp,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = nums[0];\\n        int maxp = nums[0];\\n        int minp = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            int temp = Math.max(nums[i], Math.max(maxp * nums[i], minp * nums[i]));\\n            minp = Math.min(nums[i], Math.min(maxp * nums[i], minp * nums[i]));\\n            maxp = temp;\\n            ans = Math.max(maxp, ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        ans = maxp = minp = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            temp = max(nums[i], maxp * nums[i], minp * nums[i])\\n            minp = min(nums[i], maxp * nums[i], minp * nums[i])\\n            maxp = temp\\n            ans = max(maxp, ans)\\n        \\n        return ans\\n\\n```\n```\\nvar maxProduct = function(nums) {\\n    var ans = nums[0];\\n    var maxp = nums[0];\\n    var minp = nums[0];\\n    \\n    for (var i = 1; i < nums.length; i++) {\\n        var temp = Math.max(nums[i], maxp * nums[i], minp * nums[i]);\\n        minp = Math.min(nums[i], maxp * nums[i], minp * nums[i]);\\n        maxp = temp;\\n        ans = Math.max(maxp, ans);\\n    }\\n    \\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598311,
                "title": "javascript-solution-using-dynamic-programming-in-o-n-time-w-explanation",
                "content": "## Explanation\\nMy solution for this problem utilises **Dynamic Programming (DP)**. When looking at the question, I realised that to get a product of the sub array at a given index i, I can simple take the product of the sub array up until index i-1 and multiply with the current number. This would be much more efficient as compared to recalculating the product over again. Hence, DP would be very useful here since we can solve smaller sub-problems first to solve the bigger problem, and reuse previously computed products to optimize/speed up the solution.\\n\\nBut how do we utilise DP for this problem? These are the brief steps for my solution\\n\\n1.  I will simply interate through the array as per normal. However, as i traverse trhough the array, I will not ony keep track of the max product (currMax), but I will also keep track of the min product (currMin).\\n\\n2.  It is important to keep track of currMin due to the existence of negative numbers in the array. This is because, a multiplication of a negative currMin with another negative number, may result in this product being larger than a previously computed currMax.\\n\\n\\t***Note:*\\n*In my solution, I created a variable prevMax. This is mainly to be used when updating the currMin. currMax would have already been updated before currMin, but we still want to use the previous currMax in our min function. Therefore, we can simply create a temp variable that stores the currMax before it is updated***\\n\\n3.  Now, when updating the currMax and currMin we have to consider 3 different cases:\\n\\n\\t(a) Current Number\\n\\t(b) Current Number * Current Max\\n\\t(c) Current Number * Current Min\\n\\n\\tIt is easy to understand why we have to consider cases (b) and (c), since we are keeping track of the currMax and currMin up till that point. However, (a) is also crucial as there may be instances that the number itself could be larger or smaller than currMax and currMin respectively.\\n\\n4. Lastly, we update the variable res, which stores the greatest product calculated so far, by simply taking a max function of the current res and the currMax of the subarray being tracked.\\n\\n## Performance\\n\\nThe time complexity of this solution is linear, **O(n)**, since we solved the problem by having to pass through the array only once.\\n\\nHere are the details of my submission:\\nRuntime: 68 ms, faster than 97.42% \\nMemory Usage: 40.8 MB, less than 14.36% \\n\\n## Code\\n\\n```\\nvar maxProduct = function(nums) {\\n    var res = Math.max(...nums),\\n        currMin = 1,\\n        currMax = 1,\\n        prevMax = 1\\n    \\n    for (const num of nums){\\n        prevMax = currMax * num\\n        currMax = Math.max(prevMax, currMin*num, num)\\n        currMin = Math.min(prevMax, currMin*num, num)\\n        \\n        res = Math.max(res, currMax)\\n    }\\n    return res\\n};\\n```\\n\\nI hope this helps! Do let me know if there are any lapses in my explanation and/or if my solution can be improved in any way :)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxProduct = function(nums) {\\n    var res = Math.max(...nums),\\n        currMin = 1,\\n        currMax = 1,\\n        prevMax = 1\\n    \\n    for (const num of nums){\\n        prevMax = currMax * num\\n        currMax = Math.max(prevMax, currMin*num, num)\\n        currMin = Math.min(prevMax, currMin*num, num)\\n        \\n        res = Math.max(res, currMax)\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253370,
                "title": "java-easy-solution-o-n-complexity",
                "content": "\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxP=nums[0];  //Stores the maximum product soo far\\n        int minP=nums[0];  //Stores the minimum product soo far basically the -ve product\\n\\t\\tint ans=nums[0];   //Stores the answer to be returned\\n        \\n\\t\\tfor(int i=1;i<nums.length;i++){\\n            int first=nums[i];         //First Possibility\\n            int second=maxP*nums[i];   //Second Possibility\\n            int third=minP*nums[i];    //Third Possibility\\n            minP=Math.min( Math.min(first,second) ,third);\\n            maxP=Math.max( Math.max(first,second) ,third);\\n            ans=Math.max(ans,maxP);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n(Note: variable ans is initialised as first element because in case only one element is given we need to return it.)\\n\\nNow let\\'s discuss about the possibilities,\\n1. First possibility : the current element is the maximum of all results soo far,\\n\\n2. Second possibilty : when we multiple the current element to out product, it becomes the maximum,\\n \\n3. Third possibility says that if the product obtained soo far is -ve and when we add the current element (a -ve element), it results in a positive product greater than the soo far computed max product.\\n\\nWe maintain two var. to check for soo far obtained max and min(-ve) product and check every possibilty.\\nTHANKS !!!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxP=nums[0];  //Stores the maximum product soo far\\n        int minP=nums[0];  //Stores the minimum product soo far basically the -ve product\\n\\t\\tint ans=nums[0];   //Stores the answer to be returned\\n        \\n\\t\\tfor(int i=1;i<nums.length;i++){\\n            int first=nums[i];         //First Possibility\\n            int second=maxP*nums[i];   //Second Possibility\\n            int third=minP*nums[i];    //Third Possibility\\n            minP=Math.min( Math.min(first,second) ,third);\\n            maxP=Math.max( Math.max(first,second) ,third);\\n            ans=Math.max(ans,maxP);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037018,
                "title": "python3-concise-memoization",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        def dfs(i, currentProduct):\\n            key = (i, currentProduct)\\n            if (key in self.memo):\\n                return self.memo[key]\\n            if (i >= len(nums)):\\n                return currentProduct\\n\\t\\t\\t# 3 choices, Include the current number in the product, start a new product, or end the product\\n            ans = max(dfs(i + 1, currentProduct * nums[i]), dfs(i + 1, nums[i]), currentProduct)\\n            self.memo[key] = ans\\n            return ans\\n        return dfs(1, nums[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        self.memo = {}\\n        def dfs(i, currentProduct):\\n            key = (i, currentProduct)\\n            if (key in self.memo):\\n                return self.memo[key]\\n            if (i >= len(nums)):\\n                return currentProduct\\n\\t\\t\\t# 3 choices, Include the current number in the product, start a new product, or end the product\\n            ans = max(dfs(i + 1, currentProduct * nums[i]), dfs(i + 1, nums[i]), currentProduct)\\n            self.memo[key] = ans\\n            return ans\\n        return dfs(1, nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841252,
                "title": "o-n-java-solution-with-video-explanation",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/fOUieZzRuAk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass MaximumProductSubArray {\\n    // Space => O(1), Time Complexity => O(n)\\n    public int maxProduct(int[] nums) {\\n        int maxSoFar = nums[0];\\n        int minSoFar = nums[0];\\n        int res = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int copyMaxSoFar = maxSoFar;\\n            int el = nums[i];\\n            maxSoFar = Math.max(el, Math.max(el*maxSoFar, el*minSoFar));\\n\\n            minSoFar = Math.min(el, Math.min(el*copyMaxSoFar, el*minSoFar));\\n            res = Math.max(res, maxSoFar);\\n        }\\n        return res;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/fOUieZzRuAk\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\nclass MaximumProductSubArray {\\n    // Space => O(1), Time Complexity => O(n)\\n    public int maxProduct(int[] nums) {\\n        int maxSoFar = nums[0];\\n        int minSoFar = nums[0];\\n        int res = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            int copyMaxSoFar = maxSoFar;\\n            int el = nums[i];\\n            maxSoFar = Math.max(el, Math.max(el*maxSoFar, el*minSoFar));\\n\\n            minSoFar = Math.min(el, Math.min(el*copyMaxSoFar, el*minSoFar));\\n            res = Math.max(res, maxSoFar);\\n        }\\n        return res;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 841169,
                "title": "python-3-dp-explanations",
                "content": "### Explanation\\n- `cur_max`: max product to current position (not max product before this position)\\n\\t- for [1,9,0,2], `cur_max` at index 3 is `2` not `9`, because max product to current position is only 2\\n- `cur_min`: min product to current position (not min product before this position)\\n\\t- for [-1,9,0,2], `cur_min` at index 3 is `2` not `-9`, because min product to current position is only 2; 0 seperated the global min and current min \\n- `ans` to get current max product\\n- case are handled differently depends on whether current number is positive or negative\\n- if `ans` is 0, nums is something like [-2, 0, -3] or [-2], so we return the max of `nums`\\n### Implementation\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans, cur_max, cur_min = -sys.maxsize, 0, 0\\n        for num in nums:\\n            if num > 0: cur_max, cur_min = max(num, num*cur_max), min(num, num*cur_min)\\n            else: cur_max, cur_min = max(num, num*cur_min), min(num, num*cur_max)  \\n            ans = max(ans, cur_max)    \\n        return ans if ans else max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans, cur_max, cur_min = -sys.maxsize, 0, 0\\n        for num in nums:\\n            if num > 0: cur_max, cur_min = max(num, num*cur_max), min(num, num*cur_min)\\n            else: cur_max, cur_min = max(num, num*cur_min), min(num, num*cur_max)  \\n            ans = max(ans, cur_max)    \\n        return ans if ans else max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529559,
                "title": "python-99-short-and-easy-to-read",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:        \\n        res = cmin = cmax = nums[0]\\n        for n in nums[1:]:           \\n            cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)\\n            if cmax > res: res = cmax        \\n        return res\\n```\\n\\nSo while the code is short, it had to solve a few problems.\\n\\n1. Initalization. Since we are guaranteed to have at least one element, we don\\'t need to bother checking input array size - we just use nums[0] to see our result and current max (cmax) and current min (cmin):\\n`res = cmin = cmax = nums[0]`\\n2. now we check the rest of the array: nums[1:] . `for n in nums[1:]:` Here we can have 1 out of  3 scenarios: we can start a new subarray, the previous subarray product keeps the sign or the sign changes. The fact that changing sign makes the largest product to be the smallest and vice versa needs to be addressed, so we keep track of the largest and the smallest products  (presumably a negative number).  Thanks to the Python we can do all that logic in one line:\\n`cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)`\\n3. Finally, we need to keep track of the largest product so far:\\n`if cmax > res: res = cmax `\\nInterestingly, but if I replace that `if cmax > res: res = cmax ` with `res=max(res,cmax)` - that makes better looking code, but the execution time increases, so I kept that if for performance reasons.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:        \\n        res = cmin = cmax = nums[0]\\n        for n in nums[1:]:           \\n            cmin,cmax = min(n, cmin*n, cmax*n),max(n, cmin*n, cmax*n)\\n            if cmax > res: res = cmax        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402220,
                "title": "python-o-n",
                "content": "The key idea here is to keep track of two local products that are in imax and Imin. Now when you encounter a new number its going to be multiplied with both, in case its a negative number you are going to get the imin maximized and incase its a positive its going to get the imax maximized and both are going to be tallied against the global max in each iteration making sure we don\\'t miss the global max. \\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        global_max = nums[0]\\n        imax, imin = nums[0],nums[0]\\n        \\n        # Maintain local max, local min and global max!\\n        for i in range(1,len(nums)):\\n            # Once we have encountered a negative element we consider it by multiplying it. \\n            # print(local_min, local_max, global_max)\\n            candidates = (nums[i], imax * nums[i], imin * nums[i])\\n            imax = max(candidates)\\n            imin = min(candidates)            \\n            global_max = max(global_max, imax)\\n        return global_max",
                "solutionTags": [],
                "code": "The key idea here is to keep track of two local products that are in imax and Imin. Now when you encounter a new number its going to be multiplied with both, in case its a negative number you are going to get the imin maximized and incase its a positive its going to get the imax maximized and both are going to be tallied against the global max in each iteration making sure we don\\'t miss the global max. \\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        global_max = nums[0]\\n        imax, imin = nums[0],nums[0]\\n        \\n        # Maintain local max, local min and global max!\\n        for i in range(1,len(nums)):\\n            # Once we have encountered a negative element we consider it by multiplying it. \\n            # print(local_min, local_max, global_max)\\n            candidates = (nums[i], imax * nums[i], imin * nums[i])\\n            imax = max(candidates)\\n            imin = min(candidates)            \\n            global_max = max(global_max, imax)\\n        return global_max",
                "codeTag": "Java"
            },
            {
                "id": 48409,
                "title": "share-the-easiest-4ms-solution",
                "content": "    class Solution { public:\\n        int maxProduct(vector<int>& nums) {\\n            int cur=1;\\n            int res=INT_MIN;\\n            for(vector<int>::iterator it=nums.begin();it<nums.end();++it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }\\n            cur=1;\\n            for(vector<int>::iterator it=nums.end()-1;it>=nums.begin();--it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }\\n            return res;\\n        } };",
                "solutionTags": [],
                "code": "class Solution { public:\\n        int maxProduct(vector<int>& nums) {\\n            int cur=1;\\n            int res=INT_MIN;\\n            for(vector<int>::iterator it=nums.begin();it<nums.end();++it){\\n                cur*=*it;\\n                if(cur>res)res=cur;\\n                if(cur==0)cur=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48444,
                "title": "an-implementation-of-the-suggested-solution-dynamic-programming",
                "content": "    int maxProduct(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int* maxdp = new int[n];\\n        int* mindp = new int[n];\\n        maxdp[0] = A[0];\\n        mindp[0] = A[0];\\n        int maxProduct = A[0];\\n        for(int i = 1; i < n; i++){\\n            if(A[i] > 0){\\n                maxdp[i] = max(maxdp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(mindp[i - 1] * A[i], A[i]);\\n            }\\n            else{\\n                maxdp[i] = max(mindp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(maxdp[i - 1] * A[i], A[i]);\\n            }\\n            maxProduct = max(maxProduct, maxdp[i]);\\n        }\\n        return maxProduct;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    int maxProduct(int A[], int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        int* maxdp = new int[n];\\n        int* mindp = new int[n];\\n        maxdp[0] = A[0];\\n        mindp[0] = A[0];\\n        int maxProduct = A[0];\\n        for(int i = 1; i < n; i++){\\n            if(A[i] > 0){\\n                maxdp[i] = max(maxdp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(mindp[i - 1] * A[i], A[i]);\\n            }\\n            else{\\n                maxdp[i] = max(mindp[i - 1] * A[i], A[i]);\\n                mindp[i] = min(maxdp[i - 1] * A[i], A[i]);\\n            }\\n            maxProduct = max(maxProduct, maxdp[i]);\\n        }\\n        return maxProduct;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2859129,
                "title": "python-js-easy-logic-kadane-s-algo-concise-solution-o-1-dp-o-n-tc",
                "content": "**Upvote if it helped :)**\\n### python\\n```\\nclass Solution:    \\n    def maxProduct(self, nums):\\n        maxi = mini = res = nums[0]\\n\\n        for num in nums[1:]:\\n            currMax = max(maxi * num, mini * num, num)\\n            currMin = min(maxi * num, mini * num, num)\\n            maxi = currMax\\n            mini = currMin\\n            res = max(res, maxi)\\n        \\n        return res\\n```\\n### javascript\\n```\\nvar maxProduct = function(nums) {\\n    let mini, maxi, res;\\n    mini = maxi = res = nums[0];\\n    \\n    for (let num of nums.slice(1)) {\\n        const currMini = Math.min(num, num * maxi, num * mini);\\n        const currMaxi = Math.max(num, num * maxi, num * mini);\\n        maxi = currMaxi\\n        mini = currMini\\n        res = Math.max(res, maxi)\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:    \\n    def maxProduct(self, nums):\\n        maxi = mini = res = nums[0]\\n\\n        for num in nums[1:]:\\n            currMax = max(maxi * num, mini * num, num)\\n            currMin = min(maxi * num, mini * num, num)\\n            maxi = currMax\\n            mini = currMin\\n            res = max(res, maxi)\\n        \\n        return res\\n```\n```\\nvar maxProduct = function(nums) {\\n    let mini, maxi, res;\\n    mini = maxi = res = nums[0];\\n    \\n    for (let num of nums.slice(1)) {\\n        const currMini = Math.min(num, num * maxi, num * mini);\\n        const currMaxi = Math.max(num, num * maxi, num * mini);\\n        maxi = currMaxi\\n        mini = currMini\\n        res = Math.max(res, maxi)\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139489,
                "title": "simple-easy-o-n-100-faster",
                "content": "**<++++ Press upvote Button please !!!!!!!!**\\n\\nExplanation >>\\n\\n*  [  2  ,  3  ,  -2  ,  4  ]\\n\\nFirst c1 = 0 , c2 = 0 , c3 = 0 , Max = 2 , Min = 2 , Res = 2 ;  // Res is Result\\n\\nWe Will start loop from i = 1 ;\\n\\n* When i = 1 :\\n\\t* Then c1 = 3 , c2 = 6 , c3 = 6 , Max = 6 , Min = 3 , Res = 6 ;\\n\\n* When i = 2:\\n\\t* Then c1 = -2 , c2 = -12 , c3 = -6 , Max = -2 , Min = -12 , Res = 6 ;\\n\\n* When i = 3 :\\n\\t* Then c1 = 4 , c2 = -6 , c3 = -48 , Max = 4 , Min = -48 , Res = 6 ;\\n\\nFinal ouput will be 6 .\\n\\n**To make it Simple just look if our array consist of another Number ( -2 ) in the end**\\n\\n* i.e : [  2  ,  3  ,  -2  ,  4  ,  -2  ]\\n* Then according to question Res should be Equal to 96\\n\\nIn previous example i.e [  2  ,  3  ,  -2  ,  4  ] \\n* When i = 3 :\\n\\t* Then c1 = 4 , c2 = -6 , c3 = -48 , Max = 4 , Min = -48 , Res = 6 ;\\n\\n* Then When i = 4 :\\n\\t* Then c1 = -2 , c2 = -8 , c3 = 96 , Max = 96 , Min = -8 , Res = 96 ; \\n\\n**You see Min becomes Max sometime and Max becomes Min some time  that\\'s because of product property.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int Max = nums[0],\\n            Min = nums[0],\\n            Res = nums[0],\\n        \\n        c1=0,c2=0,c3=0;\\n        \\n        for( int i=1;i< nums.size(); i++)\\n        {\\n            c1 = nums[i];\\n            c2 = Max * nums[i];\\n            c3 = Min * nums[i];\\n            \\n            Max = max( c1, max( c2 , c3 ) );\\n            Min = min( c1, min( c2 , c3 ) );\\n            Res = max( Res, Max );\\n        }\\n        \\n        return Res;      \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8a3c6764-e656-4fda-bbda-95712bfc87d8_1654968528.4146075.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        int Max = nums[0],\\n            Min = nums[0],\\n            Res = nums[0],\\n        \\n        c1=0,c2=0,c3=0;\\n        \\n        for( int i=1;i< nums.size(); i++)\\n        {\\n            c1 = nums[i];\\n            c2 = Max * nums[i];\\n            c3 = Min * nums[i];\\n            \\n            Max = max( c1, max( c2 , c3 ) );\\n            Min = min( c1, min( c2 , c3 ) );\\n            Res = max( Res, Max );\\n        }\\n        \\n        return Res;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119079,
                "title": "c-simple-explanation-o-n-time-and-o-1-space-without-dp",
                "content": "Let\\'s assume that there is no zero in the subarray\\n\\n**Logic : Let\\'s say the maximum subarray product is ans.**\\n\\n\\tthan the four posibilities will be : \\n\\n\\t.....left......ans.......right.....\\n\\n```\\n left                right\\n\\na) +                    -\\nb) +                    +\\nc) -                    -\\nd) -                    +\\n\\ncase a)\\n\\t\\tas left product is also positive than we must have to\\n\\t\\tinclude left subarray in ans\\n\\ncase b)\\n\\t\\tas left and right subarrays also giving the positive product subarrys\\n\\t\\tso left and right subarrays will also come in answer\\n\\ncase c)\\n\\t\\tas left and right subarrays product is neg so whole array product  will \\n\\t\\tbe the answer.\\n\\ncase d)\\n\\t\\tas the right subarray is giving positive subarray product so the ans will also include\\n\\t\\tright subarray\\n\\n\\nfrom all those four cases we are sure that the answer will either start from 0th index or \\nfrom n-1 th index.\\n\\n\\n\\n\\n\\nif there is zero in the subarray\\n\\n(........A.....)   0   (.....B.........)   0   (......C.......)   0   (.........D.......)\\n\\nthan the answer will be maximum of subarrays A,B,C,D........\\n```\\n\\n\\n\\n\\n```\\nint maxProduct(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint ans = INT_MIN;\\n\\tint pro = 1;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tif(nums[i]){\\n\\t\\t\\tpro *= nums[i];\\n\\t\\t\\tans = max(ans,pro);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpro = 1;\\n\\t\\t\\tans = max(ans,0);\\n\\t\\t}\\n\\n        }\\n        pro = 1;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            if(nums[i]){\\n                pro *= nums[i];\\n                ans = max(ans,pro);\\n            }else{\\n                pro = 1;\\n                ans = max(ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n left                right\\n\\na) +                    -\\nb) +                    +\\nc) -                    -\\nd) -                    +\\n\\ncase a)\\n\\t\\tas left product is also positive than we must have to\\n\\t\\tinclude left subarray in ans\\n\\ncase b)\\n\\t\\tas left and right subarrays also giving the positive product subarrys\\n\\t\\tso left and right subarrays will also come in answer\\n\\ncase c)\\n\\t\\tas left and right subarrays product is neg so whole array product  will \\n\\t\\tbe the answer.\\n\\ncase d)\\n\\t\\tas the right subarray is giving positive subarray product so the ans will also include\\n\\t\\tright subarray\\n\\n\\nfrom all those four cases we are sure that the answer will either start from 0th index or \\nfrom n-1 th index.\\n\\n\\n\\n\\n\\nif there is zero in the subarray\\n\\n(........A.....)   0   (.....B.........)   0   (......C.......)   0   (.........D.......)\\n\\nthan the answer will be maximum of subarrays A,B,C,D........\\n```\n```\\nint maxProduct(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint ans = INT_MIN;\\n\\tint pro = 1;\\n\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\tif(nums[i]){\\n\\t\\t\\tpro *= nums[i];\\n\\t\\t\\tans = max(ans,pro);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tpro = 1;\\n\\t\\t\\tans = max(ans,0);\\n\\t\\t}\\n\\n        }\\n        pro = 1;\\n        for(int i = n-1 ; i >= 0 ; i--){\\n            if(nums[i]){\\n                pro *= nums[i];\\n                ans = max(ans,pro);\\n            }else{\\n                pro = 1;\\n                ans = max(ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506795,
                "title": "c-solution-memory-o-1-time-o-n-iterative-dp-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), dp = nums[n - 1], mx = nums[n - 1], dpmn = nums[n - 1];\\n        // dp contains max value of the last index\\n        // dpmn contains min value of the last index\\n        // I use dpmn in order to calculate the maximum value with negative numbers\\n        for(int i = n - 2; i >= 0; i--) {\\n            int x = max({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dpmn = min({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dp = x;\\n            if(dp > mx) mx = dp; \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), dp = nums[n - 1], mx = nums[n - 1], dpmn = nums[n - 1];\\n        // dp contains max value of the last index\\n        // dpmn contains min value of the last index\\n        // I use dpmn in order to calculate the maximum value with negative numbers\\n        for(int i = n - 2; i >= 0; i--) {\\n            int x = max({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dpmn = min({nums[i], dp * nums[i], dpmn * nums[i]});\\n            dp = x;\\n            if(dp > mx) mx = dp; \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272401,
                "title": "90-faster-easy",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n\\t\\t  return 0;\\n\\t\\t}\\n        if(n == 1)\\n        {\\n\\t\\t  return nums[0];\\n\\t\\t}\\n        int max_prod = 0;\\n        int curr_prod = 1;\\n        for(int i = 0 ; i < n ; i++) // Traverse in the forward direction \\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        curr_prod = 1;\\n        for(int i = n-1 ; i>=0 ; i--) // Traverse in the backward direction\\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        return max_prod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0)\\n        {\\n\\t\\t  return 0;\\n\\t\\t}\\n        if(n == 1)\\n        {\\n\\t\\t  return nums[0];\\n\\t\\t}\\n        int max_prod = 0;\\n        int curr_prod = 1;\\n        for(int i = 0 ; i < n ; i++) // Traverse in the forward direction \\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        curr_prod = 1;\\n        for(int i = n-1 ; i>=0 ; i--) // Traverse in the backward direction\\n        {\\n            curr_prod *= nums[i];\\n            max_prod = max(max_prod , curr_prod);\\n            if(curr_prod == 0)\\n            {\\n                curr_prod = 1;\\n            }\\n        }\\n        return max_prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981322,
                "title": "python-3-using-kadane-s-algo",
                "content": "##### Runtime: **40 ms**, faster than **99.70%** of Python3 online submissions for Maximum Product Subarray.\\n##### Memory Usage: **14.3 MB**, less than **77.96%** of Python3 online submissions for Maximum Product Subarray.\\n```python\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        max_product = nums[0] \\n        min_product = nums[0]\\n        result = max_product\\n        for i in range(1,len(nums)):\\n            curr = nums[i]\\n            \\n            temp_max = max(curr , max_product*curr , min_product*curr)\\n            min_product = min(curr , max_product*curr , min_product*curr)\\n            max_product = temp_max\\n            \\n            result = max(max_product , result)\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        max_product = nums[0] \\n        min_product = nums[0]\\n        result = max_product\\n        for i in range(1,len(nums)):\\n            curr = nums[i]\\n            \\n            temp_max = max(curr , max_product*curr , min_product*curr)\\n            min_product = min(curr , max_product*curr , min_product*curr)\\n            max_product = temp_max\\n            \\n            result = max(max_product , result)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947589,
                "title": "similar-to-kadane-s-algorithm",
                "content": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int p = 1,p1 = 1;\\n        int res = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            p = p*nums[i];\\n            p1 = p1*nums[n-i-1];\\n            \\n            res = max(res,max(p,p1));\\n            \\n            \\n            if(p==0){\\n               p=1;\\n            }\\n            if(p1==0){\\n                p1=1;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int p = 1,p1 = 1;\\n        int res = INT_MIN;\\n        for(int i = 0;i<n;i++){\\n            p = p*nums[i];\\n            p1 = p1*nums[n-i-1];\\n            \\n            res = max(res,max(p,p1));\\n            \\n            \\n            if(p==0){\\n               p=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 833735,
                "title": "c-easyunderstanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==0) return -1;\\n        int currmax=nums[0],currmin=nums[0],finalmax=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           int temp=currmax;\\n           currmax=max(currmax*nums[i],max(currmin*nums[i],nums[i]));\\n           currmin=min(temp*nums[i],min(currmin*nums[i],nums[i]));\\n           if(currmax>finalmax) finalmax=currmax;\\n        }\\n        return finalmax;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size()==0) return -1;\\n        int currmax=nums[0],currmin=nums[0],finalmax=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n           int temp=currmax;\\n           currmax=max(currmax*nums[i],max(currmin*nums[i],nums[i]));\\n           currmin=min(temp*nums[i],min(currmin*nums[i],nums[i]));\\n           if(currmax>finalmax) finalmax=currmax;\\n        }\\n        return finalmax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716775,
                "title": "simplest-logic-o-n-solution-100-accuracy",
                "content": "```\\nint maxProduct(vector<int>& nums) {  \\n        if(nums.size()==1)\\n          return nums[0];\\n        int curr_max=nums[0];\\n        int curr_min=nums[0]; \\n        int prev_min=nums[0]; \\n        int prev_max=nums[0]; \\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n          curr_max=max(nums[i]*prev_max,max(nums[i]*prev_min,nums[i]));\\n          curr_min=min(nums[i]*prev_min,min(nums[i]*prev_max,nums[i]));\\n          ans=max(ans,curr_max); \\n          prev_min=curr_min; \\n          prev_max=curr_max;\\n        } \\n        return ans;  \\n\\t\\t}\\n\\t\\t``` \\n\\t\\tIf you like my solution please upvote.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxProduct(vector<int>& nums) {  \\n        if(nums.size()==1)\\n          return nums[0];\\n        int curr_max=nums[0];\\n        int curr_min=nums[0]; \\n        int prev_min=nums[0]; \\n        int prev_max=nums[0]; \\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n          curr_max=max(nums[i]*prev_max,max(nums[i]*prev_min,nums[i]));\\n          curr_min=min(nums[i]*prev_min,min(nums[i]*prev_max,nums[i]));\\n          ans=max(ans,curr_max); \\n          prev_min=curr_min; \\n          prev_max=curr_max;\\n        } \\n        return ans;  \\n\\t\\t}\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 386011,
                "title": "simplest-java-solution-beats-100-memory-100-o-n-time-o-1-space",
                "content": "**Here is my simple Java solution 2 for-loops.. \\none from [0->n] && [n-1 -> 0] :**\\n\\n```   \\n    public int maxProduct(int[] nums) {\\n        int max_product_so_far = Integer.MIN_VALUE;\\n\\n        int curr_product = 1;\\n        for(int i=0; i<nums.length; i++) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        curr_product = 1; // reset\\n        for(int i=nums.length-1; i>=0; i--) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        return max_product_so_far;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n    public int maxProduct(int[] nums) {\\n        int max_product_so_far = Integer.MIN_VALUE;\\n\\n        int curr_product = 1;\\n        for(int i=0; i<nums.length; i++) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        curr_product = 1; // reset\\n        for(int i=nums.length-1; i>=0; i--) {\\n            curr_product *= nums[i];\\n\\n            if(curr_product > max_product_so_far) {\\n                max_product_so_far = curr_product;\\n            }\\n\\n            if(curr_product == 0) {\\n                curr_product = 1;\\n            }\\n        }\\n\\n        return max_product_so_far;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48461,
                "title": "a-naive-but-straigtforward-solution",
                "content": "When encounter a 0, split the sequence and get the max of the left, right, and 0.\\nIf the accumulative result is negative, check two cases: 1. divide out the elements from left till the first\\nnegative element. 2. divide out the elements from right till the first negative element. Return the max result.\\n\\n    int helper(int A[], int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        if (l == r) {\\n            return A[l];\\n        }\\n        \\n        int max_prod = INT_MIN;\\n        int acc = 1;\\n        for (int i = l; i <= r; ++i) {\\n            if (A[i] == 0) {\\n                return max(helper(A, l, i - 1), max(0, helper(A, i + 1, r)));\\n            }\\n            acc *= A[i];\\n            max_prod = max(max_prod, acc);\\n        }\\n        \\n        // find first negtive number from left and divide out elements before it (including itself).\\n        if (acc < 0) {\\n            for (int i = l; i <= r; ++i) {\\n                acc /= A[i];\\n                if (A[i] < 0) {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return max(max_prod, acc);\\n    }\\n\\n    int maxProduct(int A[], int n) {\\n        return helper(A, 0, n - 1);\\n    }",
                "solutionTags": [],
                "code": "When encounter a 0, split the sequence and get the max of the left, right, and 0.\\nIf the accumulative result is negative, check two cases: 1. divide out the elements from left till the first\\nnegative element. 2. divide out the elements from right till the first negative element. Return the max result.\\n\\n    int helper(int A[], int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        if (l == r) {\\n            return A[l];\\n        }\\n        \\n        int max_prod = INT_MIN;\\n        int acc = 1;\\n        for (int i = l; i <= r; ++i) {\\n            if (A[i] == 0) {\\n                return max(helper(A, l, i - 1), max(0, helper(A, i + 1, r)));\\n            }\\n            acc *= A[i];\\n            max_prod = max(max_prod, acc);\\n        }\\n        \\n        // find first negtive number from left and divide out elements before it (including itself).\\n        if (acc < 0) {\\n            for (int i = l; i <= r; ++i) {\\n                acc /= A[i];\\n                if (A[i] < 0) {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return max(max_prod, acc);\\n    }\\n\\n    int maxProduct(int A[], int n) {\\n        return helper(A, 0, n - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3266225,
                "title": "c-javascript-o-n-time-o-1-space-100-fast-comment-explained-max-prod-subarray",
                "content": "# Intuition\\n- The intuition behind the given code is to traverse the array twice, once from start to end and once from end to start, to find the maximum product subarray.\\n\\n- The key idea is to keep track of the current product of elements encountered so far during both traversals, and update the maximum product found so far accordingly. In case the current product becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\n- By traversing the array twice in opposite directions, the code ensures that it explores all possible subarrays that may result in a maximum product. By taking the maximum value obtained from both traversals, the code returns the maximum product subarray.\\n\\nOverall, the approach used in the code is intuitive and easy to understand, and provides an efficient solution to the maximum product subarray problem.\\n\\n# Approach\\nThe approach used in this code is to traverse the array twice but in one loop using two pointers - once from start to end, and once from end to start. During both traversals, two variables \"pro1\" and \"pro2\" are used to keep track of the current product of elements encountered so far, while another two variables \"max1\" and \"max2\" are used to store the maximum product found so far.\\n\\nFor the forward traversal, the code multiplies each element of the array with the current product \"pro1\" and updates \"max1\" with the maximum value obtained so far. If the current product \"pro1\" becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\nFor the backward traversal, the code multiplies each element of the array with the current product \"pro2\" and updates \"max2\" with the maximum value obtained so far. If the current product \"pro2\" becomes 0, it is reset to 1 because any further multiplication with 0 will result in a product of 0.\\n\\nFinally, the code returns the maximum value of \"max1\" and \"max2\" as the answer.\\n\\nThis approach takes O(N) time, where N is the size of the input array, and uses O(1) extra space, making it an efficient solution to the problem.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity:O(n)**\\nAs we are traversing the entire vector for only one time so we have a linear time complexity and that of the size of the vector.\\n\\n- **Space complexity: O(1)**\\nAs we have only used variables so we have space complexity of O(1)\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int max1=INT_MIN,pro1=1,max2=INT_MIN,pro2=1,s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n            pro1*=nums[i];\\n            max1=max(pro1,max1);//storing the maximum of current_product and max1 in max1;\\n            pro1=(pro1==0?1:pro1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n            \\n            //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n            pro2*=nums[s-1-i];\\n            max2=max(pro2,max2);\\n            pro2=(pro2==0?1:pro2);// if we get 0 at any moment, we update the current_product(pro2) by 1.\\n        }\\n        return max(max1,max2);    \\n    }\\n};\\n```\\n\\n\\n# JavaScript\\n```\\nfunction max(a,b)\\n{\\n    if(a>b)\\n        return a;\\n    else\\n        return b;\\n};\\n\\nvar maxProduct = function(nums) \\n{\\n    var max1=-100,max2=-100,prod1=1,prod2=1,s=nums.length;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n        prod1*=nums[i];\\n        max1=max(max1,prod1);//storing the maximum of current_product and max1 in max1;\\n        prod1=(prod1==0?1:prod1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n\\n        //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n        prod2*=nums[s-1-i];\\n        max2=max(max2,prod2);\\n        prod2=(prod2==0?1:prod2);// if we get 0 at any moment, we update the current_product(pro2) by 1.     \\n    }    \\n    return max(max1,max2);\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int max1=INT_MIN,pro1=1,max2=INT_MIN,pro2=1,s=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n            pro1*=nums[i];\\n            max1=max(pro1,max1);//storing the maximum of current_product and max1 in max1;\\n            pro1=(pro1==0?1:pro1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n            \\n            //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n            pro2*=nums[s-1-i];\\n            max2=max(pro2,max2);\\n            pro2=(pro2==0?1:pro2);// if we get 0 at any moment, we update the current_product(pro2) by 1.\\n        }\\n        return max(max1,max2);    \\n    }\\n};\\n```\n```\\nfunction max(a,b)\\n{\\n    if(a>b)\\n        return a;\\n    else\\n        return b;\\n};\\n\\nvar maxProduct = function(nums) \\n{\\n    var max1=-100,max2=-100,prod1=1,prod2=1,s=nums.length;\\n    for(var i=0;i<nums.length;i++)\\n    {\\n        //traversing from start to end and keeping the record for maximum current_product(pro1) we get till now\\n        prod1*=nums[i];\\n        max1=max(max1,prod1);//storing the maximum of current_product and max1 in max1;\\n        prod1=(prod1==0?1:prod1);// if we get 0 at any moment, we update the current_product(pro1) by 1.\\n\\n        //traversing from end to start and keeping the record for maximum current_product(pro2) we get till now\\n        prod2*=nums[s-1-i];\\n        max2=max(max2,prod2);\\n        prod2=(prod2==0?1:prod2);// if we get 0 at any moment, we update the current_product(pro2) by 1.     \\n    }    \\n    return max(max1,max2);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746278,
                "title": "c-approach-kadane-algorithm",
                "content": "\\n      int maxProduct(vector<int>& nums) {\\n        \\n        int max_product=INT_MIN;\\n        int curr_product = 1;\\n        // we will check the max product from both side of array\\n\\t\\t//prefix sum max\\n        for(int i=0; i<nums.size(); i++){\\n            curr_product *= nums[i];\\n            max_product = max(max_product, curr_product);\\n            if(nums[i]==0)\\n                curr_product=1;\\n        }\\n         curr_product = 1;\\n         //[3 , -1 , 4]  this array can\\'t give result if we just pass from front so we have to check from back also\\n\\t\\t //suffix sum max\\n         for(int i = nums.size()-1 ; i>=0 ; i--)\\n         {\\n             curr_product *= nums[i];\\n             \\n             max_product = max(max_product , curr_product);\\n             \\n             if(nums[i]==0)\\n                 curr_product = 1;\\n         }\\n         return max_product;\\n     }\\n\\t \\n// plzz upvote if u like the solution else ask any doubt",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n      int maxProduct(vector<int>& nums) {\\n        \\n        int max_product=INT_MIN;\\n        int curr_product = 1;\\n        // we will check the max product from both side of array\\n\\t\\t//prefix sum max\\n        for(int i=0; i<nums.size(); i++){\\n            curr_product *= nums[i];\\n            max_product = max(max_product, curr_product);\\n            if(nums[i]==0)\\n                curr_product=1;\\n        }\\n         curr_product = 1;\\n         //[3 , -1 , 4]  this array can\\'t give result if we just pass from front so we have to check from back also\\n\\t\\t //suffix sum max\\n         for(int i = nums.size()-1 ; i>=0 ; i--)\\n         {\\n             curr_product *= nums[i];\\n             \\n             max_product = max(max_product , curr_product);\\n             \\n             if(nums[i]==0)\\n                 curr_product = 1;\\n         }\\n         return max_product;\\n     }\\n\\t \\n// plzz upvote if u like the solution else ask any doubt",
                "codeTag": "Unknown"
            },
            {
                "id": 1467258,
                "title": "dp-solution-with-one-pass",
                "content": "At a moment, we need to keep track of the maximum product and the minimum product while parsing through the array. We will use a 2-D array to save max and min at a particular stage.\\nFor e.g., \\n`dp[i][0]` will store the maximum product\\n`dp[i][1]` will store the minimum product\\n\\nWe need to keep a track of the min product due to negative numbers. A negative result can become a higher positive number, when multiplied by another negative number.\\n\\n\\n```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n\\t\\t/* Array to keep track of max and min product at i */\\n        int[][] dp = new int[n][2];\\n\\t\\t\\n\\t\\t/* Initialize the base case scenario for dp */\\n        int result = nums[0];\\n        dp[0][0] = result;\\n        dp[0][1] = result;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] >= 0){\\n\\t\\t\\t/* If the current number is greater than zero, we will get the maximum by multiplying with the last max value */\\n                dp[i][0] = Math.max(dp[i-1][0] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][1] * nums[i], nums[i]);\\n            } else {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tIf the current number is negative, \\n\\t\\t\\t\\twe will get the maximum value by multiplying with the last min value \\n\\t\\t\\t\\tHence, max is checked with dp[i-1][1], i.e, the last min value.\\n\\t\\t\\t\\t*/\\n                dp[i][0] = Math.max(dp[i-1][1] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][0] * nums[i], nums[i]);\\n            }\\n            \\n            result = Math.max(result, dp[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int n = nums.length;\\n\\t\\t/* Array to keep track of max and min product at i */\\n        int[][] dp = new int[n][2];\\n\\t\\t\\n\\t\\t/* Initialize the base case scenario for dp */\\n        int result = nums[0];\\n        dp[0][0] = result;\\n        dp[0][1] = result;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] >= 0){\\n\\t\\t\\t/* If the current number is greater than zero, we will get the maximum by multiplying with the last max value */\\n                dp[i][0] = Math.max(dp[i-1][0] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][1] * nums[i], nums[i]);\\n            } else {\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tIf the current number is negative, \\n\\t\\t\\t\\twe will get the maximum value by multiplying with the last min value \\n\\t\\t\\t\\tHence, max is checked with dp[i-1][1], i.e, the last min value.\\n\\t\\t\\t\\t*/\\n                dp[i][0] = Math.max(dp[i-1][1] * nums[i], nums[i]);\\n                dp[i][1] = Math.min(dp[i-1][0] * nums[i], nums[i]);\\n            }\\n            \\n            result = Math.max(result, dp[i][0]);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376980,
                "title": "c-o-n-time-kadane-s-algorithm",
                "content": "```\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        ll maxEnding = nums[0];\\n        ll minEnding = nums[0];\\n        ll res = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n           ll x = nums[i];\\n           if(x<0)\\n               swap(minEnding, maxEnding);\\n           minEnding = min(x,minEnding*x);\\n           maxEnding = max(x,maxEnding*x);\\n            \\n           res=max(res,maxEnding); \\n        }\\n        return res;   \\n    }\\n\\t\\n\\tPlease Upovote if you got any help from my code :)",
                "solutionTags": [],
                "code": "```\\n    int maxProduct(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        ll maxEnding = nums[0];\\n        ll minEnding = nums[0];\\n        ll res = nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n           ll x = nums[i];\\n           if(x<0)\\n               swap(minEnding, maxEnding);\\n           minEnding = min(x,minEnding*x);\\n           maxEnding = max(x,maxEnding*x);\\n            \\n           res=max(res,maxEnding); \\n        }\\n        return res;   \\n    }\\n\\t\\n\\tPlease Upovote if you got any help from my code :)",
                "codeTag": "Unknown"
            },
            {
                "id": 843820,
                "title": "say-goodbye-to-kadane-hello-to-intuitive-o-n-prefix-sum-solution-java",
                "content": "Why wrap your head around complicated kadane logic?\\n\\nPrefix sums are applicable for the majority of product or sum subarray problems.\\nSo whenever you see finding sum or product subarrays that meet a certain criteria, prefix sums should be the first thing that jump to your head. \\n\\nThis problem is a  bit tricker than maximum sum, but the idea is the same.\\nWe keep a running product, and divide by previous subarrays to maximize our results.\\n\\nThere are 3 cases to note:\\n1. if the running product is positive we can just be greedy and take the entire running product\\n2. if the running product is negative, we need to divide by the previous largest negative running product (or the running product that is closest to zero). We do this because we want the subarray to have the highest possible result.\\n3. if current number is zero, then this is essentially a reset, and we reset all our variables except the max and act as if the array had been bisected.\\n```\\npublic int maxProduct(int[] nums) {\\n        int runningProduct = 1;\\n        int max = nums[0];\\n        int largestNegative = Integer.MIN_VALUE;\\n        \\n        for (int num: nums) {\\n            runningProduct *= num;\\n            max = Math.max(max, runningProduct);\\n\\t\\t\\t// reset if zero\\n            if (num == 0) {\\n                runningProduct = 1;\\n                largestNegative = Integer.MIN_VALUE;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Our product is negative \\n            if (runningProduct < 0) {\\n                if (largestNegative != Integer.MIN_VALUE) {\\n\\t\\t\\t\\t// Divide by negative number closest to zero to maximize subarray\\n                    max = Math.max(max, runningProduct / largestNegative); \\n                }\\n                largestNegative = Math.max(largestNegative, runningProduct);\\n            }\\n        }\\n        return max;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int maxProduct(int[] nums) {\\n        int runningProduct = 1;\\n        int max = nums[0];\\n        int largestNegative = Integer.MIN_VALUE;\\n        \\n        for (int num: nums) {\\n            runningProduct *= num;\\n            max = Math.max(max, runningProduct);\\n\\t\\t\\t// reset if zero\\n            if (num == 0) {\\n                runningProduct = 1;\\n                largestNegative = Integer.MIN_VALUE;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Our product is negative \\n            if (runningProduct < 0) {\\n                if (largestNegative != Integer.MIN_VALUE) {\\n\\t\\t\\t\\t// Divide by negative number closest to zero to maximize subarray\\n                    max = Math.max(max, runningProduct / largestNegative); \\n                }\\n                largestNegative = Math.max(largestNegative, runningProduct);\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841111,
                "title": "c-o-n-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProduct(std::vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==0) return 0;\\n        int R = nums[0];\\n        /*\\n        The idea is to traverse array from left to right keeping two variables minVal and maxVal \\n        which represents the minimum and maximum product value till the ith index of the array. \\n        Now, if the ith element of the array is negative that means now the values of minVal and maxVal \\n        will be swapped as value of maxVal will become minimum by multiplying it with a negative number. \\n        Now, compare the minVal and maxVal. The value of minVal and maxVal depends on the current index \\n        element or the product of the current index element and the previous minVal and maxVal respectively.\\n        */\\n        int maxVal = R, minVal = R;\\n        for (int i = 1; i < n; i++) { \\n  \\n            // When multiplied by -ve number, \\n            // maxVal becomes minVal \\n            // and minVal becomes maxVal. \\n            if (nums[i] < 0) std::swap(maxVal, minVal);\\n  \\n            // maxVal and minVal stores the \\n            // product of subarray ending at arr[i]. \\n            maxVal = std::max(nums[i], maxVal * nums[i]); \\n            minVal = std::min(nums[i], minVal * nums[i]); \\n  \\n            // Max Product of array. \\n            R = max(R, maxVal); \\n        } \\n        return R;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(std::vector<int>& nums) {\\n        int n = nums.size();\\n        if (n==0) return 0;\\n        int R = nums[0];\\n        /*\\n        The idea is to traverse array from left to right keeping two variables minVal and maxVal \\n        which represents the minimum and maximum product value till the ith index of the array. \\n        Now, if the ith element of the array is negative that means now the values of minVal and maxVal \\n        will be swapped as value of maxVal will become minimum by multiplying it with a negative number. \\n        Now, compare the minVal and maxVal. The value of minVal and maxVal depends on the current index \\n        element or the product of the current index element and the previous minVal and maxVal respectively.\\n        */\\n        int maxVal = R, minVal = R;\\n        for (int i = 1; i < n; i++) { \\n  \\n            // When multiplied by -ve number, \\n            // maxVal becomes minVal \\n            // and minVal becomes maxVal. \\n            if (nums[i] < 0) std::swap(maxVal, minVal);\\n  \\n            // maxVal and minVal stores the \\n            // product of subarray ending at arr[i]. \\n            maxVal = std::max(nums[i], maxVal * nums[i]); \\n            minVal = std::min(nums[i], minVal * nums[i]); \\n  \\n            // Max Product of array. \\n            R = max(R, maxVal); \\n        } \\n        return R;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624591,
                "title": "thoroughly-explained-0ms-solution",
                "content": "Its like the kadan\\'s algorithm for maximum subarray sum. In the first pass, we calculate subarray products between any two zeroes in the array and update the maximum product. In the second pass we do the same thing but from backwards. So why we did this?\\nIf we didn\\'t had negative numbers, first pass itself would have given the us answer. But we have negative numbers, so** between any two zeroes** ,number of negative numbers can be even or odd. If they are even ,then first and second pass products between the two zeroes will be same. But if they are odd then first pass will keep the product till the last negative number and the second pass will keep the product excluding numbers before first negative number.Then we will update maximum of them. \\nFor Example: [1,0,-3,4,-6,-5,9,0,2]\\nBetween the two zeroes, first pass will give ((-3)*4*(-6)) as max product and second pass will give 9*(-5)*(-6)*4 as maxproduct and result will update maximum of them.\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }\\n        }\\n        prod = 1;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n        \\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }      \\n        }\\n        return result;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }\\n        }\\n        prod = 1;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n        \\n            prod = prod * nums[i];\\n            result = Math.max(prod, result);\\n            if(prod == 0) {\\n                prod = 1;\\n            }      \\n        }\\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 521432,
                "title": "python-3-simple-dp",
                "content": "If the array had all positive numbers, then the max product includes all the elements in the array\\n\\nAs we have +ve,  -ve integers and 0 in the input array, there are 3 choices at every index `i`\\n\\n1. Max product starts at `nums[i]`\\n2. Max product is obtained by multiplying  `nums[i]` with the minimum product so far\\n3. Max product is obtained by mulitiplying `nums[i]` with the maximum product so far\\n\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int\\n        \\n        ans = max_so_far = min_so_far = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            \\n            candidates = (nums[i], max_so_far*nums[i], min_so_far*nums[i])\\n            max_so_far = max(candidates)\\n            min_so_far = min(candidates)\\n            ans = max(ans, max_so_far)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int\\n        \\n        ans = max_so_far = min_so_far = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            \\n            candidates = (nums[i], max_so_far*nums[i], min_so_far*nums[i])\\n            max_so_far = max(candidates)\\n            min_so_far = min(candidates)\\n            ans = max(ans, max_so_far)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488903,
                "title": "100-with-detailed-explanation-o-n-time-0-1-space",
                "content": "First of all, you better be familiar with the \"Max Contiguous Subarray Sum\" problem, as this one is a modification (and the more complicated one, on my mind).\\n\\nThe general idea is: on each step we have a choise: \\n1) either we want to continue to join to the sequence \\n2) or to start a new sequence\\n\\nThat is pretty easy to decide, if we want to know a SUM or we don\\'t have negative numbers (but have zeros).\\nAssume that we don\\'t have negative, but have zeroes.\\nIn that case the only possible options for a max product are the islands that lie between zeroes.\\nWe solve that easily by the general idea mentioned above, particulary with: `max = Math.max(max * nums[i], nums[i])`\\n\\nThen the case, with negative numbers happens to appear.\\nIf you think about it, negative numbers don\\'t matter if their amount is even. Following this idea, we could have an intuition that if we have already stepped on a negative number before, and we do it again at the current iteration, then we\\'d like to know about it. Here `min` logic comes.\\n\\nWe store `min` value in the same way as we do with `max`. And we use it every time when we step on the negative number - we swap the `min` and the `max` and it is important that we do that before we do the next choice.\\n\\nNote, that it means we don\\'t always have `max` as the absolute maximum value (as we do in the similar \"sum\" problem), for that purpose we use `result` variable.\\n\\n```\\nvar maxProduct = function(nums) {\\n    let max = nums[0]\\n    let min = nums[0]\\n    let result = nums[0]\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < 0) {\\n            let temp = min\\n            min = max\\n            max = temp\\n        }\\n        \\n\\t\\t// make the choice\\n        max = Math.max(max * nums[i], nums[i])\\n        min = Math.min(min * nums[i], nums[i])\\n        result = Math.max(result, max)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxProduct = function(nums) {\\n    let max = nums[0]\\n    let min = nums[0]\\n    let result = nums[0]\\n    \\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] < 0) {\\n            let temp = min\\n            min = max\\n            max = temp\\n        }\\n        \\n\\t\\t// make the choice\\n        max = Math.max(max * nums[i], nums[i])\\n        min = Math.min(min * nums[i], nums[i])\\n        result = Math.max(result, max)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481891,
                "title": "python-o-n-rolling-kadane-algo-w-explanation",
                "content": "[DP solution tutorial video DP\\u52D5\\u614B\\u898F\\u5283\\u89E3\\u7B54\\u7684\\u89E3\\u984C\\u5F71\\u7247](https://www.youtube.com/watch?v=BBA1wARHhU0)\\n\\n\\nPython O( n ) sol. by rolling twice.\\n\\n\\'\\'\\'\\nExample explanation:\\n\\ninput = [ 2, 3, -2, 4 ]\\n\\nproduct_left_to_right = input = [ 2, 3, -2, 4 ]\\n\\nproduct_right_to_left = input[::-1] = [ 4, -2, 3, 2 ]\\n\\n---\\n\\n1st iteration:\\n\\n6 = 3 * 2\\nproduct_left_to_right = [ 2, **6**, -2, 4 ] \\n\\n-8 = -2 * 4\\nproduct_right_to_left = [ 4, **-8**, 3, 2 ]\\n\\n---\\n\\n2nd iteration:\\n\\n-12 = -2 * 6\\nproduct_left_to_right = [ 2, 6, **-12**, 4 ] \\n\\n-24 = 3 * -8\\nproduct_right_to_left = [ 4, -8, **-24**, 2 ]\\n\\n---\\n\\n3rd iteration:\\n\\n-48 = 4 * -12\\nproduct_left_to_right = [ 2, 6, -12, **-48** ] \\n\\n-48 = 2 * -24\\nproduct_right_to_left = [ 4, -8, -24, **-48** ]\\n\\n\\n---\\n\\ncomparison of max:\\n\\nmax of product_left_to_right = [ 2, **6**, -12, -48 ]  = **6**\\n\\nmax of product_right_to_left = [ **4**, -8, -24, -48 ] = **4**\\n\\n---\\n\\nmax of ( **6**, **4** ) = **6**\\n\\nreturn **6**\\n\\n\\'\\'\\'\\n\\n---\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        product_left_to_right = nums\\n        \\n        product_right_to_left = nums[::-1]\\n        \\n        # update product of two kinds of subarray, \\n\\t\\t# one is extending from left to right, the other is from right to left\\n        for i in range(1, size):\\n            \\n            # extends from left hand side, if meets 0 then restart in-place by itself.\\n\\t\\t\\t\\n            product_left_to_right[i] *= (product_left_to_right[i-1] or 1)\\n            \\n\\t\\t\\t\\n            # extends from right hand side, if meets 0 then restart in-place by itself\\n\\t\\t\\t\\n            product_right_to_left[i] *= (product_right_to_left[i-1] or 1)\\n            \\n\\t\\t\\t\\n        return max(max(product_left_to_right), max(product_right_to_left))\\n```\\n\\n---\\n\\nShare another implementation with Kadane\\'s algorithm\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        \\n        for number in nums[1:]:\\n            \\n            # local max comes from product of two positive numbers or product of two negative numbers\\n            local_max = max(prev_max * number, prev_min * number, number)\\n            local_min = min(prev_max * number, prev_min * number, number)\\n            \\n\\t\\t\\t# update global max\\n            global_max = max(global_max, local_max)\\n            \\n            prev_max, prev_min = local_max, local_min\\n            \\n        \\n        return global_max\\n```\\n\\n---\\n\\nShare another implementation with Kadane algorithm in top-down DP\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        \\n        def dp( i ):\\n            \\n            if i == 0:\\n                # Base case on index 0\\n                # min value, max value, max product are first value in array\\n                return nums[0], nums[0], nums[0]\\n            \\n            \\n            ## General cases\\n            \\n            prev_min, prev_max, prev_product = dp(i-1)\\n            \\n            # local max comes from product of two positive numbers, or product of two negative numbers\\n            candidate = [prev_min * nums[i], prev_max * nums[i], nums[i] ]\\n            cur_min = min( candidate )\\n            cur_max = max( candidate )\\n            product = max(prev_product, cur_max)\\n            \\n            return cur_min, cur_max, product\\n        \\n        # ----------------------------------------\\n        return dp( len(nums)-1 )[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        product_left_to_right = nums\\n        \\n        product_right_to_left = nums[::-1]\\n        \\n        # update product of two kinds of subarray, \\n\\t\\t# one is extending from left to right, the other is from right to left\\n        for i in range(1, size):\\n            \\n            # extends from left hand side, if meets 0 then restart in-place by itself.\\n\\t\\t\\t\\n            product_left_to_right[i] *= (product_left_to_right[i-1] or 1)\\n            \\n\\t\\t\\t\\n            # extends from right hand side, if meets 0 then restart in-place by itself\\n\\t\\t\\t\\n            product_right_to_left[i] *= (product_right_to_left[i-1] or 1)\\n            \\n\\t\\t\\t\\n        return max(max(product_left_to_right), max(product_right_to_left))\\n```\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        global_max = prev_max = prev_min = nums[0]\\n        \\n        for number in nums[1:]:\\n            \\n            # local max comes from product of two positive numbers or product of two negative numbers\\n            local_max = max(prev_max * number, prev_min * number, number)\\n            local_min = min(prev_max * number, prev_min * number, number)\\n            \\n\\t\\t\\t# update global max\\n            global_max = max(global_max, local_max)\\n            \\n            prev_max, prev_min = local_max, local_min\\n            \\n        \\n        return global_max\\n```\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        \\n        \\n        def dp( i ):\\n            \\n            if i == 0:\\n                # Base case on index 0\\n                # min value, max value, max product are first value in array\\n                return nums[0], nums[0], nums[0]\\n            \\n            \\n            ## General cases\\n            \\n            prev_min, prev_max, prev_product = dp(i-1)\\n            \\n            # local max comes from product of two positive numbers, or product of two negative numbers\\n            candidate = [prev_min * nums[i], prev_max * nums[i], nums[i] ]\\n            cur_min = min( candidate )\\n            cur_max = max( candidate )\\n            product = max(prev_product, cur_max)\\n            \\n            return cur_min, cur_max, product\\n        \\n        # ----------------------------------------\\n        return dp( len(nums)-1 )[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330822,
                "title": "dp-with-o-n-time-complexity-and-o-1-space",
                "content": "\\u4F46\\u5B9E\\u9645\\u4E0A\\uFF0C\\u8FD9\\u4E2A\\u9898\\u786E\\u5B9E\\u662F\\u4E00\\u4E2A\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u9898\\uFF0C\\u4E0D\\u8FC7\\u8FD9\\u4E2A\\u9898\\u53EF\\u4EE5\\u505A\\u5F88\\u591A\\u4F18\\u5316\\uFF0C\\u800C\\u4E0D\\u9700\\u8981\\u505A\\u4E00\\u4E2A$O(n^2)$\\u7684\\u89E3\\u7B54\\u3002\\n\\n\\u8FD9\\u4E2A\\u9898\\u5177\\u6709\\u6700\\u4F18\\u5B50\\u7ED3\\u6784\\uFF0C\\u56E0\\u4E3A\\u5FC5\\u987B\\u8981\\u8FDE\\u7EED\\u7684\\u5B50\\u6570\\u7EC4\\u3002\\u6240\\u4EE5\\u5F53\\u524D\\u7684\\u89E3\\u4E2D\\u7684\\u4E00\\u90E8\\u5206\\u4E5F\\u4E00\\u5B9A\\u662F\\u67D0\\u4E2A\\u89E3\\u3002\\n\\n\\u8FD9\\u4E2A\\u9898\\u7684DP\\u7684\\u503C\\u5E94\\u8BE5\\u8BBE\\u7ACB\\u6210**\\u4EE5nums[i]\\u4E3A\\u7ED3\\u5C3E\\u65F6\\u7684\\u5B50\\u6570\\u7EC4\\u7684\\u6700\\u5927\\u503C\\u548C\\u6700\\u5C0F\\u503C**, \\u4E4B\\u6240\\u4EE5\\u8981\\u7EF4\\u6301\\u6700\\u5C0F\\u503C, \\u662F\\u56E0\\u4E3A\\u5982\\u679C\\u78B0\\u5230\\u4E00\\u4E2A\\u5C0F\\u4E8E0\\u7684\\u6570\\u5B57, \\u5C0F\\u4E8E0\\u7684\\u6570\\u5B57\\u4E58\\u4EE5\\u6700\\u5C0F\\u503C\\u53EF\\u80FD\\u4F1A\\u5F97\\u5230\\u6700\\u5927\\u503C.\\n\\n\\u6240\\u4EE5\\u5176\\u5B9E\\u53EA\\u9700\\u8981\\u7EF4\\u6301\\u4E24\\u4E2A\\u503C\\u5C31\\u53EF\\u4EE5\\u77E5\\u9053\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u4E86. \\u4E00\\u4E2A\\u662F\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u7684\\u6700\\u5927\\u503C, \\u4E00\\u4E2A\\u662F\\u4E0A\\u4E00\\u4E2A\\u72B6\\u6001\\u7684\\u6700\\u5C0F\\u503C. \\u56E0\\u6B64\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u7EF4\\u6301\\u5728$O(1)$\\u5373\\u53EF.\\n\\n\\u5728\\u6C42\\u6574\\u4E2A\\u6570\\u7EC4\\u7684\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u8BB0\\u5F55\\u4E0B\\u6765\\u6700\\u5927\\u503C\\u5373\\u53EF\\u3002\\n\\n```\\n    int maxProduct(vector<int>& nums) {\\n        int mx, lastMax, lastMin;\\n        mx = lastMax = lastMin = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n\\n            int curMax = max(max(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n            int curMin = min(min(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n\\n            lastMax = curMax;\\n            lastMin = curMin;\\n\\n            if(curMax > mx)\\n                mx = curMax;\\n        }\\n        return mx;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int maxProduct(vector<int>& nums) {\\n        int mx, lastMax, lastMin;\\n        mx = lastMax = lastMin = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++){\\n\\n            int curMax = max(max(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n            int curMin = min(min(nums[i], nums[i]*lastMax), nums[i]*lastMin);\\n\\n            lastMax = curMax;\\n            lastMin = curMin;\\n\\n            if(curMax > mx)\\n                mx = curMax;\\n        }\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 242415,
                "title": "a-java-solution-with-detailed-explanation-of-all-possible-cases",
                "content": "The code is simple, but the logic of all possible cases is a little bit complex.\\n\\nUse two global variables:\\n\\n* **prodMax**: max accumulative product of the array which ends on current position\\n* **prodMin**: min accumulative product of the array which ends on current position\\n\\nFor each position of the array, we need to check:\\n\\n* If nums[i] > 0:\\n  * If prodMax > 0, it means we can add current position (nums[i]) to subarray[...i-1] for a bigger prodMax; else we reset prodMax (create a new subarray which starts from current position). The code is: ```prodMax = prodMax > 0 ? prodMax * nums[i] : nums[i] ```\\n  * If prodMin < 0, it means we can add current position (nums[i]) to subarray[...i-1] for a smaller prodMin; else we reset prodMin (create a new subarray which starts from current position). The code is: ```prodMin = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\\n\\n* If nums[i] < 0:\\n  * If prodMin < 0, it means we can add current position (nums[i]) to subarray[...i-1] for a bigger prodMax by multiplying nums[i] and prodMin (**since they are both negative, the multiplication will result in a big positive number**). Else we reset prodMax (create a new subarray which starts from current position). The code is: ```prodMax = prodMin < 0 ? prodMin * nums[i] : nums[i] ``` \\n  * If prodMax > 0, it means we can add current position (nums[i]) to subarray[...i-1] for a smaller prodMin by multiplying nums[i] and prodMin (**since nums[i] < 0 and prodMax > 0, the multiplication will result in a big negative number**). Else we reset prodMin (create a new subarray which starts from current position). The code is: ```prodMin = prodMax > 0 ? prodMax * nums[i] : nums[i]```\\n\\nNote that if nums[i] == 0, either logic works; so we don\\'t need to care about the case. The same is for prodMax/prodMin == 0.\\n\\n(An important logic is: if nums[i] < 0, new prodMax is decided by only `prodMin` and `nums[i]`, and **not** related to old prodMax. Since prodMax is always bigger than proMin, the multiplications with a negative value should always get a smaller value from prodMax and a bigger value from proMin. The logic is the same for new prodMin.)\\n\\nFor an implementation, we need to use posVal and negVal to save the results in advance, otherwise the modified prodMax/prodMin will impact the successive calculation. The code is:\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = posVal > 0 ? posVal : nums[i];\\n                prodMin = negVal < 0 ? negVal : nums[i];\\n            } else {\\n                prodMax = negVal > 0 ? negVal : nums[i];\\n                prodMin = posVal < 0 ? posVal : nums[i];\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nA simplification is, we don\\'t need to check posVal/negVal actually; we can simply get the max/min value. The code is:\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = Math.max(posVal, nums[i]);\\n                prodMin = Math.min(negVal, nums[i]);\\n            } else {\\n                prodMax = Math.max(negVal, nums[i]);\\n                prodMin = Math.min(posVal, nums[i]);\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nThe next step is, we can simply get the biggest/smallest value of (posVal, negVal, nums[i]) and avoid the check of nums[i]:\\n\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) { \\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            prodMax = Math.max(Math.max(posVal, nums[i]), negVal);\\n            prodMin = Math.min(Math.min(posVal, nums[i]), negVal);\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```prodMax = prodMax > 0 ? prodMax * nums[i] : nums[i] ```\n```prodMin = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\n```prodMax = prodMin < 0 ? prodMin * nums[i] : nums[i] ```\n```prodMin = prodMax > 0 ? prodMax * nums[i] : nums[i]```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = posVal > 0 ? posVal : nums[i];\\n                prodMin = negVal < 0 ? negVal : nums[i];\\n            } else {\\n                prodMax = negVal > 0 ? negVal : nums[i];\\n                prodMin = posVal < 0 ? posVal : nums[i];\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) {\\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            if(nums[i] > 0) {\\n                prodMax = Math.max(posVal, nums[i]);\\n                prodMin = Math.min(negVal, nums[i]);\\n            } else {\\n                prodMax = Math.max(negVal, nums[i]);\\n                prodMin = Math.min(posVal, nums[i]);\\n            }\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int max = Integer.MIN_VALUE, prodMax = 1, prodMin = 1;\\n        for(int i = 0;i < nums.length;i++) { \\n            int posVal = prodMax * nums[i], negVal = prodMin * nums[i];\\n            prodMax = Math.max(Math.max(posVal, nums[i]), negVal);\\n            prodMin = Math.min(Math.min(posVal, nums[i]), negVal);\\n            max = Math.max(max, prodMax);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48365,
                "title": "9-lines-concise-and-easy-understand-c-dp-solution-o-n-time-o-1-space",
                "content": "    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 1) return nums[0];\\n            int minres = 0, maxres = 0, res = 0, tmp;\\n            for(int i = 0; i < nums.size(); i++){\\n                tmp = maxres;\\n                maxres = max(nums[i],  max(maxres * nums[i], minres*nums[i]));\\n                minres = min(nums[i],  min(minres * nums[i], tmp*nums[i]));\\n                res = max(res, maxres);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            if(nums.size() == 1) return nums[0];\\n            int minres = 0, maxres = 0, res = 0, tmp;\\n            for(int i = 0; i < nums.size(); i++){\\n                tmp = maxres;\\n                maxres = max(nums[i],  max(maxres * nums[i], minres*nums[i]));\\n                minres = min(nums[i],  min(minres * nums[i], tmp*nums[i]));\\n                res = max(res, maxres);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48473,
                "title": "share-the-first-c-solution-with-notes",
                "content": "This question is pretty different from Maximum Sum of Subarray. The reason is that a negative value in array will revolute the previous **maximum** product to the **minimum** and vice versa. So both temporary results should be kept. \\n\\n\\n\\n    class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            if (n==1) return A[0];\\n            \\n            int max_temp=0,min_temp=0,result=std::numeric_limits<int>::min();\\n            \\n            for (int i=0;i<n;i++){\\n                if (A[i]>0){\\n                    max_temp=max(max_temp*A[i],A[i]);//Assign the Temporary Maximum Product\\n                    min_temp=min_temp*A[i];\\n                }\\n                else if (A[i]==0){\\n                    max_temp=0;\\n                    min_temp=0;\\n                }\\n                else{//Negative value, **maximum** and **minimum** products will be  revoluted. \\n                    int temp=max_temp;\\n                    max_temp=min_temp*A[i];\\n                    min_temp=min(temp*A[i],A[i]);//Assign the Temporary Minimum Product\\n                }\\n                result=max(max_temp,result);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProduct(int A[], int n) {\\n            if (n==1) return A[0];\\n            \\n            int max_temp=0,min_temp=0,result=std::numeric_limits<int>::min();\\n            \\n            for (int i=0;i<n;i++){\\n                if (A[i]>0){\\n                    max_temp=max(max_temp*A[i],A[i]);//Assign the Temporary Maximum Product\\n                    min_temp=min_temp*A[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3855832,
                "title": "intuitive-explanation",
                "content": "# Intuition\\nTraversing through the array, for positive elements we have no problem multiplying them into our product, its tricky when we stumble upon a negative element. We can either keep it but then how do we know if we are going to stumble upon the next negative to make it positive?\\n\\nThe trick is not to get stuck in this and focus on even negatives which will maximise our product. If there are even negative nos in arr, its straightforward but **if its odd, we need to let go one of the odd no. Now, this is going to be either the leftmost or the rightmost negative no.**\\n# Approach\\nWe go from **left to right** and calculate product of each element with previous all, and also check the max at that point comparing with the prev max. The absolute value of the product is non decreasing till we find 0. Now, here we take the max and then reset our product to 1 to handle calculations forward.\\n\\nAfter traversing from left to right, now we have the max product of the array by taking first even negative numbers from left to right. \\nBut what if the one negative number we missed towards the right was of higher value but we couldn\\'t take it because it was making our product negative due to odd number of negatives. \\nExample, [-2, -2, 2, 2, -3] max = 16 (products going left to right)\\n\\nNow, we travese the array in reverse from **right to left**, similar to how we did above and update the max product. For the above example our max will be updated to max = 24.\\n\\nFor the cases when we have even number of negative numbers in the array, max will be the same for both (left to right traversal and right to left traversal)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int max = nums[0];\\n\\n        for(int i = 0; i < nums.length; i++){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n        prod = 1;\\n\\n        for(int i = nums.length-1; i >=0; i--){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int prod = 1;\\n        int max = nums[0];\\n\\n        for(int i = 0; i < nums.length; i++){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n        prod = 1;\\n\\n        for(int i = nums.length-1; i >=0; i--){\\n            prod *= nums[i];\\n            max = Math.max(prod, max);\\n            if(prod == 0)   prod = 1;\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769816,
                "title": "maximum-product-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n       int leftHighestCount = 0;\\n       int leftTempCounter = 1;\\n       int rightHighestCount = 0;\\n       int rightTempCounter = 1;\\n       for(int i =0; i< nums.length; i++)\\n        {\\n           if(nums[i] == 0 )\\n           {\\n               if( nums[i] > leftHighestCount)\\n               {\\n                  leftHighestCount = nums[i];\\n               }\\n              leftTempCounter = 1 ;\\n           } else {\\n            leftTempCounter = nums[i] * leftTempCounter;\\n           \\n             if(leftTempCounter > leftHighestCount)\\n           {\\n              leftHighestCount = leftTempCounter;\\n           }\\n           }\\n          \\n          \\n       }\\n\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            if(nums[i] == 0 )\\n           {\\n                if( nums[i] > rightHighestCount)\\n               {\\n                  rightHighestCount = nums[i];\\n               }\\n              rightTempCounter = 1 ;\\n           } else {\\n            rightTempCounter = nums[i] * rightTempCounter;\\n    \\n             if(rightTempCounter > rightHighestCount)\\n           {\\n              rightHighestCount = rightTempCounter;\\n           }\\n           }\\n        }\\n        System.out.print(rightHighestCount);\\n        System.out.print(leftHighestCount);\\n       if(rightHighestCount > leftHighestCount)\\n       {\\n           return rightHighestCount;\\n       }\\n\\n       return leftHighestCount;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n       int leftHighestCount = 0;\\n       int leftTempCounter = 1;\\n       int rightHighestCount = 0;\\n       int rightTempCounter = 1;\\n       for(int i =0; i< nums.length; i++)\\n        {\\n           if(nums[i] == 0 )\\n           {\\n               if( nums[i] > leftHighestCount)\\n               {\\n                  leftHighestCount = nums[i];\\n               }\\n              leftTempCounter = 1 ;\\n           } else {\\n            leftTempCounter = nums[i] * leftTempCounter;\\n           \\n             if(leftTempCounter > leftHighestCount)\\n           {\\n              leftHighestCount = leftTempCounter;\\n           }\\n           }\\n          \\n          \\n       }\\n\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            if(nums[i] == 0 )\\n           {\\n                if( nums[i] > rightHighestCount)\\n               {\\n                  rightHighestCount = nums[i];\\n               }\\n              rightTempCounter = 1 ;\\n           } else {\\n            rightTempCounter = nums[i] * rightTempCounter;\\n    \\n             if(rightTempCounter > rightHighestCount)\\n           {\\n              rightHighestCount = rightTempCounter;\\n           }\\n           }\\n        }\\n        System.out.print(rightHighestCount);\\n        System.out.print(leftHighestCount);\\n       if(rightHighestCount > leftHighestCount)\\n       {\\n           return rightHighestCount;\\n       }\\n\\n       return leftHighestCount;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531445,
                "title": "kadane-s-algorithm-o-n-time-complexity-c",
                "content": "# Approach\\nOne pass , similar to Prefix Sum\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxProd = nums[0];  \\n        int currMax = nums[0]; \\n        int currMin = nums[0]; \\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < 0)\\n                swap(currMax, currMin);\\n                currMax = max(nums[i], currMax * nums[i]);\\n                currMin = min(nums[i], currMin * nums[i]);\\n                maxProd = max(maxProd, currMax);\\n        }\\n        return maxProd;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int maxProd = nums[0];  \\n        int currMax = nums[0]; \\n        int currMin = nums[0]; \\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < 0)\\n                swap(currMax, currMin);\\n                currMax = max(nums[i], currMax * nums[i]);\\n                currMin = min(nums[i], currMin * nums[i]);\\n                maxProd = max(maxProd, currMax);\\n        }\\n        return maxProd;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208209,
                "title": "152-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use the dynamic programming approach. We can define two arrays max_prod and min_prod, where max_prod[i] stores the maximum product ending at index i and min_prod[i] stores the minimum product ending at index i. We also keep track of the maximum product seen so far using a variable result. We initialize these arrays and result as follows:\\n\\n```\\nmax_prod[0] = nums[0]\\nmin_prod[0] = nums[0]\\nresult = nums[0]\\n\\n```\\n\\nThen, for i in the range [1, len(nums)), we update max_prod[i] and min_prod[i] as follows:\\n```\\nif nums[i] >= 0:\\n    max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\nelse:\\n    max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n\\nresult = max(result, max_prod[i])\\n\\n```\\nFinally, we return result. The intuition behind this approach is that a subarray with maximum product can be obtained by multiplying the maximum product of its previous subarray with the current element (if the current element is positive) or the minimum product of its previous subarray with the current element (if the current element is negative). We keep track of both the maximum and minimum products because a negative number can also result in a maximum product if multiplied by another negative number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxProduct(self, nums: List[int]) -> int:\\n    # Initialize max_prod, min_prod, and result\\n    max_prod = [0]*len(nums)\\n    min_prod = [0]*len(nums)\\n    max_prod[0] = nums[0]\\n    min_prod[0] = nums[0]\\n    result = nums[0]\\n\\n    # Loop through the array and update max_prod, min_prod, and result\\n    for i in range(1, len(nums)):\\n        if nums[i] >= 0:\\n            max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\n        else:\\n            max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n        result = max(result, max_prod[i])\\n\\n    return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nmax_prod[0] = nums[0]\\nmin_prod[0] = nums[0]\\nresult = nums[0]\\n\\n```\n```\\nif nums[i] >= 0:\\n    max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\nelse:\\n    max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n    min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n\\nresult = max(result, max_prod[i])\\n\\n```\n```\\nclass Solution:\\n  def maxProduct(self, nums: List[int]) -> int:\\n    # Initialize max_prod, min_prod, and result\\n    max_prod = [0]*len(nums)\\n    min_prod = [0]*len(nums)\\n    max_prod[0] = nums[0]\\n    min_prod[0] = nums[0]\\n    result = nums[0]\\n\\n    # Loop through the array and update max_prod, min_prod, and result\\n    for i in range(1, len(nums)):\\n        if nums[i] >= 0:\\n            max_prod[i] = max(nums[i], max_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], min_prod[i-1]*nums[i])\\n        else:\\n            max_prod[i] = max(nums[i], min_prod[i-1]*nums[i])\\n            min_prod[i] = min(nums[i], max_prod[i-1]*nums[i])\\n        result = max(result, max_prod[i])\\n\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174702,
                "title": "c-modified-kadane-s-easy-to-understand-o-n",
                "content": "Like kadane\\'s we calculate the max ending here at each index;\\nMax ending at index i could be:\\n- min ending at previous index * nums[i] (if min is negative, negative * negative can yield a max value)\\n- max ending at previous index * nums[i] (positive * positive)\\n- nums[i]\\n  \\nMin ending at index i could be:\\n- min ending at previous index * nums[i] (if nums[i] is positive this can yield a bigger negative)\\n- max ending at previous index * nums[i] (if nums[i] is negative and min ending at previous index is postive, this could yield a new minimum)\\n- nums[i]\\n\\n\\n```\\nint n = nums.size();\\nint max_so_far = nums[0];\\nint max_ending_here = nums[0];\\nint min_ending_here = nums[0];\\nfor(int i=1;i<n;i++){\\n\\tint temp = max_ending_here*nums[i];\\n\\tmax_ending_here = max(nums[i], max(temp, min_ending_here*nums[i]));\\n\\tmin_ending_here = min(nums[i], min(temp, min_ending_here*nums[i]));\\n\\tmax_so_far = max(max_so_far, max_ending_here);\\n}\\nreturn max_so_far;\\n```",
                "solutionTags": [],
                "code": "```\\nint n = nums.size();\\nint max_so_far = nums[0];\\nint max_ending_here = nums[0];\\nint min_ending_here = nums[0];\\nfor(int i=1;i<n;i++){\\n\\tint temp = max_ending_here*nums[i];\\n\\tmax_ending_here = max(nums[i], max(temp, min_ending_here*nums[i]));\\n\\tmin_ending_here = min(nums[i], min(temp, min_ending_here*nums[i]));\\n\\tmax_so_far = max(max_so_far, max_ending_here);\\n}\\nreturn max_so_far;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1608884,
                "title": "c-one-pass-simple-and-easy-code-w-explanation",
                "content": "The idea is to**Find the Maximum and Minimum Product found till every index**. The final result will be the maximum of result and Maximum product subarray till every index.\\n\\nThe reason why we are finding minimum product subarray till every index is because we have negative numbers too in the array. So, if we have current element as a negative number, then the minimum product found so far(greatest nagative product) * current nagtive element will give us the maximum product. So, we are keeping track of minimum product found so far too.\\n\\n**Example with Explanation:**\\nEx- nums = [2,3,-2,4]\\n\\nInitially keeping, both min and max product as 1.\\nat index 0 : minProd=1 maxProd=1;\\nat index 1 : minProd=2, maxProd=2;\\nat index 2 : minProd=3, maxProd=6;\\nat index 3 : minProd=-12, maxProd=-2;\\n```\\nint maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = nums[0];\\n        int currMax = 1, currMin = 1;\\n        for (int i = 0; i < n; i++) {\\n            int tempMax = nums[i] * currMax;  \\n            currMax = max({tempMax, nums[i]*currMin, nums[i]});\\n            currMin = min({tempMax, nums[i]*currMin, nums[i]});\\n            res = max(res, currMax);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = nums[0];\\n        int currMax = 1, currMin = 1;\\n        for (int i = 0; i < n; i++) {\\n            int tempMax = nums[i] * currMax;  \\n            currMax = max({tempMax, nums[i]*currMin, nums[i]});\\n            currMin = min({tempMax, nums[i]*currMin, nums[i]});\\n            res = max(res, currMax);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779357,
                "title": "c-sol1-o-n-space-sol2-o-1-space",
                "content": "**Solution 1 : Using two dp arrays : O(n) Time + O(n) space**  \\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n\\n        int dp_max[nums.size()];\\n        int dp_min[nums.size()];\\n        \\n        dp_min[0] = nums[0];\\n        dp_max[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.size() ; i++){\\n            if(nums[i] < 0){\\n                dp_max[i]=  max(nums[i],nums[i]*dp_min[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_max[i-1]);\\n                \\n            }\\n            else{\\n                dp_max[i]=  max(nums[i],nums[i]*dp_max[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_min[i-1]);\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            maxm = max(maxm,dp_max[i]);\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```\\n\\n**Solution 2 : Optimization using two variables, getting rid of the arrays. O(n) Time + O(1) space** \\n\\n```\\nclass Solution {\\npublic:\\n\\tint maxProduct(vector<int>& nums) {\\n\\t\\tint maxm  = nums[0];\\n        int minm  = nums[0];\\n        int res = nums[0];\\n        \\n        for(int i = 1 ; i < nums.size() ; ++i){\\n            if(nums[i] < 0){\\n                int tmp = maxm;\\n                maxm = minm;\\n                minm = tmp;\\n            }\\n            \\n            maxm = max(nums[i],nums[i]*maxm);\\n            minm = min(nums[i],nums[i]*minm);\\n            res = max(maxm,res);\\n        }\\n        return res;\\n\\t}\\n};\\n```\\n\\t\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n\\n        int dp_max[nums.size()];\\n        int dp_min[nums.size()];\\n        \\n        dp_min[0] = nums[0];\\n        dp_max[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.size() ; i++){\\n            if(nums[i] < 0){\\n                dp_max[i]=  max(nums[i],nums[i]*dp_min[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_max[i-1]);\\n                \\n            }\\n            else{\\n                dp_max[i]=  max(nums[i],nums[i]*dp_max[i-1]);\\n                dp_min[i]=  min(nums[i],nums[i]*dp_min[i-1]);\\n            }\\n        }\\n        \\n        int maxm = INT_MIN;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            maxm = max(maxm,dp_max[i]);\\n        }\\n        \\n        return maxm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint maxProduct(vector<int>& nums) {\\n\\t\\tint maxm  = nums[0];\\n        int minm  = nums[0];\\n        int res = nums[0];\\n        \\n        for(int i = 1 ; i < nums.size() ; ++i){\\n            if(nums[i] < 0){\\n                int tmp = maxm;\\n                maxm = minm;\\n                minm = tmp;\\n            }\\n            \\n            maxm = max(nums[i],nums[i]*maxm);\\n            minm = min(nums[i],nums[i]*minm);\\n            res = max(maxm,res);\\n        }\\n        return res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757686,
                "title": "java-simple-2-pass-o-n-easy-to-remember",
                "content": "Intutuion here is that multiplying forward vs. backwards will result in different intermediate products, but will result in same final product. Multiplying by more numbers always results in a number that is the same or higher magnitude (except for 0), so hopefully in the case of a very negative number we eventually find another negative number to flip the sign.\\n\\nIn case we encounter a 0, reset product to 1 so we can continue to multiplying remaining numbers.\\n\\nSimply return the max product found from the forwards and backwards traversal.\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int product = 1;\\n        int maxProduct = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        product = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        return maxProduct;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int product = 1;\\n        int maxProduct = Integer.MIN_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        product = 1;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            product *= nums[i];          \\n            maxProduct = Math.max(maxProduct, product);\\n            if (product == 0) {\\n                product = 1;\\n            }\\n        }\\n        \\n        return maxProduct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728760,
                "title": "simple-python",
                "content": "```\\ndef maxProduct(self, a):\\n\\tans = max_prod = min_prod = a[0]                       \\n\\tfor x in a[1:]:\\n\\t\\tmax_prod, min_prod = max(x, min_prod*x, max_prod*x), min(x, min_prod*x, max_prod*x) \\n\\t\\tans = max(ans, max_prod)\\n\\treturn ans",
                "solutionTags": [],
                "code": "```\\ndef maxProduct(self, a):\\n\\tans = max_prod = min_prod = a[0]                       \\n\\tfor x in a[1:]:\\n\\t\\tmax_prod, min_prod = max(x, min_prod*x, max_prod*x), min(x, min_prod*x, max_prod*x) \\n\\t\\tans = max(ans, max_prod)\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 660113,
                "title": "c-dp-o-n-time-o-1-space-with-explanation",
                "content": "```\\n/**\\nThe question seems pretty straigtforward, apart from the fact that we have to take into account negative elements.\\nProduct of subarray can only be positive if the number of negative elements are even.\\n\\nSo we will keep two variables, posMax and negMax\\nposMax will keep track of the highest positive running product found till now.\\nnegMax will keep track of the lowest negative running product found till now.\\n\\nThere are 3 cases.\\nIf element encountered is positive, we can simply multiply it with posMax to get maximum running product.\\nnegMax will also be updated since the running negative product shall also decrease in value by multiplying it with a positive number\\n\\nIf element encountered is negative, we can multiply it with negMax( lowest negative running product ) to get a positive value . If this is greater than positive running product (posMax) then update it.\\nWe will also update negMax by multiplying nums[i] (negative) with posMax, since it will yield a negative value which might be lesser than our already found running negative product.\\n\\nIf the element is 0, then both running products shall be set to 0 (Note that we only have to consider contiguous subarrays).\\n\\nAn example will make it much more clearer.\\nDry run it yourself to understand the algorithm fully\\nnums[i] - -2         5          -1          -4         2          3\\nposMax  -2           5          10          20        40         120\\nnegMax  -2          -10         -5         -40       -80        -120\\nresult   0           5          10          20        40         120\\n**/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size() == 0){ return 0; }\\n        if(nums.size() == 1){ return nums[0]; }\\n        int posMax = 1;\\n        int negMax = 1;\\n        int result = 0;        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int nextPosMax = 1;\\n            int nextNegMax = 1;\\n           if(nums[i] > 0){\\n               nextPosMax = max(posMax * nums[i], nums[i]);\\n               nextNegMax = min(negMax * nums[i], nums[i]);\\n           } else if( nums[i] < 0 ){\\n               nextPosMax = max(negMax * nums[i], nums[i]);\\n               nextNegMax = min(posMax * nums[i], nums[i]);\\n           } else {\\n              nextPosMax = 0;\\n              nextNegMax = 0;\\n           }\\n            result = max(result, max(nextPosMax, nextNegMax));\\n            posMax = nextPosMax;\\n            negMax = nextNegMax;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\nThe question seems pretty straigtforward, apart from the fact that we have to take into account negative elements.\\nProduct of subarray can only be positive if the number of negative elements are even.\\n\\nSo we will keep two variables, posMax and negMax\\nposMax will keep track of the highest positive running product found till now.\\nnegMax will keep track of the lowest negative running product found till now.\\n\\nThere are 3 cases.\\nIf element encountered is positive, we can simply multiply it with posMax to get maximum running product.\\nnegMax will also be updated since the running negative product shall also decrease in value by multiplying it with a positive number\\n\\nIf element encountered is negative, we can multiply it with negMax( lowest negative running product ) to get a positive value . If this is greater than positive running product (posMax) then update it.\\nWe will also update negMax by multiplying nums[i] (negative) with posMax, since it will yield a negative value which might be lesser than our already found running negative product.\\n\\nIf the element is 0, then both running products shall be set to 0 (Note that we only have to consider contiguous subarrays).\\n\\nAn example will make it much more clearer.\\nDry run it yourself to understand the algorithm fully\\nnums[i] - -2         5          -1          -4         2          3\\nposMax  -2           5          10          20        40         120\\nnegMax  -2          -10         -5         -40       -80        -120\\nresult   0           5          10          20        40         120\\n**/\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if(nums.size() == 0){ return 0; }\\n        if(nums.size() == 1){ return nums[0]; }\\n        int posMax = 1;\\n        int negMax = 1;\\n        int result = 0;        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int nextPosMax = 1;\\n            int nextNegMax = 1;\\n           if(nums[i] > 0){\\n               nextPosMax = max(posMax * nums[i], nums[i]);\\n               nextNegMax = min(negMax * nums[i], nums[i]);\\n           } else if( nums[i] < 0 ){\\n               nextPosMax = max(negMax * nums[i], nums[i]);\\n               nextNegMax = min(posMax * nums[i], nums[i]);\\n           } else {\\n              nextPosMax = 0;\\n              nextNegMax = 0;\\n           }\\n            result = max(result, max(nextPosMax, nextNegMax));\\n            posMax = nextPosMax;\\n            negMax = nextNegMax;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580658,
                "title": "beats-97-java-easy-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int[] max = new int[nums.length];\\n        int[] min = new int[nums.length];\\n        max[0] = min[0] = nums[0];\\n        int result = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>0){\\n                max[i]=Math.max(nums[i], max[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], min[i-1]*nums[i]);\\n            }else{\\n                max[i]=Math.max(nums[i], min[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], max[i-1]*nums[i]);\\n            }\\n            result = Math.max(result, max[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int[] max = new int[nums.length];\\n        int[] min = new int[nums.length];\\n        max[0] = min[0] = nums[0];\\n        int result = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>0){\\n                max[i]=Math.max(nums[i], max[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], min[i-1]*nums[i]);\\n            }else{\\n                max[i]=Math.max(nums[i], min[i-1]*nums[i]);\\n                min[i]=Math.min(nums[i], max[i-1]*nums[i]);\\n            }\\n            result = Math.max(result, max[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48335,
                "title": "two-clean-different-solutions-c-well-commented",
                "content": "    class Solution {\\n    public:\\n        //min can turn max when encountering another negative number\\n        //so we have to record all the min and max values;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size(), maxProduct = nums[0];\\n            int maxProducts[size]{0}, minProducts[size]{0};\\n            maxProducts[0] = minProducts[0] = nums[0];\\n            for(int i = 1; i < size; ++i)\\n            {\\n                maxProducts[i] = max(maxProducts[i-1]*nums[i], max(minProducts[i-1]*nums[i], nums[i]));\\n                minProducts[i] = min(maxProducts[i-1]*nums[i], min(minProducts[i-1]*nums[i], nums[i]));\\n                maxProduct = max(maxProduct, maxProducts[i]);\\n            }\\n            return maxProduct;\\n        }\\n    \\n        //actually we only need two variables to record the\\n        //previous min and max products;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size();\\n            int minProduct = nums[0], maxProduct = nums[0], ret = nums[0];\\n            for(int i = 1; i < size; ++i)\\n            {\\n                if(nums[i] < 0) swap(minProduct, maxProduct);\\n                maxProduct = max(maxProduct*nums[i], nums[i]);\\n                minProduct = min(minProduct*nums[i], nums[i]);\\n                ret = max(ret, maxProduct);\\n            }\\n            return ret;\\n        }\\n    \\n        //another solution using constant space too;\\n        //traversing from left to right and meantime from right to left\\n        //to calculate the possible max products since the subsequence will be \\n        //from left to right or right to left anyway but in two directions \\n        //in case of neglecting the other half;\\n        int maxProduct(vector<int>& nums) \\n        {\\n            int lProduct = 1, rProduct = 1;\\n            int size = nums.size(), maxProduct = nums[0];\\n            for(int i = 0; i < size; ++i)\\n            {\\n                lProduct *= nums[i];\\n                rProduct *= nums[size-i-1];\\n                maxProduct = max(maxProduct, max(lProduct, rProduct));\\n                if(lProduct == 0) lProduct = 1;\\n                if(rProduct == 0) rProduct = 1;\\n            }\\n            return maxProduct;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        //min can turn max when encountering another negative number\\n        //so we have to record all the min and max values;\\n    \\tint maxProduct(vector<int>& nums) \\n        {\\n            int size = nums.size(), maxProduct = nums[0];\\n            int maxProducts[size]{0}",
                "codeTag": "Java"
            },
            {
                "id": 48413,
                "title": "6-simple-lines-ruby-is-awesome-here",
                "content": "I walk over `nums` front to back. My `min` and `max` tell me the smallest and largest product ending with the current number `n`. For the next `n`, I can either use that `n` alone or I can extend the previous min/max products by multiplying them with `n`.\\n\\n    def max_product(nums)\\n        min = max = 1\\n        best = nums[0]\\n        nums.each { |n|\\n            min, max = [n, min*n, max*n].minmax\\n            best = [best, max].max\\n        }\\n        best\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "I walk over `nums` front to back. My `min` and `max` tell me the smallest and largest product ending with the current number `n`. For the next `n`, I can either use that `n` alone or I can extend the previous min/max products by multiplying them with `n`.\\n\\n    def max_product(nums)\\n        min = max = 1\\n        best = nums[0]\\n        nums.each { |n|\\n            min, max = [n, min*n, max*n].minmax\\n            best = [best, max].max\\n        }\\n        best\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 3991285,
                "title": "0-n-best-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe approach used in this code is based on maintaining two variables, prefix and suffix, to keep track of the product of elements from the left and right sides of the current position in the array. Here\\'s a step-by-step explanation of the approach:\\n\\nInitialize the prefix and suffix variables to 1. These variables will store the product of elements from the left and right sides, respectively.\\n\\nInitialize the maxi variable to INT_MIN. This variable will store the maximum product found so far.\\n\\nIterate through the nums array using a for loop. The loop variable i represents the current position in the array.\\n\\nInside the loop:\\n\\nCheck if prefix is equal to 0. If it is, set prefix to 1. This step ensures that if the product becomes 0, it won\\'t affect the overall product.\\nCheck if suffix is equal to 0. If it is, set suffix to 1. Similar to the prefix, this step ensures that if the product becomes 0 when considering elements from the right side, it won\\'t affect the overall product.\\nUpdate prefix by multiplying it with the current element nums[i]. This step accumulates the product of elements from the left side.\\nUpdate suffix by multiplying it with the element at position nums[n - i - 1]. This step accumulates the product of elements from the right side, starting from the end of the array.\\nUpdate maxi by taking the maximum value among maxi, prefix, and suffix. This step ensures that maxi always stores the maximum product found so far.\\nAfter the loop completes, maxi will contain the maximum product of a subarray within the nums array.\\n\\nIn summary, this code maintains two variables to track the product of elements from the left and right sides of the current position and keeps updating the maximum product found while iterating through the array. The final result is stored in the maxi variable and returned as the answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\nGO THROUGH THIS VIDEO TO GET A COMPLETE KNOWLEDGE ABT THIS CODE \\n[https://www.youtube.com/watch?v=hnswaLJvr6g]()\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prefix=1;\\n        int suffix=1;\\n        int n = nums.size();\\n        int maxi=INT_MIN;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            if(prefix==0)\\n            {\\n                prefix=1;\\n            }\\n            if(suffix==0)\\n            {\\n                suffix=1;\\n            }\\n            prefix*=nums[i];\\n            suffix*=nums[n-i-1]; // to start suffix from the last end \\n            maxi=max(maxi , max(suffix,prefix));\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prefix=1;\\n        int suffix=1;\\n        int n = nums.size();\\n        int maxi=INT_MIN;\\n        for(int i = 0; i < nums.size();i++)\\n        {\\n            if(prefix==0)\\n            {\\n                prefix=1;\\n            }\\n            if(suffix==0)\\n            {\\n                suffix=1;\\n            }\\n            prefix*=nums[i];\\n            suffix*=nums[n-i-1]; // to start suffix from the last end \\n            maxi=max(maxi , max(suffix,prefix));\\n\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388098,
                "title": "simple-javascript-very-easy-explanation-49ms-98-91beats",
                "content": "![Screenshot 2023-04-07 at 01.15.42.png](https://assets.leetcode.com/users/images/3d1691f5-2690-4331-bba3-71e031d63bb6_1680823010.6114805.png)\\n\\n# Ways to solve problem:\\n1. Brute Force way which takes two loop and iterates to and update max prodcut. Time-complexity = 0(n^2)\\n2. Dynamic Programming which takes one loop and iterates to and update max product. Time-complexity = O(n) which is better than first way.\\n\\nI selected dynamic programming appraoch\\n# How this code works:\\n```\\n                      /-------------\\\\\\n                      v             |\\nInput Array: [-2, 3, -4, 5, 2, -2, 1]\\n        index:  0  1   2  3  4   5  6\\n\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              3         |\\n              /---------\\\\\\n              v         |\\n              -4        |\\n              /---------\\\\\\n              v         |\\n              5         |\\n              /---------\\\\\\n              v         |\\n              2         |\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              1         |\\n              \\\\---------/\\n\\nAt each iteration, we calculate the local maximum and local minimum products ending at the current index (represented by the arrows above). The global maximum product is updated based on the local maximum product calculated at each iteration. Here\\'s how the values of the variables change at each iteration for the input array above:\\n\\ni = 1:\\nlocalMaxProduct = 3\\nlocalMinProduct = -6\\nglobalMaxProduct = 3\\n\\ni = 2:\\nlocalMaxProduct = 24\\nlocalMinProduct = -12\\nglobalMaxProduct = 24\\n\\ni = 3:\\nlocalMaxProduct = 120\\nlocalMinProduct = -60\\nglobalMaxProduct = 120\\n\\ni = 4:\\nlocalMaxProduct = 240\\nlocalMinProduct = -120\\nglobalMaxProduct = 240\\n\\ni = 5:\\nlocalMaxProduct = 480\\nlocalMinProduct = -480\\nglobalMaxProduct = 480\\n\\ni = 6:\\nlocalMaxProduct = 480\\nlocalMinProduct = -960\\nglobalMaxProduct = 480\\n\\nIn each iteration, we update `localMaxProduct` and `localMinProduct` based on the current element and the previous values of `localMaxProduct` and `localMinProduct`. We then update `globalMaxProduct` to be the maximum of the current `localMaxProduct` and the previous `globalMaxProduct`. This ensures that we keep track of the maximum product seen so far.\\n\\n```\\nPlease do not forget to like and comment :)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function (nums) {\\n  let globalMaxProduct = nums[0];\\n  let localMaxProduct = nums[0];\\n  let localMinProduct = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    // We keep a temp variable because we want to keep track of the localMaxProduct before any calculations.\\n    let prevLocalMaxProduct = localMaxProduct;\\n\\n    localMaxProduct = Math.max(\\n      nums[i],\\n      nums[i] * localMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n    localMinProduct = Math.min(\\n      nums[i],\\n      nums[i] * prevLocalMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n\\n    globalMaxProduct = Math.max(localMaxProduct, globalMaxProduct);\\n  }\\n\\n  return globalMaxProduct;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n                      /-------------\\\\\\n                      v             |\\nInput Array: [-2, 3, -4, 5, 2, -2, 1]\\n        index:  0  1   2  3  4   5  6\\n\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              3         |\\n              /---------\\\\\\n              v         |\\n              -4        |\\n              /---------\\\\\\n              v         |\\n              5         |\\n              /---------\\\\\\n              v         |\\n              2         |\\n              /---------\\\\\\n              v         |\\n              -2        |\\n              /---------\\\\\\n              v         |\\n              1         |\\n              \\\\---------/\\n\\nAt each iteration, we calculate the local maximum and local minimum products ending at the current index (represented by the arrows above). The global maximum product is updated based on the local maximum product calculated at each iteration. Here\\'s how the values of the variables change at each iteration for the input array above:\\n\\ni = 1:\\nlocalMaxProduct = 3\\nlocalMinProduct = -6\\nglobalMaxProduct = 3\\n\\ni = 2:\\nlocalMaxProduct = 24\\nlocalMinProduct = -12\\nglobalMaxProduct = 24\\n\\ni = 3:\\nlocalMaxProduct = 120\\nlocalMinProduct = -60\\nglobalMaxProduct = 120\\n\\ni = 4:\\nlocalMaxProduct = 240\\nlocalMinProduct = -120\\nglobalMaxProduct = 240\\n\\ni = 5:\\nlocalMaxProduct = 480\\nlocalMinProduct = -480\\nglobalMaxProduct = 480\\n\\ni = 6:\\nlocalMaxProduct = 480\\nlocalMinProduct = -960\\nglobalMaxProduct = 480\\n\\nIn each iteration, we update `localMaxProduct` and `localMinProduct` based on the current element and the previous values of `localMaxProduct` and `localMinProduct`. We then update `globalMaxProduct` to be the maximum of the current `localMaxProduct` and the previous `globalMaxProduct`. This ensures that we keep track of the maximum product seen so far.\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function (nums) {\\n  let globalMaxProduct = nums[0];\\n  let localMaxProduct = nums[0];\\n  let localMinProduct = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    // We keep a temp variable because we want to keep track of the localMaxProduct before any calculations.\\n    let prevLocalMaxProduct = localMaxProduct;\\n\\n    localMaxProduct = Math.max(\\n      nums[i],\\n      nums[i] * localMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n    localMinProduct = Math.min(\\n      nums[i],\\n      nums[i] * prevLocalMaxProduct,\\n      nums[i] * localMinProduct\\n    );\\n\\n    globalMaxProduct = Math.max(localMaxProduct, globalMaxProduct);\\n  }\\n\\n  return globalMaxProduct;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286073,
                "title": "follow-up-question-also-print-return-the-maximum-product-subarray",
                "content": "# Intuition\\nHave an end pointer to the index whenever you update global maximum. After traversing the array fully, have a seperate while to see what is the potential starting point of the maximum product subarray.\\n\\n# Approach\\nEvery time global maximum is updated, we reset the end of the subarray. So we move from back to find what could be possible starting of that subarray that contributes to maximum product.\\n\\nWhile moving the starting pointer if we encounter some number to be 0, the start pointer stops there, or if the number itself has contributed for the globalMaximum at that point, IT MEANS NO VALUE BEFORE THAT POINT HAS CONTRIBUTED TO THE MAXIMUM PRODUCT. Moving back from end to potential start point using j pointer, at every point we divide contributed value by the number itself to move backwards in search of finding the starting point of subarray.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentMinimum = nums[0]\\n        currentMaximum = nums[0]\\n        globalMaximum = nums[0]\\n\\n        start = 0\\n        end = 1\\n\\n        for i in range(1,len(nums)):\\n            currentMinimum, currentMaximum  = min(currentMinimum * nums[i], currentMaximum * nums[i], nums[i]), max(currentMinimum * nums[i], currentMaximum * nums[i], nums[i])\\n            \\n            if (currentMaximum > globalMaximum):\\n                globalMaximum = currentMaximum\\n                end=i+1\\n                \\n\\n        j=end-1\\n        while j>=0:\\n            if nums[j]==0:\\n                start = j\\n                break\\n            else:\\n                if globalMaximum == nums[j]:\\n                    start = j\\n                    break\\n                globalMaximum = globalMaximum/nums[j]\\n            j-=1\\n\\n        #nums[start: end] is the maximum product subarray!!\\n        prod = 1\\n        for num in nums[start: end]:\\n            prod *=num\\n\\n        return prod\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProduct(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentMinimum = nums[0]\\n        currentMaximum = nums[0]\\n        globalMaximum = nums[0]\\n\\n        start = 0\\n        end = 1\\n\\n        for i in range(1,len(nums)):\\n            currentMinimum, currentMaximum  = min(currentMinimum * nums[i], currentMaximum * nums[i], nums[i]), max(currentMinimum * nums[i], currentMaximum * nums[i], nums[i])\\n            \\n            if (currentMaximum > globalMaximum):\\n                globalMaximum = currentMaximum\\n                end=i+1\\n                \\n\\n        j=end-1\\n        while j>=0:\\n            if nums[j]==0:\\n                start = j\\n                break\\n            else:\\n                if globalMaximum == nums[j]:\\n                    start = j\\n                    break\\n                globalMaximum = globalMaximum/nums[j]\\n            j-=1\\n\\n        #nums[start: end] is the maximum product subarray!!\\n        prod = 1\\n        for num in nums[start: end]:\\n            prod *=num\\n\\n        return prod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267334,
                "title": "2-best-solutions-in-constant-space",
                "content": "# Code\\n```\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), maxi = nums[0], pre = 0, suf = 0;\\n        for(int i = 0;i < n; i++) {\\n            pre = (pre ? pre : 1) * nums[i];\\n            suf = (suf ? suf : 1) * nums[n-i-1];\\n            maxi = max(maxi, max(pre, suf));\\n        }\\n        return maxi;\\n    }\\nor\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = nums[0], imax = nums[0], imin = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < 0)\\n                swap(imax, imin);\\n            imax = max(imax * nums[i], nums[i]);\\n            imin = min(imin * nums[i], nums[i]);\\n            maxi = max(maxi, imax);\\n        }\\n        return maxi;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size(), maxi = nums[0], pre = 0, suf = 0;\\n        for(int i = 0;i < n; i++) {\\n            pre = (pre ? pre : 1) * nums[i];\\n            suf = (suf ? suf : 1) * nums[n-i-1];\\n            maxi = max(maxi, max(pre, suf));\\n        }\\n        return maxi;\\n    }\\nor\\n    int maxProduct(vector<int>& nums) {\\n        int maxi = nums[0], imax = nums[0], imin = nums[0];\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] < 0)\\n                swap(imax, imin);\\n            imax = max(imax * nums[i], nums[i]);\\n            imin = min(imin * nums[i], nums[i]);\\n            maxi = max(maxi, imax);\\n        }\\n        return maxi;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3050988,
                "title": "super-easy-java-sol-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int curr_prod = 1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            curr_prod*=nums[i];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n            }\\n        }\\n        curr_prod=1;\\n        for(int j=nums.length-1;j>=0;j--){\\n            curr_prod*=nums[j];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n        }\\n        }   return ans;\\n        } \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int ans = Integer.MIN_VALUE;\\n        int curr_prod = 1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            curr_prod*=nums[i];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n            }\\n        }\\n        curr_prod=1;\\n        for(int j=nums.length-1;j>=0;j--){\\n            curr_prod*=nums[j];\\n            ans = Math.max(ans,curr_prod);\\n            if(curr_prod==0){\\n                curr_prod=1;\\n        }\\n        }   return ans;\\n        } \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420264,
                "title": "easiest-o-n-python-soln-w-explanation-single-pass",
                "content": "* Traverse L-R and keep storing the min product and max product. \\n* If current val is 0 or neg, **swap the min and max** product bcz Max value when mulitplied to neg, will be the minimum value now ( 100 * -2 = -200 ) and vice versa.\\n* **Upvote the solution if you find it helpful**\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        maxprod,minprod=ans,ans\\n\\t\\t\\n        for i in range(1,len(nums)):\\n            if nums[i]<0:\\n                maxprod,minprod=minprod,maxprod\\n                \\n            maxprod=max(nums[i],maxprod*nums[i])\\n            minprod=min(nums[i],minprod*nums[i])\\n            ans=max(ans,maxprod)\\n            \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        ans=nums[0]\\n        maxprod,minprod=ans,ans\\n\\t\\t\\n        for i in range(1,len(nums)):\\n            if nums[i]<0:\\n                maxprod,minprod=minprod,maxprod\\n                \\n            maxprod=max(nums[i],maxprod*nums[i])\\n            minprod=min(nums[i],minprod*nums[i])\\n            ans=max(ans,maxprod)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944256,
                "title": "java-100-working-and-explained-each-line",
                "content": "We need to solve the given question considering that (neg * neg = pos) and this value can be the max product so we need to store the max negative products too, \\nagain one more edge case comes for the zeroes since X * 0 = 0; be it negative or positive, so we need to handle for that as well;\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint max_prod = nums[0];\\n\\t\\t\\tint curr_max = 1, curr_min = 1; \\n\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t  if(nums[i]==0){ curr_max = 1; curr_min = 1; }\\n\\n\\t\\t\\t int temp = curr_max * nums[i];\\n\\t\\t\\t curr_max = Math.max(nums[i], Math.max(curr_max * nums[i], curr_min*nums[i]));\\n\\t\\t\\t curr_min = Math.min(nums[i], Math.min(temp, curr_min * nums[i]));\\n\\t\\t\\t max_prod = Math.max(max_prod, curr_max);\\n\\t\\t\\t}\\n\\t\\t\\treturn max_prod;\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n curr_max = Math.max(nums[i], Math.max(curr_max * nums[i], curr_min * nums[i])); //this line checks if the stored product multiplied with the new number  is greater or the stored minimum number with the new number multiplied is greter or the current number itself is greater,\\n Similarly for the curr_min , since we need to get the lowest value possible bcoz (-10<-80, but if -80 * -1 = 80, which ofcourse wil be greater than -10 * -1 , hence the minimum)\\n now finally we store the gretest value in our max_prod, we are not considering curr_min here is becoz, curr_min has to be multiplied with a value to become the greatest number.\\n \\n### please upvote if you liked the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int maxProduct(int[] nums) {\\n\\t\\t\\tint max_prod = nums[0];\\n\\t\\t\\tint curr_max = 1, curr_min = 1; \\n\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t  if(nums[i]==0){ curr_max = 1; curr_min = 1; }",
                "codeTag": "Java"
            },
            {
                "id": 1848322,
                "title": "100-faster-time-o-n-one-pass-solution",
                "content": "***Upvote to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n\\n**Explanation :-**\\n1. Calculate prod1 from the start and prod2 from the end.\\n2. Update res with the maximum of previous res value and maximum of prod1( calculated from left side) and prod2( calculated from right side).\\n3. If prod1 or prod2 becomes 0, update them with 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prod1 = 1;\\n        int prod2 = 1;\\n        int res = nums[0];\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            prod1 *= nums[i];\\n            prod2 *= nums[n - 1 - i];\\n            res = max(res, max(prod1 , prod2));\\n            if(prod1 == 0){\\n                prod1 = 1;\\n            }\\n            if(prod2 == 0){\\n                prod2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int prod1 = 1;\\n        int prod2 = 1;\\n        int res = nums[0];\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            prod1 *= nums[i];\\n            prod2 *= nums[n - 1 - i];\\n            res = max(res, max(prod1 , prod2));\\n            if(prod1 == 0){\\n                prod1 = 1;\\n            }\\n            if(prod2 == 0){\\n                prod2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770091,
                "title": "c-super-simple-o-n",
                "content": "Appraoch : \\nStep 1: Traverse the array from Left -> Right. \\nStep 2: Traverse the array from Right -> Left.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int prod=1;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prod=prod*nums[i];\\n            ans=max(ans,prod);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        \\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            prod=prod*nums[i];\\n            ans=max(prod,ans);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int prod=1;\\n\\n        \\n        for(int i=0;i<nums.size();i++){\\n            prod=prod*nums[i];\\n            ans=max(ans,prod);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        \\n        prod=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            prod=prod*nums[i];\\n            ans=max(prod,ans);\\n            \\n            if(prod==0) prod=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681214,
                "title": "python-intuitive-o-n-time-explained",
                "content": "**Approach**\\n\\nSo, the first thing that comes to mind is using the same approach as the maximum sum subarray, however, this breaks down with multiplying negative numbers because a negative number can lead you to a maximum later down the line. This means we must keep track of both the current maximum product and the current minimum product. This can allow us to account for negative values that lead to maximums further in the iterations.\\n\\n**Big O Break Down**\\nThis is O(n) because we are iterating through the list one time, and every iteration has constant time calculations. \\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        totalMax = prevMax = prevMin = nums[0]\\n        for i,num in enumerate(nums[1:]):\\n            currentMin = min(num, prevMax*num, prevMin*num)\\n            currentMax = max(num, prevMax*num, prevMin*num)\\n            totalMax = max(currentMax, totalMax)\\n            prevMax = currentMax\\n            prevMin = currentMin\\n        return totalMax\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        totalMax = prevMax = prevMin = nums[0]\\n        for i,num in enumerate(nums[1:]):\\n            currentMin = min(num, prevMax*num, prevMin*num)\\n            currentMax = max(num, prevMax*num, prevMin*num)\\n            totalMax = max(currentMax, totalMax)\\n            prevMax = currentMax\\n            prevMin = currentMin\\n        return totalMax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508486,
                "title": "1-ms-in-java-using-kadane-s-algorithm",
                "content": "```\\npublic  int MaximumProduct(int[] arr, int n) {\\n\\n        int result = arr[0];\\n        int maxNegative = arr[0];\\n        int maxPositive = arr[0];\\n\\n        for (int i = 1; i < n; i++) {\\n\\t\\t// We are using temp variable to store the maxPositive incase it changes!\\n            int temp = maxPositive;\\n            maxPositive = Math.max(arr[i], Math.max(arr[i] * maxPositive, arr[i] * maxNegative));\\n            maxNegative = Math.min(arr[i], Math.min(arr[i] * maxNegative, arr[i] * temp));\\n            result = Math.max(result, maxPositive);\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic  int MaximumProduct(int[] arr, int n) {\\n\\n        int result = arr[0];\\n        int maxNegative = arr[0];\\n        int maxPositive = arr[0];\\n\\n        for (int i = 1; i < n; i++) {\\n\\t\\t// We are using temp variable to store the maxPositive incase it changes!\\n            int temp = maxPositive;\\n            maxPositive = Math.max(arr[i], Math.max(arr[i] * maxPositive, arr[i] * maxNegative));\\n            maxNegative = Math.min(arr[i], Math.min(arr[i] * maxNegative, arr[i] * temp));\\n            result = Math.max(result, maxPositive);\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1421549,
                "title": "python-simplest-possible-dp-solution-o-n-time-o-1-space",
                "content": "Here, we think about the simplest recurrence relation as we will with any DP solution.\\n\\nAt each value, we simply either take the value or don\\'t take the value. It\\'s very similar to the maximum subarray.\\n\\nAt each point, you simply cache a min value and a max value, any min value can be constructed from the num at an index, the products of all mins before and the current num or the max multiplied by the current num if the num is negative.\\n\\n```python\\ndef maxProduct(self, nums: List[int]) -> int:\\n    if len(nums) == 0:\\n        return 0\\n        \\n    min_rolling = 1\\n    max_rolling = 1\\n    max_product = nums[0]\\n        \\n    for num in nums:\\n        min_rolling, max_rolling = \\\\\\n            min(min_rolling * num, num, max_rolling * num), \\\\\\n            max(max_rolling * num, num, min_rolling * num)\\n        max_product = max(max_rolling, max_product)\\n        \\nreturn max_product\\n```\\n\\nHere\\'s a simple example to illustrate the edge case of a positive number being wedged between multiple negative numbers.\\n\\n```\\nTest case: [-1, 0, -2, 5, -10]\\n\\nnum = -1\\nmax_rolling = max(1 * -1, -1, 1 * -1) => -1\\nmin_rolling = min(1 * -1, -1, 1 * -1) => -1\\nmax_product = max(-1, -1) => -1\\n\\nnum = 0\\nmax_rolling = max(-1 * 0, 0, -1 * 0) => 0\\nmin_rolling = min(-1 * 0, 0, -1 * 0) => 0\\nmax_product = max(-1, 0) => 0\\n\\nnum = -2\\nmax_rolling = max(0 * 2, -2, 0 * 2) => 0\\nmin_rolling = min(0 * 2, -2, 0 * 2) => -2\\nmax_product = max(0, 0) => 0\\n\\nnum = 5\\nmax_rolling = max(0 * 5, 5, -2 * 5) => 5\\nmin_rolling = min(0 * 5, 5, -2 * 5) => -10\\nmax_product = max(0, 5) => 5\\n\\nnum = -10\\nmax_rolling = max(5 * -10, -10, -2 * -10) => 20\\nmin_rolling = min(5 * -10, -10, -2 * -10) => -50\\nmax_product = max(5, 20) => 20\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxProduct(self, nums: List[int]) -> int:\\n    if len(nums) == 0:\\n        return 0\\n        \\n    min_rolling = 1\\n    max_rolling = 1\\n    max_product = nums[0]\\n        \\n    for num in nums:\\n        min_rolling, max_rolling = \\\\\\n            min(min_rolling * num, num, max_rolling * num), \\\\\\n            max(max_rolling * num, num, min_rolling * num)\\n        max_product = max(max_rolling, max_product)\\n        \\nreturn max_product\\n```\n```\\nTest case: [-1, 0, -2, 5, -10]\\n\\nnum = -1\\nmax_rolling = max(1 * -1, -1, 1 * -1) => -1\\nmin_rolling = min(1 * -1, -1, 1 * -1) => -1\\nmax_product = max(-1, -1) => -1\\n\\nnum = 0\\nmax_rolling = max(-1 * 0, 0, -1 * 0) => 0\\nmin_rolling = min(-1 * 0, 0, -1 * 0) => 0\\nmax_product = max(-1, 0) => 0\\n\\nnum = -2\\nmax_rolling = max(0 * 2, -2, 0 * 2) => 0\\nmin_rolling = min(0 * 2, -2, 0 * 2) => -2\\nmax_product = max(0, 0) => 0\\n\\nnum = 5\\nmax_rolling = max(0 * 5, 5, -2 * 5) => 5\\nmin_rolling = min(0 * 5, 5, -2 * 5) => -10\\nmax_product = max(0, 5) => 5\\n\\nnum = -10\\nmax_rolling = max(5 * -10, -10, -2 * -10) => 20\\nmin_rolling = min(5 * -10, -10, -2 * -10) => -50\\nmax_product = max(5, 20) => 20\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1337502,
                "title": "python-3-o-n-solution-hints-with-spoiler",
                "content": "**Hints:**\\n* The solution idea is very similar to Kadane\\'s Algorithm. \\n* In each iteration, we keep track of the max product of sub-arrays till the current num\\n* Think about what happens when we multiply negative numbers with the current max product. \\ne.g. if current max is `100` and we get the number `-2` then we get `(100 * -2) = -200`\\n* So, we need to keep track of min product of sub-arrays as well in each iteration \\n*  Because, min product can also turn into a potential max product if we multiply it with negative number. \\ne.g. `(-200 * -2) = 400`\\n<details>\\n<summary> View Code </summary>\\n\\n```python\\nclass Solution:\\n\\tdef maxProduct(self, nums: List[int]) -> int:    \\n\\t\\tans , max_p, min_p = nums[0], 1, 1   \\n\\t\\tfor num in nums:            \\n\\t\\t\\tmax_p, min_p = max(num, min_p * num, max_p * num), min(num, min_p * num, max_p * num)\\n\\t\\t\\tans = max(ans, max_p)\\n\\t\\treturn ans\\n```\\n</details>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef maxProduct(self, nums: List[int]) -> int:    \\n\\t\\tans , max_p, min_p = nums[0], 1, 1   \\n\\t\\tfor num in nums:            \\n\\t\\t\\tmax_p, min_p = max(num, min_p * num, max_p * num), min(num, min_p * num, max_p * num)\\n\\t\\t\\tans = max(ans, max_p)\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975310,
                "title": "java-recursive-and-dp-solution-time-o-n-2-o-n-space-o-1",
                "content": "**Algorithm**\\n* **Approach 1 (Recursion - TLE)**\\n* call the recursive `dfs` function with each of the `index`\\n* In the recursive `dfs` function, the base case is to check if the passed `index` is going over the length of the `nums` array\\n* If not recurse with multiplying the result with the `index` element and increment the `index` for the next recursive call\\n\\n```\\nclass Solution {\\n     int max = Integer.MIN_VALUE;\\n     protected void dfs(int[] nums, int res, int index){\\n         if (index > nums.length-1)\\n             return;\\n         res = res * nums[index];\\n         max  = Math.max(max, res);\\n         dfs(nums, res, index+1);    \\n     }\\n     public int maxProduct(int[] nums) {\\n         if (nums.length == 0)\\n             return 0;\\n        \\n         for (int i=0;i<nums.length;i++){\\n             int res = 1;\\n             dfs(nums,res, i);\\n         }\\n         return max;\\n     }\\n```\\n* **Approach 2 (DP / Kadane\\'s Algorithm Accepted)**\\n* At each index we make sure to compute three values - overall max, max seen so far, min seen so far\\n* **maxEndingHere** will store all the max product seen so far \\n\\t* this will be coming from either the current element `nums[i]`\\n\\t* or the product of current element with `maxEndingHere` so far\\n\\t* or the product of current element with `minEndingHere` so far (two negative can be positive and may be higher)\\n* **minEndingHere** to store the mininmum product seen so far\\n\\t* this will be coming from either the current element itself `nums[i]`\\n\\t* or the product of current element with `minEndingHere` so far\\n\\t* or the product of current element with `maxEndingHere` (since max Ending here will be updated prior to this, we take the value of `maxEndingHere` just before updating in a temp variable)\\n* **maxOverall** to store the maximum product that was ever computed while iterating the elements, get the max from `maxOverall` and `maxEndingHere`\\n\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxOverall = nums[0];\\n        int maxEndingHere = nums[0];\\n        int minEndingHere = nums[0];\\n\\n        for (int i=1;i<nums.length; i++){\\n            int tmp = maxEndingHere;\\n            maxEndingHere = Math.max(nums[i], Math.max(nums[i] * maxEndingHere,nums[i] * minEndingHere));\\n            minEndingHere = Math.min(nums[i], Math.min(nums[i] * tmp,nums[i] * minEndingHere));\\n            maxOverall = Math.max(maxOverall, maxEndingHere);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     int max = Integer.MIN_VALUE;\\n     protected void dfs(int[] nums, int res, int index){\\n         if (index > nums.length-1)\\n             return;\\n         res = res * nums[index];\\n         max  = Math.max(max, res);\\n         dfs(nums, res, index+1);    \\n     }\\n     public int maxProduct(int[] nums) {\\n         if (nums.length == 0)\\n             return 0;\\n        \\n         for (int i=0;i<nums.length;i++){\\n             int res = 1;\\n             dfs(nums,res, i);\\n         }\\n         return max;\\n     }\\n```\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int maxOverall = nums[0];\\n        int maxEndingHere = nums[0];\\n        int minEndingHere = nums[0];\\n\\n        for (int i=1;i<nums.length; i++){\\n            int tmp = maxEndingHere;\\n            maxEndingHere = Math.max(nums[i], Math.max(nums[i] * maxEndingHere,nums[i] * minEndingHere));\\n            minEndingHere = Math.min(nums[i], Math.min(nums[i] * tmp,nums[i] * minEndingHere));\\n            maxOverall = Math.max(maxOverall, maxEndingHere);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841314,
                "title": "java-super-simple-short-solution-o-n-faster-than-95",
                "content": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0){\\n                int tmp = min_save;\\n                min_save = max_save;\\n                max_save = tmp;\\n            }\\n            min_save = Math.min(nums[i], min_save*nums[i]);\\n            max_save = Math.max(nums[i], max_save*nums[i]);\\n            max_pro = Math.max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n         // we keep also the minimum-product subarray for the case of multiplying negative with negative\\n        int max_pro = nums[0];\\n        int min_save = nums[0];\\n        int max_save = nums[0];\\n        for (int i=1; i<nums.length; i++) {\\n            // if we got a negative element, we will swap maximum with minimum\\n            if (nums[i] < 0){\\n                int tmp = min_save;\\n                min_save = max_save;\\n                max_save = tmp;\\n            }\\n            min_save = Math.min(nums[i], min_save*nums[i]);\\n            max_save = Math.max(nums[i], max_save*nums[i]);\\n            max_pro = Math.max(max_pro, max_save);\\n        }\\n        return max_pro;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457534,
                "title": "go-golang-kadane-s-algorithm-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximum Product Subarray.\\nMemory Usage: 2.7 MB, less than 100.00% of Go online submissions for Maximum Product Subarray.\\n\\n```go\\nfunc maxProduct(nums []int) int {\\n    curMax, curMin, ans := nums[0], nums[0], nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        tmp := curMax\\n        curMax = max(nums[i], max(tmp * nums[i], curMin * nums[i]))\\n        curMin = min(nums[i], min(tmp * nums[i], curMin * nums[i]))\\n        if curMax > ans { ans = curMax }\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maxProduct(nums []int) int {\\n    curMax, curMin, ans := nums[0], nums[0], nums[0]\\n    for i := 1; i < len(nums); i++ {\\n        tmp := curMax\\n        curMax = max(nums[i], max(tmp * nums[i], curMin * nums[i]))\\n        curMin = min(nums[i], min(tmp * nums[i], curMin * nums[i]))\\n        if curMax > ans { ans = curMax }\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417082,
                "title": "python-92-speed-in-6-lines-with-explanation",
                "content": "Intuitively, you need to keep track of a current product as well as a maximum product. The current product at each index in the list will choose to start the subarray over at that index or multiply it into the current product depending on which is bigger. But, because of negative products, we need to additionally keep track of a minimum current product, because a large negative value could be changed into positive again. So at each index, the min and max current products are chosen from starting the subarray over, continuing from curMax, or continuing from curMin.\\n\\n```\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax = curMin = maxProd = nums[0]\\n        for i in range(1, len(nums)):\\n            curMin, curMax = min(curMax * nums[i], curMin * nums[i], nums[i]), max(nums[i], curMax * nums[i], curMin * nums[i])\\n            maxProd = max(maxProd, curMax)\\n        return maxProd\\n```\\n\\n**Test case:**\\n\\n[0, 12, 3, -1, 1, 1, -10]\\n\\n[**0**, 12, 3, -1, 1, 1, -10]\\ncurMax = 0\\ncurMin = 0\\nmaxProd = 0\\n\\n[0, **12**, 3, -1, 1, 1, -10]\\ncurMax = 12\\ncurMin = 0\\nmaxProd = 12\\n\\n[0, 12, **3**, -1, 1, 1, -10]\\ncurMax = 36\\ncurMin = 0\\nmaxProd = 36\\n\\n[0, 12, 3, **-1**, 1, 1, -10]\\ncurMax = 0\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, **1**, 1, -10]\\ncurMax = 1\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, 1, **1**, -10]\\ncurMax = 1\\ncurMin = -36\\nmaxProd = 36\\n\\n[0, 12, 3, -1, 1, 1, **-10**]\\ncurMax = 360\\ncurMin = -10\\nmaxProd = 360\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, nums: List[int]) -> int:\\n        curMax = curMin = maxProd = nums[0]\\n        for i in range(1, len(nums)):\\n            curMin, curMax = min(curMax * nums[i], curMin * nums[i], nums[i]), max(nums[i], curMax * nums[i], curMin * nums[i])\\n            maxProd = max(maxProd, curMax)\\n        return maxProd\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 385813,
                "title": "python-simple-7-line-code-o-n-time-o-1-space-dp-better-than-99-51-of-submissions",
                "content": "```\\nclass Solution:\\n\\n    def maxProduct(self, nums: List[int]) -> int:\\n        min_ = max_ = overall_max = nums[0]\\n        \\n        for num in nums[1:]:\\n            temp_max = max(num, min_*num, max_*num)\\n            min_ = min(num, min_*num, max_*num)\\n            max_ = temp_max\\n            overall_max =  max(overall_max, max_)\\n            \\n        return overall_max\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def maxProduct(self, nums: List[int]) -> int:\\n        min_ = max_ = overall_max = nums[0]\\n        \\n        for num in nums[1:]:\\n            temp_max = max(num, min_*num, max_*num)\\n            min_ = min(num, min_*num, max_*num)\\n            max_ = temp_max\\n            overall_max =  max(overall_max, max_)\\n            \\n        return overall_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284569,
                "title": "c-dp-solution-o-n-time-o-1-space-with-detailed-explaination",
                "content": "```\\n\\n        SubProblem(i): \\n\\t\\t\\t\\t\\tMax[i]: the maximum product of a continuous subarray that ends at i\\n                    Min[i]: the minimum product of a continuous subarray that ends at i\\n\\t\\tAnalysis:\\n\\t\\t\\t\\tNote that since the subarray ends at i must include the ith element,\\n\\t\\t\\t\\tinorder to get the maximum product that ends at i we only has three cases\\n\\t\\t\\t\\tcase1: the maximum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. 1 2 3 4 5  we have Max[i] = Max[i-1] * nums[i] for all i\\n\\t\\t\\t\\tcase2: the minimum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. sign changes involves -1 2 3 4 5 -6, we have Max[5] = Min[4] * nums[5]\\n\\t\\t\\t\\t\\t(0 index)\\n\\t\\t\\t\\tcase3: the maximum product is the ith number\\n\\t\\t\\t\\t\\te.g. -1 0 0 1 we have Max[3] = 1\\n\\t\\tCombine these three cases we have:\\n\\t\\t\\tBase Case:\\n\\t\\t\\t\\t\\tMin[0] = nums[0], Max[0] = nums[0]\\n\\t\\t\\tRecursive Case:\\n\\t\\t\\t\\t\\t\\tMax[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\t\\t\\t\\tMin[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\tAnswer:\\n\\t\\t\\t\\t\\tmaximum Max[i]\\n\\t\\t\\tTime Complexity:\\n\\t\\t\\t\\tO(n)\\n\\t\\t\\tSpace Complexity:\\n\\t\\t\\t\\tO(1), by writing Max[i] as Max[i % 2]\\n    \\n\\n```\\n```\\nclass Solution {\\npublic:\\n  \\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n        int Min[2] = {nums[0], 0}, Max[2] = {nums[0], 0};\\n        int ans = Max[0], i;\\n        for (i = 1; i < n; i++) {\\n            Max[i % 2] = max(max(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            Min[i % 2] = min(min(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            ans = max(ans, Max[i % 2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n        SubProblem(i): \\n\\t\\t\\t\\t\\tMax[i]: the maximum product of a continuous subarray that ends at i\\n                    Min[i]: the minimum product of a continuous subarray that ends at i\\n\\t\\tAnalysis:\\n\\t\\t\\t\\tNote that since the subarray ends at i must include the ith element,\\n\\t\\t\\t\\tinorder to get the maximum product that ends at i we only has three cases\\n\\t\\t\\t\\tcase1: the maximum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. 1 2 3 4 5  we have Max[i] = Max[i-1] * nums[i] for all i\\n\\t\\t\\t\\tcase2: the minimum product that ends at i-1 times the ith number\\n\\t\\t\\t\\t\\te.g. sign changes involves -1 2 3 4 5 -6, we have Max[5] = Min[4] * nums[5]\\n\\t\\t\\t\\t\\t(0 index)\\n\\t\\t\\t\\tcase3: the maximum product is the ith number\\n\\t\\t\\t\\t\\te.g. -1 0 0 1 we have Max[3] = 1\\n\\t\\tCombine these three cases we have:\\n\\t\\t\\tBase Case:\\n\\t\\t\\t\\t\\tMin[0] = nums[0], Max[0] = nums[0]\\n\\t\\t\\tRecursive Case:\\n\\t\\t\\t\\t\\t\\tMax[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\t\\t\\t\\tMin[i] = max(Min[i-1] * nums[i], nums[i], Max[i-1] * nums[i])\\n\\t\\t\\tAnswer:\\n\\t\\t\\t\\t\\tmaximum Max[i]\\n\\t\\t\\tTime Complexity:\\n\\t\\t\\t\\tO(n)\\n\\t\\t\\tSpace Complexity:\\n\\t\\t\\t\\tO(1), by writing Max[i] as Max[i % 2]\\n    \\n\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 0) return 0;\\n        int Min[2] = {nums[0], 0}, Max[2] = {nums[0], 0};\\n        int ans = Max[0], i;\\n        for (i = 1; i < n; i++) {\\n            Max[i % 2] = max(max(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            Min[i % 2] = min(min(Max[(i - 1) % 2] * nums[i], nums[i]), Min[(i - 1) % 2] * nums[i]);\\n            ans = max(ans, Max[i % 2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188541,
                "title": "recursive-memoized-solution",
                "content": "\\nHer is the recursive memoized solution if you wanted to draw intuition for the iterative solution\\n\\n```\\n    public int maxProduct(int[] nums) {\\n        Integer[][] table = new Integer[nums.length][2] ;\\n        memo(nums.length-1,nums, table);\\n        int max = nums[0];\\n        \\n        for(Integer[] t : table)\\n            for(Integer val : t)\\n                max = Math.max(val,max);\\n        \\n        return max;     \\n    }\\n    \\n    Integer[] memo(int i, int[] nums, Integer[][] dp){\\n        if(i == 0)\\n            dp[i] = new Integer[]{nums[0],nums[i]};\\n        if(dp[i][0] == null){\\n            dp[i][0] = Math.min(memo(i-1,nums,dp)[1] * nums[i],Math.min(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n            dp[i][1] = Math.max(memo(i-1,nums,dp)[1] * nums[i],Math.max(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n                        \\n        }\\n        return dp[i];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxProduct(int[] nums) {\\n        Integer[][] table = new Integer[nums.length][2] ;\\n        memo(nums.length-1,nums, table);\\n        int max = nums[0];\\n        \\n        for(Integer[] t : table)\\n            for(Integer val : t)\\n                max = Math.max(val,max);\\n        \\n        return max;     \\n    }\\n    \\n    Integer[] memo(int i, int[] nums, Integer[][] dp){\\n        if(i == 0)\\n            dp[i] = new Integer[]{nums[0],nums[i]};\\n        if(dp[i][0] == null){\\n            dp[i][0] = Math.min(memo(i-1,nums,dp)[1] * nums[i],Math.min(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n            dp[i][1] = Math.max(memo(i-1,nums,dp)[1] * nums[i],Math.max(memo(i-1,nums,dp)[0] * nums[i], nums[i]));\\n                        \\n        }\\n        return dp[i];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118535,
                "title": "c-dp-solution-using-2-arrays",
                "content": "The following solution is acheived using Dynamic Programming concept. We are finding the maximum product posssible(pos[]) and the minimum product possible(neg[]) at each step.\\n\\nWe have to maintain the minimum possible product because if we encounter a negative number in future, this product will result into the maximum positive value\\n\\n```\\nclass Solution {\\npublic:\\n    inline int maximum(const int& a,const int& b,const int& c) {\\n        return a>b?(a>c?a:c):(b>c?b:c);\\n}\\n    \\n    inline int minimum(const int& a,const int& b,const int& c) {\\n        return a<b?(a<c?a:c):(b<c?b:c);\\n}\\n    int maxProduct(vector<int>& nums) {\\n        //Making two dp arrays to store the maximum postive product and minimum negative product at each point\\n        int size = nums.size();\\n        int pos[size],neg[size];\\n        \\n        //Initialize to first term\\n        pos[0] = nums[0];\\n        neg[0] = nums[0];\\n        int ans = nums[0];\\n        \\n        //The positive array tries toget the max product while the negative array tries to get the least\\n        for(int i=1; i<size; i++) \\n        {\\n            pos[i] = maximum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]); \\n            neg[i] = minimum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]);\\n           \\n            ans = max(ans, pos[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThankyou @shinichish for the [solution](https://leetcode.com/problems/maximum-product-subarray/discuss/48261/Share-my-DP-code-that-got-AC). \\nAlso, the given solution can be solved just using 2 variables - Check [this](https://leetcode.com/problems/maximum-product-subarray/discuss/48261/Share-my-DP-code-that-got-AC/48395)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    inline int maximum(const int& a,const int& b,const int& c) {\\n        return a>b?(a>c?a:c):(b>c?b:c);\\n}\\n    \\n    inline int minimum(const int& a,const int& b,const int& c) {\\n        return a<b?(a<c?a:c):(b<c?b:c);\\n}\\n    int maxProduct(vector<int>& nums) {\\n        //Making two dp arrays to store the maximum postive product and minimum negative product at each point\\n        int size = nums.size();\\n        int pos[size],neg[size];\\n        \\n        //Initialize to first term\\n        pos[0] = nums[0];\\n        neg[0] = nums[0];\\n        int ans = nums[0];\\n        \\n        //The positive array tries toget the max product while the negative array tries to get the least\\n        for(int i=1; i<size; i++) \\n        {\\n            pos[i] = maximum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]); \\n            neg[i] = minimum(nums[i], pos[i-1]*nums[i],neg[i-1]*nums[i]);\\n           \\n            ans = max(ans, pos[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48303,
                "title": "summary-of-maximum-subarray-maximum-product-subarray",
                "content": "Maximum Product Subarray\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int result = nums[0], global_min = nums[0], global_max = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            int local_min = global_min, local_max = global_max;\\n            global_max = max(max(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            global_min = min(min(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            result = max(result, global_max);\\n        }\\n        return result;\\n    }\\n};\\n```\\nMaximum Subarray\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int global = nums[0];\\n        int local = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            local = max(nums[i], local + nums[i]);\\n            global = max(global, local);\\n        }\\n        return global;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        int result = nums[0], global_min = nums[0], global_max = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            int local_min = global_min, local_max = global_max;\\n            global_max = max(max(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            global_min = min(min(nums[i], local_max * nums[i]), local_min * nums[i]);\\n            result = max(result, global_max);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48346,
                "title": "o-n-time-o-1-space-c-solution",
                "content": "\\n    class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            assert (!nums.empty());\\n            int curMax = nums[0], curMin = nums[0], res = nums[0];\\n            for (int i = 1; i < nums.size(); ++i) {\\n                int mx = curMax, mn = curMin;\\n                curMax = max(max(mx * nums[i], mn * nums[i]), nums[i]);\\n                curMin = min(min(mx * nums[i], mn * nums[i]), nums[i]);\\n                res = max(res, curMax);\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProduct(vector<int>& nums) {\\n            assert (!nums.empty());\\n            int curMax = nums[0], curMin = nums[0], res = nums[0];\\n            for (int i = 1; i < nums.size(); ++i) {\\n                int mx = curMax, mn = curMin;\\n                curMax = max(max(mx * nums[i], mn * nums[i]), nums[i]);\\n                curMin = min(min(mx * nums[i], mn * nums[i]), nums[i]);\\n                res = max(res, curMax);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48408,
                "title": "share-accepted-dp-java-o-n-solution",
                "content": "    public class Solution {\\n        public int maxProduct(int[] nums) {\\n            int n = nums.length;\\n            int[] maxProduct = new int[n];\\n            int[] minProduct = new int[n];\\n            maxProduct[0] = nums[0];\\n            minProduct[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n               int[] temp = new int[3];\\n               temp[0] = nums[i];\\n               temp[1] = nums[i] * maxProduct[i - 1];\\n               temp[2] = nums[i] * minProduct[i - 1];\\n               Arrays.sort(temp);\\n               minProduct[i] = temp[0];\\n               maxProduct[i] = temp[2];\\n            }\\n            int max = Integer.MIN_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                if (maxProduct[i] > max) {\\n                    max = maxProduct[i];\\n                }\\n            }\\n            return max;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProduct(int[] nums) {\\n            int n = nums.length;\\n            int[] maxProduct = new int[n];\\n            int[] minProduct = new int[n];\\n            maxProduct[0] = nums[0];\\n            minProduct[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n               int[] temp = new int[3];\\n               temp[0] = nums[i];\\n               temp[1] = nums[i] * maxProduct[i - 1];\\n               temp[2] = nums[i] * minProduct[i - 1];\\n               Arrays.sort(temp);\\n               minProduct[i] = temp[0];\\n               maxProduct[i] = temp[2];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3748707,
                "title": "c-python-kadane-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKadane\\'s Algorithm for maximal product for subarrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/solutions/3748707/c-kadane-s-algorithm/)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)\\n\\nThe code solves the problem of finding the maximum product of a subarray within an input vector nums. It is based on the Kadane\\'s algorithm, which is typically used to find the maximum sum of subarrays. However, in this case, instead of finding the maximum sum, we need to find the maximum product.\\n\\nIn the modified version of the algorithm for finding the maximum product, instead of considering the sum, the code tracks the product. However, due to the presence of negative numbers, simply considering the maximum product ending at the current index is not sufficient. Negative numbers can potentially result in a larger product when multiplied by another negative number. Hence, it becomes necessary to keep track of both the maximum and minimum products ending at each index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int x0=nums[0];\\n        int max_product = x0;  \\n        int curr_max = x0; \\n        int curr_min = x0;  \\n        \\n        for (int i=1; i<n; i++) {\\n            int x=nums[i];\\n            if (x < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products\\n            curr_max = max(x, curr_max * x);\\n            curr_min = min(x, curr_min * x);\\n            \\n            // Update the overall maximum product\\n            max_product = max(max_product, curr_max);\\n        }\\n        return max_product;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        x0=nums[0]\\n        max_p=x0\\n        curr_max=x0\\n        curr_min=x0\\n\\n        for x in nums[1:]:\\n            if x<0:\\n                tmp=curr_max\\n                curr_max=curr_min\\n                curr_min=tmp\\n            curr_max=max(curr_max*x, x)\\n            curr_min=min(curr_min*x, x)\\n\\n            max_p=max(max_p, curr_max)\\n        return max_p\\n```\\n# C++ code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_prod = nums[0];  // Initialize the maximum product\\n        int curr_max = nums[0];  // Store the maximum product ending at the current index\\n        int curr_min = nums[0];  // Store the minimum product ending at the current index\\n        \\n        for (int i = 1; i < n; i++) {\\n            // If the current number is negative, swap the maximum and minimum products\\n            if (nums[i] < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products for the current index\\n            curr_max = max(nums[i], curr_max * nums[i]);\\n            curr_min = min(nums[i], curr_min * nums[i]);\\n            \\n            // Update the overall maximum product if necessary\\n            max_prod = max(max_prod, curr_max);\\n        }\\n        \\n        return max_prod;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int x0=nums[0];\\n        int max_product = x0;  \\n        int curr_max = x0; \\n        int curr_min = x0;  \\n        \\n        for (int i=1; i<n; i++) {\\n            int x=nums[i];\\n            if (x < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products\\n            curr_max = max(x, curr_max * x);\\n            curr_min = min(x, curr_min * x);\\n            \\n            // Update the overall maximum product\\n            max_product = max(max_product, curr_max);\\n        }\\n        return max_product;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        x0=nums[0]\\n        max_p=x0\\n        curr_max=x0\\n        curr_min=x0\\n\\n        for x in nums[1:]:\\n            if x<0:\\n                tmp=curr_max\\n                curr_max=curr_min\\n                curr_min=tmp\\n            curr_max=max(curr_max*x, x)\\n            curr_min=min(curr_min*x, x)\\n\\n            max_p=max(max_p, curr_max)\\n        return max_p\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_prod = nums[0];  // Initialize the maximum product\\n        int curr_max = nums[0];  // Store the maximum product ending at the current index\\n        int curr_min = nums[0];  // Store the minimum product ending at the current index\\n        \\n        for (int i = 1; i < n; i++) {\\n            // If the current number is negative, swap the maximum and minimum products\\n            if (nums[i] < 0)\\n                swap(curr_max, curr_min);\\n            \\n            // Update the maximum and minimum products for the current index\\n            curr_max = max(nums[i], curr_max * nums[i]);\\n            curr_min = min(nums[i], curr_min * nums[i]);\\n            \\n            // Update the overall maximum product if necessary\\n            max_prod = max(max_prod, curr_max);\\n        }\\n        \\n        return max_prod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251454,
                "title": "easy-solution-o-n-time-complexity-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can easily reach to the solution by finding out the max product from left side and right side of the array.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we have to traverse the array from **0th** index till the last index of **nums[]** array and keep on multiplying the **curr** value with the current index value and check whether **curr > max** or not. If **curr > max** then we simply update max as curr. \\n\\nif there\\'s an index in the array whose value is 0 then the curr value gets updated to 1 **(as after that curr value will remain as 0 till the end if we do not update it)**.\\n\\n\\nSimilarly, we traverse from the last index and apply the same logic again.\\n\\nWe do this because, \\n\\nfor nums[] = [3,-1,4] , if we traverse from left index only then we get the max value as **3**. \\n\\nmax at index 0 = 3;\\nmax at index 1 = 3(product will be -3);\\nmax at index 2 = 3(product will be -12);\\n\\nbut we can see that the maximum product will be **4** if we traverse from the right side of the array.\\n\\nmax at index 2 = 4;\\nmax at index 1 = 4(product will be -4);\\nmax at index 0 = 4(product will be -12);\\n\\nhence , when we traverse from the last also it will rectify the mistake and give us the correct answer as **4**.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int curr = 1;\\n        int i , j , len = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        for(i = 0 ; i < len ; i++){\\n            curr *= nums[i];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        curr = 1;\\n        for(j = len - 1 ; j >= 0 ; j--){\\n            curr *= nums[j];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProduct(int[] nums) {\\n        int curr = 1;\\n        int i , j , len = nums.length;\\n        int max = Integer.MIN_VALUE;\\n        for(i = 0 ; i < len ; i++){\\n            curr *= nums[i];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        curr = 1;\\n        for(j = len - 1 ; j >= 0 ; j--){\\n            curr *= nums[j];\\n            if(curr > max){\\n                max = curr;\\n            }\\n            if(curr == 0){\\n                curr = 1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565102,
                "title": "o-n-tc-o-1-sc-two-scan-even-and-odd-negative-number-approach",
                "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        res=nums[0]\\n        temp=1\\n        for i in nums:\\n            temp*=i\\n            res=max(res,temp)\\n            if temp==0:\\n                temp=1\\n        temp=1\\n        for i in reversed(nums):\\n            temp*=i\\n            res=max(temp,res)\\n            if temp==0:\\n                temp=1\\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        res=nums[0]\\n        temp=1\\n        for i in nums:\\n            temp*=i\\n            res=max(res,temp)\\n            if temp==0:\\n                temp=1\\n        temp=1\\n        for i in reversed(nums):\\n            temp*=i\\n            res=max(temp,res)\\n            if temp==0:\\n                temp=1\\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566383,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1827167,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568984,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574343,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2059311,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566672,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1965281,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1785312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565370,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566383,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1827167,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568984,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574343,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 2059311,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566672,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1965281,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1785312,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565370,
                "content": [
                    {
                        "username": "siddhantchimankar",
                        "content": "* Highly non-intuitive.\\n* Even if you figure out the idea, very difficult to implement correctly since there are many corner cases.\\n* A person who has seen and memorized the solution holds a huge advantage.\\n\\n"
                    },
                    {
                        "username": "Limon020",
                        "content": "I disagree, I found this problem to be quite intuitive and I am not very good at DP. First I drew the decision tree, realized there was no way to improve on it from brute force, then you realize that each position can produce a maximum value or a minimum value, and from that we can deduce the next positions max or min value and so on (working backwards)."
                    },
                    {
                        "username": "201132",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) no it still fails around 40 cases"
                    },
                    {
                        "username": "mehvix",
                        "content": "* Cope"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Aman__Bhardwaj](/Aman__Bhardwaj) You\\'re correct. Kadane\\'s algorithm won\\'t work directly for this problem due to the presence of negative numbers. Kadane\\'s algorithm is a dynamic programming solution that works for finding the maximum sum subarray by keeping track of the maximum sum at each position in the array, assuming that the maximum sum at the current position is either the current number itself or the maximum sum up to the previous position plus the current number.\\n\\nHowever, in this problem, because we\\'re looking for the maximum product, the presence of negative numbers complicates things. A negative number could become a positive product if it\\'s multiplied by another negative number. So, we cannot simply discard a negative product thinking it won\\'t contribute to the maximum product because it may contribute to the maximum product later when multiplied with another negative number.\\n"
                    },
                    {
                        "username": "mayursonowal7",
                        "content": "Amen dude amen."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "[@Ankit_Hanotia](/Ankit_Hanotia) I believe, Kadane\\'s Algo will not work... Kadane\\'s Algo is a greedy algo and in this ques greedy will give incorrect results due to the presence of -ve numbers. "
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "use kadane\\'s algorithm [if(sum == 0)     sum = 1]\\ntime complexity of profram is O(n);\\nno need of corner cases !!!!!\\n"
                    },
                    {
                        "username": "shubham_kewat",
                        "content": "we just need to keep in mind, when  the produce minimal. it can be either in negative or 0. then we can solve the problem easily :)"
                    },
                    {
                        "username": "archip",
                        "content": "I\\'ve come up with another, more intuitive approach. It\\'s different to the traditional prefix/suffix solution. See here if you\\'re interested: https://leetcode.com/problems/maximum-product-subarray/solutions/3126003/beats-98-o-1-space-o-n-time-new-idea/"
                    },
                    {
                        "username": "kuelf",
                        "content": "Not at all difficult to implement. There\\'s only one corner case of the nums size being 1. Other than that all cases fit in general category. See : https://leetcode.com/problems/maximum-product-subarray/submissions/866819845/ \\n\\n"
                    },
                    {
                        "username": "dsacj",
                        "content": "Try working your solution out for this testcase:\\n[-1,4,-4,5,-2,-1,-1,-2,-3]\\nHope it helps."
                    },
                    {
                        "username": "jun15",
                        "content": "Since all the elements in the array are integers. If there are even number of negative elements, the maximum product will be the multiplication of all the elements. If there are odd number of negative elements, we can just compare the products of the following two:\\n1. multiplication of all the elements until we find the last negative element.\\n2. multiplication of all the elements starting after the first negative element. \\nBoth cases contain even number of negative elements and the result will be positive. Is this a correct analysis?"
                    },
                    {
                        "username": "shashankjagtap8806",
                        "content": "what about 0s\\n"
                    },
                    {
                        "username": "vindog",
                        "content": "[@kursdragon](/kursdragon) Yes, I used a combination of the two ideas: Split the array by 0s so that each subarray has only non-zero elements. Then apply jun15's algorithm to get the max product for each subarray. The global max will be the max of the max product for each subarray (and the product of the whole original array, of course). All of this can be done in one pass."
                    },
                    {
                        "username": "kursdragon",
                        "content": "This isn\\'t true, you also need to look at the case where you have a 0 in the array, since if you include a zero it will make whatever the rest of the numbers are multiplied together 0 as well. But you could do a similar idea but doing before and after zeros as well"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "It is really hard to understand your words contiguously meaning adjacent or including all nums in the array. make sure you give us some examples showing those cases if you want to write your description so ambiguously."
                    },
                    {
                        "username": "0icy",
                        "content": "its your problem if you dont understand english, not the problem setters fault"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "Contiguous literally means adjacent"
                    },
                    {
                        "username": "wrakc",
                        "content": "Why the result for this [-3,0,1,-2] is 1 and not 0?\\nI am not able to clearly understand this situation, can anyone help?"
                    },
                    {
                        "username": "srinumocharla",
                        "content": "the answer is 1 because max(0,1) is obviously 1 so they asked about maxProduct"
                    },
                    {
                        "username": "aniketme8201",
                        "content": "because 1 is also a subarray"
                    },
                    {
                        "username": "redghost50",
                        "content": "This problem is flawed. A product is the multiplication of two or more numbers a sub array or nums array of size 1 cannot have a product by definition. So yes in that example the result should be 0 or the problem should be reworded."
                    },
                    {
                        "username": "dan_stark123",
                        "content": "you are asked to find the max product of adjacent elements"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "Because your answer is [1], which is maximum "
                    },
                    {
                        "username": "bparanj",
                        "content": "In the given array [-3,0,1,-2], the maximum product subarray is indeed [1]. This is because a subarray must be contiguous, and we are asked to find the maximum product that can be achieved from any such subarray. \\n\\nIf we multiply any number by 0, the product becomes 0. So, a subarray that contains 0 cannot yield a maximum product, unless the rest of the numbers in the array are all 0 or less. In this case, the maximum product that we can achieve is 1, which is the single element subarray [1].\\n\\nThe confusion might arise from considering the entire array as a subarray, but remember that a single number is also considered a subarray. So, while [-3, 0, 1, -2] or [0] are valid subarrays, they don\\'t give the maximum product, which is 1 in this case."
                    },
                    {
                        "username": "Socrii13",
                        "content": "subarray get multiplied and come at 0 , as required to get the maximum subarray so 1 is also a subarray"
                    },
                    {
                        "username": "sachinparmar3803",
                        "content": "bcz there is little sub arry [1] and product of it self is one which is greater than zero\\n"
                    },
                    {
                        "username": "sanjayadhikari",
                        "content": "If you take a subarray starting at value 1 or index 2, there are two sub-arrays [1] and [1,-2] yielding maximum product result 1 and -2 respectively. Hence, answer is 1."
                    },
                    {
                        "username": "Siddharth_singh",
                        "content": "because 1>0"
                    },
                    {
                        "username": "iammuditverma",
                        "content": "I get this error for test case : \\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n\\nLine 9: Char 31: runtime error: signed integer overflow: 1000000000 * -10 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:18:31\\n\\nNot just my code, but I have tried looking at others\\' solutions and those don\\'t work either."
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "[@GA1_I1_E0](/GA1_I1_E0) double res = nums[0];\\n        double min = nums[0];\\n        double max = nums[0];\\n\\n        for(int i=1;i<nums.length;i++) {\\n            double newMin = Math.min(nums[i], Math.min(min*nums[i], max*nums[i]));\\n            double newMax = Math.max(nums[i], Math.max(min*nums[i], max*nums[i]));\\n            res = Math.max(res, Math.max(newMin, newMax));\\n            min = newMin;\\n            max = newMax;\\n        }\\n\\n        return (int)res;"
                    },
                    {
                        "username": "GA1_I1_E0",
                        "content": "in my case i use double in java and when i return my answer i typecase to int \\nit works for me"
                    },
                    {
                        "username": "CruzJoel3",
                        "content": "Is there a reason people aren\\'t using sliding window? it\\'s O(N), and it\\'s not bad to implement"
                    },
                    {
                        "username": "Rockro",
                        "content": "[@Vithesh](/Vithesh) kadane\\'s algo ki spelling tw sikh le bro"
                    },
                    {
                        "username": "Vithesh",
                        "content": "[@somashekhar_98](/somashekhar_98)  yes you are wrong. please do check out kadnes algorithm."
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason sliding window technique is not typically used for this problem is that the maximum product subarray doesn\\'t follow the properties required for sliding windows. \\n\\nSliding window technique is typically applied on arrays when the problem can be solved by identifying a contiguous block of elements satisfying certain conditions. The key aspect is that the condition should be such that, if it is satisfied by a window (a, b), then it should be satisfied by any window (a, b\\'), where b\\' > b. Therefore, the problem has to have the property that adding more elements to the window can\\'t invalidate the condition. \\n\\nIn the case of the maximum product subarray problem, it\\'s not just about contiguous blocks of positive numbers or negative numbers, because the product is affected by the number of negative numbers (an even number of negatives multiplied together give a positive product). A sliding window wouldn\\'t easily account for this because adding a new negative number into the window could switch the product from positive to negative or vice versa, depending on the current product. \\n\\nThus, problems like maximum/minimum sum subarray, longest substring with k distinct characters, etc., which hold properties necessary for sliding window approach, are suitable for this technique. But the maximum product subarray problem doesn\\'t possess these properties which makes it not suitable for sliding window technique.\\n\\nHence, this problem is best solved using dynamic programming, where we keep track of the maximum and minimum product up to the current position, which can handle the negative numbers case."
                    },
                    {
                        "username": "SanjayGugan",
                        "content": "I\\'ve implememnted a sliding window approach, but we also have to iterate and apply the approach from the last of the array. Ex: [-2,-3,-4], here using sliding window approach we get 6 as the max(when we iterate from the beginning, but when we iterate from the last , we get 12. Edge cases must be checked."
                    },
                    {
                        "username": "hamin3",
                        "content": "Utilizing a sliding window is definitely possible with a variable-sized window. the key is to shrink the window when you hit a zero or the end of the array and increase the window otherwise."
                    },
                    {
                        "username": "somashekhar_98",
                        "content": "i think we can\\'t use sliding window because we can\\'t decide the size of window to use , since here we are asked on subarray.\\n\\nif i am wrong, please do correct me"
                    },
                    {
                        "username": "dkvern01",
                        "content": "[@ashish7475](/ashish7475)  I haven\\'t done the problem, but I would imagine sliding window is possible with some if conditions. I might however be wrong."
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@andvalsol](/andvalsol) sliding window is not aplicable with negatives\\n"
                    },
                    {
                        "username": "andvalsol",
                        "content": "I think that the reason is because the numbers are not in order."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Kadane\\'s algorithm is used for solving some other problems which are more as follows:\\n\\n[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3722855/w-explanationc-using-kadanes-algorithm/)\\n\\n[53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-interview-150)\\n\\n[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/solutions/3738775/c-kadane-s-algorithm/)"
                    },
                    {
                        "username": "Achilles_107",
                        "content": "Tips to remember:\\n1. Check if size is 1, then return nums[0]\\n2. Check if you total prod is positive (skip the zero), if positive then return total prod.\\n3. Iterate through the array, and keep track of max/min  prods till index i (update min or max carefully)\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-product-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1571346,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058942,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1571343,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1570007,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2059974,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058644,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1988153,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1576410,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 2058704,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1810599,
                "content": [
                    {
                        "username": "sudeeshs",
                        "content": "Hi there leetcoders,\\n\\n   I can't digest why the expected output of the testcase [-2, 3 -4] is 24? The numbers aren't contiguous!!\\n\\nAnd how do you obtain 24? |-2| * |3| * |-4| ???? Weird! Haaallppp!!!"
                    },
                    {
                        "username": "A_ADITI",
                        "content": "[@rahulbhatta](/rahulbhatta)   hey can u tell me how to check all the test cases "
                    },
                    {
                        "username": "rahulbhatta",
                        "content": "Exactly. The first case is expected to be 6,makes sense if you are getting the max of only 2 inputs. But in the 84th case, they expect the muliplication of all the values in the list."
                    },
                    {
                        "username": "ThatsBig",
                        "content": "-2*(-4) = 8"
                    },
                    {
                        "username": "s_r_1000",
                        "content": "This is the definition of contiguous, a continuous subarray. So when you do:\\n\\n-2 * 3 * -4 you get 24, because the values are one after the other."
                    },
                    {
                        "username": "hp01",
                        "content": "(-2 * 3 * -4) = 24"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "product of tow negative numbers comes positive my mate"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "its -2*3*-4 which is +24\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@bhardwajashish](/bhardwajashish) true its so obvious bro"
                    },
                    {
                        "username": "vipin0761",
                        "content": "no need to take \"abs\" value, -2*3*-4=24"
                    },
                    {
                        "username": "bhardwajashish",
                        "content": "bro product of 2 negative is positive, [-2,3,-4] it is a subset in itself, hence -2*3*-4 = 24\\n"
                    },
                    {
                        "username": "Yash2403",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nWho the hell added this test case ?"
                    },
                    {
                        "username": "prakhar241",
                        "content": "We can certainly devise divide and conquer for Maximum sum subarray, but while developing divide and conquer based algorithm for maximum product subarray, I found we might need to keep the maximum & absolute maximum for both parts (and crossing products), but it seems we can devise it. I was just curios why I don't see any divide and conquer based algorithm in discussions?\\n\\nIs it because since we keep the max and global max are we going towards the DP?\\n\\nAny idea will be appreciated. I just want to clarify my understanding for approach. Thanks."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the Maximum Subarray Problem can be solved using a divide and conquer approach, which is based on the observation that a contiguous subarray\\'s maximum sum is either in the left half, right half, or crosses the middle.\\n\\nFor the Maximum Product Subarray Problem, a divide and conquer approach is a bit trickier, due to the nature of multiplication. In the case of sum, you only need to care about the largest sum; but in the case of product, you need to consider both the largest and smallest (most negative) product, because a negative number can turn the smallest product into the largest.\\n\\nWhile you could technically use a divide and conquer approach similar to the maximum sum subarray problem, the reason you don\\'t see it often in discussions or solutions is because it\\'s more complicated and doesn\\'t offer any significant advantages in terms of time complexity. The time complexity for both the divide and conquer and dynamic programming (DP) solutions is O(n), but the DP solution tends to be simpler to understand and implement.\\n\\nIn terms of your question about DP: yes, keeping track of the maximum and global maximum as you iterate through the array is a form of DP. In essence, DP is about breaking a problem down into smaller subproblems, and reusing solutions to those subproblems to build up the solution to the overall problem. In this case, the subproblems are finding the maximum product subarray ending at each position in the array, and you\\'re reusing those solutions to find the maximum product subarray over the entire array."
                    },
                    {
                        "username": "shiv_commit",
                        "content": "we can also \\napply, extension of kadance algo"
                    },
                    {
                        "username": "andrewtgg",
                        "content": "Why is expected output 2? how do you get that value?"
                    },
                    {
                        "username": "cthuga",
                        "content": "There is a testcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nand constraint says: The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\\nWhich is clearly not true. Can someone help me understand here ?"
                    },
                    {
                        "username": "anurag_333",
                        "content": "a new test case is added which voilates the constraint.\\nCode that was AC earlier is getting overflowed\\n\\n"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "How many people initially went ahead with directly implementing Kadane\\'s algorithm only to realize that the direct implementation doesn\\'t work?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/4dbff713-aa0c-4c2d-b920-2530b32e0548_1645155457.5751603.jpeg)\\n"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "What part of no solutions in discussion did you not understand?"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@ashish7475](/ashish7475)  i got it , just to eradicate all edge cases we can traverse from both sides or in other words kedane from both sides."
                    },
                    {
                        "username": "ashish7475",
                        "content": "can you share the intuition behind this appraoch\\n"
                    },
                    {
                        "username": "aftabmk",
                        "content": "Everyone : Kadane\\'s Algorithm !\\ntestcase [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] : No!"
                    },
                    {
                        "username": "jwggernawt",
                        "content": "Is it considered product when there is only one operand?\\nFor example: array=[3]. "
                    },
                    {
                        "username": "fkhd",
                        "content": "Personally I don\\'t think so. But they are considering it in their usecases."
                    }
                ]
            },
            {
                "id": 1748589,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1974202,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1847212,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1794899,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1571344,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1571345,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1575812,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1575634,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1573941,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 1573099,
                "content": [
                    {
                        "username": "vik24k",
                        "content": "nums =\\n[0,2]\\n\\nOutput\\n0\\n\\nExpected\\n2\\n\\nhow?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem asks for the maximum product subarray, and in this case, the maximum product is 2. A subarray can be any contiguous part of the original array. In this case, the subarray [2] has the highest product. The subarray [0] has a product of 0, and the entire array [0,2] also has a product of 0 (since any number multiplied by 0 equals 0), so both of those options would be smaller than the product of the subarray [2]. \\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "[@Crispy_coffee](/Crispy_coffee) Being a subarray is not equal to the product of subarray elements. \\n"
                    },
                    {
                        "username": "0x415374",
                        "content": "this should be wrong, as the statement clearly says that the largest product has to be returned. A  product requires at least two factorials, so the subarray length needs to be >= 2"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "because 2 is also a subarray and 2>0 , this is why the answer is 2."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I maintain the prefix and suffix product of the array. If at any time the prefix or suffix product is equal to 0, then I update it to 1. I update the current answer as the maximum of the prefix or suffix product. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHere is how I maintain the prefix and suffix product:\\n1. Initialize the prefix product to 1 and the suffix product to 1.\\n2. Iterate over the array.\\n3. In each iteration, multiply the prefix product by the current element.\\n4. Multiply the suffix product by the element at the end of the array, which is nums[n - i - 1].\\n6. If the prefix or suffix product is equal to 0, then I update it to 1. (The reason why I update the prefix or suffix product to 1 if it is equal to 0 is because I want to ensure that the product is never 0. If the product is 0, then the maximum product subarray will be 0.)\\n7. I update the current answer as the maximum of the prefix or suffix product.\\n8. I also update the final answer as the maximum of the current answer and the final answer.\\n\\nHOPE IT HELPS !\\n"
                    },
                    {
                        "username": "fkhd",
                        "content": "Any product involves atleast two numbers. Even if it is a subarray there should me no possible product for the single element.  For the usecase : [0,2]. The output they are expecting is 2.  It must be 0.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The term \"product\" in mathematics generally refers to the result of multiplying two or more numbers together. However, in the context of this problem, when considering a subarray of just one element, the \"product\" of the subarray is simply the number itself. \\n\\nThis convention allows us to handle cases where the input array contains just one element, or the maximum product is achieved with a single-element subarray. In this sense, a product of a single number can be considered as that number \"multiplied by 1\". \\n\\nSo, for the array [0,2], the maximum product subarray is [2], and thus the maximum product is 2. \\n\\nThis may seem a little counter-intuitive based on the traditional definition of \"product\", but it\\'s a useful abstraction for the purposes of solving this type of problem."
                    },
                    {
                        "username": "ahmadafghan",
                        "content": "Python solution:\\n\\ndef maxProduct(self, nums: List[int]) -> int:\\n        maxProduct = nums[0]\\n        minProduct = nums[0]\\n        result = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < 0:\\n                maxProduct, minProduct = minProduct , maxProduct \\n            maxProduct = max(nums[i], maxProduct * nums[i])\\n            minProduct = min(nums[i], minProduct * nums[i])\\n            result = max(result, maxProduct)\\n        return result \\n\\n        #time O(N)  n is the lenght of the input array \\n        #space O(1) using constant spance"
                    },
                    {
                        "username": "alexTheCoder",
                        "content": "From the known cases, the sequence of 2 , -3 , 1 , 2 , 3 , -2 is considered contiguous, so is -1, 1, it seems to me that zero is omitted, and duplicates are allowed, so, what is the requirement?"
                    },
                    {
                        "username": "ZonaZZZ",
                        "content": "Shouldn't it be -1? There is no contiguous number in this array except for itself."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a subarray can consist of a single number. So if the array only has one number, then that number itself is considered a subarray. Therefore, if you have an array [3] (with just one number 3), then the maximum product subarray is 3, which is the number itself.\\n\\nSimilarly, for an array [-1], the maximum product subarray is -1, because -1 is the only element and thus the only subarray.\\n\\nThis is a valid interpretation because in mathematics, the product of a single number is the number itself. In this problem, we\\'re looking for the maximum product of numbers in a subarray, so a single number counts as its own product. \\n\\nThe statement \"find the contiguous subarray within an array (containing at least one number) that has the largest product\" allows for this interpretation because it specifies \"at least one number,\" meaning a single number can constitute a subarray."
                    },
                    {
                        "username": "onesong2021",
                        "content": "If we have a non-zero array, that has the max product in the middle which doesn\\'t contains start and end number, then sliding window will not work.\\nBut, because the input is an integer array, the max product will not appear in the middle, it must at least contains one of start and end.\\n\\nLet\\'s assume, we have a non-zero integer array, which has the max product(P) in the middle.\\nThen this P will surround by two non-zero integers(a, b).\\nwhen a >= 1 && b >= 1 (P must > a , b > 0),  P <= P * a * b\\nwhen a >= 1 && b <= -1 (P must > a , b > 0), P <= P * a\\nwhen a <=-1 && b >= 1 (P must > a , b > 0), P <= P * b\\nwhen a <= -1 && b <= -1:\\n\\twhen P > 0, P <= P * a * b\\n\\twhen P < 0, P < P * a / P * b\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "[-2,0,1,-2] contradicts your assumption (max product is 1, doesn\\'t include the first nor the last - the 0 there nullifies the product of extremes)"
                    },
                    {
                        "username": "revenant7",
                        "content": "A good example which shows understanding the question clearly is important before coding. I thought of product as multiplication of two numbers (a * b), which means [2] gives result as 0. But this problem answers 2 for input [2] which made my code to fail for some test-cases."
                    },
                    {
                        "username": "max_223",
                        "content": "Refer below for O(n) time solution with constant space in C++/Java/Python\\nhttps://www.techiedelight.com/find-maximum-product-subarray-given-array/"
                    },
                    {
                        "username": "Manashi",
                        "content": "Some wrong solutions pass, as my own solution is wrong."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Ha Ha... Funny "
                    }
                ]
            },
            {
                "id": 2067626,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2062140,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2062075,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2061987,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2060675,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2056191,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2047587,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2046387,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2043534,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2034485,
                "content": [
                    {
                        "username": "yogiwaran2003",
                        "content": "why can't be the sub array be {3,4} or {2,4} it has the maximum product?\n"
                    },
                    {
                        "username": "kaylent",
                        "content": "[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0] testcase moves this task from an interesting one to the edge-case-hell..."
                    },
                    {
                        "username": "anmay007",
                        "content": "I am failing at only one test case that is [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]  my output is 1981284352   and the expected one is1000000000.. I am not able to understand how i am getting this wrong..remaining all test cases are fine..please help"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "If(res == 1000000000) break;\\n\\nPut this base case in your loop\\nIt will surely be fixed"
                    },
                    {
                        "username": "mihirpanchal555",
                        "content": "how to solve this test case\\n[0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\n??"
                    },
                    {
                        "username": "codepout",
                        "content": "Remove this testcase please, [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0], for everyone just add an edgecase to check for 1000000000 and return true. "
                    },
                    {
                        "username": "Sharad_pal",
                        "content": "My Recursive approach solution got accepted Successfully ,but when i copy pasted this testcase, it gave me Wrong Answer lol...is this testcase removed or something now?                                                                   [0, 10, 10, 10, 10, 10, 10, 10, 10, 10, -10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 0]\\nOutput\\n1981284352\\nExpected\\n1000000000"
                    },
                    {
                        "username": "caldempsey",
                        "content": "This is a doozy but its worth really having a go, you will come to learn that Kadanes prefix sum is the way to go and you will add it to your toolkit, but I tried a tonne of stuff, including filtering out all of the zeros and trying to move two pointers :D"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "You only need to worry about the **zeros** and the **negative** values. `Hint`\\nReaching a zero should reset the current product. Otherwise, it will stay at 0. `Hint`\\nDividing two negative values gives a positive. `Hint`\\n\\nWith these in mind, you should be able to solve the problem by yourself. If you do, your follow-up would be cleaning up your code."
                    },
                    {
                        "username": "anshgandhi21",
                        "content": "here is my code it is getting stuck in [-2] edge case\\n\\n public int maxProduct(int[] nums) {\\n        int count =0 ; \\n        for(int i =0;i<nums.length -1;i=i+2){\\n            int max = nums[i] + nums[i+1];\\n            if(nums.length != nums.length-1 && max > count){\\n                count=  max;\\n            }\\n            else {\\n                int maxelse = nums[nums.length-1] + nums[0];\\n                if(maxelse>count){\\n                    count = maxelse;\\n                }\\n\\n            }\\n        }\\n        return count;\\n    }"
                    },
                    {
                        "username": "abhinavsinha19",
                        "content": "I tried using recursion to solve the problem, but could not find a way to memoize it, can somebody help me with it or where I am lacking?\\n\\n```\\nclass Solution {\\n    int maxp = -1e9;\\npublic: \\n    void f(vector<int>& nums, int ind, int product) {\\n        if (ind == nums.size()) return;\\n\\n        maxp = max(maxp, product*nums[ind]);\\n\\n        f(nums, ind+1, product*nums[ind]);\\n        f(nums, ind+1, 1);\\n    }\\n\\n    int maxProduct(vector<int>& nums) {\\n        f(nums, 0, 1);\\n        return maxp;\\n    }\\n};\\n\\n```"
                    },
                    {
                        "username": "sobo",
                        "content": "Why this solution doesn\\'t work...It gets stuck at the last test case the I am not able to see the test case either.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProduct(vector<int> &nums, int index, int prevMul, unordered_map<string, int> &dp) {\\n        if (index >= nums.size()) {\\n            return prevMul;\\n        }\\n        string key = to_string(index) + \":\" + to_string(prevMul);\\n        if (dp.find(key) != dp.end()) {\\n            return dp[key];\\n        }\\n        // Srart fresh\\n        // no prev + no current + only future (may be)\\n        int ans1 = maxProduct(nums, index+1, INT_MIN, dp); \\n\\n        // prev + current + only future (may be)\\n        int k = prevMul==INT_MIN?1:prevMul;\\n        int ans2 = maxProduct(nums, index+1,  k*nums[index], dp);\\n\\n        // prev + no current + no future (because it is a subarray)\\n        // which means we can not take the future elements if we\\n        // do take the current and take the previous.\\n        int ans3 = prevMul;\\n        return dp[key] = max({ans3, ans1, ans2});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        unordered_map<string, int> dp;\\n        int ans = maxProduct(nums, 0, INT_MIN, dp);\\n        return ans;\\n    }\\n};```"
                    }
                ]
            },
            {
                "id": 2022668,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2018334,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2018219,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 2010923,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1987331,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1983746,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1970589,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1951030,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1945040,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1944132,
                "content": [
                    {
                        "username": "Vithesh",
                        "content": "it took me like 25min to solve this..using kadnes algorithm..."
                    },
                    {
                        "username": "mvp_amansingh",
                        "content": "All testcases passed  still giving TLE  , please help me \\n\\n\\nhere is the solution  \\n\\n `class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        \\n\\n         int i, j , mx= INT_MIN, n= nums.size();\\n\\n        for(i=0;i<n;i++)\\n        {\\n            int s= 1;\\n            for(j=i;j<n;j++)\\n            {\\n                s= s*nums[j];\\n                //mx= max(s,mx);\\n                if(s>mx)\\n                {\\n                    mx=s;\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};`\\n\\nAll testcases passed but giving TLE ,what is wrong here"
                    },
                    {
                        "username": "kapil198",
                        "content": "The Brute Force  of that question is like subarray sum but  that solution does not satisfy the some test case.\n"
                    },
                    {
                        "username": "ANANYAAGARWAL3545325",
                        "content": "CRISP AND SHORT SOLUTION\\n\\n#include<iostream>\\nusing namespace std;\\nvoid productsubarray(int arr[],int n)\\n{\\n    int i=0;\\n    int j=i+1;\\n    int m=-1;\\n    while(i<n&&j<=n-1)\\n    {\\n        int p=1;\\n        p=p*arr[i]*arr[j];\\n        if(p>m)\\n        {\\n        m=p;\\n        }\\n        i++;\\n        j++;\\n    }\\n    cout<<m<<endl;\\n}\\nint main()\\n{\\n    int arr[100]={2,3,-2,4};\\n    int n=4;\\n    productsubarray(arr,n);\\n}\\nOUTPUT:  6\\nHOPE IT HELPED"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Tons of edge cases! Got an idea but it is very hard to pass all the test cases correctly, After some time i felt that I\\'m hard coding according to the test cases."
                    },
                    {
                        "username": "suman_saini",
                        "content": "how can i handle this corner case ? \\nanyone help me .\\nnums =[-2]\\nOutput\\n0\\nExpected\\n-2"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you can check if the size of the array is 1 then return that only element"
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "Can anyone please tell my why it is tagged as a Dynamic Programming problem?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m getting 190/190 testcases passed but TLE on a final empty testcase. \\nnums =\\nAnyone else having this problem? Gonna put a report in. I\\'m using c#."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@vatanyan](/vatanyan) Unfortunately no :( I did put a report in though for a missing testcase"
                    },
                    {
                        "username": "vatanyan",
                        "content": "I have the same problem.\\nAny news??"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "better>>\\nnotice the max subarray can be in left part then terminator and then the right array, here u can get the ans easily using kadens.\\nBut if your max prod sub array lies in right part, using above method will give the max prod of left subarray, so in that case u need to run the loop from right to left and store those prods,\\nT.c O(N), s.c> O(n)\\n\\nnow try to figure optimal solution. "
                    },
                    {
                        "username": "dotz",
                        "content": "If you think in the right direction, the solution actually isn\\'t all that unintuitive.\\n\\nTo guide your thought:\\n- Think of the most obvious subproblem...\\n- Maybe the max product of subarrays with a given ending index...\\n- Can you build a recurrence relation from that?\\n- Not really... Negative numbers are an issue...\\n- What happens when you multiply by negative number?\\n- Can you keep track of an additional subproblem to resolve this issue?"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem does indeed lend itself well to dynamic programming due to its subproblem structure. Each subarray ending at a specific index influences the solutions for subsequent indices.\\n\\nHowever, as you\\'ve pointed out, negative numbers do complicate things. When you multiply by a negative number, the sign of the product flips. This means that a large negative product could become a large positive product if we multiply it by a negative number. \\n\\nTo address this issue, we need to keep track of not only the maximum product so far, but also the minimum product so far (which could be a large negative number). Thus, we have two subproblems to keep track of:\\n\\n1. `max_product[i]`: The maximum product of any subarray ending at index `i`.\\n2. `min_product[i]`: The minimum product (i.e., a large negative number) of any subarray ending at index `i`.\\n\\nFor each new number at index `i`, the maximum product is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number. Similarly, the minimum product at index `i` is either the number itself, the maximum product up to index `i-1` multiplied by the number, or the minimum product up to index `i-1` multiplied by the number.\\n\\nFinally, the answer is the maximum value in `max_product[]`. \\n\\nThis approach allows us to keep track of the current maximum and minimum products while also handling the sign-flipping nature of multiplication by negative numbers."
                    }
                ]
            },
            {
                "id": 1923425,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1919864,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1903102,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1877378,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1870961,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1840586,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1839292,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1806694,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1798391,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1795055,
                "content": [
                    {
                        "username": "NunoLealF",
                        "content": "These last few test cases, oh my *god*."
                    },
                    {
                        "username": "sahilkumar32755",
                        "content": "// Second Easy Method:\\n//     vector<int> ptr(100000,0);\\n\\n    //     for(int i = 0 ;i<nums.size();i++){\\n    //         ptr[nums[i]]++;\\n    //     }\\n    //     vector<int> ans;\\n    //     for(int i = 0;i<100000;i++){\\n    //         if(ptr[i] == 2){\\n    //             ans.push_back(i);\\n    //         }\\n    //     }\\n    // return ans;"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "Some tips!\\n\\n1.  Can you use Kadane\\'s Algo here?\\n2.  How\\'ll you handle the negative elements?\\n3.  Is keep tracking of Maximum Product enough?"
                    },
                    {
                        "username": "mazharkafi",
                        "content": "https://leetcode.com/problems/maximum-product-subarray/solutions/3554945/modified-kadane-s-algorithm-c-beginner-friendly/"
                    },
                    {
                        "username": "shliucsdcogs",
                        "content": "is empty array a subarray?"
                    },
                    {
                        "username": "zalars",
                        "content": "What is this mean? -\n\nTime Limit Exceeded (190 / 190 testcases passed)\n\nLast Executed Input\n`nums =`\n\n1) all testcases passed or not?\n2) empty array?"
                    },
                    {
                        "username": "vatanyan",
                        "content": "[@jackbb147](/jackbb147) too slow for what?!?! It has passed all non-empty-input testcases and falls on the empty-input one??? I have the same problem and really do not know understand what is the problem.\\nI have tried to use that 190\\'th test as a case and then ran (instead of submit), and it works, but when I am submitting it falls??"
                    },
                    {
                        "username": "jackbb147",
                        "content": "I have this same issue. I used brute force and it\\'s probably too slow "
                    },
                    {
                        "username": "karunakarvarada73",
                        "content": "How many  members are  commenting for upvote \\uD83E\\uDD23\\uD83D\\uDE02"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "Consider checking min and max product you can get. Also think how this helps with negative numbers"
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "What is a subarray in this case? \\nIn set theory all combinations are a sub set can anyone explain"
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "a few things that I thought which helped me arrive at the solution\\n1. for every index , we have two choices, either to include it , or to not include it\\n2. sometimes, even though including or not including an element may lead to a local minimum it can even cause a global maximum\\n3. hence what really matters is the magnitude of the element. even the smallest negative product with a maximum magnitude could lead to an optimum solution\\n4. the fact that the array needs to be contiguous makes it easier "
                    },
                    {
                        "username": "Princesah999",
                        "content": "those who trying to solve this using kanades algo!!"
                    }
                ]
            },
            {
                "id": 1791027,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1785111,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1778112,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1758783,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1756369,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1746374,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1738799,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1724233,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1720746,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            },
            {
                "id": 1718421,
                "content": [
                    {
                        "username": "jiaheaaa",
                        "content": "I understood the question (and solved it) but I still feel weird about we can't output an empty subarray and claim the product is 1... It will make things much easier."
                    },
                    {
                        "username": "bparanj",
                        "content": "The lower bound for the array size is given to be 1 in the constraints. If the problem statement specifies that the array size has a lower bound of 1, it means that the array must contain at least one element. Therefore, we don\\'t need to consider the case of an empty array (or empty subarray), because such a situation falls outside of the problem\\'s constraints.\\n\\nIn this particular problem, the term \"subarray\" refers to a contiguous subset of elements within the array. A subarray with one element is considered valid and within the problem constraints, but an empty subarray wouldn\\'t be considered because it falls outside of the specified constraints. This is why the empty subarray (product 1) doesn\\'t come into play in this problem.\\n\\nRemember, the specifications and constraints in a problem statement are very important as they guide your solution. They often simplify the problem by eliminating the need to consider certain edge cases or more complex scenarios.\\n"
                    },
                    {
                        "username": "mars_999",
                        "content": "How I approached this problem:\\n\\nAs soon as I saw maximum product subarray with +ve and -ve integers , max sum subarray problem i. e Kadane\\'s algorithm came to my mind. But I couldn\\'t come up with anything to deal with negative numbers as that  can change the result entirely.\\n\\nSo Leetcode Official Solution helped me a lot.  Its just an extension to Kadane\\'s algo, we need to keep track of min product sub array which will help to get the max product subarray."
                    },
                    {
                        "username": "Sadiya-Irin",
                        "content": "Why this solution gives the verdict WA? Could anyone please point me out about the mistake?\\nclass Solution {\\npublic:\\nint maxProduct(vector<int> &nums){\\n    int i,n = nums.size();\\n    int prod=1, mx=LLONG_MIN;\\n    for(i=0; i<n; i++){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod==0) prod=1;\\n    }\\n//    cout<<endl;\\n    prod=1;\\n    for(i=n-1; i>=0; i--){\\n        prod = prod * nums[i];\\n//        cout<<prod<<\" \";\\n        mx = max(mx, prod);\\n        if(prod == 0)   prod=1;\\n    }\\n//    cout<endl;\\n    return mx;\\n}\\n};\\n\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This code tries to solve the problem by checking the maximum product from left to right and then from right to left. However, this approach will not work for certain cases where negative numbers are involved.\\n\\nFor example, let\\'s consider the array: `[-1, -2, -3]`. The expected output is `6` because the maximum product can be achieved by multiplying all the elements. But, if you check your code, you will get `-1` as the answer. This is because your code resets `prod` to `1` whenever `prod` is `0`, but it doesn\\'t consider the case when `prod` is negative. A negative `prod` means that we have encountered an odd number of negative numbers so far, and there might be a chance that we can get a positive product by multiplying with some negative numbers in the future.\\n\\nSo, the code fails to handle the case where there are an even number of negative numbers in the array. A correct approach would be to maintain two variables, `maxProduct` and `minProduct` at each point in the array. `maxProduct` will store the maximum product that can be obtained up to the current position and `minProduct` will store the minimum (most negative) product that can be obtained up to the current position. Then at each point, you update `maxProduct` and `minProduct` using the current number, and the product of the current number with the previous `maxProduct` and `minProduct`.\\n\\nHere\\'s how you could update your function to implement this:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxProduct = nums[0], minProduct = nums[0], maxSoFar = nums[0];\\n\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] < 0) swap(maxProduct, minProduct);\\n            maxProduct = max(nums[i], maxProduct * nums[i]);\\n            minProduct = min(nums[i], minProduct * nums[i]);\\n            maxSoFar = max(maxSoFar, maxProduct);\\n        }\\n\\n        return maxSoFar;\\n    }\\n};\\n```\\n\\nThis approach ensures that we correctly consider the effects of negative numbers in the array.\\n"
                    },
                    {
                        "username": "abdulhamid28",
                        "content": "testcase no 189 \\ninput nums=(no value at all)\\nhelp me"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ay96052003",
                        "content": "I cannot understand this problem, \\nfor the 1st test case : nums = [2, 3, -2, 4]\\nwhy the max product is 6 and not 12?? "
                    },
                    {
                        "username": "PhNTOm_12",
                        "content": "because [2,3] is a subarray which has a product of 6 whereas [3,4] (max product = 12)is not a a subarray, taking [3,4] means you are considering it as a subsequence. \\nA subarray or substring will always be contiguous, but a subsequence need not be contiguous.....:))"
                    },
                    {
                        "username": "ashuthe1",
                        "content": "I  am trying to use divide & conquer approach but I am getting WA in 140th test case.\\ncan anyone help me in this.\\n\\nint divideRule(int l, int r, vector<int>&v)\\n    {\\n        if(l > r) return 0;\\n        if(l == r) return v[l];\\n        int mid = (l+r)/2;\\n\\n        int left = divideRule(l,mid-1,v);\\n        int right = divideRule(mid+1,r,v);\\n\\n        int ml = 1, mr = 1;\\n        for(int i = mid-1, cur = ml; i >= l; i--)\\n        {\\n            cur *= v[i];\\n            ml = max(ml,cur);\\n        }\\n        for(int i = mid+1, cur = mr; i <= r; i++)\\n        {\\n            cur *= v[i];\\n            mr = max(mr,cur);\\n        }\\n        return max({ml*v[mid]*mr,left,right});\\n    }\\n    int maxProduct(vector<int>& nums) {\\n        return divideRule(0,nums.size()-1,nums);\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you\\'ve chosen, which is a divide and conquer approach, is generally sound for solving problems similar to this one. However, it falls short when dealing with the Maximum Product Subarray problem, primarily due to the presence of negative numbers and zeros in the array.\\n\\nThe main issue with your approach lies in how you calculate `left` and `right`. In your current implementation, you calculate the product of the left and right subarrays separately and then find the maximum. However, this doesn\\'t account for situations where the maximum product could span across both the left and right subarrays.\\n\\nFor example, let\\'s take the array [-2, -3, -4]. The maximum product subarray is the entire array itself, with a product of -2*-3*-4 = 24. But in your code, you divide the array into left and right subarrays, then calculate the maximum product of each, and take the maximum of these two. As a result, you miss out on the possibility that the maximum product subarray could span across both the left and right subarrays.\\n\\nFurther, your code doesn\\'t account for zeros or an even number of negative numbers correctly. For example, if you have an array like [-2, -3, 0, -4], your current code would not return the correct answer, as the maximum product is actually 24, obtained by the subarray [-2, -3, -4].\\n\\nFor these reasons, the Maximum Product Subarray problem is usually solved using a dynamic programming approach, which takes into account both the maximum and minimum product at each step. This allows the algorithm to correctly handle cases with negative numbers and zeros. It might be worth revisiting your approach to this problem and considering a dynamic programming solution instead."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/152_max_product_subarray.cpp"
                    },
                    {
                        "username": "jaronkelly0",
                        "content": "I passed all 188/188 test and yet I get a time limit exceeded? I think I figured out why the acceptance rate is so low. The problem isn\\'t difficult but with this bug I\\'m surprised anyone passed this problem. "
                    },
                    {
                        "username": "jackbb147",
                        "content": "it\\'s intentional, to prevent brute force approaches "
                    },
                    {
                        "username": "sergiycheck",
                        "content": "why the expected output for nums = [-3,-1,-1] is 3 and not -1 ? I am so confused. "
                    },
                    {
                        "username": "Aquil",
                        "content": "(-3)*(-1)=3"
                    }
                ]
            }
        ]
    },
    {
        "title": "Meeting Rooms",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1928591,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1573106,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1571493,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 2053905,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            },
            {
                "id": 1746557,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "It would\\'ve been helpful if they mentioned whether a person could attend a meeting that starts exactly after another meeting ends. "
                    },
                    {
                        "username": "CivilCS",
                        "content": "Exactly, I was running into that issue and failing 4 test cases because of this. \\n\\nCLARIFICATION:\\nA person cannot  attend a meeting that starts at the same time another meeting ends "
                    },
                    {
                        "username": "granzort",
                        "content": "Trying to understand why empty interval needs to return true logically. For some problems, default results are more predictable than this, or it is given through the notes. If anyone have good logical explanation it would be helpful.\\n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is saying \"Do I have a schedule conflict?\"\n\nIf `intervals` is empty then clearly False doesn't work. If you don't have any meetings you can't have a schedule conflict. It makes perfect sense to return True since you don't have a conflict.\n\nA slightly different interpretation is \"Can I attend all my meetings?\". Then you could argue it's weird to say you can attend all meetings when you don't even _have_ any meetings. But False definitely still doesn't work.\n\nUnder this interpretation you could say that not having meetings is an error. In production code you might throw an exception or return an error code. But LeetCode doesn't allow for that in this problem definition so you don't have a choice anyway."
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "Sort the intervals by start time, then check whether all pairs of consecutive intervals are disjoint.\\n\\n    def can_attend_meetings(intervals)\\n      intervals.sort_by(&:start).each_cons(2).all? { |i, j| i.end <= j.start }\\n    end"
                    },
                    {
                        "username": "Joao_Ribeiro",
                        "content": "This is a pure \"Line Sweep\" problem. Why not add \"Prefix Sum\" and \"Line Sweep\" tags for this problem? This might help someone coming up with a solution or even find this problem in the list of problems."
                    },
                    {
                        "username": "FRin323",
                        "content": "why is \\'*range\\' giving a syntax error?"
                    }
                ]
            }
        ]
    }
]