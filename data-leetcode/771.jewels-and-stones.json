[
    {
        "title": "Climbing Stairs",
        "question_content": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 45",
        "solutions": [
            {
                "id": 25299,
                "title": "basically-it-s-a-fibonacci",
                "content": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The problem seems to be a *dynamic programming* one. **Hint**: the tag also suggests that! \\nHere are the steps to get the solution incrementally. \\n\\n- Base cases:  \\nif n <= 0, then the number of ways should be zero. \\nif n == 1, then there is only way to climb the stair. \\nif n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time. \\n\\n- The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points `[n-1]` and `[n-2]` respectively, denoted as `n1` and `n2` , then the total ways to get to the point `[n]` is `n1 + n2`. Because from the `[n-1]` point, we can take one single step to reach `[n]`. And from the `[n-2]` point, we could take two steps to get there.\\n\\n- The solutions calculated by the above approach are ***complete*** and ***non-redundant***. The two solution sets (`n1`  and `n2`) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step. \\n\\nNow given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1. \\n\\nThe implementation in Java as follows: \\n\\n    public int climbStairs(int n) {\\n        // base cases\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int one_step_before = 2;\\n        int two_steps_before = 1;\\n        int all_ways = 0;\\n        \\n        for(int i=2; i<n; i++){\\n        \\tall_ways = one_step_before + two_steps_before;\\n        \\ttwo_steps_before = one_step_before;\\n\\t        one_step_before = all_ways;\\n        }\\n        return all_ways;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1531764,
                "title": "python-detail-explanation-3-solutions-easy-to-difficult-recursion-dictionary-dp",
                "content": "#####\\n### General inutution\\n##### \\t-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\n##### \\t\\tdistinct(n) = distinict(n-1) + distinict(n-2)\\n##### This intution can be applied using the following three approach --> ordered from easy to difficult approach\\n#####\\n##### \\n##### \\n#### Idea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n##### \\t- The base case will be when only 1 or 2 steps left\\n##### \\t- Result time-exced limit\\n##### \\n        \\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\\n#####     \\n#####         \\'\\'\\'\\n####         Idea 2 : use dictionary (look-up table) to memorize repeating recursion\\n#####             - The memory start with the base case and recored every recurssion\\n#####         \\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n    \\n#####         \\'\\'\\'\\n###         Idea 3 : Dynamic programming \\n#####             --> store the distinct ways in a dynamic table\\n#####             climb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\n#####             dp = [   0,           1,            2,                               3,                      5,                           dp(i-1)+dp(i-2])]\\n#####             return dp[n]\\n#####         \\'\\'\\'\\n\\tdef climb(n):\\n        #edge cases\\n        if n==0: return 0\\n        if n==1: return 1\\n        if n==2: return 2\\n        dp = [0]*(n+1) # considering zero steps we need n+1 places\\n        dp[1]= 1\\n        dp[2] = 2\\n        for i in range(3,n+1):\\n            dp[i] = dp[i-1] +dp[i-2]\\n        print(dp)\\n        return dp[n]\\n\\t\\t\\t\\n### ******  upvote as a sign of appriatation *****",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n    \\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708750,
                "title": "4-method-s-beat-s-100-c-java-python-beginner-friendly",
                "content": "# Intuition:\\nTo calculate the number of ways to climb the stairs, we can observe that when we are on the nth stair, \\nwe have two options: \\n1. either we climbed one stair from the (n-1)th stair or \\n2. we climbed two stairs from the (n-2)th stair. \\n\\nBy leveraging this observation, we can break down the problem into smaller subproblems and apply the concept of the Fibonacci series. \\nThe base cases are when we are on the 1st stair (only one way to reach it) and the 2nd stair (two ways to reach it). \\nBy summing up the number of ways to reach the (n-1)th and (n-2)th stairs, we can compute the total number of ways to climb the stairs. This allows us to solve the problem efficiently using various dynamic programming techniques such as recursion, memoization, tabulation, or space optimization.\\n\\n# Approach 1: Recursion ```\\u274C TLE \\u274C```\\n**Explanation**: The recursive solution uses the concept of Fibonacci numbers to solve the problem. It calculates the number of ways to climb the stairs by recursively calling the `climbStairs` function for (n-1) and (n-2) steps. However, this solution has exponential time complexity (O(2^n)) due to redundant calculations.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\n# Approach 2: Memoization\\n**Explanation**: The memoization solution improves the recursive solution by introducing memoization, which avoids redundant calculations. We use an unordered map (`memo`) to store the already computed results for each step `n`. Before making a recursive call, we check if the result for the given `n` exists in the memo. If it does, we return the stored value; otherwise, we compute the result recursively and store it in the memo for future reference.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\\n\\n# Approach 3: Tabulation\\n**Explanation**: The tabulation solution eliminates recursion and uses a bottom-up approach to solve the problem iteratively. It creates a DP table (`dp`) of size n+1 to store the number of ways to reach each step. The base cases (0 and 1 steps) are initialized to 1 since there is only one way to reach them. Then, it iterates from 2 to n, filling in the DP table by summing up the values for the previous two steps. Finally, it returns the value in the last cell of the DP table, which represents the total number of ways to reach the top.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\\n\\n# Approach 4: Space Optimization\\n**Explanation**: The space-optimized solution further reduces the space complexity by using only two variables (`prev` and `curr`) instead of an entire DP table. It initializes `prev` and `curr` to 1 since there is only one way to reach the base cases (0 and 1 steps). Then, in each iteration, it updates `prev` and `curr` by shifting their values. `curr` becomes the sum of the previous two values, and `prev` stores the previous value of `curr`.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/f7f5193b-c407-4cc3-93ac-969a8ab8aacf_1688305654.6101635.png)\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\u274C TLE \\u274C```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n, unordered_map<int, int>& memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (memo.find(n) == memo.end()) {\\n            memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n        }\\n        return memo[n];\\n    }\\n\\n    int climbStairs(int n) {\\n        unordered_map<int, int> memo;\\n        return climbStairs(n, memo);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        return climbStairs(n, memo);\\n    }\\n    \\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        if (!memo.containsKey(n)) {\\n            memo.put(n, climbStairs(n-1, memo) + climbStairs(n-2, memo));\\n        }\\n        return memo.get(n);\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        memo = {}\\n        return self.helper(n, memo)\\n    \\n    def helper(self, n: int, memo: dict[int, int]) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        if n not in memo:\\n            memo[n] = self.helper(n-1, memo) + self.helper(n-2, memo)\\n        return memo[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n\\n        dp = [0] * (n+1)\\n        dp[0] = dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        int prev = 1, curr = 1;\\n        for (int i = 2; i <= n; i++) {\\n            int temp = curr;\\n            curr = prev + curr;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        prev, curr = 1, 1\\n        for i in range(2, n+1):\\n            temp = curr\\n            curr = prev + curr\\n            prev = temp\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25296,
                "title": "3-4-short-lines-in-every-language",
                "content": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "solutionTags": [],
                "code": "Same simple algorithm written in every offered language. Variable `a` tells you the number of ways to reach the current step, and `b` tells you the number of ways to reach the next step. So for the situation one step further up, the old `b` becomes the new `a`, and the new `b` is the old `a+b`, since that new step can be reached by climbing 1 step from what `b` represented or 2 steps from what `a` represented.\\n\\nRuby wins, and *\"the C languages\"* all look the same.\\n\\n**Ruby** (60 ms)\\n\\n    def climb_stairs(n)\\n        a = b = 1\\n        n.times { a, b = b, a+b }\\n        a\\n    end\\n\\n**C++** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Java** (208 ms)\\n\\n    public int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Python** (52 ms)\\n\\n    def climbStairs(self, n):\\n        a = b = 1\\n        for _ in range(n):\\n            a, b = b, a + b\\n        return a\\n\\n**C** (0 ms)\\n\\n    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n--)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**C#** (48 ms)\\n\\n    public int ClimbStairs(int n) {\\n        int a = 1, b = 1;\\n        while (n-- > 0)\\n            a = (b += a) - a;\\n        return a;\\n    }\\n\\n**Javascript** (116 ms)\\n\\n    var climbStairs = function(n) {\\n        a = b = 1\\n        while (n--)\\n            a = (b += a) - a\\n        return a\\n    };",
                "codeTag": "Python3"
            },
            {
                "id": 3213547,
                "title": "c-python-beats-100-using-dp-2-ways-recursion-memorization-tabulation-space-opt",
                "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963994,
                "title": "java-from-recursion-to-dp",
                "content": "**Recustion (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Recustion + Memorization (Top Down Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\n**DP (Bottom Up Approach)**\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**DP + Optimization (Bottom Up Approach)**\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25313,
                "title": "python-different-solutions-bottom-up-top-down",
                "content": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n    # Top down - TLE\\n    def climbStairs1(self, n):\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        return self.climbStairs(n-1)+self.climbStairs(n-2)\\n     \\n    # Bottom up, O(n) space\\n    def climbStairs2(self, n):\\n        if n == 1:\\n            return 1\\n        res = [0 for i in xrange(n)]\\n        res[0], res[1] = 1, 2\\n        for i in xrange(2, n):\\n            res[i] = res[i-1] + res[i-2]\\n        return res[-1]\\n    \\n    # Bottom up, constant space\\n    def climbStairs3(self, n):\\n        if n == 1:\\n            return 1\\n        a, b = 1, 2\\n        for i in xrange(2, n):\\n            tmp = b\\n            b = a+b\\n            a = tmp\\n        return b\\n        \\n    # Top down + memorization (list)\\n    def climbStairs4(self, n):\\n        if n == 1:\\n            return 1\\n        dic = [-1 for i in xrange(n)]\\n        dic[0], dic[1] = 1, 2\\n        return self.helper(n-1, dic)\\n        \\n    def helper(self, n, dic):\\n        if dic[n] < 0:\\n            dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n        return dic[n]\\n        \\n    # Top down + memorization (dictionary)  \\n    def __init__(self):\\n        self.dic = {1:1, 2:2}\\n        \\n    def climbStairs(self, n):\\n        if n not in self.dic:\\n            self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n        return self.dic[n]",
                "codeTag": "Python3"
            },
            {
                "id": 1792723,
                "title": "python-in-depth-walkthrough-explanation-dp-top-down-bottom-up",
                "content": "## Intuition and Approach\\nWe can climb $$n$$ stairs by going up 1 or 2 steps at a time. So if we\\'re currently on step $$i$$, the only places we could get to in one iteration would be steps $$i + 1$$ (if we take 1 step) and $$i + 2$$ (if we take 2 steps).\\n\\nThis means that if we are currently on step $$n$$, our final destination, we could have only gotten there in one of two ways:\\n1. From step $$n - 1$$ , having gone up 1 step to $$n$$\\n2. From step $$n - 2$$, having gone up 2 steps to $$n$$\\n\\nThis highlights that the number of ways to reach step $$n$$ depends on the number of ways to get to step $$n - 1$$ **and** the number of ways to get to step $$n - 2$$. Since both of the above possibilities are valid choices, the number of ways to get to $$n$$ is going to be their **sum**. Thus, we have the following relationship (formally called a **recurrence relation**): $$ways(n) = ways(n - 1) + ways(n - 2)$$\\n\\nLooking at the problem constraints, we see that the smallest possible value of $$n$$ is 1. If we are asked to climb 1 step, the above relationship will not work because $$ways(0)$$ and $$ways(-1)$$ are not defined. More formally, we haven\\'t defined our recurrence\\'s **base case(s)**. We calculate this base case manually: there\\'s only 1 way to climb a singular step - just climb that step! We couldn\\'t possibly take 2 steps in this situation, because then we\\'d be climbing more steps than there are to climb. We notice that if $$n = 2$$, the relationship will also not hold because $$ways(0)$$ is still undefined. Calculating this base case is slightly more involved, but still easy: we can either climb the 2 steps by taking 2 steps, or climb 1 step twice, for a total of 2 ways to climb.\\n\\nTo recap, we have the following relationship, depending on the value of $$n$$:\\n- $$ways(1) = 1 \\\\text{ for } n = 1$$\\n- $$ways(2) = 2 \\\\text{ for } n = 2$$\\n- $$ways(n) = ways(n - 1) + ways(n - 2) \\\\text{ for } n > 2$$\\n\\n\\n---\\n\\n\\n## **Implementation**\\nWe\\'ll explore multiple approaches from simple to more complex, incrementally improving upon each solution. \\n\\n##### **1. Naive recursion**\\nWe can translate the recurrence we came up with earlier into code, as follows:\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nHowever, running this yields Time Limit Exceeded. Why is it so inefficient? Let\\'s think about calculating the ways to climb 6 stairs,  `climbStairs(6)`.\\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\\n\\nAs you can see from the recursion tree above, we are calculating `climbStairs(4)` and `climbStairs(3)` multiple times. Specifically, `climbStairs(4)` is being recalculated twice, while `climbStairs(3)` is being recalculated 3 times. If you think about what happens for larger values of `n`, you can see that we are recalculating a lot of values! \\n\\n**Complexity**\\n* **Time**: Each additional level in the recursion tree is going to have double the amount of calls to `climbingStairs` than the one above it. For $$n$$, this gives us a staggering $$2^n$$ function calls, for a $$O(2^n)$$ time complexity. No wonder we get TLE!\\n* **Space**: We aren\\'t storing any additional variables, so that\\'s a $$O(1)$$ space complexity.\\n\\n\\nCan we avoid repeated computation?\\n\\n##### **2. Memoization (Top-Down DP)** \\nWhat if instead of recomputing each value of `climbStairs`, we made sure to save the unique values (such as `climbingStairs(5)`), trading space for time? That\\'s what a top-down dynamic programming approach called **memoization** is. We make use of a dictionary `memo` in which we store the values of `climbStairs` that we have computed, and if we ever have to compute that value again we just check `memo` in (average) $$O(1)$$ time instead of doing the work all over again. \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\\n\\nWe can also make use of Python\\'s handy `@cache` function decorator that does this for us in the background like so:\\n\\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\n\\nThis top-down paradigm works well when we approach the problem from the top of the stairs (the last step we needed to climb, $$n$$) down. \\n\\n**Complexity**\\n* **Time**: There are $$O(n)$$ distinct subproblems to solve, each requiring only $$O(1)$$ amount of work of getting the values of smaller subproblems from `memo` and adding them together. When we encounter a subproblem we\\'ve already solved, we can get the answer in $$O(1)$$ time.\\n* **Space**: We are using an additional `memo` dictionary that will store the answer to each subproblem, so $$O(n)$$ space complexity.\\n\\nCan we be even more efficient and avoid the overhead of recursion?\\n\\n\\n**3. Bottom-Up DP**\\nTurns out we can build the solution from the ground up (quite literally in this case). From our recurrence relation, we saw that the number of ways to climb $$n$$ stairs depends on the number of ways to climb $$n - 1$$ and $$n - 2$$ stairs. So instead of approaching the problem top-down and computing these values recursively, we compute them bottom-up, starting with the base cases and building upon the previous values until we reach $$n$$. We use a `dp` array of length $$n + 1$$ (to accomodate for the 0-based indexing of Python; we could just have it be length $$n$$ and return `dp[n - 1]` but in this way we are aligning the step numbers with the indices) and successively build up each index from the previous two.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 elements of the array). That\\'s $$O(n)$$time complexity.\\n* **Space**: Since we are storing the answers to previous subproblems in the `dp` array, this will be $$O(n)$$ too.\\n\\nCan we do even better?\\n\\n**4. Optimizied Bottom-Up DP**\\nWhile the above works well enough, we can optimize our approach even further by making a simple but important observation: we are only utilizing the last 2 subproblem answers when solving each subproblem. If you look at the recurrence again, you can see that the only pieces information we use are $$ways(n - 1)$$ and $$ways(n - 2)$$. Since we\\'re computing from bottom-up, once we compute those answers, the smaller subproblems (such as $$ways(n - 3)$$) are not needed anymore. Thus, instead of keeping the entire `dp` array, we can save some space and just maintain 2 variables that track our last 2 subproblem answers!\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```\\n\\n**Complexity**\\n* **Time**: As before, we are computing each subproblem once and each subproblem requires constant amount of work (just the addition of the previous 2 number of ways). That\\'s $$O(n)$$ time complexity.\\n* **Space**: $$O(1)$$ since we are maintaining 3 extra variables only!\\n\\nAnd that\\'s it! We went from a TLE solution to an elegant and optimized version.\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n                                       climbStairs(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /               \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\tcS(5)       +          cS(4)\\n\\t\\t\\t\\t\\t           /    \\\\                  /    \\\\\\n\\t\\t\\t               cS(4)   +   cS(3)         cS(3) + cS(2)\\n\\t\\t\\t\\t\\t\\t   /  \\\\        /   \\\\         /   \\\\\\n\\t\\t\\t\\t      cS(3) + cS(2) cS(2) + cS(1) cS(2) + cS(1)\\n\\t\\t\\t\\t\\t  /  \\\\\\n\\t\\t\\t     cS(2) + cS(1)\\n\\t\\t\\t\\n\\t\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def climb(n):  # inner function to make code simpler\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = climb(n-1) + climb(n-2)\\n                return memo[n]\\n        memo = {1: 1, 2: 2}  # base cases\\n        return climb(n)\\n```\n```\\nclass Solution:\\n\\t@cache\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 2\\n        else:\\n            return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        dp = [-1] * (n + 1)  # to accomodate for 0-based indexing \\n        dp[1], dp[2] = 1, 2\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2]\\n        return dp[n]\\n            \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        ways = 0\\n\\t\\t# base cases\\n        two_below_curr = 1  # 2 steps below 3 - ways to take 1 step: 1\\n        one_below_curr = 2  # 1 step below 3 - ways to take 2 steps: 2\\n        for i in range(3, n + 1):\\n            # compute number of ways for i\\n            ways = one_below_curr + two_below_curr\\n            # step up to i + 1   \\n            # 1 step below becomes 2 steps below\\n            # current number of ways becomes 1 step below\\n            two_below_curr, one_below_curr = one_below_curr, ways\\n    \\n        return ways\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205775,
                "title": "0ms-java-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/b84f646e-53f9-4218-a2dc-fb26bcf4746b_1676808521.7800605.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        \\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137892,
                "title": "dp-easy-js-sol-approachable-code",
                "content": "# Intuition\\n\\n-     Dynamic Programming by implementing the Fibonacci Sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The approach of the below code is to solve the problem of counting the number of ways to climb stairs using **`Dynamic Programming by implementing the Fibonacci Sequence`**.\\n2. The function calculates the nth number in the fibonacci sequence using a for loop, where n is the number of stairs. \\n3. The first two numbers in the sequence are initialized as 1 and the next numbers are calculated as the sum of the previous two numbers.\\n4. The result, the nth number, is returned as the answer to the number of ways to climb stairs.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the number of stairs.\\n2. Because as it uses a for loop to calculate the fibonacci sequence, it has $$O(n)$$ time complexity.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because as it only uses a constant amount of extra memory to store a few variables.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/af110665-c61e-46b7-9325-161eacdd66f3_1675453763.6499822.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    \\n    if (n < 2) {\\n        return 1;\\n    }\\n    \\n    let firstStep = 1;\\n    \\n    let secondStep = 1;\\n    \\n    let thirdStep = 0;\\n    \\n    for (let i = 2; i <= n; i++) {\\n        \\n        thirdStep = firstStep + secondStep;\\n        \\n        firstStep = secondStep;\\n        \\n        secondStep = thirdStep;\\n    }\\n    return thirdStep;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25345,
                "title": "easy-solutions-for-suggestions",
                "content": "Hi guys, I come up with this arithmetic way. Find the inner logic relations and get the answer.\\n\\n\\n    public class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}\\n        int[] mem = new int[n];\\n        mem[0] = 1;\\n        mem[1] = 2;\\n        for(int i = 2; i < n; i++){\\n            mem[i] = mem[i-1] + mem[i-2];\\n        }\\n        return mem[n-1];\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int climbStairs(int n) {\\n        if(n == 0 || n == 1 || n == 2){return n;}",
                "codeTag": "Java"
            },
            {
                "id": 3306307,
                "title": "dynamic-programming-python3",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp=[-1]*(n+2)\\n        def solve(i):\\n            if i==0 or i==1:\\n                return 1\\n            if dp[i]!=-1:\\n                return dp[i]\\n            left=solve(i-1)\\n            right=solve(i-2)\\n            dp[i]=left+right\\n            return left+right\\n        return solve(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one+two\\n            one=two\\n            two=temp\\n        return two\\n    #please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147963,
                "title": "4-solutions-recursion-memoization-dp-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFibonacci series\\n\\n# Approach\\n\\n\\n\\n- Using the top-down approach of recursion,try to reach stair 0 standing from n.\\n- There are two possible ways at each stair =>take 1 step or 2 steps at a time.\\n- This problem is similar to fibonacci problem.Because the recurrence relation of both these problem is exactly the same.\\n- The base case is:\\n1. When standing at stair 1 or 0 there is only 1 possible way to come to 0.\\n\\n\\n```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\\n\\n# 1.Recursion:(TLE)\\n- For the above recurrence relation, the recusive solution is:\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(2^n)= Exponential time complexity\\n- Space complexity:O(n)=if recursion depth is considered,else:O(1) \\n\\n\\n# 2.Memoization: (Accepted)\\n- In above recusrion, the same subproblems are solved again and again.\\n- This is recomputaion and to avoid it store the results of subproblems which are already solved in dp array.\\n- So when a problem needs to be solved, if it is already solved then directly return the anwswer stored in dp array instead of again computing it.\\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n)+O(N)= extra space of size n(dp) and recursion depth n \\n\\n\\n# 3.Dynamic Programming: (Accepted)\\n- The above approach requires recursive stack space.\\n- To optimize that space, use bottom-up approach of TABULATION.\\n- Start from base case and based on previous results gradually build the result.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n\\n- Time complexity: O(n)= Linear time complexity\\n- Space complexity:O(n) = Extra space of size n and no recusrion stack space used. \\n\\n\\n# 4. Space Optimzation of DP (OPTIMAL SOLUTION)\\n- If we carefully observe above tabulation, we only need previous two values to fill current index rather than whole dp array.\\n- So we just maintain only those two values in 2 variables and update them accordingly for subsequent iterations.\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```\\n---\\n\\n- *Please Leave a like if you found the solution or explanation helpful.*\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif(n==0 or n==1) {\\n    return 1\\n}\\nreturn f(n-1)+f(n-2)\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n){\\n        if(n<=1) return 1; //base case\\n        return findWays(n-1)+findWays(n-2);\\n    }\\n\\n    int climbStairs(int n) {\\n        return findWays(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findWays(int n, vector<int> &dp)\\n    {\\n        if (n <= 1) return 1;\\n        if (dp[n] != -1) return dp[n];//already solved subproblems\\n        return dp[n]=findWays(n - 1, dp) + findWays(n - 2, dp); //store the result of subproblem in dp array\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1); //fill all values with -1\\n        return findWays(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n         vector<int>dp(n+1,-1);\\n         dp[0]=1,dp[1]=1; //base cases\\n         for(int i=2;i<=n;++i){\\n             dp[i]=dp[i-1]+dp[i-2];\\n         }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int prev2=1,prev1=1; //initally at 0th and 1st index\\n        \\n        for(int i=2;i<=n;i++){\\n            int curr=prev1+prev2;\\n            prev2=prev1; //update pointers\\n            prev1=curr;\\n        }\\n        return prev1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25652,
                "title": "5-lines-of-python",
                "content": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's essentially Fibonacci number:\\n     \\n    def climbStairs(self, n):\\n        a, b = 1, 1\\n        for i in range(n):\\n            a, b = b, a + b\\n        return a",
                "codeTag": "Python3"
            },
            {
                "id": 1504255,
                "title": "c-simple-and-easy-fibonacci-solution-with-explanation",
                "content": "**Idea - this is just simple fibonacci!**\\nThe base cases are: \\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step `i`, the number of ways to get to it is: either the last step was of 1 step, so we have `prev`, or it was a 2 step, and that\\'s `prev2`, so all together the number of ways to get to our current step is `prev + prev2`.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25315,
                "title": "my-dp-solution-in-c-with-explanation",
                "content": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "solutionTags": [],
                "code": "     int climbStairs(int n) \\n    {\\n         vector<int> steps(n,0);\\n         steps[0]=1;\\n         steps[1]=2;\\n         for(int i=2;i<n;i++)\\n         {\\n             steps[i]=steps[i-2]+steps[i-1];\\n         }\\n         return steps[n-1];\\n     }\\n\\nArray 'steps' stands for how many distinct ways to climb to each level (index from 0,  so 0 means level 1, 1 means level 2 and so on.... ).   It's trivial to know it has 1 distinct way to climb to stair 1 , and 2 distinct ways to climb to stair 2 .   For stair level n (n>=3) ,   you can either (1) climb to stair n-2 , and climb 2 more steps to reach n  ,  OR (2) climb to stair n-1, and climb 1 more step to reach n.   That said ,  steps[n]=steps[n-1]+steps[n-2].     In another word,  the number of distinct ways to reach level n is the sum of  number of distinct ways to reach level n-1 and n-2.",
                "codeTag": "Unknown"
            },
            {
                "id": 3091065,
                "title": "java-no-recursion-100-faster",
                "content": "Initially, i wrote this code :\\n```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\\nBut, It yields error as **Time limit Exceeded**. Because this is tree recursion and it is too expensive for this problem. \\nInstead of it, I wrote this code that is very cheapier than the first.\\n\\n```\\nplease upvote, if you found it useful\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-2)+climbStairs(n-1);\\n    }\\n```\n```\\nplease upvote, if you found it useful\\n```\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n\\n        int[] a =  new int[n];\\n        a[0]=1;\\n        a[1]=2;\\n\\n        for(int i=2;i<n;i++){\\n            a[i]=a[i-1]+a[i-2];\\n        }\\n        return a[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428533,
                "title": "3-lines-code-faster-than-100-beginner-friendly-detailed-explanation-of-approach",
                "content": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "first make a dp array of size (1 more than the maximum value of n)\\nif the value at nth index of dp array is not equal to 0 then simply return it.\\nif the value of n=1 then we can clearlt say that the number of ways are 1 and if n=2 then we can clearly sat that the number of ways of climbing stairs is 2(1+1 , 2)\\nthen make a recursive step of dp\\nthe ways of climbing n staits equal to the sum of climbing (n-1) and (n-2) stairs.\\nthen return dp[n].\\n\\nint dp[46];\\n    int climbStairs(int n) {\\n      \\n      if(dp[n]!=0) return dp[n];\\n      \\n      if(n==1 || n==2) return n;\\n      dp[n]=climbStairs(n-1)+climbStairs(n-2);\\n      return dp[n];\\n      \\n        \\n    }\\n\\t\\n\\t//Guys plz plz plz upvote my solution if you really like and understand it.and comment if you dont able to understand it\\n\\t\\n\\t//Happy Coding Guys",
                "codeTag": "Unknown"
            },
            {
                "id": 241466,
                "title": "java-solutions",
                "content": "**Solution 1: Brute-Force Approach**\\n\\nBase cases:\\nif `n == 0`, then the number of ways should be `zero`.\\nif `n == 1`, then there is only `one` way to climb the stair.\\nif `n == 2`, then there are `two` ways to climb the stairs. One solution is `one` step by another; the other one is `two` steps at one time.\\n\\n- We can reach `i`th step in one of the two ways:\\n1. Taking a single step from `(i - 1)`th step\\n2. Taking a step of two from `(i - 2)`th step.\\n- So, the total number of ways to reach `i`th step is equal to sum of ways of reaching `(i - 1)`th step and ways of reaching `(i - 2)`th step.\\n\\nTime complexity: `O(2^n)` - since size of recursion tree will be `2^n`\\nSpace Complexity: `O(n)` - space required for the recursive function call stack.\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Solution 2: Dynamic Programming**\\n\\n- This similar to `Solution1`, but here we cache the intermediate results in an array for the performance improvement.\\n- Let `dp[i]` denotes the number of ways to reach on `i`th step, then\\n`dp[i] = dp[i - 1] + dp[i - 2]`\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n\\n**Top-Down Approach**\\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\n**Bottom-Up Approach**\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Solution 3: Fibonacci Number**\\n\\n- In the above approach of `Solution2`, we have used an array where `dp[i] = dp[i - 1] + dp[i - 2]`. It can be easily analyzed that `dp[i]` is nothing but `i`th Fibonacci number.\\n`Fib(n) = Fib(n - 1) + Fib(n - 2)`\\n- So now we just have to find `n`th number of the Fibonacci series having `1` and `2` as their first and second term respectively, \\ni.e. `Fib(1) = 1` and `Fib(2) = 2`.\\n\\nTime complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else\\n            return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    int[] cache = new int[46];\\n    \\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n        else if(cache[n] != 0)\\n            return cache[n];\\n        else\\n            return cache[n] = climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n        if(n <= 2)\\n            return n;\\n\\n        int a = 1;\\n        int b = 2;\\n\\n\\t\\tfor(int i = 3; i <= n; i++)\\n\\t\\t{\\n            int sum = a + b;\\n            a = b;\\n            b = sum;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861147,
                "title": "clean-python-fibonacci-growth",
                "content": "**Clean Python | Fibonacci Growth**\\n\\nPython solution similar to the Approach N\\xBA 4 (Fibonacci Growth) discussed in the official LeetCode solution:\\n\\nWe basically consider all steps from 1 to n: ```x=[1,2,3,4,...]```. Here we note that we can only reach step number ```x[i]``` by advancing one step from ```x[i-1]``` or two steps from ```x[i-2]```. Based on this insight, we can say with confidence that the total number of alternatives to reach step number ```x[i]``` is ```N[i] = N[i-1]+N[i-2]``` (sum of alternatives at previous steps). This gives us a Fibonacci growth sequence.\\n\\nThe steps ```[i-1]``` and ```[i-2]``` receive the names ```a``` and ```b``` in the code. If we advance in the array ```[...,b,a]```, we can say that new element in the array will be ```c = a+b```. Therefore, we get ```[..., ,b,a,a+b]```. If we iterate in the loop, we note that our variables are updated as ```b,a = a,a+b```, or reversing the order: ```a,b = a+b,a``` (this is what appears in the code).\\n\\nWe return the value of ```a``` at the end of the function, because this is our last step taken. Now regarding the initialization ```a,b=1,0```, this can be a bit tricky. One way to sense of this would be to think that initially we are at ```n=0``` (before taking one step), but ```n=-1``` is nonsense, so we have one alternative at ```n=0``` and zero alternatives at ```n=-1```. If you follow the first elements in the sequence ```[0,1,...]```, you will see that the upcoming sequence ```[1,2,3,...]``` is formed perfectly with this initialization :)\\n\\nTo be honest, I first thought about this initialization as a small hack to get the code running without if-clauses, because I knew the first element would be ```c = a+b = 1+0 = 1``` for ```n=1```, and then having the initial elements ```[1,1]```, the rest of the code would work perfectly lol.\\n\\nI hope the explanation was helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```x=[1,2,3,4,...]```\n```x[i]```\n```x[i-1]```\n```x[i-2]```\n```x[i]```\n```N[i] = N[i-1]+N[i-2]```\n```[i-1]```\n```[i-2]```\n```a```\n```b```\n```[...,b,a]```\n```c = a+b```\n```[..., ,b,a,a+b]```\n```b,a = a,a+b```\n```a,b = a+b,a```\n```a```\n```a,b=1,0```\n```n=0```\n```n=-1```\n```n=0```\n```n=-1```\n```[0,1,...]```\n```[1,2,3,...]```\n```c = a+b = 1+0 = 1```\n```n=1```\n```[1,1]```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        a,b = 1,0\\n        for _ in range(n):\\n            a,b = a+b,a\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838261,
                "title": "dynamic-programming-soln-in-c",
                "content": "**Recursive Approach(TLE)**\\n```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\\n\\n**Top Down Approach**\\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\\n\\n**Bottom up Approach**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n```\n```\\nint t[46]={0};\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1) {t[n]=1; return 1;}\\n        if(n==2) {t[n]=2; return 2;}\\n        else if(t[n]!=0) return t[n];\\n        t[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return t[n];\\n    }\\n};\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        for(int i=0;i<=n;i++) t[i]=0;\\n        t[1]=1;\\n        if(n>=2) t[2]=2;\\n        for(int i=3;i<=n;i++){\\n             t[i] = t[i-1]+t[i-2];    \\n        }\\n        return t[n];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044200,
                "title": "c-solution-three-approaches-with-explanation-easy-to-understand",
                "content": "**Approach 1 : (Recursion)**\\n\\n**Recursion** is a programming technique using function or algorithm which calls itself directly or indirectly until a suitable condition is met. In this method, we repeatedly call the function within the same function, and it has a base case and a recursive condition.\\n\\n**It gives us Time Limit Exceeded (TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Approach 2 : (DP - Memoization / Top Down)**\\n\\n**Memoization** is a technique for improving the performance of recursive algorithms. It involves rewriting the recursive algorithm so that as answers to problems are found, they are stored in an array. Recursive calls can look up results in the array rather than having to recalculate them.\\n\\nWe start our journey from the top most destination state and compute its answer by taking in count the values of states that can reach the destination state, till we reach the bottom-most base state. Hence, it is also called as **Top-Down Approach**\\n\\n**Runtime: 0 ms\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\\n\\n**Approach 3 :(DP - Bottom Up / Tabulation)**\\n\\n**Tabulation** is a bottom-up method for solving DP problems.\\nIt goes one level up and combines the solutions it previously obtained to construct the optimal solutions to more complex problems. Eventually, tabulation combines the solutions of the original problem\\'s subproblems and finds its optimal solution.\\n\\n**Runtime: 3 ms\\nMemory Usage: 6.3 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**If you liked the solution and understood the approaches well , then please upvote, it motivates me to write more solutions that can help others to understand the concepts well \\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<0) return 0;\\n        if(n==0 || n==1) return 1;\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &dp,int n){\\n        if(n<0) return 0;\\n        if(n==0 || n==1)    return 1;\\n        if(dp[n]!=-1)   return dp[n];\\n        return dp[n]=helper(dp,n-1)+helper(dp,n-2);\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(dp,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++)   \\n            dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914779,
                "title": "dp-recursion-w-memo-two-js-solutions",
                "content": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612132,
                "title": "easy-solution-in-c-all-approaches-discussed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount manually and find dependencies of solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we observe the pattern by counting manually. For n<=2, the answer is n itself. For n>2, the solution is obtained by adding the solutions to previous two subproblems. So we obtain the recurrenece relation **F(n)=F(n-1)+F(n-2) for n>2.** The naive approach would be to apply recursion. That is, no doubt absolutely correct but not a very fast solution. Applying recursion would give TLE.\\n\\nThe second approach would be to apply recursion and adding memoization, i.e., storing the solution of smaller problems so that we don\\'t have to calculate them again and again while solving the bigger problem. But that also will give TLE.\\n\\nThe third approach is tabulation method. That is basically iterating manually for values 0 to n. The base cases are known to us(n=0,1,2) and we can simply iterate for values over 2 and store them in the vector named dp. This is the fastest solution and gives the correct answer.\\n\\nHowever, the third approach is still not the best one. We store all the values in an additional vector, using space. We know that our solution depends upon the previous two solutions. So instead of storing all the solutions in a vector, we keep the track of the solutions using three variables - prev1, prev2 and prev3. Initially prev1 = 0(n=0 case), prev2=1(n=1 case) and prev3=2(n=2 case). We take another variable curr and run a loop from i=3 to n, updating each variable acccoringly. This is the best solution, as alongwith being the fastest, it does not take up any extra space as well.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(2^n)\\nRecursion + Memoization Solution - O(n)\\nTabulation Solution - O(n)\\nTabulation + Space Optimization Solution - O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRecursive Solution - O(n), due to recursive stack\\nRecursion + Memoization Solution - O(n)+O(n)=O(n), due to recursive stack and dp array\\nTabulation Solution - O(n), due to dp array\\nTabulation + Space Optimization Solution - O(1), as no extra space is being used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/6bf23c95-e4dd-4836-9464-c2c640159868_1686204613.032207.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //RECURSIVE\\n    int solve(int n) {\\n        if(n<=2) return n;\\n\\n        return solve(n-1)+solve(n-2);\\n    }\\n\\n    //RECURSION+MEMOIZATION - TOP DOWN\\n    int solveTD(int n, vector<int> &dp) {\\n        if(n<=2) return n;\\n        if(dp[n]!=-1) return dp[n];\\n        dp[n]=solve(n-1)+solve(n-2);\\n\\n        return dp[n];\\n    }\\n\\n    //BOTTOM UP APPROACH\\n    int solveBU(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0]=0;\\n        if(n==0) return dp[0];\\n        dp[1]=1;\\n        if(n==1) return dp[1];\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++) dp[i]=dp[i-1]+dp[i-2];\\n\\n        return dp[n];\\n    }\\n\\n    int solveBUSpace(int n) {\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 2;\\n        int curr;\\n\\n        if(n==0) return prev1;\\n        if(n==1) return prev2;\\n        if(n==2) return prev3;\\n\\n        for(int i=3;i<=n;i++) {\\n            curr=prev2+prev3;\\n            prev1=prev2;\\n            prev2=prev3;\\n            prev3=curr;\\n        }\\n        return curr;\\n    }\\n\\n    int climbStairs(int n) {\\n        \\n        //RECURSIVE CALL\\n        // return solve(n);\\n\\n        //TOP DOWN CALL\\n        // vector<int> dp(n+1,-1);\\n        // return solveTD(n,dp);\\n\\n        //BOTTOM UP CALL\\n        // return solveBU(n);\\n\\n        //BOTTOM UP WITH SPACE OPTIMIZATION\\n        return solveBUSpace(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25436,
                "title": "using-the-fibonacci-formular-to-get-the-answer-directly",
                "content": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "solutionTags": [],
                "code": "    \\nThis is Fibonacci number, and the world has already worked out an formula that\\n\\n![enter image description here][1]\\n\\nand where \\n\\n![enter image description here][2]\\n\\nor you can check the wiki [Fibonacci Number][3]\\n\\nand noticed the Fibonacci begins with F(0)=0, F(1)=1, F(2)=1, F(3)=2\\n\\nbut this problem begins with F'(1)=1, F'(2)=2\\n\\nSo we need a (n++) at the beginning to match the Fibonacci formula\\n\\n    int climbStairs(int n) {\\n        n++;\\n        double root5 = pow(5, 0.5);\\n        double result = 1/root5*( pow((1+root5)/2, n) - pow((1-root5)/2, n) );\\n        return (int)(result);\\n    }\\n\\n\\n  [1]: https://upload.wikimedia.org/math/5/9/9/5992591704ae747ece79e8808dcadd63.png\\n  [2]: https://upload.wikimedia.org/math/4/9/e/49e8a76ceee7c67c84383ebdf06683be.png\\n  [3]: https://en.wikipedia.org/wiki/Fibonacci_number",
                "codeTag": "Unknown"
            },
            {
                "id": 2760912,
                "title": "plain-and-simple-explaination-100-fast-and-beginner-friendly-please-vote-if-understood",
                "content": "\\n![Screenshot (936).png](https://assets.leetcode.com/users/images/855c97e9-296a-48a8-b3d9-79304a71d5c4_1667155951.7405477.png)\\n\\n\\n# Approach\\nif there is x ways of climbing n-2 stairs and y ways of climbing n-1 stairs, we can say that there are x+y ways of climbing n stairs. we can take 1 step from (n-1)th stair or 2 steps from (n-2)th stair to get to the nth stair.\\n\\nSo ans(n) = ans(n-1)+ans(n-2) i.e. Fibonacci situation.\\n\\nNow we have to calculate for n>=3 only so n=1 and n=2 are already solved cases.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) { //FIBONACCI\\n        if(n<=2)\\n            return n;\\n        int one =1;\\n        int two =2;\\n        for(int i = 3;i<=n;i++){\\n            int temp = one;\\n            one = two;\\n            two+=temp;\\n        }\\n        return two;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691420,
                "title": "100-faster-solution-without-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```\\n\\nIf you like it then pls don\\'t forget to give it a reputation!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[46];  // because Constraints are: 1 <= n <= 45\\n        arr[0] = 1; // oth stairs should be 1\\n        arr[1] = 1; // 1th stair should be 1\\n        arr[2] = 2; // 2nd stair should be 2\\n        for(int i=3; i<=n; i++){\\n            arr[i] = arr[i-1] + arr[i-2];\\n        }\\n        return arr[n]; // finally returning the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725940,
                "title": "js-fibonacci-without-recursion-with-explanation-4-solutions",
                "content": "Solving this problem does not require an understanding of Fibonacci numbers. The Fibonacci numbers are the numbers in the next integer sequence.\\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ........\\n\\n**Fn = Fn-1 + Fn-2**\\n\\nRecursion is often used to solve the problem, but it is not very efficient with large fibonacci numbers, and the complexity of such a program can be very disappointing.\\nTherefore, we will **use dynamic programming.**\\n\\n**Recursive solution example:**\\n```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\\n\\n**Dynamic programming** is basically an optimization of regular recursion. Wherever we see a recursive solution, we can optimize it with dynamic programming. The idea is to simply store the results of the subtasks so that we don\\'t have to recalculate them later when needed. This simple optimization reduces the time complexity from exponential to polynomial.\\n\\nSo, instead of recursing, we\\'ll create variables with the first Fibonacci numbers (1, 1), **not including 0**, and with a simple iteration, we\\'ll update them until we get what we want. \\n\\nWe also add a check, if the values are less than 4, return n, since the Fibonacci number 1 is \\'1\\', 2 is \\'2\\', 3 is \\'3\\', and only starting from 4, we will get a distinctive value.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\\n**Time complexity: O(n)\\nExtra space: O(1)**\\n\\nThis solution looks more understandable, but takes up more space than the first one.\\n\\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\\n**Time complexity: O(n) for given n;\\nAuxiliary space: O(n);**\\n\\nAlso, to obtain Fibonacci numbers, you can use the matrix method, it is considered one of the most effective.\\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```\\n**Time complexity: O(Log n)\\nAdditional space: O(Log n)** when considering the size of the function call stack, O(1) otherwise.\\nAnd this is very cool - if, of course, this complexity is really so important to us.\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\n    function fib(n) {\\n    if (n <= 1)\\n        return n;\\n    return fib(n-1) + fib(n-2);\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let a = 1, b = 1, fib;\\n    for(let i = 2; i <= n; i++) {\\n        fib = a + b;\\n        a = b;\\n        b = fib;\\n    }\\n    return fib;\\n};\\n```\n```\\nvar climbStairs = function(n) {\\n    if (n < 4) return n;\\n    let fib = [1, 1];\\n    for (let i = 2; i <= n; i++) {\\n        fib[i] = fib[i - 1] + fib[i - 2];\\n    }\\n    return fib[n];\\n};\\n```\n```\\nconst mul = (\\n    [[a1, a2],[a3, a4]],\\n    [[b1, b2],[b3, b4]]) =>\\n    [[a1 * b1 + a2 * b3, a1 * b2 + a2 * b4],\\n     [a3 * b1 + a4 * b3, a3 * b2 + a4 * b4]];\\n\\nconst matrix = [[0, 1],[1, 1]];\\n\\nconst id = [[1, 0],[0, 1]]\\n\\nvar climbStairs = function(n) {\\n    let result = id;\\n    const bits = (n + 1).toString(2);\\n\\n    for(const bit of bits){\\n        result = mul(result, result);\\n        if(bit === \"1\"){\\n            result = mul(result, matrix);\\n        }\\n    }\\n    return result[1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25459,
                "title": "memoization-with-recursion-top-down-approach-dynamic-programming-bottom-up",
                "content": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "This problem is nothing but a Fibonacci Sequence.\\n\\nLet\\u2019s define a function T(n) for the number of choices available with n stairs(n steps).There are 2 choices for the first step: One choice is to climb only one stair, and has T(n-1) choices for the remaining n-1 stairs. The other one is to jump two stairs at the first step, and has T(n-2) choices for the remaining n-2 stairs. Therefore, the total number of choices for n stairs is T(n) = T(n-1) + T(n- 2), which is the nothing but Fibonacci Sequence.\\n\\nFor example, there are three choices to climb up a stair with three levels: (1) climb in three steps, one stair for each climb; (2) climb in two steps, one level for the first step and two levels for the second; or (3) climb with two steps, two levels for the first step and one level for the last jump.\\n\\nNow if we code a recursive function T(n) = T(n-1) + T(n-2), each recursive call is called twice for large n, making 2^n calls. This is not recommended. Instead, we save result from each call and check if its available before triggering another call. \\n\\nThis type of saving the intermediate results to get final result is called Memoization. Here we follow top-down approach.\\n\\n    int f(int n, int *arr)\\n    {\\n    \\tif (n == 0 || n == 1) return 1;\\n    \\tif (arr[n] != 0) return arr[n];\\n    \\telse{\\n    \\t  arr[n] = f(n - 1, arr) + f(n - 2, arr);\\n    \\t  return arr[n];\\n    \\t}\\n    }\\n\\n    int climbStairs(int n) {\\n    \\tint *p = (int *)malloc(sizeof(int) * (n + 1));\\n    \\tint res, i;\\n    \\t\\n    \\tif (n == 0 || n == 1) p[n] = 1;  //Base condition\\n    \\t\\n    \\tfor (i = 2; i <= n; i++) p[i] = 0; //For memoization, defaulting all values to 0\\n    \\t\\n    \\tres = f(n, p);\\n    \\tfree(p);\\n    \\t\\n    \\treturn res;\\n    }\\n\\nNow this even can be simplified, what we call as 'Dynamic Programming'. Instead of going from top down, we will do bottom up approach. Calculate T(n) for small values and build larger values using them.\\nThe code looks something like this...\\n\\n    ....\\n    store[0] = 1;\\n    store[1] = 1;\\n    for (i = 2; i <=n; i++)\\n        store[i] = store[i - 1] + store[i - 2];\\n    return store[n];\\n    ...",
                "codeTag": "Unknown"
            },
            {
                "id": 914746,
                "title": "easy-js-solution-memoization-and-recursion-in-3-lines",
                "content": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n, memo = {1:1, 2:2}) {\\n   if (memo[n] !== undefined) return memo[n];   \\n   memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n   return memo[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25338,
                "title": "fibonacci-sequence-solution-in-java",
                "content": "public class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int climbStairs(int n) {\\n        if(n < 0)\\n            return 0;\\n        if(n == 1)\\n            return 1;\\n            \\n        int[] store = new int[n];\\n        \\n        store[0] = 1;\\n        store[1] = 2;\\n        \\n        for(int i = 2; i < n; ++i)\\n            store[i] = store[i-1] + store[i-2];\\n            \\n        return store[n-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 25609,
                "title": "simple-and-clear-2ms-solution-in-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }\\n            return ret;\\n        }\\n    };\\n\\nThis problem is a Fibonacci problem.\\nF(n)=F(n-1)+F(n-2);\\nSolving this problem by recursion ,we will do a lot of same recursion.\\nExample:\\nF(10)=F(9)+F(8);\\nF(9)=F(8)+F(7);\\nwe calculate F(8) twice,when n is large,this will increase as a rate of n's exponent.\\n\\nSo a more efficient way to solve this problem is from Bottom to Top.\\nCalculate F(0) ,F(1);\\nthen F(2).........",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int StepOne = 1;\\n            int StepTwo = 0;\\n            int ret = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                ret = StepOne + StepTwo;\\n                StepTwo = StepOne;\\n                StepOne = ret;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 346943,
                "title": "simple-understandable-fibonacci-solution",
                "content": "This is fibonacci without recurrsion.\\n\\n```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar climbStairs = function(n) {    \\n    let prev = 0;\\n    let cur = 1;\\n    let temp;\\n    \\n    for (let i = 0; i < n; i++) {\\n        temp = prev;\\n        prev = cur;\\n        cur += temp; \\n    }\\n    return cur;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791210,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677712,
                "title": "python-4-approaches-with-time-and-space-complexity",
                "content": "Approach 1:- ***Recursion***\\nTC:- ***Exponential (2^n)***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\\nApproach 2:- ***Recursion+Memoization(Top Down DP)***\\nTC:- ***O(N)*** but space complexity will still have ***stack space*** involved along with ***O(N) Dp array***.\\n\\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\\nApproach 3:- ***Bottom Up DP*** \\nTC:- ***O(N)*** with ***no stack space*** involved but with a **O(n)  dp array**.\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\\nApproach 4:- ***Space Optimisation technique!!!***\\nTC:- ***O(N) with NO EXTRA SPACE!!!***\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```\\n\\t\\t \\n****Do upvote. :)****\\n    \\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n        \\n            wayone=stairs(i-1)\\n            waytwo=stairs(i-2)\\n            \\n            return wayone+waytwo\\n        \\n    \\n        return stairs(n)\\n```\n```\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(i,dp):\\n            if i==0:\\n                return 1\\n            if i<0:\\n                return 0\\n            \\n            if dp[i]!=-1:\\n                return dp[i]\\n        \\n            wayone=stairs(i-1,dp)\\n            waytwo=stairs(i-2,dp)\\n            \\n            dp[i]= wayone+waytwo\\n            \\n            return dp[i]\\n        \\n        dp=[-1]*(n+1)\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n,dp):\\n            for i in range(2,n+1):\\n                dp[i]=dp[i-1]+dp[i-2]\\n                \\n            return dp[n]\\n            \\n        dp=[-1]*(n+1)\\n        dp[0]=1\\n        dp[1]=1\\n        return stairs(n,dp)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        def stairs(n):\\n            if n==0 or n==1:\\n                return 1\\n                \\n            a=1\\n            b=1\\n            for i in range(2,n+1):\\n                c=a+b\\n                a=b\\n                b=c\\n                \\n            return c\\n           \\n            \\n         return stairs(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282043,
                "title": "python-easy-4-line-dp-36-ms-faster-than-77-83",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        steps = [1,1]\\n        for i in range(2,n+1):\\n            steps.append(steps[i-1] + steps[i-2])\\n        return steps[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764938,
                "title": "cpp-recursive-memoization-dp-three-solution-easy-to-understand",
                "content": "**Three Solutions step by step \\nfrom recursion to DP**\\n\\n**1. Recursive Solution**\\n**It will give TLE but for better understanding to memoization we have to write it**\\n```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\\n\\n**2. Memoization of Recursive Solution**\\n\\n**Runtime: 0 ms .\\nMemory Usage: 6.2 MB**\\n\\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\\n\\n**3. Convert Memoization into dp**\\n\\n**Runtime: 4 ms\\nMemory Usage: 5.9 MB**\\n\\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```\\n\\n**If any improvement , Kindly comment.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mk(int n)\\n    {\\n         if(n<0) return 0;\\n         if(n==0) return 1;\\n         return mk(n-1)+mk(n-2); \\n    } \\n    int climbStairs(int n) {\\n        return mk(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mk(int n,vector<int> &memo)\\n    {     \\n         if(n<0) return 0;\\n         if(memo[n]!=-1) return memo[n];\\n         if(n==0) return 1;\\n         return memo[n]=mk(n-1,memo)+mk(n-2,memo);\\n    }\\n     \\n    int climbStairs(int n) {\\n        vector<int> memo(n+1,-1);\\n        return mk(n,memo);\\n    }\\n};\\n```\n```\\n class Solution {\\npublic:\\n    \\n    int climbStairs(int n) {\\n\\t    if(n<1) return 0;\\n        int a[100];\\n        a[0]=1;\\n        a[1]=2;\\n        for(int i=2;i<n;i++)\\n            a[i]=a[i-1]+a[i-2];\\n        return a[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399534,
                "title": "one-liner-javascript-typescript-solution-with-recursion",
                "content": "# Complexity\\n- Time complexity: 59 ms\\n- Space complexity: 43.3 MB\\n\\n# Code\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\n# Explanation\\n\\nIf we start making outputs for n starting from 1:\\n\\n### n = 1, Output: 1\\n1. 1 step\\n\\n### n = 2, Output: 2\\n1. 1 step + 1 step\\n2. 2 steps\\n\\n### n = 3, Output: 3\\n1. 1 step + 1 step + 1 step\\n2. 1 step + 2 steps\\n3. 2 steps + 1 step\\n\\n### n = 4, Output: 5\\n1. 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 2 steps\\n3. 1 step + 2 steps + 1 step\\n4. 2 steps + 1 step + 1 step\\n5. 2 steps + 2 steps\\n\\nOn a closer look, we can see that these 5 ways are actually:\\n1. 1 step + (1st case of n = 3)\\n2. 1 step + (2nd case of n = 3)\\n3. 1 step + (3rd case of n = 3)\\n4. 2 steps + (1st case of n = 2)\\n5. 2 steps + (2nd case of n = 2)\\n\\ni.e. the output is: (Output for n = 3) + (Output for n = 2)\\n\\n### n = 5, Output: 8\\n1. 1 step + 1 step + 1 step + 1 step + 1 step\\n2. 1 step + 1 step + 1 step + 2 steps\\n3. 1 step + 1 step + 2 steps + 1 step\\n4. 1 step + 2 steps + 1 step + 1 step\\n5. 1 step + 2 steps + 2 steps\\n6. 2 steps + 1 step + 1 step + 1 step\\n7. 2 steps + 1 step + 2 steps\\n8. 2 steps + 2 steps + 1 step\\n\\nSimilarly again, we can see that these 8 ways are actually:\\n1. 1 step + (1st case of n = 4)\\n2. 1 step + (2nd case of n = 4)\\n3. 1 step + (3rd case of n = 4)\\n4. 1 step + (4th case of n = 4)\\n5. 1 step + (5th case of n = 4)\\n6. 2 steps + (1st case of n = 3)\\n7. 2 steps + (2nd case of n = 3)\\n8. 2 steps + (3rd case of n = 3)\\n\\ni.e. the output is: (Output for n = 4) + (Output for n = 3)\\n\\n### Formula\\nSo from above cases, we can see that the output for n = 1 and n = 2 is n. And for n = 3 or > 3 it is: (Output for n - 1) + (Output for n - 2).\\n\\nBecause, for any given n stairs (n >= 3), \\n- if we take 1 step, then we will be left with n - 1 stairs.\\n- and if we take 2 steps, then we will be left with n - 2 stairs.\\n\\nSo, our output will always be: \\n`distinct ways for n stairs = distinct ways for n-1 + distinct ways for n-2`\\n\\nAs our function name is climbStairs, so we can make the formaula using that:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n\\nSo, the code will be like:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\\n\\nIf we submit this solution, it throws runtime error. So we can try to simplify it more:\\n`climbStairs(n) = climbStairs(n-1) + climbStairs(n-2)`\\n`climbStairs(n) = (climbStairs(n-2) + climbStairs(n-3)) + climbStairs(n-2)`\\n(because climbStairs(n-1) = climbStairs(n-2) + climbStairs(n-3))\\n\\nAs the code is doing recursion and here we can see it was calling climbStairs twice for n-2 case in our code. So, to reduce execution time, we can just call it once and multiply it\\'s answer with 2.\\ni.e.\\n`climbStairs(n) = 2 * climbStairs(n-2) + climbStairs(n-3)`\\n\\nMoreover, as we saw for n = 3 case, that the output is 3 i.e. n. So, we can change our if condition to n <= 3, to reduce execution time more.\\n\\n### Final Code\\nSo this makes our solution:\\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\\n\\nwhich can be simplified to:\\n\\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 \\n        ? n \\n        : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 2) {\\n        return n;\\n    }\\n    return climbStairs(n - 1) + climbStairs(n - 2);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    if (n <= 3) {\\n        return n;\\n    }\\n    return 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```\n```\\nfunction climbStairs(n: number): number {\\n    return n <= 3 ? n : 2 * climbStairs(n - 2) + climbStairs(n - 3);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915720,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25368,
                "title": "dynamic-programming-solution-using-java",
                "content": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "solutionTags": [],
                "code": "\\n\\n    /*\\n     * Ideas:\\n     * Use Dynamic Programming,\\n     * for each step, the stair could ether combine with the previous one or as a single step.\\n     * Ways to climb to ith stair is W(i) = W(i-1) + W(i-2)\\n     * where W(i-1) is when the ith stair is as a single step\\n     * and W(i-2) is when the ith stair is paired with the previous one.\\n     */\\n    public int climbStairs(int n) {\\n            int[] tmp = new int[n];\\n            if (n < 2){\\n                return 1;\\n            }\\n            tmp[0] = 1;\\n            tmp[1] = 2;\\n            for (int i = 2; i < n; i++){\\n                tmp[i] = tmp[i-1] + tmp[i-2];\\n            }\\n            return tmp[n-1];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1515325,
                "title": "java-tc-o-logn-sc-o-1-matrix-multiplication-space-optimized-dp-solutions",
                "content": "**Binets Method (Using Matrix Multiplication to find the Fibonacci Number)**\\n\\n```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\n---\\n**Space Optimized Dynamic Programming**\\n\\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Binets Method (Using Matrix Multiplication to find the Fibonacci Number)\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1) -> Uses constant complexity\\n *\\n * N = Input number n\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n\\t\\tint[][] q = { { 1, 1 }, { 1, 0 } };\\n        int[][] result = q;\\n        n--; // As we have already solved for n = 1. q[0][0] points to 2nd Fibonacci Number.\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result = multiplyMatrix(result, q);\\n                if (n == 1) {\\n                    break;\\n                }\\n                n--;\\n            }\\n\\n            q = multiplyMatrix(q, q);\\n            n /= 2;\\n        }\\n\\n        return result[0][0];\\n    }\\n\\n    private int[][] multiplyMatrix(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\n```java\\n/**\\n * Space Optimized Dynamic Programming\\n *\\n * DP[i] = DP[i-1] + DP[i-2]\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Input number n.\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"n in invalid\");\\n        }\\n        if (n <= 1) {\\n            return n;\\n        }\\n\\n        int pre = 1; // n == 1\\n        int cur = 2; // n == 2\\n        for (int i = 3; i <= n; i++) {\\n            int sum = cur + pre;1\\n            pre = cur;\\n            cur = sum;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271911,
                "title": "python-dp-fibonacci",
                "content": "To each a specific stair ```x```, we can either climb 1 stair from ```x-1```, or 2 stairs from ```x-2```. Therefore, suppose ```dp[i]``` records the number of ways to reach stair ```i```, ```dp[i] = dp[i-1]+dp[i-2]```. And it\\'s a Fibonacci Array.\\nThe base case is to reach the first stair, we only have one way to do it so dp[1] = 1.\\nBesides, since only dp elements we used is most recent two elements, we can use two pointer to save using of dp array. So space complexity is O(1)/\\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```x```\n```x-1```\n```x-2```\n```dp[i]```\n```i```\n```dp[i] = dp[i-1]+dp[i-2]```\n```\\ndef climbStairs(n):\\n\\tcurr = prev = 1\\n\\tfor _ in range(n-1):\\n\\t\\tcurr, prev = curr + prev, curr\\n\\treturn curr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765140,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236863,
                "title": "climbing-stairs-all-approaches-well-explained-faster-than-100",
                "content": "**I have shared all four  approaches for the question**\\n**Recursive solution:- Gives TLE if n>=44**\\nt.c-O(2^n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\\n\\n**Memoization method:- Top-Down Approach**\\nt.c-O(n)\\ns.c-O(n) + O(n)\\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\\n**Tabulation method:- Bottom-up approach**\\nt.c-O(n)\\ns.c-O(n)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Optimal Approach**\\nt.c-O(n)\\ns.c-O(1)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```\\nIf you like please upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2)\\n        {\\n            return n;\\n        }\\n        return climbStairs(n-1)+climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int calc(int n,vector<int> &dp)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(n==0 || n==1)\\n            return 1;\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        int left = calc(n-1,dp);\\n        int right = calc(n-2,dp);\\n        return dp[n] = left + right;\\n        \\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return calc(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n==2)\\n        {\\n            return n;\\n        }\\n        int a = 1;\\n        int b = 2;\\n        int c = 0;\\n        for(int i=3;i<=n;i++)\\n        {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764847,
                "title": "python-2-solution-dp-fibonacci-math-explained",
                "content": "### Solution 1:\\n\\nWe can climb either `1` or `2` steps, and we are interested how many ways to climb ladder with `n` stairs. How can we reach step number `n`:\\n1. Making step with size `1`, so from step with number `n-1`\\n2. Making step with size `2`, so from step with number `n-2`.\\n\\nSo, if we denote `F[n]` numbers of ways to reach step number `n`, we can write equation: `F[n] = F[n-1] + F[n-2]`. But it is not enough, we also need to define starting cases: `F[1] = 1` and `F[2] = 2`. Or we can say, that `F[0] = 1` and `F[1] = 1`.\\n\\nNow, everything is ready to write our dynamic programming problem.\\n\\n**Complexity**: time complexity is `O(n)` and space complexity is `O(1)`.\\n\\n\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\\n\\n### Solution 2\\n\\nIf we look carefully at equation `F[n] = F[n-1] + F[n-2]` and starting points, we can see, that we have nothing else, than Fibonacci sequence:\\n\\n`1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`\\n\\nNote however, that it is shifted by one position. So, what we need to do is to use Binet formula: https://en.wikipedia.org/wiki/Fibonacci_number#Binet\\'s_formula, where we use computation by rounding.\\n\\n**Complexity**: both time and memory is `O(1)` if we assume that number in `int32` range and if we assume complexity of `**` as `O(1)`.\\n\\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n):\\n        dp = (1, 1)\\n        for i in range(n-1):\\n            dp = (dp[1], dp[0] + dp[1])\\n        return dp[1]\\n```\n```\\nreturn round((0.5+sqrt(5)/2)**(n+1)/sqrt(5))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302571,
                "title": "fastest-possible-solution-c-professors-hate-him",
                "content": "# Intuition\\nThey don\\'t teach you this at school\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI AM SPEED\\n\\n# Complexity\\n- Time complexity:O(0)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(45)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        long fast[] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073};\\n\\n        return (int)fast[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893345,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst cache: number[] = []\\n\\nfunction climbStairs(n: number): number {\\n  if (n <= 2) return n\\n  if (!cache[n]) { cache[n] = climbStairs(n - 2) + climbStairs(n - 1) }\\n  return cache[n]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379365,
                "title": "bored-of-long-solution-try-mine-pls-upvote-if-helpful",
                "content": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```\\nSee pattern:\\nn=1, output=1\\nn=2, output=2\\nn=3, output=3\\nn=4, output=5\\nn=5, output=8\\n.....\\nBasically, answers are coming in the form of fibonacci series f(n)=f(n-1)+f(n-2).\\nWhat we are doing is storing the value of f(n) at every recursion step in the form of dictionary and we don\\'t need to go to base case for every step. We are just checking at every recursion call if that value of f(n-1) or f(n-2) called by f(n) is already there in dictionary if it\\'s there we reduce number of steps and return the answer to further function call.\\nFor example, take n=6\\ncalls going like this:\\n![image](https://assets.leetcode.com/users/images/85d9f775-a841-4ed8-b29b-52e8ae9bdf39_1627966437.362527.png)\\nI think this might help.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    d={1:1,2:2}\\n    def climbStairs(self, n: int) -> int:\\n        if self.d.get(n,0):return self.d.get(n)\\n        self.d[n]=self.climbStairs(n-1)+self.climbStairs(n-2)\\n        return self.d[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385821,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/dca7255e-0637-4e64-b0ea-eba1eb0291b9_1680770553.0661306.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int dp[n+1];\\n        dp[1]=1;\\n        dp[0]=1;\\n        for(int i=2;i<=n;i++)dp[i]=dp[i-1]+dp[i-2];\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609648,
                "title": "100-faster-solution-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n# Iterative solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\\n\\n# Recursive solution: (*will give TLE*)\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```\\n# DP solution:\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int t[n+1];\\n        \\n        t[1]=1;\\n        if(n>=2) t[2]=2; //if we don\\'t give the condition then it will give runtime error for i/p 1\\n        \\n        for(int i=3; i<=n; i++)\\n            t[i]= t[i-1]+t[i-2];\\n        \\n        return t[n];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        int x=1, y=2;\\n        \\n        for(int i=3; i<n; i++){ // if i<=n\\n            int temp = y;\\n            y += x;\\n            x = temp;\\n        }\\n        return x+y; // return y\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n            return n;\\n        \\n        return climbStairs(n-1)+ climbStairs(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434721,
                "title": "c-100-o-n-with-explanation",
                "content": "#To climb a stair we have to check the recurrence relation:\\n\\n              climb(n) = climb(n-1) + climb(n-2);   //arr[0]=1&&arr[1]=1; (to reach ground and\\n\\t\\t\\t                                         //first stair we have to take one step only).\\n\\t\\t\\t  \\nwe can either take 1 step or 2 step at once.....so to reach suppose 3rd stair we can either jump 2 steps from 1st stair or 1 step from 2nd stair......so total ways to reach 3rd stair will be sum of total ways to reach 1st stair + 2nd stair.\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn arr[n];\\n\\t\\t}\\n\\t};                  \\n\\t                  //please upvote if i helped",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint climbStairs(int n) {\\n\\t\\t\\t\\tint arr[n+1];\\n\\t\\t\\t\\tarr[0]=1;\\n\\t\\t\\t\\tarr[1]=1;\\n\\t\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\t\\tarr[i]=arr[i-1]+arr[i-2];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 417563,
                "title": "javascript-very-short",
                "content": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    let a = 1, b = 2, next;\\n    \\n    for(let i = 3; i <= n; i++) {\\n        next = a + b;\\n        a = b;\\n        b = next;\\n    }\\n    return n === 1 ? a : b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231911,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-c-javascript-java",
                "content": "\\n# Approach\\nIn that firstly we created an array that consists of two possibilties just like we did in fibnocci series and then we loop through it and added value in to the index which will be increased on every iteration. At the end we are returning the second last number from the array and this is our expected result we want very simple logic you can clealy understand the code.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code by using For Loop\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\\n# Code By using Recursion\\n# Approach\\nwe can also did it by using recursion but in leetcode this is not acceptable due to the big out input when we passed some big number init it will taked time to execute so due to this reason Maximum time is exceeded on leetcode editor you can try it on another editor.\\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```\\n\\n##### I am working hard for you guys...\\n##### Please upvote if you found any help with this code...",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let arr = [1,2];\\n    for(let i =2; i <= n; i++){\\n        arr[i] = arr[i - 1] + arr[i - 2]\\n    }\\n    return arr[n-1]\\n};\\n```\n```\\nvar climbStairs = (n) => {\\n    if(n <= 1) return 1;\\n    return climbStairs(n - 1) + climbStairs(n - 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2810612,
                "title": "4-ways-to-solve-with-detailed-diagrams-no-memoization-beats-100-time-memory",
                "content": "For the lazy one\\'s... here\\'s your solution:\\n\\n# Hackers Approach:\\n```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\\n\\nBut for the more curious types read below for the detailed explaination...\\n\\n\\n# Intuition\\n*Some much necessary research to come up with the solution:*\\n![Untitled4.png](https://assets.leetcode.com/users/images/23dc8877-f265-49b1-b372-3b3b46db7759_1695038975.7068937.png)\\n\\n\\n![Untitled2.png](https://assets.leetcode.com/users/images/8e65a7d5-7dcb-4bcb-b13d-32aaf1fbf9a6_1695038994.3318722.png)\\n\\n![Untitled3.png](https://assets.leetcode.com/users/images/7bca2cec-0a9c-42c0-8368-b1f9a10262f0_1695039072.5319896.png)\\n\\nSample runs:\\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\\nwe see the pattern, the ways to climb N stairs is sum total of ways to climb (N-1) stairs plus (N-2) stairs.\\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\\n\\nLet\\'s appreciate the fact that we\\'ve all solved a **fibonacci** before and this is not much different.\\n\\n\\n# Recursive Approach\\nBased on our intuition, we come up with the following algo:\\n\\n***Recursive solution: O(2^n) time and O(n) space for call stack***\\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\\n\\n> However, the above solution would result in TLE(time limit exceeded) as we will keep on calculating some already calculated values again and again. So, maybe we could store the previous results. Memoization to the rescue.\\nWe can achieve this by modifying the above implementation, like so:\\n\\n# DP Approach\\n***Dynamic Programming solution: O(n) time and O(n) space***\\n![Screenshot 2023-09-18 at 6.06.35 PM.png](https://assets.leetcode.com/users/images/6ddbc852-d2bf-4a7c-a054-16451276cb5e_1695040633.4257736.png)\\n\\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\\n\\n> However, this is just waste of space. At any given point, all we need is the previous two calculated results, not all. \\n![IMG_0252.jpg](https://assets.leetcode.com/users/images/f30555a5-0507-4c54-8526-eb0978b31d57_1695040666.829807.jpeg)\\nNot to mention the space needed for the recursion call stack. We can avoid an O(2n) space by getting rid of the recursion and unused memoized values in the above implementation, like so:\\n\\n\\n# Iterative Approach\\n***Iterative Solution: O(n) time and O(1) space***\\n\\n\\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\\n\\n> a few more hacks to slim down this code above and you\\'ll end up with the concise code shared at the top...\\nOr, we could come up with this algo directly, without needing to build upon all the above iterations. Let\\'s answer a few questions for that:\\n\\n_Q: How many ways are there to climb up to the floor?_\\n_A: Duh! Zero_\\n\\n_Q: How many ways can I climb up to the first step?_\\n_A: One. Yeah just One._\\n\\n_Q: How many ways can I climb up to the 2nd step?_\\n_A: Uhmm! Either I take 2 steps from the floor or, I take 1 step from the 1st step._\\n\\n_Q: So how many ways is that?_\\n_A: Two_\\n\\n_Q: Cool, now how many ways can I climb up to the 3rd step?_\\n_A: 2 Ways. Either I take 2 steps from the 1st step or, I take 1 step from the 2nd step._\\n\\n_Q: Nope, to take 1 step from the 2nd step, you need to first reach the 2nd step, and there are more than 1 ways to reach. We need to consider all those ways too. We already calculated it earlier. So how many now?_\\n_A: X ways to reach step 1st step + Y ways to reach 2nd step_\\n_That should be `1 + 2 = 3`_\\n\\n_Q: Great, Now to reach 4th step...?_\\n_A: 1 step from the 3rd step or 2 steps from the 2nd step_\\n_that is, `ways to reach 3rd step + ways to reach 2nd step = 3 + 2 = 5`_\\n\\n_Q: Awesome, can we generalize it?_\\n_A: Yes, `ways to reach given step = ways to reach last step + ways to reach second-last step`_\\n\\n_Q: How can we find ways to reach the `N-th` step?_\\n_A: Simple, we use the result from previous 2 runs and repeat this process N times._\\n\\n_Q: A where do we start?_\\n_A: from the floor. lol. `secondLast=0` and `last=1`.\\n\\n_Q: Can we write the code now?_\\n_A: Ofcourse_\\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```\\n\\n\\n\\n#### PS: Please upvote if you liked the explanatoin and appreciate my effort, helps it reaching others who need it. Thanks :)\\nStay motivated. \\n\\n\\n\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc climbStairs(n int) int {\\n    next, secondNext := 0, 1\\n    for ; n > 0; n-- {\\n        next, secondNext = secondNext, next + secondNext\\n    }\\n    return secondNext\\n}\\n```\n```\\n1 stairs --> [(1)] --> 1 way\\n2 stairs --> [(1,1); (2)] --> 2 ways\\n3 stairs --> [(1,1,1);(2,1); (1,2)] --> 3 ways\\n4 stairs --> [(1,1,1,1);(2,1,1);(1,2,1); (1,1,2);(2,2)] --> 5 ways\\n... so on\\n```\n```\\nways(1) = 1\\nways(2) = 2\\nways(3) = 3 = 2+1 = [1step first => ways(2)] + [2steps first => ways(1)]\\nways(4) = 5 = 3+2 = [1step first => ways(3)] + [2steps first => ways(2)]\\n... so on\\n...\\nways(n) = ways(n-1) + ways(n-2)\\n```\n```go\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    }\\n    \\n    return climbStairs(n-1) + climbStairs(n-2)    \\n}\\n```\n```\\nvar mem map[int]int = map[int]int{}\\n\\nfunc climbStairs(n int) int {\\n    if n == 1 {\\n        return 1\\n    } else if n == 2 {\\n        return 2\\n    } else if val, ok := mem[n]; ok {\\n        return val\\n    }\\n\\n    res := climbStairs(n-1) + climbStairs(n-2)\\n    mem[n] = res\\n    return res\\n}\\n```\n```\\nfunc climbStairs(n int) int {\\n    res := 0\\n    \\n    secondNext := 0\\n    next := 0\\n    for i := 1; i <= n; i++ {\\n        if i == 1 {\\n            res = 1\\n        } else if i == 2 {\\n            res = 2\\n        } else {\\n            res = secondNext + next\\n        }\\n        \\n        next = secondNext\\n        secondNext = res\\n    }\\n    \\n    return res\\n}\\n```\n```go\\nfunc climbStairs(n int) int {\\n    secondLast, last := 0, 1\\n    for i:=1; i<=n; i++ {\\n        secondLast, last = last, secondLast + last\\n    }\\n    return last\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2712423,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [0, 1]\\n        \\n        for i in range(2, n+2):\\n            dp.append(dp[i-2] + dp[i-1])\\n            \\n        return dp[n+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677807,
                "title": "comprehensive-python-explanation",
                "content": "The key here is that we can climb 1 or 2 steps at each point. Therefore, the number of ways to climb ```n``` steps is equal to the number of ways to climb ```n-1``` steps + the number of ways to climb ```n-2``` steps since we can reach the ```n```th step from either of these two previous steps. This is actually the exact same as the fibonnaci sequence, meaning we can solve this problem exactly like we would solve [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/?envType=study-plan&id=level-1).\\n\\n**Basic Recursion Solution; Time: O(2^N), Space: O(1) --> TLE**\\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThis is the most basic solution, taking advantage of the recursive relationship we explored above. However, it is quite slow and results in a time limit exception because it has a time complextiy of ```O(2^N)``` since we need to make 2 recursive calls at each point and those recursive calls make recursive calls of their own. This can be illustrated with the following diagram about the fibonnaci sequence (credit to [Prateek Narang](https://www.scaler.com/topics/fibonacci-series-in-c/)):\\n![image](https://assets.leetcode.com/users/images/0b8e23d2-abd9-4553-b622-5efb833ba81a_1665202511.7852473.png)\\nTo improve on this solution, we can use memoization, one of the core DP techniques. Memoization just means storing our previous results. One way to do this is with python\\'s built in ```@cache```, which stores previous return values from a function call.\\n\\n**Cache Memoization Solution: Time: O(N), Space: O(N)**\\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\\nThe time complexity is now ```O(N)``` since we only need to make one calculation for every value from ```1``` to ```n```. The space is also ```O(N)``` since we are now storing the answers to recursive calls to ```climbStairs```. This solution is probably not what an interviewer wants though, so let\\'s store the results ourselves by using a list where the ```i```th index corresponds to the result of ```climbStairs(i+1)```.\\n\\n**List Memoization Solution; Time: O(N), Space: O(N)**\\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\\nThis is a great solution, but we can do even better! When we add the newest number to ```distinct_ways``` , we actually only need to access the previous numbers in ```distinct_ways```, so we can just use a tuple to store the last two!\\n\\n**Optimized Memoization Solution; Time: O(N), Space: O(1)**\\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```n```\n```n-1```\n```n-2```\n```n```\n```\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(2^N)```\n```@cache```\n```\\n@cache # store previous results\\ndef climbStairs(self, n):\\n\\tif n <= 2: # there is 1 way to climb up 1 step and 2 ways to climb up 2 steps\\n\\t\\treturn n\\n\\treturn self.climbStairs(n-1)+self.climbStairs(n-2) # we can get to this step from either of the last two steps\\n```\n```O(N)```\n```1```\n```n```\n```O(N)```\n```climbStairs```\n```i```\n```climbStairs(i+1)```\n```\\ndef climbStairs(self, n):\\n\\tdistinct_ways = [1,2] # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways.append(distinct_ways[-1] + distinct_ways[-2]) # can come from either of the last two steps\\n\\treturn distinct_ways[n-1] # how many ways to go up n stairs\\n```\n```distinct_ways```\n```distinct_ways```\n```\\ndef climbStairs(self, n):\\n\\tif n == 1: # only 1 way to go up 1 step\\n\\t\\treturn 1\\n\\tdistinct_ways = (1,2) # 1 way to go up 1 step, 2 ways to go up 2 steps\\n\\tfor i in range(2,n): # go up to n steps\\n\\t\\tdistinct_ways = (distinct_ways[1], distinct_ways[0] + distinct_ways[1]) # the previous number of ways becomes the second previous number of ways and the previous number of ways becomes the sum of the last two\\n\\treturn distinct_ways[1] # how many ways to go up n stairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2383701,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\nRecustion (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\\n\\nRecustion + Memorization (Top Down Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\\n\\nDP (Bottom Up Approach)\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\nDP + Optimization (Bottom Up Approach)\\n\\nTo calculate the new value we only leverage the previous two values. So we don\\'t need to use an array to store all the previous values.\\n\\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n**Idea - this is just simple fibonacci!**\\nThe base cases are:\\n\\n* n = 0 -> 0\\n* n = 1 -> 1\\n* n = 2 -> 2\\n\\nThen, for each step i, the number of ways to get to it is: either the last step was of 1 step, so we have prev, or it was a 2 step, and that\\'s prev2, so all together the number of ways to get to our current step is prev + prev2.\\nIf we check the first few, we can see clearly that it comes out a fibonacci sequence.\\n\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\n\\nGeneral inutution\\n-> Intution : the next distinict way of climbing stairs is euqal to the sum of the last two distinict way of climbing\\ndistinct(n) = distinict(n-1) + distinict(n-2)\\nThis intution can be applied using the following three approach --> ordered from easy to difficult approach\\n\\n\\n\\nIdea 1 : pure recursive (Can\\'t pass the test case :does not work for big number, result time-exced limit)\\n- The base case will be when only 1 or 2 steps left\\n- Result time-exced limit\\n\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\\n\\n\\'\\'\\'\\nIdea 2 : use dictionary (look-up table) to memorize repeating recursion\\n- The memory start with the base case and recored every recurssion\\n\\'\\'\\'\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\\n\\'\\'\\'\\nIdea 3 : Dynamic programming\\n--> store the distinct ways in a dynamic table\\nclimb = [climb(0), climb(1), climb(2)=climb(0)+climb(1), climb(3)=climb(2)+climb(1),......climb(n)=climb(n-1)+climb(n-2)]\\ndp = [ 0, 1, 2, 3, 5, dp(i-1)+dp(i-2])]\\nreturn dp[n]\\n\\'\\'\\'\\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\\n\\n* Base case: First steir - we have just 1 option, Second stair - same, only one option.\\n* Starting from 3rd stair Iterate over stairs,\\nnumber of posiible stair options - is a sum of possible options for previous stair + pre-previous, since we can move by 2 stairs in one step.\\n\\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\\n\\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\\n\\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\\n\\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(2^n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        Map<Integer, Integer> memo = new HashMap<>();\\n        memo.put(1, 1);\\n        memo.put(2, 2);\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, Map<Integer, Integer> memo) {\\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        memo.put(n, climbStairs(n - 1, memo) + climbStairs(n - 2, memo));\\n        return memo.get(n);\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(n)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\n/**\\n * Question   : Climbing Stairs\\n * Complexity : Time: O(n) ; Space: O(1)\\n */\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int prev1 = 1;\\n        int prev2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int newValue = prev1 + prev2;\\n            prev1 = prev2;\\n            prev2 = newValue;\\n        }\\n\\n        return prev2;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\n# Top down - TLE\\ndef climbStairs1(self, n):\\n    if n == 1:\\n        return 1\\n    if n == 2:\\n        return 2\\n    return self.climbStairs(n-1)+self.climbStairs(n-2)\\n \\n# Bottom up, O(n) space\\ndef climbStairs2(self, n):\\n    if n == 1:\\n        return 1\\n    res = [0 for i in xrange(n)]\\n    res[0], res[1] = 1, 2\\n    for i in xrange(2, n):\\n        res[i] = res[i-1] + res[i-2]\\n    return res[-1]\\n\\n# Bottom up, constant space\\ndef climbStairs3(self, n):\\n    if n == 1:\\n        return 1\\n    a, b = 1, 2\\n    for i in xrange(2, n):\\n        tmp = b\\n        b = a+b\\n        a = tmp\\n    return b\\n    \\n# Top down + memorization (list)\\ndef climbStairs4(self, n):\\n    if n == 1:\\n        return 1\\n    dic = [-1 for i in xrange(n)]\\n    dic[0], dic[1] = 1, 2\\n    return self.helper(n-1, dic)\\n    \\ndef helper(self, n, dic):\\n    if dic[n] < 0:\\n        dic[n] = self.helper(n-1, dic)+self.helper(n-2, dic)\\n    return dic[n]\\n    \\n# Top down + memorization (dictionary)  \\ndef __init__(self):\\n    self.dic = {1:1, 2:2}\\n    \\ndef climbStairs(self, n):\\n    if n not in self.dic:\\n        self.dic[n] = self.climbStairs(n-1) + self.climbStairs(n-2)\\n    return self.dic[n]\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if (n <= 2) return n;\\n        int prev = 2, prev2 = 1, res;\\n        for (int i = 3; i <= n; i++) {\\n            res = prev + prev2;\\n            prev2 = prev;\\n            prev = res;\\n        }\\n        return res;\\n    }\\n};\\n\\n```\n```\\n```\n```\\n```\n```\\n/*\\nDP\\n\\ndp[i] represents the total number of different ways to take i steps\\nSo, we want to get dp[n].\\ndp[n] = dp[n-1] + dp[n-2] because we can either take 1 or 2 steps.\\n\\nWe have two base cases: dp[1] = 1 and dp[2] = 2 because\\nthere is one way to take 1 step and there are two ways to take 2 steps (1 step + 1 step OR 2 step)\\n*/\\nvar climbStairs = function(n) {\\n    let dp = new Array(n + 1);\\n    dp[1] = 1, dp[2] = 2;\\n    for (let i = 3; i <= n; i++) {\\n        dp[i] = dp[i-1] + dp[i-2];\\n    }\\n    return dp[n];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\nRecursion\\n\\nclimbStairs(n) returns the total number of different ways of taking n steps.\\nHence, climbStairs(n-1) + climbStairs(n-2) gives the result\\nsince we can either climb 1 or 2 steps\\n\\nFor more optimised solution, we use an Array to keep track of results that have already been computed\\n*/\\n\\nvar climbStairs = function(n, memo = new Array()) {\\n    if (n === 1) {\\n        return 1;\\n    }\\n    if (n === 2) {\\n        return 2;\\n    }\\n    if (memo[n] !== undefined) {\\n        return memo[n];\\n    }\\n    let res = climbStairs(n-1, memo) + climbStairs(n-2, memo);\\n    memo[n] = res;\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n         def climb(n):\\n             if n==1: #only one step option is availble\\n                 return 1\\n             if n ==2: # two options are possible : to take two 1-stpes or to only take one 2-steps\\n                 return 2\\n             return climb(n-1) + climb(n-2)\\n         return climb(n)\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo ={}\\n        memo[1] = 1\\n        memo[2] = 2\\n        \\n        def climb(n):\\n            if n in memo: # if the recurssion already done before first take a look-up in the look-up table\\n                return memo[n]\\n            else:   # Store the recurssion function in the look-up table and reuturn the stored look-up table function\\n                memo[n] =  climb(n-1) + climb(n-2)\\n                return memo[n]\\n        \\n        return climb(n)\\n```\n```\\ndef climb(n):\\n    #edge cases\\n    if n==0: return 0\\n    if n==1: return 1\\n    if n==2: return 2\\n    dp = [0]*(n+1) # considering zero steps we need n+1 places\\n    dp[1]= 1\\n    dp[2] = 2\\n    for i in range(3,n+1):\\n        dp[i] = dp[i-1] +dp[i-2]\\n    print(dp)\\n    return dp[n]\\n```\n```\\n```\n```\\n```\n```\\n\\nfun climbStairs(n: Int): Int {\\n      tailrec fun fib(i: Int, first: Int, second: Int): Int =\\n          if (i == n)\\n              first + second\\n          else\\n              fib(i + 1, first = second, second = first + second)\\n\\n      return fib(1, 0, 1)\\n}\\n\\n```\n```\\nTime complexity - O(n) - iterate through all n stairs\\nSpace complexity - O(n+1) - space for dp array\\n```\n```\\nfun climbStairs(n: Int): Int {\\n    val dp = IntArray(n + 1)\\n\\n    dp[0] = 1\\n    dp[1] = 1\\n\\n    for (i in 2..n) {\\n        dp[i] = dp[i - 1] + dp[i - 2]\\n    }\\n    return dp[n]\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of steps.\\n    //   - space: O(1), only constant space is used.\\n\\n    func climbStairs(_ n: Int) -> Int {\\n        if n == 0 || n == 1 { return 1 }\\n\\n        var first = 1\\n        var second = 1\\n        var third = 0\\n        \\n        for _ in 2...n {\\n            third = first + second\\n            first = second\\n            second = third\\n        }\\n\\n        return second\\n    }\\n\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\nfunction climbStairs($n) {\\n\\n    $arr = [NULL, 1, 2];\\n    for($i = 3; $i <= $n; $i++)\\n      $arr[$i] = $arr[$i-1] + $arr[$i-2];\\n\\n    return $arr[$n];\\n}\\n\\n```\n```\\nfunction climbStairs($n) {\\n            return round(pow((sqrt(5)+1)/2, $n+1) / sqrt(5));\\n    }\\n```\n```\\n```\n```\\n```\n```\\n\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n\\n```\n```\\nint climbStairs(int n){\\n    if(n==1) return 1;\\n    else if(n==2) return 2;\\n    else\\n    {\\n        int sum = 0,s1 = 1,s2 = 2;\\n        for(int i=3;i<=n;i++)\\n        {\\n            sum=s1+s2;\\n            s1 = s2;\\n            s2 = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567398,
                "title": "go-solution",
                "content": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc climbStairs(n int) int {\\n    a, b := 1, 1\\n    for ; n > 1; n-- {\\n        a, b = b, a + b\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283874,
                "title": "simple-dp-javascript-fibonacci-solution-js",
                "content": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar climbStairs = function(n) {\\n    if (n < 3) return n;\\n    let first = 1;\\n    let second = 2;\\n    for (let i = 3; i <= n; i++) {\\n        const current = first + second;\\n\\t\\t// Update first and second for next loop\\n        first = second;\\n        second = current;\\n    }\\n\\t// When loop fininshes, second is pointing to the result of the last index, which is the result of the whole function\\n    return second;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686525,
                "title": "c-0ms-100-faster-solution-using-dp",
                "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }\\n    \\npublic:\\n    int solve(int n,vector<int>dp)\\n    {\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i = 2;i < n; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        int c = solve(n+1,dp);\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2567823,
                "title": "java-100-fast-4-lines-code-climbing-stairs",
                "content": "**If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have any queries or any improvements please feel free to comment and share your views.**\\n\\nNOTE : its acutally a fibanacci pattern,\\n1 step = 1 stair, 2 step = 2 stair, 3 step = 3 stair , 4 step = 5 stair, 5 step = 8 stair , etc..\\nfibannaci pattern : 0,1,1,2,3,5,8,13...... \\n\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int a =0;\\n        int b=1;\\n        int sum =0;\\n        for(int i=0;i<n;i++){\\n            sum=a+b;\\n            a=b;\\n            b=sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25298,
                "title": "python-solution-beats-96-with-factorial",
                "content": "The basic idea is to get all possible permutations of fixed # of 1 and 2 \\n```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```\\n\\ne.g.\\n5 stairs in total, so we get:\\n1) 0 two, 5 ones  -> 1 permutation \\n2) 1 two, 3 ones  -> (3+1)!/(3!*1!) = 4 permutations\\n3) 2 twos, 1 one -> (2+1)!/(2!*1!) = 3 permutations\\n\\n1+4+3 = 8 in total\\n\\nThis is my first time to post...\\nHope you like my solution :)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import factorial\\ndef climbStairs(self, n):\\n    res= 0\\n    two = n//2\\n\\n    for i in range(two+1):\\n        t = i           # number of twos\\n        o = n-t*2       # number of ones\\n        res += factorial(t+o)/(factorial(t)*factorial(o))     # (two+one)!/ (two!*one!)\\n            \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25522,
                "title": "0ms-o-n-constant-space-java-solution",
                "content": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "solutionTags": [],
                "code": "      public int climbStairs(int n) {\\n        if(n==1||n==0)\\n            return n;\\n        int count1=1;\\n        int count2=1;\\n        \\n        \\n        for(int i=2; i<=n; i++){\\n            int temp = count2;\\n            count2 = temp+count1;\\n            count1 = temp;\\n        }\\n        return count2;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2903888,
                "title": "one-line-math-javascript-time-o-log-n-space-o-1",
                "content": "# Intuition\\nBinet\\'s Formula. Please upvote if you found something interesting :)\\n\\n![image.png](https://assets.leetcode.com/users/images/833a64f1-7fda-4783-a20e-a369dd73d258_1670839810.799308.png)\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n,s=Math.sqrt(5)) {\\n  return (Math.pow((1+s)/2,n+1)-Math.pow((1-s)/2,n+1))/s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903557,
                "title": "c-dynamic-programming-modified-version",
                "content": "**Please vote if my solution was helpful ;)**\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n# Optimized Solution -  O(1) space complexity\\n\\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\npublic class Solution \\n{\\n    public int ClimbStairs(int n) \\n    {\\n        if (n == 1) \\n        {\\n            return 1;\\n        }\\n        int first = 1;\\n        int second = 2;\\n        int output = second;\\n        for (int i = 3; i <= n; i++) \\n        {\\n            output = first + second;\\n            first = second;\\n            second = output;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212257,
                "title": "java-100-faster-and-cleaner-two-approaches",
                "content": "![image](https://assets.leetcode.com/users/images/d5df59c3-02b5-499d-95f1-69e6b350c940_1662187370.809809.jpeg)\\nHaving doubts? Ask me in the comment section. If you find this solution helpful please leave an upvote. Thanks for visiting! Happy Coding ; )\\n\\n# Bottom-up approach\\nthis is like a combination problem\\nIt is given you can can either climb `1` or `2` steps\\nMeaning, if you are at stair number `i`, from here you can only jump to stair `i+1` or stair `i+2`, now like this you can have multiple ways to reach your target stair.\\n\\nSo, consider these stairs as different levels of a game.\\nSee this picture, to reach round 1, you have two ways, like this at every point, you have two ways to reach the next round\\nIf your final round is `3`,total number of possible paths would be 5.\\n\\nIntuition: `total ways to reach from i to n` = `total ways to reach from i+1 to n` + `total ways to reach from i+2 to n`\\n\\nAlso, `use an array to store already calculated paths, to save time`.--> important!\\n\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\\n\\n# Top-down approach\\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n        x = n;\\n        return util(0);\\n    }\\n    private int util(int n) {\\n        if(n == x) {\\n            return 1;\\n        }\\n        if(n > x) {\\n            return 0;\\n        }\\n        if(data[n] == 0) {\\n            data[n] = util(n+1) + util(n+2);\\n        }\\n        return data[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int x = 0;\\n    int[] data = new int[46];\\n    public int climbStairs(int n) {\\n       if(n < 3) {\\n           return n;\\n       } \\n       if(data[n] == 0) {\\n           data[n] = climbStairs(n-1) + climbStairs(n-2);\\n       }\\n       return data[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599466,
                "title": "python-dp-solution-with-explanation",
                "content": "This problem is actually a problem of finding Fibonacci series. But realizing the connection between those two requires some exploration first.\\n\\nThe problem statement has one restriction: you can take 1 step or 2 steps. During the actual interview, you may be asked to solve a problem with different step parameter. The solution will change accordingly but your thinking process will be pretty much the same.\\n\\n* For a stair with no steps: we can assume that we can go to the top in 1 step. (Actually this is a good thing to confirm with the interviewer)\\n* For a stair with 1 step: we can assume that we can go to the top in 1 step. \\n\\nThese two will be in the base case `dp` mapping.\\n\\n* For a stair with two steps: there are 2 ways to get to the top. (take one step at a time, or just take 2 steps)\\n* For a stair with three steps: there are 3 ways to get to the top. (take one step at a time, or take 2 steps first followed by one step, or take 1 step followed by two steps)\\n\\t* Here you should start to make an important observation: for a stair with three steps, you can think of taking a stair of 2 steps followed by a stair of 1 step **OR** you think of taking a stair of 1 step followed by a stair of 2 steps. Since addition is commutative, we are okay with thinking in just one way.\\n\\t* In fact, you can start to make this observation even with the stair with two steps. That is, you have to take a stair of 1 step followed by another stair of 1 step. But sometimes, trival cases can be more confusing so it is more convenient to start observing at stair with 3 steps.\\n\\n* For a stair with four steps: you can first get to step 3 using the solution from stair of 3 steps and then you can make one jump *OR* you get to step 2 using the solution from stair of 2 steps and then making 2 jumps from there.\\n\\t* If your interviewer changes the jump parameter to 3 or 4, this observation will help you modify the algorithm.\\n\\n``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "``` python\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 2: # Trival base cases\\n            return 1\\n        i = 2\\n        dp = {\\n\\t\\t\\t\\t  0: 1,\\n\\t\\t\\t\\t  1: 1\\n\\t\\t\\t\\t } #Base case DP table\\n        while i < n+1:\\n            dp[i] = dp[i-1] + dp[i-2]\\n            i += 1\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386129,
                "title": "solution-in-python-3-beats-90-three-lines-fibonacci",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n    \\ta, b = 1, 1\\n    \\tfor i in range(n): a, b = b, a + b\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 25477,
                "title": "o-logn-c-python-solutions-using-matrix-power",
                "content": "**Updates**: Thank StefanPochmann for posting a concise Python implementation of this `O(logn)` idea using matrix power in the first answer. \\n \\n**Note**: If you feel unwilling to read the long codes, just take the idea with you. The codes are unnecessarily long due to the inconvenient handle of matrices. \\n\\nWell, a classic and interesting problem. The recursion is simply `f(n) = f(n - 1) + f(n - 2)`, which means that we can either climb to `n - 1` and then climb `1` step or climb to `n - 2` and then climb `2` steps. So this problem is actually asking for the `n`-th Fibonacci number. However, if you code it in such a recursive way, it will meet TLE due to the large number of overlapping sub-problems. \\n \\nThere are mainly two ways to solve this problem. The first one uses the above formula in a bottom-up manner and takes `O(n)` time. [This link][1] shares the `O(n)` solution in all the supported languages of the LeetCode OJ. You may take a look at it and appreciate the appetite of each language :-)\\n \\nNow I will focus on another solution, which takes `O(logn)` time. The idea is to use the matrix power. In fact, `[f(n), f(n - 1); f(n - 1), f(n - 2)] = [1, 1; 1, 0] ^ n` for `n >= 2`. And similar to the problem **Pow(x, n)**, the power of a matrix can be computed in `O(logn)` time.\\n  \\nThe C++ and Python codes are shown below. Note that the computation of the power of the matrix `[1, 1; 1, 0]` is hard-coded. Since it is a bit trickier to handle matrix multiplications, the codes become much longer. \\n \\n----------\\n**C++**\\n \\n\\n    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0};\\n            vector<int> ans = fibPower(fibs, n);\\n            return ans[0];\\n        }\\n    private:\\n        vector<int> matrixProd(vector<int>& l, vector<int>& r) {\\n            vector<int> ans(4, 0);\\n            ans[0] = l[0] * r[0] + l[1] * r[2];\\n            ans[1] = l[0] * r[1] + l[1] * r[3];\\n            ans[2] = l[2] * r[0] + l[3] * r[2];\\n            ans[3] = l[2] * r[1] + l[3] * r[3]; \\n            return ans;\\n        }\\n        vector<int> fibPower(vector<int>& fibs, int n){\\n    \\t\\tif (n == 1) return fibs;\\n            vector<int> half = fibPower(fibs, n / 2);\\n            vector<int> ans = matrixProd(half, half);\\n            if (n % 2 == 0) return ans;\\n            ans[1] = (ans[0] += ans[1]) - ans[1];\\n            ans[3] = (ans[2] += ans[3]) - ans[3];\\n            return ans;\\n        }\\n    };\\n\\n----------\\n**Python**\\n\\n    class Solution:\\n        # @param {integer} n\\n        # @return {integer}\\n        def climbStairs(self, n):\\n            if n  < 2:\\n                return n\\n            fibs = [1, 1, 1, 0]\\n            ans = self.fibsPower(fibs, n)\\n            return ans[0]\\n        \\n        def matrixProd(self, l, r):\\n            ans = [0] * 4\\n            ans[0] = l[0] * r[0] + l[1] * r[2]\\n            ans[1] = l[0] * r[1] + l[1] * r[3]\\n            ans[2] = l[2] * r[0] + l[3] * r[2]\\n            ans[3] = l[2] * r[1] + l[3] * r[3]\\n            return ans\\n            \\n        def fibsPower(self, fibs, n):\\n            if n == 1:\\n                return fibs\\n            half = self.fibsPower(fibs, n / 2)\\n            ans = self.matrixProd(half, half)\\n            if n % 2 == 0:\\n                return ans\\n            ans[0], ans[1], ans[2], ans[3] = ans[0] + ans[1], ans[0], ans[2] + ans[3], ans[2]\\n            return ans\\n\\n  [1]: https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n    \\t\\tif (n < 2) return n;\\n            vector<int> fibs = {1, 1, 1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2903478,
                "title": "python-c-it-s-fibonacci-explained-bonus-one-liners",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**.\\n****\\n\\n**Comment.** For every step, we are asked to calculate the sum of the number of ways for the previous two steps. That\\'s a Fibonacci sequence.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\\n\\n**C++ #1.** Explicit Fibonacci calculation.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\\n\\n**C++ #2.** A more compact version of it.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\\n\\n**C++ #3.** Almost a one-liner with a slightly different computational scheme.\\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python #1.** One-liner: recursion with memoization.\\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\\n\\n**Python #2.** One-liner: [**computation by rounding**](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int, a: int = 1, b: int = 0) -> int:\\n        for _ in range(n): a, b = a + b, a\\n        return a\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n) \\n    {\\n        int w1 = 1, w2 = 0, tmp;\\n        for (int i = 0; i < n; ++i)\\n            tmp = w1, w1 += w2, w2 = tmp;\\n        return w1;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(int n, int a = 1, int b = 0) \\n    {\\n        while (n--)\\n            a = a + b, b = a - b;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int climbStairs(long n, long a = 1, long b = 1) \\n    {\\n        while (n--) b = (a += b) - b;\\n        return b;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    @lru_cache(None)\\n    def climbStairs(self, n: int) -> int:\\n        return self.climbStairs(n-2) + self.climbStairs(n-1) if n > 1 else 1\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        return int(((1 + sqrt(5)) / 2) ** (n+1) / sqrt(5) + 0.5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789848,
                "title": "standard-decision-the-same-as-in-fibonacci-numbers-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used the same method that in the Fibonacci numbers task. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created the basic array which contain [1, 2] (this is the resulrs of the  first 2 case when the inputs are 1 and 2). \\nThan I am adding into the array new element, which is sum from the previus two numbers. We start to add new elements from the 3rd positions (becouse we already have the first two).  \\nThe last added num will be our needed result.\\n\\nRuntime: 95ms (beats 46.99%)\\nMemory: 42.1mb (beats 18.7%)\\n\\n\\n# Complexity\\n- complexity:  O(n)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    let noOfWays = [1, 2]\\n\\n    for(let i = 2; i < n; i++) {\\n        noOfWays[i] = noOfWays[i - 1] + noOfWays[i - 2]\\n    }\\n\\n    return noOfWays[n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545778,
                "title": "c-dp-recursive-explained-solution",
                "content": "```\\n// please upvote if understand.\\n\\n// recursive solution \\napproach -\\nsuppose if we are at nth stair and we have only two types of move 1 & 2, \\nthen we will get result easily from the previous steps result.\\nex. for 4, we will find the result for 3 stair, In how many ways I can take 3 stair and for three we find the result for 2 stair since 1st stair is our base case that we can take only one step for 1st stair.\\nwe recursively call for n-1th stairs and n-2th stairs and we will increase ways by 1 when we reach at ground or n will become 0.\\n\\n\\nclass Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }\\n        if(n < 0) return ;\\n        solve(n-1, ans);\\n        solve(n-2, ans);\\n    }\\n    int climbStairs(int n) {\\n        int ans = 0;\\n        solve(n, ans);\\n        return ans;\\n    }\\n};\\n\\n\\nDP solution - \\nif we break our recursive solution then previous two stairs ways summation will become our result.\\nbecause we can reach n th stair with possibly two moves either from n-1th stair or from n-2th stair, then using memoization we will use bottom up approach to find our result.\\nfor, n = 7\\nfirst two stair will be our base case \\nn = 1, only single way\\nn = 2, we have only two ways either take 1 1 step or single step of 2 steps.\\n\\n1  2  3  5  8  13  21\\nfor 7th stair we will watch in how many ways i have taken 6 stairs and 5th stair.\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 1 || n == 2){\\n            return n;\\n        }\\n        vector<int> v;\\n        v.push_back(1);\\n        v.push_back(2);\\n        for(int i = 2; i<n; i++){\\n            int num = v[i-1]+v[i-2];\\n            v.push_back(num);\\n        }\\n        return v.back();\\n    }\\n};\\n\\n// please upvote if understand.\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void solve(int n, int &ans){\\n        if(n == 0){\\n            ans += 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1799067,
                "title": "dp-based-c-solution-100-faster-with-0-ms",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```\\n***If you like solution, then please upvote it.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int climb(int dp[],int n)\\n    {\\n        \\n        \\n        if(n==0 || n==1 || n==2)\\n         return n;\\n        if(dp[n]>0)\\n            return dp[n];\\n       int output = climb(dp,n-1)+climb(dp,n-2);\\n        dp[n]=output;\\n        return output;\\n        \\n    }\\n    \\n    int climbStairs(int n) {\\n          if(n==0 || n==1 || n==2)\\n            return n;\\n     int *dp = new int[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=0;\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n     int x=climb(dp,n);\\n        delete [] dp;\\n        return x;\\n    }\\n    \\n    \\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329446,
                "title": "solution-swift-climbing-stairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func climbStairs(_ n: Int) -> Int {\\n        var zero = 1, one = 1, step = 2\\n        while step <= n {\\n            let temp = zero + one\\n            zero = one\\n            one = temp\\n            step += 1\\n        }\\n        return one\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two ways to climb to the top.\\n    /// 1. 1 step + 1 step\\n    /// 2. 2 steps\\n    func test0() {\\n        let value = solution.climbStairs(2)\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    /// There are three ways to climb to the top.\\n    /// 1. 1 step + 1 step + 1 step\\n    /// 2. 1 step + 2 steps\\n    /// 3. 2 steps + 1 step\\n    func test1() {\\n        let value = solution.climbStairs(3)\\n        XCTAssertEqual(value, 3)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861070,
                "title": "progression-of-python-solutions",
                "content": "Approach 1: Naive backtracking\\nintuition: to calculate how many ways to reach nth step, we add up how many ways to reach (n-1)th and (n-2)th step, since from (n-1)th step we take a 1-step to get to nth and similarly from (n-2)th step. \\n\\nN = the input\\ntime: recursion tree of depth N, branching factor of 2, runtime is recursion trees is typically O(branching_factor^depth), plugging in we get O(2^N) as our upper bound for runtime. \\nspace: O(N), b/c of depth of recursion stack \\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\\n\\nApproach 2: top down memoization\\nintuition: if we draw out the recursion tree we see a lot of repeated work. we are able to see this repeated work because nodes with the same parameters mean that the exact same subproblem is getting recomputed. Drawing out the recursion tree, we see many nodes with the same parameters:\\n\\n![image](https://assets.leetcode.com/users/images/f4e6230d-b0ce-4b07-ac35-6e29feeaeab7_1600885828.9303908.png)\\n\\nthis repeated work is a strong indicator that caching can help us here. We make use of python\\'s lru_cache to do caching for us here, based on what arguments are passed into the function. if we want to avoid usage of python\\'s lru cache, we can just as easily mimic this functionality using a dictionary (shown in approach 3).\\n\\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\\n\\nApproach 3: top down memoization (without lru cache)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\\n\\nAnalysis for approach 2 and 3:\\nN=input\\ntime: O(N). we get O(N) time complexity because each subproblem is only solved once, and then the subresult is cached for future use if we need it again. So analyzing time complexity here boils down to how many subproblems are there? Since our input is N, we have N subproblems (1, 2, ..., N-1, N). For analyzing time complexity of these types of problems, it is best to think in terms of what parameters define the subproblems, and use that intuition to figure out how many unique subproblems there are (how many unique parameter sets there are, since parameters define the subproblems).\\nspace: O(N). Space is O(N) because the recursion tree can still hit a depth of O(N) (1-step each time), and also the cache stores O(N) subproblems, so we get a total space complexity of O(N).\\n\\nApproach 4: Dynamic programming (not optimized)\\nintuition:\\n- from thinking about the top down solution, it is clear that in order to get the solution for climbStairs(i), we need the solutions for climbStairs(i-1) and climbStairs(i-2). At first we look at this top down in terms of the recursion tree, but we can instead flip our viewpoint and go from the bottom up. Since we know that at any point i, we need the subproblems for i-1 and i-2, let\\'s just go ahead and calculate the subproblems in order from bottom to top. So we start with the base cases and we build to the solution, instead of starting with the solution we want and figuring out which subproblems we need to solve. \\n\\nanalysis:\\ntime: O(N)\\nspace: O(N)\\n\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\\nApproach 5: optimized dynamic programming solution\\nintuition:\\n- notice that in our dp solution, we only require the subproblems of i-1 and i-2 in order to solve for ith subproblem. So why waste space and store the whole array when instead we could just store i-1th answer and i-2th answer? and then we just update correspondingly\\n\\ntime: O(N)\\nspace: O(1)\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Naive backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n```\n```\\nclass Solution:\\n    @lru_cache(maxsize=None)\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        if n == 0 or n == 1: return 1\\n        return self.climbStairs(n-1) + self.climbStairs(n-2)\\n        \\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Top down memoization: backtracking\\n        \\'\\'\\'\\n        \\n        cache={}\\n        def helper(n):\\n            if n in cache: return cache[n]\\n            if n == 0 or n == 1: return 1\\n            cache[n] = helper(n-1) + helper(n-2)\\n            return cache[n]\\n        \\n        return helper(n)\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Dynamic programming solution\\n        \\'\\'\\'\\n        stepsToReachIthPosn=[1] * (n+1)\\n        for i in range(2, n+1):\\n            stepsToReachIthPosn[i] = stepsToReachIthPosn[i-1]+stepsToReachIthPosn[i-2]\\n        return stepsToReachIthPosn[n]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        \\'\\'\\'\\n        Optimized dynamic programming solution\\n        \\'\\'\\'\\n        oneBack=1\\n        twoBack=1\\n        if n <= 1: return 1\\n        for i in range(2, n+1):\\n            cur=oneBack+twoBack\\n            twoBack=oneBack\\n            oneBack=cur\\n        return oneBack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 25643,
                "title": "o-log-n-solution-with-matrix-multiplication",
                "content": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "\\nI saw most solutions posted in discussion are DP with runtime O(n) and O(1) space which is accepted by OJ.\\n\\nThe only O(log(n)) solution so far is **lucastan's** using Binet's formula.\\n\\nThere actually is a matrix multiplication solution which also runs in O(log(n)). It basically calculates fibonacci numbers by power of matrix ((0, 1), (1, 1)) ^ (n-1).\\n\\n\\n\\n\\n\\n        public int climbStairs1(int n) {\\n        int[][] a = {{0, 1}, {1, 1}};\\n        int[][] m = pow(a, n - 1);\\n        return m[0][1] + m[1][1];\\n    }\\n\\n    private int[][] pow(int[][] a, int n) {\\n        int[][] ret = {{1, 0}, {0, 1}};\\n        while (n > 0) {\\n            if ((n & 1) == 1) {\\n                ret = multiply(ret, a);\\n            }\\n            n >>= 1;\\n            a = multiply(a, a);\\n        }\\n        return ret;\\n    }\\n\\n    private int[][] multiply(int[][] a, int[][] b) {\\n        int[][] c = new int[2][2];\\n        for (int i = 0; i < 2; i++) {\\n            for (int j = 0; j < 2; j++) {\\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\\n            }\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2853027,
                "title": "70-climbing-stairs-three-solutions",
                "content": "All the 3 solutions listed \\nIf you find my Solutions helpful then An upvote would be an O(N) Decision :)\\n\\n1. recursive sol \\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\\n\\n2. now tabulation\\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```\\n\\n3.memoization \\n```\\nclass Solution {\\n public int climbStairs(int n) {\\n     return memoDp(new int [n+1],n);\\n }\\n    int memoDp(int dp[],int n){ \\n        if(n==0 || n==1)\\n           return 1; \\n        if (dp[n]!=0)\\n            return dp[n];\\n        int step=memoDp(dp,n-1) +memoDp(dp,n-2);\\n        dp[n]=step;\\n        return dp[n];\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic int climbStairs(int n) {\\n if(n==0) // at 0 do nothing yes that\\'s also a step:)\\nreturn 1;\\nif(n==1) // when we are taking two steps back then from 2 to 0 is 1 way only \\nreturn 1;\\n return climbStairs(n-1) +climbStairs( n-2);   \\n }\\n}\\n```\n```\\nclass Solution {\\npublic int climbStairs(int n) {\\nif (n <= 1) {\\n return 1;\\n  }\\nint dp[]=new int [n+1];\\ndp[1]=1;\\ndp[2]=2;\\nfor(int i=3;i<=n;i++) {\\n   dp[i]=dp[i-1] + dp[i-2];\\n}\\nreturn dp[n];\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935980,
                "title": "javascript-all-approaches",
                "content": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```javascript\\n// recursive\\nvar climbStairs = function(n) {\\n   if (n <= 2) return n;\\n    return climbStairs(n - 2) + climbStairs(n - 1);\\n};\\n\\n// recursive top down (memoization)\\nconst climbStairs = (n) => {\\n    const memo = new Map();\\n    \\n    return climbStairsMemo(n, memo);\\n};\\n\\nconst climbStairsMemo = (n, memo) => {\\n    if(n <= 2) return n;\\n    if(!memo.has(n)) {\\n        memo.set(n, climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo))\\n    }\\n    \\n    return memo.get(n);\\n};\\n\\n// iterative bottom-up\\nconst climbStairs = (n) => {\\n    const memo = new Array(n + 1).fill(0);\\n    memo[0] = 0;\\n    memo[1] = 1;\\n    memo[2] = 2;\\n    for(let i = 3; i <= n; i++) {\\n        memo[i] = memo[i -1] + memo[i - 2];\\n    }\\n    \\n    return memo[n];\\n};\\n\\n// iterative space-saver\\nconst climbStairs = (n) => {\\n    if(n <= 2) return n;\\n    \\n    let prev2 = 1;\\n    let prev1 = 2;\\n    let curr = 0;\\n    for(let i = 3; i <= n; i++) {\\n        curr = prev2 + prev1;\\n        prev2 = prev1;\\n        prev1 = curr;\\n    }\\n    \\n    return curr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910653,
                "title": "java-dynamic-programming-solution-memoization-with-explanation",
                "content": "If n= 0 the answer is = 0\\nIf n= 1 the answer is = 1\\nIf n= 2 the answer is = 2\\nIf n= 3 the answer is = (n-1) + (n-2)\\nand so on\\n\\nIn every n we store we store the answer into memo array.\\n\\nIf we consider n = 5 then \\n![image](https://assets.leetcode.com/users/images/e2034166-f069-4973-ac7a-a0efa6f5923e_1648992757.1789904.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    public int climbStairs(int n) {\\n        memo = new int[n+1];\\n        for(int i =0;i<=n;i++) memo[i] = -1;\\n        return climbStairsRec(n);\\n    }\\n    \\n    public int climbStairsRec(int n){\\n        if(memo[n]==-1){\\n            int r;\\n            if(n==0 || n==1 || n==2) r = n;\\n            else{\\n                r = climbStairsRec(n-1) + climbStairsRec(n-2);\\n            }\\n            memo[n] = r;\\n        }\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668980,
                "title": "this-is-nothing-but-fibonacci-only-2-approachs",
                "content": "Approach 1 : **Memoization**\\n\\n```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Tc : O(N) Sc:O(N)**\\n\\n**Optimization**\\n*we can reduce the space complexity*\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Sc : O(1)**\\n\\n*If you like the post then please upvote it keeps me motivating \\uD83D\\uDE01\\uD83C\\uDF88*\\n**:) happy coding**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int step(int n,vector<int>&dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(dp[n] != -1)return dp[n];\\n        if(n>=2){\\n            return dp[n] = step(n-1,dp)+step(n-2,dp);\\n        }\\n            return dp[n] = step(n-1,dp)+0;\\n    }\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,-1);\\n        step(n,dp);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)return 1;\\n        else if(n==2)return 2;\\n        int ans = 0;\\n        int a = 1,b = 2;\\n        for(int i=3;i<=n;i++){\\n            ans = a+b;\\n            a = b;\\n            b = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998650,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```\\nfor more questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 2: return n\\n        c1, c2, c3 = 0, 1, 2\\n        while n > 2:\\n            c1, c2 = c2, c3\\n            c3 = c1 + c2\\n            n -= 1\\n        return c3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628462,
                "title": "python-js-java-go-c-o-n-dp-fibonacci-w-hint",
                "content": "Python/JS/Go/C++ O(n) DP // Fibonacci\\n\\n[My tutorial with DP problem solving framework to climbing stairs in English](https://medium.com/@cutesciuridae/dive-into-dp-take-climbing-stairs-for-example-4e3c1344e73c)\\n\\n[My tutorial with DP problem solving framework to climbing stairs in Chinese](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5climbing-stairs-%E7%82%BA%E4%BE%8B-45716ab7f555)\\n\\n[My tutorial with DP solution to climbing stairs in Chinese \\u4E2D\\u6587\\u5F71\\u7247\\u8B1B\\u89E3](https://youtu.be/SUeaLvIOScY)\\n\\n---\\n\\n**Abstract model & visualization**\\n\\n<img src=\"https://assets.leetcode.com/users/images/90e639e3-0c19-478d-acca-79c11eb77c0b_1641029846.7747073.png\" width=\"600\" height=\"400\" border=\"10\"/>\\n\\n\\n---\\n\\n**Hint**:\\n\\nThink of **fibanacci series** and **recursion**.\\n\\nClimbing Stairs can be described as following:\\n\\n**Method to level n** = **Method to level (n-1)** + **Method to level (n-2)**\\n\\nIt\\'s the same as the one of Fibonacci series\\n\\nf( n ) = f( n - 1 ) + f( n - 2 ) \\n\\nwith f( 0 ) = 1 and f( 1 ) = 1\\n\\n---\\n\\n```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\\n\\n---\\n\\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\\n\\n---\\n\\n**Implementation** by top-down DP in Python\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\\n\\n---\\n\\nShare similar implementation with python built-in decorator\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Java**:\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **JavaScript**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **Go**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\t\\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\n**Implementation** in **C++**\\n\\n<details>\\n\\t<summary> Click to show source code</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```\\n\\n</details>\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\n# Base case, aka stop condition:\\n\\ndp(0) = 1\\ndp(1) = 1\\n```\n```\\n# General cases:\\n\\ndp(n) = dp( n-1 ) + dp( n-2 ) for n >= 2\\n```\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        \\n        self.cache = {}\\n    \\n    def climbStairs(self, n: int) -> int:    \\n        \\n        if n in self.cache:\\n            return self.cache[n]\\n        \\n        if n == 0 or n == 1:\\n            return 1\\n        \\n        else:\\n            result = self.climbStairs(n-1) + self.climbStairs(n-2)\\n            self.cache[n] = result\\n            return result\\n```\n```\\nclass Solution:\\n\\n    def climbStairs(self, n: int) -> int:\\n    \\n        #--------------------------\\n        @cache\\n        def dp(i):\\n            \\n            # base case\\n            if i == 0 or i == 1:\\n                return 1\\n            \\n            # general cases\\n            return dp(i-1) + dp(i-2)\\n        \\n        # -------------------------\\n        return dp(n)\\n```\n```\\nclass Solution {\\n\\n    public Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo.put(0, 1);   // reach floor_0 by doing nothing\\n        climbMethodTo.put(1, 1);   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo.containsKey( n ) ){\\n            return climbMethodTo.get(n);\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo.put(n, climbStairs(n-1) + climbStairs(n-2) );\\n        \\n        return climbMethodTo.get(n);\\n    }\\n    \\n\\n    private HashMap<Integer, Integer> climbMethodTo = new HashMap<Integer, Integer>();\\n}\\n```\n```\\nvar climbStairs = function(n) {\\n  \\n    // create array of length n+1\\n    var memo = new Array(n+1);\\n    \\n    // Initialization on base case\\n    memo[0] = 1;\\n    memo[1] = 1;\\n    \\n    var climb = function( i ){\\n        \\n        if( i <= 1 ){\\n            // base case\\n            return memo[i];\\n            \\n        }else if( memo[i] != undefined ) {\\n            // climb(i) has been computed before, directly look-up memo\\n            return memo[i];\\n        }\\n        else{\\n            // general cases:\\n            memo[i] = (climb(i-1) + climb(i-2));\\n            return memo[i];\\n        }\\n    }\\n    \\n    return climb(n);\\n```\n```\\nfunc climbStairs(n int) int {\\n    \\n    // key: stair i\\n    // value: method count of climbing to stair i\\n    memo := make(map[int]int)\\n    \\n    // initialization on base case\\n    memo[0] = 1\\n    memo[1] = 1\\n    \\n    // define inenr function: climb\\n    var climb func(int)int \\n    climb = func(i int)int{\\n        \\n        if i <= 1 {\\n            // base case\\n            return memo[i]\\n            \\n        }else if val, exist := memo[i]; exist{\\n            \\n            // climb(i) has been computed before, directly look-up memo\\n            return val\\n            \\n        }else{\\n            // general cases\\n            memo[i] = climb(i-1) + climb(i-2)\\n            return memo[i]\\n        }\\n        \\n    }\\n    \\n    return climb( n )\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        \\n        // Initialization\\n        // Base case:\\n        climbMethodTo[0] = 1;   // reach floor_0 by doing nothing\\n        climbMethodTo[1] = 1;   // reach floor_1 with one step\\n    }\\n    \\n    int climbStairs(int n) {\\n        \\n        // look-up table, also known as memoization\\n        if( climbMethodTo[n] ){\\n            return climbMethodTo[n];\\n        }\\n        \\n        // General cases\\n        // reach floor n from floor (n-1) as well as floor (n-2)\\n        climbMethodTo[n] = climbStairs(n-1) + climbStairs(n-2);\\n        \\n        return climbMethodTo[n];\\n    }\\n    \\nprivate:\\n    map<int, int> climbMethodTo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207575,
                "title": "javascript-top-down-bottom-up-5-different-solutions-3-faster-than-100-o-n",
                "content": "recursive solution - stepping down\\n*** this unfortunately times out ***\\n```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\\n\\n\\nrecursive solution with memoization - stepping down\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\\n\\n\\niterative solution - stepping up\\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\\n\\nrecursive solution - stepping up\\n*** this unfortunately times out ***\\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\\n\\n\\nrecursive solution with memoization - stepping up\\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst climbStairs  = n => {\\n    if (n <= 3) return n;\\n    return climbStairs(n-1) + climbStairs(n-2);\\n}\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(n, cache);\\n};\\n\\nconst climb = (n, cache) => {\\n    if (n in cache) {\\n        return cache[n];\\n    } else {\\n        if (n <= 3) return n;\\n        else {\\n            cache[n] = climb(n-1, cache) + climb(n-2, cache);\\n            return cache[n];\\n        }\\n    }\\n};\\n```\n```\\nconst climbStairs = n => {\\n    // we know that 3 steps returns 3\\n    if (n <= 3) return n;\\n    let arr = [1,2,3];\\n    for (let i = 3; i < n; i++) {\\n        arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr.pop();\\n}\\n```\n```\\nconst climbStairs = n => {\\n    return climb(0, n);\\n}\\n    \\nconst climb = (step, destination) => {\\n    if (step > destination) return 0;\\n    if (step === destination) return 1;\\n    return climb(step+1, destination) + climb(step+2, destination);\\n};\\n```\n```\\nconst climbStairs = n => {\\n    const cache = {};\\n    return climb(0, n, cache);\\n};\\n\\nconst climb = (step, destination, cache) => {\\n    if (step in cache) {\\n        return cache[step];\\n    } else {\\n        if (step > destination) return 0;\\n        if (step === destination) return 1;\\n        else {\\n            cache[step] = \\n                climb(step+1, destination, cache) + \\n                climb(step+2, destination, cache);\\n            return cache[step];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25292,
                "title": "python-solution-in-one-line",
                "content": "Since we know that the answer should be Fibonacci Number, we can directly calculate the Fibonacci Number with mathematical expressions.\\n```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```\\nDone.^^",
                "solutionTags": [],
                "code": "```\\nreturn int(round(1/5**0.5 * (((1+5**0.5)/2.0)**(n+1) - ((1-5**0.5)/2.0)**(n+1))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25481,
                "title": "1ms-java-solution-easy-to-understand-with-dp",
                "content": "public class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }\\n        if(memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        result = climbStairs(n-1) + climbStairs(n-2);\\n        memo.put(n,result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    \\n    int result;\\n    HashMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\\n    \\n    public int climbStairs(int n) {\\n        if(n < 2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 25560,
                "title": "1-liner-formula",
                "content": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "solutionTags": [
                    "Python"
                ],
                "code": "I didn't see anyone using [this formula](https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding) yet, so here it is (in Python).\\n\\n    def climbStairs(self, n):\\n        return int(((1 + 5**.5) / 2) ** -~n / 5**.5 + .5)\\n\\n(No, I would not be able to recall that formula in an interview. There I would do [my normal solution](https://leetcode.com/discuss/42044/3-4-short-lines-in-every-language) or maybe the [matrix solution](https://leetcode.com/discuss/45797/o-logn-c-python-solutions-using-matrix-power?show=46059#a46059), which is not that hard to remember)\\n\\nIf you're wondering about `-~n`, that's just short for `(n+1)`. Apparently I was in golfing mode.",
                "codeTag": "Python3"
            },
            {
                "id": 25549,
                "title": "simplest-answer-in-c",
                "content": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        int a = 1, b = 1;\\n        for (int i = 1;i < n;i++) {\\n            b += a;\\n            a = b - a;\\n        }\\n        return b;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3418402,
                "title": "beats-100-easiest-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n            n+=2;\\n            int fib[n];\\n            fib[0]=0;fib[1]=1;\\n\\n            for(int i=2;i<n;i++){\\n                fib[i]=fib[i-1]+fib[i-2];\\n            }\\n            \\n            return fib[n-1];\\n    }\\n};\\nDO UPVOTE if you Like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051988,
                "title": "super-fast-0ms-beat-100-and-super-small-space-complexity-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nList the all possible ways for the step from 1 to 6;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can see that for the step 1 stair --one way;the step 2 stairs, there are 2ways;step 3, 3ways; step 4, 5ways; step 5, 8ways; and step 6, 13ways.\\n\\nWhat do u find?\\n\\n1, 2, 3, 5, 8, 13......\\n\\nIt is the Fibonacci sequence!\\nAnd , the answer is easy...\\n\\n\\nThe first attempt i use recursive, unfortunately, it waste a lot of time!!\\n\\nWe only need 3 ints, which are first, second, and third.\\nAnd just use the nature of Fibonacci, the third number equals the sum of the first and the second number. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n<2)\\n        return 1;\\n        int first=1;\\n        int second=1;\\n        int third=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            third=first+second;\\n            first=second;\\n            second=third;\\n        }\\n        return third;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354896,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n        if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n        // Create an array to store the answer...\\n        int[] ans = new int[n];\\n        for(int i=1;i<=n;i++) {\\n            if(i==1) {\\n                ans[0]=1;\\n            }\\n            if(i==2) {\\n                ans[1]=2;\\n            }\\n            // There are two options...\\n            // 1.we came from (i-1)th step\\n            // 2.we came from (i-2)th step\\n            if(i>2) {\\n                ans[i-1] = ans[i-2] + ans[i-3];\\n            }\\n        }\\n        return ans[n-1];    // Return the answer...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int pre = 1;\\n        int curr = 1;\\n        int temp = 0;\\n        for (int i = 1; i < n; i++) {\\n            temp = curr;\\n            curr = curr + pre;\\n            pre = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```\n```\\nvar climbStairs = function(n) {\\n    if(n==1) return 1;      // If n == 1, then there is only way to climb the stair...\\n    if(n==2) return 2;      //If n == 2, then there is only way to climb the stair...\\n    // Create an array to store the answer...\\n    let ans = [n];\\n    for(let i=1;i<=n;i++) {\\n        if(i==1) {\\n            ans[0]=1;\\n        }\\n        if(i==2) {\\n            ans[1]=2;\\n        }\\n        // There are two options when we reach ith step:\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        if(i>2) {\\n            ans[i-1] = ans[i-2] + ans[i-3];\\n        }\\n    }\\n    return ans[n-1];    // Return the answer...\\n};\\n```\n```\\nint climbStairs(int n){\\n    if(n==0 || n==1 || n==2)\\n    return n;\\n    // Create an array to store the answer...\\n    int ans[50];\\n    ans[0]=0;\\n    ans[1]=1;\\n    ans[2]=2;\\n    for(int i=3; i<=n; i++) {\\n        // There are two options...\\n        // 1.we came from (i-1)th step\\n        // 2.we came from (i-2)th step\\n        ans[i] = ans[i-1] + ans[i-2];\\n    }\\n    return ans[n];      // Return the answer...\\n}\\n```\n```\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        if n<=2:\\n            return n\\n        # create the array to store the answer...\\n        ans = [0]*(n+1)\\n        ans[1] = 1\\n        ans[2] = 2\\n        for i in range(3,n+1):\\n            # There are two options when we reach ith step:\\n            # 1.we came from (i-1)th step\\n            # 2.we came from (i-2)th step\\n            ans[i] = ans[i-1]+ans[i-2]\\n        return ans[n]       # Return the answer...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275058,
                "title": "c-representation-solution-with-comments-space-optimisation",
                "content": "***\\n***Please Upvote if it Helps......***\\n***\\n***\\n***Solution :***\\n***\\n***How to Identify a DP problem?***\\n\\nWhen we see a problem, it is very important to identify it as a dynamic programming problem. Generally (but not limited to) if the problem statement asks for the following:\\n\\n* Count the total number of ways\\n* Given multiple ways of doing a task, which way will give the minimum or the maximum output.\\n\\nWe can try to apply recursion. Once we get the recursive solution, we can go ahead to convert it to a dynamic programming one.\\n***\\n***Steps To Solve The Problem After Identification***\\n***\\nOnce the problem has been identified, the following three steps comes handy in solving the problem:\\n\\n* Try to represent the problem in terms of indexes.\\n* Try all possible choices/ways at every index according to the problem statement.\\n* If the question states\\n    * Count all the ways \\u2013 return sum of all choices/ways.\\n    * Find maximum/minimum- return the choice/way with maximum/minimum output.\\n***\\n***Using these steps to solve the problem \\u201CClimbing Stairs\\u201D***\\n\\nStep 1: We will assume n stairs as indexes from 0 to N.\\n![image](https://assets.leetcode.com/users/images/0e2588c0-6c6e-4fc3-9e0a-a65e3daadbdf_1657686866.9534023.png)\\n\\n\\nStep 2: At a single time, we have 2 choices: Jump one step or jump two steps. We will try both of these options at every index.\\n\\n![image](https://assets.leetcode.com/users/images/97b90fad-e603-403a-9865-df049c300187_1657686879.0325246.png)\\n\\nStep 3: As the problem statement asks to count the total number of distinct ways, we will return the sum of all the choices in our recursive function.\\n\\nThe base case will be when we want to go to the 0th stair, then we have only one option.\\n\\nThe basic pseudo-code for the problem will be given as:\\n\\n![image](https://assets.leetcode.com/users/images/9dca5aef-77eb-421f-b492-b9a24e356710_1657686889.5174844.png)\\n\\nThere will be one more edge-case when n=1, if we call f(n-2) we will reach stair numbered -1 which is not defined, therefore we add an extra test case to return 1 ( the only way) when n=1.\\n![image](https://assets.leetcode.com/users/images/6c70d64c-8a25-44f8-a201-58042f4801be_1657686900.0129309.png)\\n\\n***\\n***\\n\\n***Steps for the Tabulation approach.***\\n***\\n* Declare a dp[] array of size n+1.\\n* First initialize the base condition values, i.e i=0 and i=1 of the dp array as 1.\\n* Set an iterative loop which traverses the array( from index 2 to n) and for every index set its value as dp[i-1] + dp[i-2]. \\n***\\n***\\n***C++ Code***\\n***\\n```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n**Reason:** We are running a simple iterative loop\\n\\n***Space Complexity: O(N)***\\n\\n**Reason:** We are using an external array of size \\u2018n+1\\u2019.\\n***\\n***\\n***Part 3: Space Optimization***\\n\\nIf we closely look the relation,\\n\\n***dp[i] =  dp[i-1] + dp[i-2]***\\n\\nwe see that for any i, we do need only the last two values in the array. So is there a need to maintain a whole array for it? \\n\\nThe answer is \\u2018No\\u2019. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now understand the following illustration.\\n![image](https://assets.leetcode.com/users/images/cd60c07a-aa40-4d39-b069-de5538f334fe_1657687029.7320123.png)\\n\\n\\n* Each iteration\\u2019s cur_i and prev becomes the next iteration\\u2019s prev and prev2 respectively.\\n* Therefore after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. \\n* After the iterative loop has ended we can simply return prev as our answer.\\n***\\n***\\n\\n***C++ Code***\\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using any extra space.\\n***\\n***Please Upvote if it Helps......***\\n***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n  vector<int> dp(n+1,-1);\\n  \\n  dp[0]= 1;\\n  dp[1]= 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      dp[i] = dp[i-1]+ dp[i-2];\\n  }\\n  return dp[n];\\n  \\n```\n```\\n  int prev2 = 1;\\n  int prev = 1;\\n  \\n  for(int i=2; i<=n; i++){\\n      int cur_i = prev2+ prev;\\n      prev2 = prev;\\n      prev= cur_i;\\n  }\\n  return prev;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1504269,
                "title": "java-easy-solution-and-runtime-0-ms-faster-than-100-used-fibonacci-series",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466915,
                "title": "two-simple-c-solutions-using-top-down-and-bottom-up-dp",
                "content": "```\\n// solution 1\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }\\n    int climb(int n, vector<int> &dp){\\n        \\n        if(dp[n] > 0) return dp[n];\\n        return dp[n] = climb(n-1, dp) + climb(n-2, dp);\\n    }\\n};\\n\\n\\n\\n// solution 2\\nclass Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        \\n        if(n<=2) return n;\\n        vector<int> dp(n+1,0);\\n        \\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for(int i = 3; i<=n; i++){\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:      \\n    int climbStairs(int n) {\\n        if(n <= 2) return n;\\n        vector<int> dp(n+1);\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        return climb(n, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1098633,
                "title": "climbing-stairs-all-three-approaches-recursion-top-down-memoization-bottom-up-tabulation",
                "content": "**In this post, I am going to talk about all the three approaches involved to solve this problem**\\n\\n#1 Recursion\\n\\nThis solution is the most simplest one among three but yes it will give TLE due to its fairly exponential time complexity.... Not a suggested way but its surely the first step and the basic step to move towards DP i.e. optimised solution...\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n#2 Memoization (Top-Down)\\n\\nAn optimisation to the recursive approach... In this recursion is still present but here what we do is store the overlapping subproblems results in hand... as the main problem with recursive approach was that we were solving many sub problems repeatedly.... and so memoization comes into play... In this we store our results in a dp table(here its 1-D) and that would bring reduce the complexity O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\\n\\n#3 Tabulation (Bottom-up)\\n\\nSame as memoization but here iteratively result is evaluated and this method is preferred over memoization due to various stack calls in Top down.... \\n\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //  Recursive\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    static int helper(int n,int *dp){\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n]=helper(n-1,dp) + helper(n-2,dp);\\n    }\\n    \\n    int climbStairs(int n) {\\n        //  Memoized\\n        \\n        int dp[n+1];\\n        for(int i=0;i<=n;i++){\\n            dp[i]=-1;\\n        }\\n        return helper(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        //DP\\n        if(n==0){\\n            return 1;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 2;\\n        }\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        \\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353923,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```\\n\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Climbing Stairs.\\nMemory Usage: 32.8 MB, less than 5.26% of Java online submissions for Climbing Stairs.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        \\n        int n2 = 1, n1 = 2, all = 0;\\n        \\n        for(int i = 2; i < n; i++){\\n            all = n2 + n1;\\n            n2 = n1;\\n            n1 = all;\\n        }\\n        return all;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300652,
                "title": "javascript",
                "content": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    let arr = [0,1,2,3];\\n    for(let i = 4; i <= n; i++){\\n        arr[i] = arr[ i - 1] + arr[i - 2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25646,
                "title": "my-solution-considering-odd-and-even",
                "content": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "solutionTags": [],
                "code": "    public int climbStairs(int n){\\n\\t\\tif(n <= 0) return 0;\\n\\t\\tint [] stairs = {1,2};\\n\\t\\tfor(int i = 2;i < n;i++){\\n\\t\\t\\tstairs[i%2] = stairs[0]+stairs[1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn n % 2 == 0 ? stairs[1]:stairs[0];\\n\\t}\\n\\n\\n\\nconsiding f(n) = f(n-1)+f(n-2),that is: \\n\\n\\n----------\\n\\n\\nf(1) = 1\\n\\n\\n----------\\nf(2) = 2\\n\\n\\n----------\\n\\n\\nf(3) = f(2)+f(1)\\n\\n\\n----------\\n\\n\\nf(4) = f(3)+f(2)\\n\\n\\n----------\\n\\n\\n...\\n\\n\\n----------\\n\\n\\nand the values before f(2) will never use again,so we can use an array with two elements to store the tmp values",
                "codeTag": "Unknown"
            },
            {
                "id": 25608,
                "title": "my-divide-and-conquer-way-to-solve-this-problem-java",
                "content": "Hi guys, here is my solution:\\n\\n    public class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }\\n            \\n            if(n == 1){\\n                return 1;\\n            }\\n            if(n == 2){\\n                return 2;\\n            }\\n            if(n == 3){\\n                return 3;\\n            }\\n            \\n            return climbStairs(n/2)*climbStairs(n - n/2) + climbStairs(n/2 - 1) * climbStairs(n - n/2 - 1);\\n            \\n        }\\n    }\\n\\nEach time we cut n stairs in the middle:\\n\\ntotal case(n) = total case(head half of n) * total case(tail half of n) + additional case.\\n\\nAbout the additional case: The border on head half and tail half contribute an \\'1\\', then we form a \\'2\\' in the middle. So total case of additional case should = total case(head half - 1) * total case(tail half -1).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public int climbStairs(int n) {\\n            //bottom case\\n            if(n < 1){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3956051,
                "title": "java-runtime-0-ms-beats-100",
                "content": "# Intuition\\nMy initial approach to solving this problem involves considering the fact that reaching the \\'n\\'th step can be achieved by either taking a single step from the \\'n-1\\'th step or taking two steps from the \\'n-2\\'th step. Therefore, the number of distinct ways to reach the \\'n\\'th step is the sum of the ways to reach the \\'n-1\\'th and \\'n-2\\'th steps.\\n\\n# Approach\\nI will use a recursive approach with memoization to calculate the total number of distinct ways to climb the staircase of \\'n\\' steps. I\\'ll create a memoization array to store the results for already calculated steps, which will help avoid redundant calculations. Starting from the base cases where \\'n\\' is 1 or 2, I\\'ll recursively calculate the number of ways to reach the \\'n\\' step by summing the ways from \\'n-1\\' and \\'n-2\\' steps. I\\'ll store the results in the memoization array and return the final result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n  The algorithm calculates each distinct step\\'s number of ways only once due to memoization, so the time complexity is linear, where \\'n\\' is the input value.\\n\\n- Space complexity: O(n)\\n  The algorithm uses extra space for the memoization array, which stores the number of ways for each step.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return calculateWays(n, memo);\\n    }\\n    \\n    private int calculateWays(int n, int[] memo) {\\n        if (n == 1 || n == 2) {\\n            return n;\\n        }\\n        \\n        if (memo[n] != 0) {\\n            return memo[n];\\n        }\\n        \\n        memo[n] = calculateWays(n - 1, memo) + calculateWays(n - 2, memo);\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831506,
                "title": "easiest-and-optimized-code-explained-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- After observation one can realize that this nothis just a fibbonacci sequence.\\n- We can also implement this in simple manner. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        int res;\\n        \\n        if(n<=3)return n;\\n        int prev=3;\\n        int uska_prev = 2;\\n        \\n        for(int i=4;i<=n;i++){\\n            \\n            res = prev + uska_prev;\\n            uska_prev = prev;\\n            prev = res;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675671,
                "title": "beginner-friendly-detailed-explanation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuitively, the code utilizes a dynamic programming approach to solve the problem. It keeps track of the counts for the current step and the next step, updating them iteratively based on the counts of the previous steps. By the end of the loop, the value of b represents the total number of distinct ways to reach the top of the staircase with n steps.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code is implementing a method climbStairs in the Solution class. This method calculates the number of distinct ways to climb to the top of a staircase with n steps, where each time you can either climb 1 or 2 steps at a time.\\n\\nHere\\'s how the code works:\\n\\nThe method initializes two variables, a and b, to keep track of the number of distinct ways to reach the current step and the next step, respectively. Initially, a is set to 0 and b is set to 1.\\nUsing a for loop, the code iterates n times, representing each step in the staircase.\\nIn each iteration, the code updates a and b by swapping their values and assigning a + b to b. This step effectively calculates the number of distinct ways to reach the current step (a) and updates the number of distinct ways to reach the next step (b) based on the previous steps\\' counts.\\nAfter the loop finishes executing n times, the method returns the value of b, which represents the number of distinct ways to reach the top of the staircase with n steps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the number of steps in the staircase. This is because the code iterates n times in the for loop.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) since the code only uses a constant amount of additional space to store the variables a and b, regardless of the input size.\\n# Code\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a, b = 0, 1\\n        for i in range(n):\\n\\t        a, b = b, a + b         \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085426,
                "title": "rust-0ms-100-faster-by-cheating-with-your-friendly-lut",
                "content": "A long time ago, my mechanical engineering teacher told me a story about how his team manage to make one of the fastest robot-arm firmware by pre-computing a table of square root values. \\n\\nThis problem is a typical case were we can apply this cheat. We don\\'t have to use the most sofisticated algorithm to compute every value of N, since we just have to compute it once :) .\\n\\n\\n# Code\\n```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```rust\\nconst LUT: &[i32] = &[\\n    0, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946,\\n    17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578,\\n    5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296,\\n    433494437, 701408733, 1134903170, 1836311903,\\n];\\n\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        return LUT[n as usize];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798735,
                "title": "climbing-stairs-solution-recursion-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n    //Recursion\\n        //if(n==1)return 1;\\n        //if(n==0)return 1;                   // stand at 0th stair\\n          //return climbStairs(n-1) + climbStairs(n-2);\\n        \\n    //Memoization\\n        //  int dp[] = new int[n+1];\\n        //  for(int i=0; i<n+1; i++)\\n        //      dp[i]=-1;\\n        // return memo(n,dp);\\n    //Dp\\n        return dp(n);\\n    }\\n    public int memo(int n, int dp[]){\\n        if(n==1)return 1;\\n        if(n==0)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        \\n        dp[n] = memo(n-1,dp) + memo(n-2,dp);\\n        return dp[n];\\n    }\\n    public int dp(int n){\\n       int dp[] = new int[n+1]; \\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        for(int i=2; i<n+1; i++)\\n            dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703084,
                "title": "climbing-stairs-using-fibonacci",
                "content": "**DON\\'T FORGOT TO UPVOTE**\\nIt is basically fibonacci.\\nFor 0 stair : 1 way\\nFor 1 stair : 1 way\\nFor 2 stairs : 2 ways ((1+1), (2))\\nFor 3 stairs : 3 ways ((1+1+1), (1+2), (2+1))\\nFor 4 stairs : 5 ways ((1+1+1+1), (1+1+2), (2+1+1), (1+2+1), (2+2))\\nFor 5 stairs : 8 ways ((1+1+1+1+1), (1+1+1+2), (2+1+1+1), (1+2+1+1), (1+1+2+1), (2+2+1), (2+1+2), (1+2+2))\\n...\\n1 , 1, 2, 3, 5, 8, 13, 21, ...\\n\\nBottom-Up Approach:\\n```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\\nTop-Down Approach:\\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint climbStairs(int n) {\\n     if(n <= 1) {\\n\\t\\t return 1;\\n     }\\n     int arr[n];\\n     arr[0] = arr[1] = 1;\\n     for(int i = 2; i < n; i++) {\\n\\t\\t arr[i] = arr[i-1] + arr[i-2];\\n     }\\n\\t return arr[n-1] + arr[n-2];\\n }\\n```\n```\\nint solve(int n, vector<int>& dp) {\\n\\tif(n <= 1) return 1;\\n    if(dp[n] != -1) return dp[n];\\n    return dp[n] = solve(n-1, dp) + solve(n-2, dp);\\n}\\nint climbStairs(int n) {   \\n    if(n == 1) return 1;\\n    vector<int> dp(n+1, -1);\\n    return solve(n, dp);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1851337,
                "title": "it-s-literally-the-fibonacci-numbers",
                "content": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "[Leetcode](https://leetcode.com/) [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/).\\n\\nIn fact, it\\'s a [Fibonacci Numbers](https://en.wikipedia.org/wiki/Fibonacci_number), the sequence is as follows:\\n\\n$1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, \\\\dots$\\n\\nTo find out the $nth$ **Fibonacci Numbers**, we can use such algorithms: [9 Fibonacci Algorithms | The Most Complete Solutions | Image Explanation](https://leetcode.com/problems/fibonacci-number/solutions/1854398/9-fibonacci-algorithms-the-most-complete-solutions-image-explanation/)\\n\\nor visit the discuss:\\n[Leetcode Discuss: Fibonacci Numbers](https://leetcode.com/discuss/study-guide/1854405/9-fibonacci-algorithms-the-most-complete-solutions-all-in-one-easy-to-understand) .\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1504370,
                "title": "python-3-solution-comparison-3-approaches",
                "content": "# Solution #1\\nClassical DP solution\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\\nThe first solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #2\\nClassical DP solution without array\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\\nThe second solution is faster than **60.32%** of others and requires memory of less than **42.71%**.\\n# Solution #3\\nRecursion solution with memorization by using a dictionary mem\\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```\\nThe third solution is faster than **95.02%** of others and requires memory of less than **90.49%**.\\n# Conclusion:\\n- The first and second solutions don\\'t differ either in speed or execution time, therefore it makes no sense to avoid using the classic dp array.\\n- Tip: If it\\'s important for you to overtake your rivals, then you can set as many initial values as possible, which will significantly speed up the execution. \\nFor example,` dp = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...]`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        dp = [1,1] + [0]*(n-1)\\n        for i in range(2, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1:\\n            return n\\n        p = pp = 1\\n        for i in range(2, n+1):\\n            res = p + pp\\n            pp = p\\n            p = res\\n        return res\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n: int, mem={1:1,2:2,3:3}) -> int:\\n        if n in mem:\\n            return mem[n]\\n        mem[n] = self.climbStairs(n-1, mem) + self.climbStairs(n-2, mem)\\n        return mem[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327557,
                "title": "rust-one-liner-fibbonacci-numbers",
                "content": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn climb_stairs(n: i32) -> i32 {\\n        (0..n)\\n            .fold((1, 0), |(res, prev), _| (res + prev, res))\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791308,
                "title": "javascript-solution-70",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 64.59% of JavaScript online submissions for Climbing Stairs.**\\n\\n**Memory Usage: 36.4 MB, less than 34.63% of JavaScript online submissions for Climbing Stairs.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet climbStairs = function(n) {\\n    let arr=[];\\n    arr[1]=1;\\n    arr[2]=2;\\n    for(let i=3;i<=n;i++){\\n        arr[i]=arr[i-1]+arr[i-2];\\n    }\\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25350,
                "title": "both-bottom-up-and-top-down-dynamic-programming-style-java-code-good-for-learners",
                "content": "\\nThe bottom-up approach is provided as following. \\nThe idea is that we consider from `stair level 0` and `stair level 1`, which are the base cases. And we use an array N to record the number of distinct ways for each level. \\nObviously, for `level 0` and `level 1`, the number of distinct ways are 1. After that, for each level `i` where `i` is greater than `0` and `1`, we have 2 possible way to step on it: The first one is to go from  `level i - 1` (i.e. climb 1 steps); the second one is to go from `level i - 2` (i.e. climb 2 steps). Thus for each level `i` where `i` is greater than  `1`, `N[i] = N[i - 1] + N[i - 2]`.\\nAnd hence, `N[n]` stores the total number of distinct ways to climb `n` stairs after the `for` loop.  \\n```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\\n\\nThe top down approach is showed as following. \\nIn the top down approach, we actually consider from the top, which is `stair level n`. And the recursive equation is still `N[i] = N[i - 1] + N[i - 2]`. Hence we get the so-called optimal substructures in `Dynamic programming`. Thus, by recursively calculate each level from `n` to base case, which is `0` and `1` and memorize the intermediate, we can still get the total number of distinct ways to go to stair `n`. \\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nbottom-up approach\\n*/\\n\\npublic int climbStairs(int n){\\n    if (n == 0){\\n        return 1;\\n    }\\n    else{\\n        int[] N = new int[n + 1];\\n        N[0] = 1;\\n        N[1] = 1;\\n        for (int i = 2; i <= n; i ++){\\n            N[i] = N [ i - 1] + N[i - 2];\\n        }\\n        return N[n];\\n    }\\n}\\n```\n```\\n/*\\ntop-down approach\\n*/\\n\\n\\npublic int climbStairs(int n) {\\n    int[] N = new int[n];\\n    for (int i = 0; i < n; i++){\\n        N[i] = -1;\\n    }\\n    \\n    return topdownclimbStairs(n, N);\\n}\\n\\nprivate int topdownclimbStairs(int n, int[] N){\\n    if (n == 0 || n == 1){\\n        return 1;\\n    }\\n    \\n    if (N[n - 1] >= 0){\\n        return N[n - 1];\\n    }\\n\\n    else {\\n        N[n - 1] = topdownclimbStairs(n-1, N) + topdownclimbStairs(n - 2, N);\\n        return N[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 25624,
                "title": "this-is-essentially-a-fibonacci-sequence",
                "content": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "solutionTags": [],
                "code": "Solution to this problem makes a Fibonacci sequence. We can understand it better if we start from the end. To reach to Step N, you can either reach to step N-1 and take 1 step from there or take 2 step from N - 2. \\nTherefore it can be summarized as:\\nF(N) = F(N-1) + F(N-2)\\n\\nOnce you have recognized the pattern, it is very easy to write the code:\\n\\n    class Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def climbStairs(self, n):\\n        if n < 1:\\n            return 0\\n        prev = 1\\n        curr = 1\\n        while n > 1:\\n            prev, curr = curr, prev + curr\\n            n -=1\\n        return curr",
                "codeTag": "Java"
            },
            {
                "id": 3436390,
                "title": "fibo-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        if (n == 1) {\\n            return n;\\n        }\\n\\n        int n1 = 1;\\n        int n2 = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            int next = n1;\\n            n1 = n2;\\n            n2 = next + n2;\\n        }\\n\\n        return n2;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252887,
                "title": "explanation-of-the-idea-of-dp-o-n-time-space-c",
                "content": "\\n# Climbing Stairs problem\\n\\n\\n\\n- We are given a staircase which has **\\u2018n\\u2019 steps/floors**.\\n- Each time, on each step, **we can either take 1 step or 2 steps at a time**.\\n- We need to **find the number of distinct ways in which we can reach the top step/floor.**\\n\\n- Let n = 3, meaning we have 3 steps or floors to climb to as shown below :\\n![stairs_0.PNG](https://assets.leetcode.com/users/images/6a78b919-b75a-4b00-a995-041a9e540e9a_1677862570.6098013.png)\\n\\n\\n- One way to climb the stairs is : 1 step + 1 step + 1 step , as shown below :\\n\\n![stairs_1.PNG](https://assets.leetcode.com/users/images/8c9c1e95-6a83-4c7b-afe4-1c8fcf09089f_1677862584.8530686.png)\\n\\n- Another way would be  : 2 step + 1 step :\\n\\n![stairs_3.PNG](https://assets.leetcode.com/users/images/4ca71d7c-5257-4f5e-89a6-38feb75fc9f3_1677862653.4234407.png)\\n\\n- Another way would be : 1 step + 2 step as shown below :\\n\\n![stairs_2.PNG](https://assets.leetcode.com/users/images/22f620cc-2f44-40ca-bc3c-d9d61bda7d38_1677862666.0298843.png)\\n\\n\\n- So total number of distinct ways to climb n = 3 floors = 1 + 1 + 1 = 3.\\n\\n## Explanation:\\n\\n- For n = 2 , we know there are following 2 ways in which we can climb :\\n\\n![stairs_4.PNG](https://assets.leetcode.com/users/images/04cc0ecb-a6e3-4cec-b29b-99c557271f74_1677862691.0310204.png)\\n\\n- We can either go 1 step + 1 step , or 2 step directly.\\n\\n- Now , we can define an **array \\u2018dp\\u2019** of size \\u2018n\\u2019, ie the number of floors.\\n\\n```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\\n\\n- So ultimately we need to find **dp[n] ie the number of distinct ways in which we can climb \\u2018n\\u2019 floors.**\\n- So what is **dp[i] ?**\\n\\n \\n\\n- Say, there is some ith floor to which we need to count number of ways to climb.\\n![stairs_5.PNG](https://assets.leetcode.com/users/images/a6352348-80a2-4410-b343-c77df8a92034_1677862714.0218048.png)\\n\\n- **To reach to the ith floor, either of the two options must have happened**\\n    - **took 1 step from (i-1)th floor**\\n    - **took 2 step from (i-2)ith floo**r\\n\\n![stairs_6.PNG](https://assets.leetcode.com/users/images/27460725-01f5-4020-90ed-62a4d7c83456_1677862732.8335752.png)\\n\\n- So, dp[i] can be written as :\\n![stairs_7.PNG](https://assets.leetcode.com/users/images/8a09b1c9-a78f-4087-8e59-53ec45f9128e_1677862751.7524385.png)\\n\\n- So , what are the **base cases** :\\n    - **dp[1] = 1** , because to climb to floor = 1 , there is only 1 way ie to take 1 step\\n    - **dp[2] = 2** , because to climb to floor = 2, there are 2 ways : 1 step + 1 step OR 2 step.\\n    \\n\\n![stairs_8.PNG](https://assets.leetcode.com/users/images/3a140591-2427-44d2-a375-967ccd4dd26d_1677862771.3870678.png)\\n\\n### Let\\u2019s do a case for n = 4.\\n\\n![stairs_9.PNG](https://assets.leetcode.com/users/images/784c008f-2c41-4bfa-85c4-a4267f7c5a0e_1677862791.054674.png)\\n\\n\\n- dp[1] = 1 and dp[2] = 2.\\n- Let\\u2019s **find dp[3]** then.\\n- Our formula is :\\n\\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\\n![stairs_10.PNG](https://assets.leetcode.com/users/images/eda4eef1-fd19-4e5e-9422-526bf06eb677_1677862805.104596.png)\\n\\n- Therefore **dp[3] = 2 + 1 = 3 , therefore there are 3 distinct ways to reach the 3rd floor using 1 step and 2 step.**\\n\\n![stairs_11.PNG](https://assets.leetcode.com/users/images/7e99c5f2-1e53-44da-b6a7-fd71892748a0_1677862821.0890055.png)\\n\\n\\n- Now, for **dp[4] :**\\n\\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\\n\\n![1.PNG](https://assets.leetcode.com/users/images/d09f400d-19b6-4d0d-bfc2-1ece3c2e326a_1677862837.9587646.png)\\n\\n![2.PNG](https://assets.leetcode.com/users/images/1ab2836a-d21f-42a7-83bb-52210f793a16_1677862876.0183854.png)\\n\\n\\n![3.PNG](https://assets.leetcode.com/users/images/46e50134-09a2-4aa4-8423-ce984d5c3d86_1677862902.4442675.png)\\n\\n![4.PNG](https://assets.leetcode.com/users/images/2bb6a386-9567-455a-bfb8-b0b6f545b460_1677862915.397574.png)\\n\\n\\n![5.PNG](https://assets.leetcode.com/users/images/31a97205-4239-41cb-bddd-942c3853cb30_1677862928.6362588.png)\\n\\n- Therefore there are **5 distinct ways to reach 4th floor.**\\n# Code\\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n**dp[i] ==> number of  distinct ways climb to the \\'ith\\' floor from \\'0th\\' floor**\\n```\n```cpp\\n         dp[i] = dp[i-1] + dp[i-2]\\n\\nhere, i = 3 ,\\ndp[3] = dp[2] + dp[1] \\ndp[3] = 2 + 1\\ndp[3] = 3\\n```\n```cpp\\n\\t\\t\\t\\tdp[i] = dp[i-1] + dp[i-2]\\ni = 4,\\ndp[4] = dp[3] + dp[2]\\ndp[4] = 3 + 2\\ndp[4] = 5\\n```\n```\\n \\nclass Solution \\n{\\n public :\\n int climbStairs(int n)\\n {\\n    if(n<=1)\\n        return 1;\\n    int dp[n + 1];\\n    dp[1] = 1;\\n    dp[2] = 2;\\n    for(int i = 3 ; i <= n ; i++ )\\n        dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164321,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\\n\\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      const int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n < 3:\\n            return n\\n\\n        cur = 2\\n        prev = 1\\n\\n        for _ in range(3, n + 1):\\n            cur, prev = cur + prev, cur\\n        \\n        return cur\\n```\n```Java []\\nclass Solution {\\n  public int climbStairs(int n) {\\n    int prev1 = 1;\\n    int prev2 = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      final int dp = prev1 + prev2;\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902866,
                "title": "java-explained-in-detail-simple-fast-solution-dynamic-programming",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n# Java - Recursive & Memoization\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the recursive method, using the \\'memo\\' keep track of the calculated number to lower the time complexity.\\n\\n## Complexity\\n- Time Complexity  : O(n), as the recursive call stack is at a maximum of size \\'n\\', when climbStairs(i - 1) is called until reaching the base case.\\n\\n- Space Complexity : O(n), as we use the memo of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\\n\\n---\\n\\n# Java - Iterative & Tabulation\\n\\n## Approach\\nThis problem is the same as the Fibonacci number sequence, where the number of ways is the sum of the ways for \\'n - 1\\' and \\'n - 2\\'.\\n\\nWhen we are on step i, we can only be at i + 1 or i + 2 for one iteration.\\n\\nConversely, when we are at step n, we can only have taken the route from i - 1 or i - 2.\\n\\nThe same applies to the route to arrive at i - 1 and i - 2 respectively.\\n\\nThus, ways(n) = ways(n - 1) + ways(n - 2).\\n\\nHere, we use the iterative and tabulation method, using an array to keep track.\\n\\nNote that it is possible to use only two variables to keep track of ways(i - 1) and ways(i - 2), but this is a good practice for the tabulation method in dynamic programming.\\n\\n## Complexity\\n- Time Complexity  : O(n),\\nas we iterate from 1 to \\'n\\' to find the number of ways to climb stairs.\\n\\n- Space Complexity : O(n), \\nas we use the table of size \\'n\\' to record the result of stairs from 1 to \\'n\\'.\\nIf we use only two variable to record ways(i - 1) and ways(i - 2), then it will be O(1).\\n\\n## Java - With Explanation\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\\n## Java - Clean Code\\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic class ClimbingStairs_Recursive {\\n\\n    // Wrapper method.\\n    public int climbStairs(int n) {\\n\\n        // Use an integer array as \\'memo\\' to record the results that was calculated.\\n        // This is so to not repeat the same calculation over the recursive calls.\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    // Recursive method.\\n    private int climbStairs(int n, int[] memo) {\\n\\n        // We know the ways for n == 1 and n == 2, so record it into the memo.\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        // If \\'n\\' is already in the memo, return memo[n].\\n        if (memo[n] > 0) return memo[n];\\n\\n        // If the current \\'n\\' is not in the memo, then we call the recursive method to calculate and record memo[n],\\n        // and return the result.\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Recursive {\\n\\n    public int climbStairs(int n) {\\n        int[] memo = new int[n + 1];\\n        return climbStairs(n, memo);\\n    }\\n\\n    private int climbStairs(int n, int[] memo) {\\n\\n        if (n == 1) memo[1] = 1;\\n        if (n == 2) memo[2] = 2;\\n\\n        if (memo[n] > 0) return memo[n];\\n\\n        return memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n\\n        // Return the ways for n == 1 and n == 2, since we know the result already.\\n        if (n == 1 || n == 2) return n;\\n\\n        // When using tabulation, seed the table with the base cases for n == 1 and n == 2.\\n        // Since the array in Java is zero-indexed, we make sure to have the table of size \"n + 1\"\\n        // as we need to access index \\'n\\'.\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n        // Iterate through the table and update its values until \\'n\\'.\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n\\n        // table[n] is the result.\\n        return table[n];\\n    }\\n}\\n```\n```\\npublic class ClimbingStairs_Iterative {\\n\\n    public int climbStairs(int n) {\\n        if (n == 1 || n == 2) return n;\\n\\n        int[] table = new int[n + 1];\\n        table[1] = 1;\\n        table[2] = 2;\\n\\n        for (int i = 3; i <= n; i++) {\\n            table[i] = table[i - 1] + table[i - 2];\\n        }\\n        return table[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775347,
                "title": "ruby-six-approaches",
                "content": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# 70.climbing_stairs.rb\\n# @param {Integer} n\\n# @return {Integer}\\n#\\n# recursion using brute force approach\\n#\\n# time: O(2^n) the size of the recursion tree is 2^n\\n#\\n# space: O(n) where n is the height or depth of the three.\\n#\\n# climb_stair(i,n) = (i + 1, n) = climb_stair(i + 2, n)\\ndef climb_stairs(n)\\n    return climb_stair(0, n) # helper function\\n end\\n \\n # where i is the current step and n is the destination step\\n def climb_stair(i, n)\\n \\n     # base case\\n     # if i > n we walked over and we return 0\\n     return 0 if i > n \\n     # if n is 1 we can only take one step thus return 1\\n     return 1 if i == n \\n \\n     # recursive case\\n     # we climb 1 step and climb 2 steps\\n     return climb_stair(i + 1, n) + climb_stair(i + 2, n)\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with array)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = Array.new(n + 1, 0)\\n     return climb_stair(0, n, memo) \\n end\\n  \\n def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i] > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # recursion with memoiztion (i.e. dynamic programming with hash)\\n #\\n # time: O(n) we reduce the size of the the tree by n\\n #\\n # space: O(n) the depth of the three\\n #\\n def climb_stairs(n)\\n     memo = {}\\n     return climb_stair(0, n, memo) \\n end\\n  \\n  def climb_stair(i, n, memo)\\n     return 0 if i > n \\n     return 1 if i == n \\n     return memo[i] if memo[i].to_i > 0\\n \\n     memo[i] = climb_stair(i + 1, n, memo) + climb_stair(i + 2, n, memo)\\n     return memo[i]\\n end\\n```\n```\\n \\n # with memoiztion without recursion\\n #\\n # time: O(n) we iterate over one array.\\n #\\n # space: O(n) array of size n.\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     memo    = Array.new(n + 1, 0)\\n     memo[1] = 1\\n     memo[2] = 2\\n \\n     for i in (3..n)\\n         memo[i] = memo[i - 1] + memo[i - 2]\\n     end\\n \\n     return memo[n]\\n end\\n```\n```\\n \\n # fibonacci number approach\\n #\\n # time: O(n) single loop\\n #\\n # space: O(1) no memory space is allocated\\n #\\n # note: credit to other programmer for this solution\\n def climb_stairs(n)\\n     return 1 if n == 1\\n \\n     first   = 1\\n     second  = 2\\n \\n     for i in (3..n)\\n         third   = first + second\\n         first   = second\\n         second  = third\\n     end\\n     \\n     return second \\n end\\n```\n```\\n \\n # fibonacci formula\\n #\\n # time: O(log n) raising it to power of x takes log n time.\\n #\\n # space: O(1) constant space.\\n #\\n # note: credit to other programmer for this solution \\n def climb_stairs(n)\\n     sqrt5   = Math::sqrt(5)\\n     phi     = (1 + sqrt5) / 2.0\\n     psi     = (1 - sqrt5) / 2.0\\n \\n     return (((phi ** (n + 1)) - (psi ** (n + 1))) / sqrt5).to_i\\n end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2765329,
                "title": "fibo",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.fibnocci = [0,1,2]\\n        for i in range(3,46):\\n            self.fibnocci.append(self.fibnocci[i-1]+self.fibnocci[i-2]);\\n            \\n    def climbStairs(self, n: int) -> int:\\n        return self.fibnocci[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735055,
                "title": "0ms-runtime-c-solution-dynamic-programming",
                "content": "This question follows the same pattern as the fibbonaci series.\\n\\nLet\\'s see how.\\n\\nFor n=1, no of solutions = 1\\nFor n=2, no of solutions = 2\\nFor n=3, no of solutions = 3  [1+2]\\nFor n=4, no of solutions = 5  [2+3]\\nFor n=5, no of solutions = 8  [3+5]\\nFor n=5, no of solutions = 13 [5+8]\\n\\nAs we can see the steps are sum of it\\'s two predecessors. We can apply the same algorithm for getting the $$n^{th}$$ sum of a fibonacci series here.\\n\\nWe store the already calculated values in a vector array to prevent calculating the same step sum again & again. This in face same a lot of time, thus bringing down the time complexity.\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```\\n\\n*if this solution helped you, please do upvote it*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    int climbStairsdp(int n, vector<int>& dp) {\\n        if (n<2) return 1;\\n        if (dp[n]) return dp[n];\\n        else return dp[n] = climbStairsdp(n-1, dp) + climbStairsdp(n-2, dp);\\n    }\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return climbStairsdp(n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732425,
                "title": "o-1-time-complexity-solution",
                "content": "As many have already pointed out, this Is basically a fibonacci series implimentation and there already are good explanations of this in the discussions.\\n\\nHowever there is a direct mathematical fomula for fibonacci that you can refer to here: https://math.hmc.edu/funfacts/fibonacci-number-formula/\\n\\nMeaning its a direct answer with no loops.\\n\\n__NOTE__ - At this point the complexity of the actual operators like ** and / do start mattering so its not exactly O(1) technically speaking, but I believe this is the closest we can get to an O(1) solution.\\n\\n``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` Python \\nclass Solution(object):\\n    def climbStairs(self, n):\\n        n = n+1\\n        root5 = 5**0.5\\n        Phi,phi = (1 + root5)/2,(1 - root5)/2\\n        return int((Phi**n - phi**n)/root5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698704,
                "title": "c-java-python3-javascript-solutions-faster-than-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n**Example : C# Solution1 - temporary interger**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n\\n**Example : C# Solution2 - use Array to store**\\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        //the first example has tell us how many distinct way for 1 or 2 steps stairs\\n        int first  = 1;     \\n        int second = 2;     \\n        int tmp = 0;        \\n        \\n        if(n<=2)    //if n not more than 2 than just return the stpes it take\\n        {\\n            return n;\\n        }\\n        else\\n        {\\n            for(int i =3; i<=n;i++) //every iteration,will add the last two steps together and save as \\'second\\'\\n            {\\n                tmp = second;       \\n                second+=first;      //set second as now iteration needed steps\\n                first = tmp;        //set first as the last time needed steps\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n\\n        if(n<2){\\n            return n;\\n        }\\n        \\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        ans[1] = 2;\\n        \\n        for(int i=2;i<n;i++) {\\n            ans[i]=ans[i-1]+ans[i-2];\\n        }\\n        return ans[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690264,
                "title": "faster-than-100",
                "content": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        // simple fibonacci problem\\n        int steps=0;\\n        int n1=0;\\n        int n2=1;\\n            for(int i=1; i<=n;i++){\\n                steps=n1+n2;\\n                n1=n2;\\n                n2=steps;\\n            }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437625,
                "title": "five-different-solution-c-easily-understandable",
                "content": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nTime: O(2^n)  Space: O(n)\\n--> Recursion (TLE)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        int left=climbStairs(n-1);\\n        int right=climbStairs(n-2);\\n        return left+right;\\n    }\\n};\\n\\nTime: O(n)  Space: O(n)\\n--> Memoization (Top-Down)\\n\\nclass Solution {\\npublic:\\n    int dp[46]={0};\\n    int climbStairs(int n) {\\n        if(n==1)\\n            return 1;\\n        else if(n==2)\\n            return 2;\\n        else if(dp[n]!=0)\\n            return dp[n];\\n        dp[n] = climbStairs(n-1)+climbStairs(n-2);\\n        return dp[n];\\n    }\\n};\\n\\n--> Without using Global Variable\\n\\nclass Solution {\\npublic:\\n    int f(int n,vector<int>& dp){\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 2;\\n        if(dp[n]!=0)\\n            return dp[n];\\n        int left=f(n-1,dp);\\n        int right=f(n-2,dp);\\n        return dp[n]=left+right;\\n    }\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        return f(n,dp);\\n    }\\n};\\n\\nTime: O(n) Space: O(n) \\n--> Tabulation (Bottom-Up)\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1);\\n        dp[1]=1;dp[0]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\nTime: O(n)  Space: O(1)\\n--> Tabulation and Space Optimized\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<2)\\n            return 1;\\n        int a=1,b=1,c=0;\\n        for(int i=2;i<=n;i++){\\n            c=a+b;\\n            a=b;b=c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334116,
                "title": "c-java-python3-javascript-solutions-faster-than-85-90",
                "content": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "### **Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50**\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n**A similar question : [Zyrastory - Pascal\\'s Triangle](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-118-pascals-triangle-solution-explanation/)**\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "codeTag": "Unknown"
            },
            {
                "id": 2191631,
                "title": "simplest-python-solution-explanation-code-dp-approach",
                "content": "**CLIMBING STAIRS PROBLEM:**\\nThis problem is very similar to [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n\\nWe have two choices at the start: either climb the first stair or climb the 2nd stair.\\n* if we take one step from the ground, then the subproblem becomes: *climbing the nth stair from the 1st stair.*\\n\\n* if we take two step from the ground, then the subproblem becomes: *climbing the nth stair from the 2nd stair.*\\n\\nSo we can solve the given problem recursively by adding the results of sub-problems:\\n**climbStairs(0, n) = climbStairs(1, n) + climbStairs(2, n)**\\n\\n```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\\n\\n**Another more efficient approach could be:**\\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```\\n\\nFeel free to ask the doubts and please upvote!(^_^)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef climbStairs(self, n: int) -> int:\\n\\t\\tif n <= 2:\\n            return n\\n        \\n        dp = [0] * (n+1)\\n\\t\\t\\n        dp[1] = 1\\n        dp[2] = 2\\n        \\n        for i in range(3, n+1):\\n            dp[i] = dp[i-1] + dp[i-2]\\n        \\n        return dp[n]\\n```\n```\\ndef climbStairs(self, n: int) -> int:\\n        if n <= 2:\\n            return n\\n        \\n        dp = [0, 1, 2]\\n        \\n        for i in range(3, n+1):\\n            dp[i%3] = dp[(i-1) % 3] + dp[(i-2) % 3]\\n        \\n        return dp[n % 3]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176954,
                "title": "java-solution-in-depth-explanation-w-mathmatical-proof",
                "content": "This is a very good DP problem based on mathematical proof. I believe many people have the same questions in their mind like I do. Why it\\'s `(n-1)` step + `(n-2)` step, but not `(n-1)` step + `(n-2)` step + `1` since we need to do an additional step to get to stair `n`? I would use [@WX-78](https://leetcode.com/WX-78) \\'s idea to explain. \\n  Think about what happens on the `n`-th step. We can get to stair `n` from `(n-1)` step or from `(n-2)` step. Also, we know there are `x` distinct ways to get to `(n-1)` step, and `y` distinct ways to get to `(n-2)` steps.\\n\\n  1. For `(n-1)`, we just need to add 1 on `x` paths to get to `n` step. It doesn\\'t change the number of `x` paths required to get `(n-1)` step.\\n  2. For `(n-2)`, we need to add 2 on `y` paths to get to `n` step. It also doesn\\'t change the number of `y` paths required to get to `(n-2)` step.\\n  Therefore, we just need to add `(n-1)` step and `(n-2)` step together to get all the possible ways to `n` step. I believe it is still unclear at this point so let\\'s look the **examples** below.\\n\\nFor example 1, what are all the paths leading to `3`:\\n`[1 + 1 + 1]`\\n`    [2 + 1]`\\n`    [1 + 2]`\\nTo get to `5`, we simply need to add `2` to all the possible paths:\\n`[1 + 1 + 1] + 2`\\n`    [2 + 1] + 2`\\n`    [1 + 2] + 2`\\nNow we can see how the magic works here. The number of ways to get from `3` to `5` does not change with this operation, right? We are adding `2`to each sequence, but it just makes each sequence longer **not making more of possible sequences**.\\n\\nLet\\'s look at another example, just in case it\\'s still not clear enough.\\n\\nFor example 2, for `4` we have five possible ways to get to there:\\n`[1 + 1 + 1 + 1]`\\n`    [1 + 1 + 2]`\\n`    [1 + 2 + 1]`\\n`    [2 + 1 + 1]`\\n`        [2 + 2]`\\nTo get to `5`, we need to add `1` to all the possible sequence so we will have:\\n`[1 + 1 + 1 + 1] + 1`\\n`    [1 + 1 + 2] + 1`\\n`    [1 + 2 + 1] + 1`\\n`    [2 + 1 + 1] + 1`\\n`        [2 + 2] + 1`\\nAgain, we can see how the magic works here. With the adding operation, it doesn\\'t change the number of possible ways to get to `5`. Hence, the total number of paths to get to `5` is the total number of path to get to `3` + the total number of path to get to `4`.\\n\\n  Below is my solution in Java.\\n```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int climbStairs(int n) \\n    {\\n        // O(n) time | O(n) space\\n        if(n == 0)  return 1;\\n        if(n == 1)  return 1;\\n        \\n        int[] stairs = new int[n];\\n        \\n        stairs[0] = 1;\\n        stairs[1] = 2;\\n        \\n        for(int i = 2; i < n; i++)\\n            stairs[i] = stairs[i-1] + stairs[i-2];\\n        \\n        return stairs[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851979,
                "title": "illustrated-explanation",
                "content": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "<<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/3c78e85c-e538-4392-a13b-ae1d1bb04642_1647355317.703214.png)\\n\\n    @functools.cache\\n    def climbStairs(self, n: int) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        return self.climbStairs(n - 2) + self.climbStairs(n - 1) if n > 2 else n",
                "codeTag": "Python3"
            },
            {
                "id": 1822442,
                "title": "climbing-stairs-easy-java-solution",
                "content": "***IF YOU LIKE IT, PLS PLS UPVOTE IT :)***\\n![image](https://assets.leetcode.com/users/images/dd1f3bc6-3040-42ab-871f-8f2660595ceb_1646499781.8532014.jpeg)\\n\\n```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//A type of fibonacci number problem\\n//I\\'m gonna use memoization here\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        //to store the value of recursive call\\n        int[] dp=new int[n+1];\\n        return  countSteps(n,dp); \\n    \\n    }\\n    \\n    static int countSteps(int n,int[] dp){\\n\\n\\n        //BASE CASE\\n        //I can only jump on the last stair can\\'t go next\\n        if(n==0){return 1;}\\n        //I can go till 0th stair from 1st stair\\n        if(n==1) {return 1;}\\n        \\n        //to check if I have computed this value earlier or not!\\n        if(dp[n]!=0){\\n            return dp[n];\\n        }\\n        //I can either jump one step or two step!\\n        int lh=countSteps(n-1,dp);\\n        int rh=countSteps(n-2,dp);\\n        \\n        //sum of both side\\n        return dp[n]=lh+rh;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671910,
                "title": "python-detailed-explanation-o-n-time-o-n-space-beats-92-05-time",
                "content": "So the first intution here is going to be approaching this as a dfs problem similar to the [combination sum](https://leetcode.com/problems/combination-sum/) problem, except now this time, we\\'re only looking at the amount of ways we can sum n with only 1 and 2. \\n\\nSo we begin by drawing a graph of the problem to figure out our next steps and see if we can find a particular pattern. Let\\'s take 4 for example:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\\nFirst things first, we realize we can use 1 and 2 as our base case, since it\\'s a relatively simple answer, and every branch will always end in a 1 or a 2. \\n\\nThe second thing we can realize is that we can sort of start looking at every solution less than 4 below it. The right hand hand side of the tree gives us the solution of 3, and left hand side gives us the solution for 2. Then the branches of 3 gives us the solution for 2 and 1. We also realize that the sum of the solutions of both sides of the tree gives us the final answer for the root.  So we begin plotting out for funtion f:\\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\\nThus we see that for n in range [2, inf]:\\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\\nWhich should look familiar, because this is just a fibonacci sequence!\\nUsing this information, we can create some simple code similiar to the code of the classic fib sequence problem:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\\nIn this solution, since the longest branch is going to be us just repeatingly subtracting 1 from n, n is going to be our tree height, and thus our space complexity from our stack will be O(n). \\nSince for n tree height we are going to have a worst case of 2^n nodes (you can test this out yourself by drawing a tree, with each node having exactly two children), then the time complexity for this solution is O(2^n). \\n\\nThis solution is clearly not an efficient one, so we are going to try to see how we can speed things up. One thing we can usually do whenever we are dealing with recursion is memoizing. And since we have a bunch of branches that repeat, this is the perfect opportunity to utalize it. \\n\\nSo if we are calculating a large number like 45, instead of calculating the solution for any n less than 44 multiple times, we can just calculate it once, and hold the solution we find in a dictionary. That way, whenever we come accross the need to find the solution for the same number in the future, we can solve it in O(1) time. \\n\\nSince recursion sort of works like dfs, and we are doing n - 1 first, we\\'re going to have the solution for every number up to n before we even start going to any of the right branches. Since at that point all of the solutions for the right branches are found and only require O(1) lookup time, the only calculations we\\'re doing is the left branches which are made up of n nodes. \\nThus, our new time complexity should be O(n), all while our space complexity should stay the same, since we\\'re only storing up to n solutions in the dictionary.\\n\\nAwesomely enough, we can achieve this through just a few edits of our old code:\\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```\\n\\nLet me know if there are any questions or sugestions!\\nIf you want to look further into it, I recommend looking at the first problem solved in the dynamic programming video offered by freecodecamp.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   /         \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     2            3\\n\\t\\t\\t\\t\\t\\t\\t       / \\t\\\\       /    \\\\\\n\\t\\t\\t\\t\\t\\t           1    0      2      1\\n\\t\\t\\t\\t\\t\\t         /           /   \\\\      \\\\ \\n\\t\\t\\t\\t\\t            0           1     0       0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      /\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t0\\n```\n```\\nf(5) = f(4) + f(3)\\nf(4) = f(3) + f(4)\\nf(3) = f(2) + f(1)\\n```\n```\\nf(n) = f(n - 1) + f(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n in {1, 2}:\\n            return n\\n        \\n        return self.climbStairs(n - 1) + self.climbStairs(n - 2)\\n```\n```\\n# Andres \"Mateo\" Ruiz Flores\\n# 6 January 2022\\n\\nclass Solution:\\n    def climbStairs(self, n: int, memo = {1:1, 2:2}) -> int:\\n        if n in memo:\\n            return memo[n]\\n        \\n        memo[n] = self.climbStairs(n - 1, memo) + self.climbStairs(n - 2, memo)\\n        \\n        return memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591139,
                "title": "javascript-python-beat-96-fibonacci-sequence-simple-readable",
                "content": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\\n\\nJavascript\\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\\n\\nPython\\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/* \\n1 -> 1\\n2 -> 2 (1+1 | 2+0)\\n3 -> 3 (1+1+1 | 2+1 | 1+2)\\n4 -> 5 (1+1+1+1 | 2+1+1 | 2+2 | 1+2+1 | 1+1+2)\\nand so on\\n\\nThis is exactly a fibonacci sequence\\nEach next amount of steps equals to sum of previous 2\\n1 -> 2 -> 3 -> 5 -> 8 -> 13\\n*/\\n```\n```\\nvar climbStairs = function(n) {\\n  let a = 0;\\n  let b = 1;\\n  for (let i = 0; i < n; i++) {\\n    [a, b] = [b, a + b];\\n  }\\n  return b;\\n};\\n```\n```\\nclass Solution:\\n  def climbStairs(self, n: int) -> int:\\n    a, b = 0, 1;\\n    for i in range(1, n + 1):\\n      b, a = a + b, b;\\n\\n    return b;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563121,
                "title": "c-2-solutions-memoization-tabulation-dp",
                "content": "**1. Memoization**\\n```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\\n\\n**2. Tabulation (DP)**\\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    int climbStairsHelper(int n, vector<int>& t){\\n        if(n<=1) return 1;\\n        if(t[n] != -1) return t[n];\\n        else return t[n] = climbStairsHelper(n-1, t) + climbStairsHelper(n-2, t);\\n    }\\n    int climbStairs(int n) {\\n        if(n<=1) return 1;\\n        vector<int> t(n+1,-1);\\n        return climbStairsHelper(n,t);\\n    }\\n```\n```\\nint climbStairs(int n) {\\n        int t[n+1];\\n        t[0] =1;\\n        t[1] = 1;\\n        for(int i=2; i<n+1; i++) t[i] = t[i-1] + t[i-2];\\n        return t[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514782,
                "title": "js-solution",
                "content": "# js solution\\n```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar climbStairs = function(n) {\\n    if(n == 1) return 1;\\n    if(n==2) return 2;\\n    let arr = [1,2]\\n    for(let i=2; i<n;i++) {\\n    arr.push(arr[i-1] + arr[i-2]);\\n    }\\n    return arr[arr.length -1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435924,
                "title": "java-solution",
                "content": "When thinking about this problem, I started by taking a look at how many possible ways you could climb up N stairs..\\n\\n```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\\n\\nAt this point, it became pretty clear that a pattern was forming where the maximum number of ways you could climb up N stairs was equivalent to the MAX[N - 1] + MAX[N - 2].\\n\\nHowever, if N == 1 or N == 2 this doesn\\'t work, its simply 1 or 2.\\n\\nSolution (recursive):\\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\\n\\nThats really bad when N becomes large.. but we can use store the previous values in an array as we calculate to avoid the recursive call.\\n\\nSolution (Dynamic Programming):\\n\\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nN = 1 -> [1] -> 1 way\\nN = 2 -> [1 + 1, 2] -> 2 ways\\nN = 3 -> [1+1+1, 1+2, 2+1] -> 3 ways\\nN = 4 -> [1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2] -> 5 ways\\nN = 5 -> [1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1] -> 8 ways\\n\\n```\n```\\n    public int climbStairs(int n) {\\n        if(n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n\\n        return climbStairs(n - 1) + climbStairs(n - 2);\\n    }\\n```\n```\\n    public int climbStairs(int n) {\\n        if (n < 1) {\\n            return 0;\\n        } else if (n == 1) {\\n            return 1;\\n        } else if (n == 2) {\\n            return 2;\\n        }\\n        int[] steps = new int[n];\\n        steps[0] = 1;\\n        steps[1] = 2;\\n        for (int i = 2; i < n; i++) {\\n            steps[i] = steps[i - 1] + steps[i - 2];\\n        }\\n        return steps[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415908,
                "title": "python3-24ms-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        one,two=1,1\\n        for i in range(n-1):\\n            temp=one\\n            one=one+two\\n            two=temp\\n        return one\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316496,
                "title": "python-top-down-recursive-with-memo-bottom-up-iterative-with-tab",
                "content": "\\n\\n**1. Top-down recursive | Without memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\\n\\n**2. Top-down recursive | With memoization**\\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\\n\\n**3. Bottom-up itertaive with tabulization**\\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\\n\\n- v2.0\\n\\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\treturn recurse(n-1) + recurse(n-2)\\n\\n\\t# main\\n\\treturn recurse(n)\\n\\n```\n```\\ndef climbStairs(n):       \\n\\n\\t# helper\\n\\tdef recurse(n):\\n\\t\\tif n == 0 or n == 1:\\n\\t\\t\\treturn 1\\n\\n\\t\\tif n in d:\\n\\t\\t\\treturn d[n]\\n\\t\\td[n] = recurse(n-1) + recurse(n-2)\\n\\t\\treturn d[n]\\n\\n\\t# main\\n\\td = {}\\n\\treturn recurse(n)\\n```\n```\\ndef climbStairs(n):       \\n\\n\\ttable = [0]*(n+1) # this stores how many ways to arrive at each index/step - NOTE [1]\\n\\t\\n\\ttable[0] = 1 # only one way to arrive at index 0 (this is basically the starting point aka ground level)\\n\\ttable[1] = 1 # only one way to arrive at index 1 (first step)\\n\\n\\t# for remaining steps/indicies, each can be arrived at from: a) 1 step away, b) 2 steps away\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\treturn table[n]\\n\\t\\n# NOTE [1]\\n# Use (n+1) so that we can have index 0 for when person is at the ground level still\\n```\n```\\ndef climbStairs(n):       \\n\\tif n == 0 or n == 1:\\n\\t\\treturn 1\\n\\tif n == 2:\\n\\t\\treturn 2\\n\\n\\ttable = [0]*n\\n\\ttable[0] = 1\\n\\ttable[1] = 2\\n\\n\\tfor i in range(2, len(table)):\\n\\t\\ttable[i] = table[i-1] + table[i-2]\\n\\n\\tprint(table)\\n\\treturn table[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307722,
                "title": "fibonacci-turned-stairs",
                "content": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "The given question is actually a variation of Fibonacci Numbers using DP. If one has faced the Fibonacci one, the this one is a piece of cake. \\n\\nThe following is the recursive code to build your intuition. It is clearly visible that this is similar to fibo code:\\n\\n\\tint climbStairs(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n<0)\\n            return 0;\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }//Gives TLE for your info., hence the DP solution\\n\\nNow as per general conception, the only thing needed to do here inorder to convert it into a DP solution is to just replace the recursive calls to elements of the dp table :\\n\\n    int climbStairs(int n) {\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;                                 //Initialization--> if n is 0 or 1 then only one way is possible\\n        dp[1] = 1;\\n        for(int i=2;i<=n;i++){\\n            dp[i] = dp[i-2] + dp[i-1];             //Update the current value\\n        }\\n        return dp[n];                              //Answer is stored at the last index o the **dp** array \\n    }\\n\\nGive a star if u liked it :)\\nThanks!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 974032,
                "title": "java-top-down-dp-explaination-w-video",
                "content": "Video walkthough\\nhttps://www.youtube.com/watch?v=aquoXtYMUME\\n\\nTop Down DP is an optimization built on top of a brute force recursive problem.\\n\\nNot even thinking about DP, how would we solve the problem? The answer is to use a brute force recursive backtracking solution to try every single path we can take.\\n\\nHere\\'s a visualization at N=4\\n\\n![image](https://assets.leetcode.com/users/images/557539f6-041c-4937-b5b2-08c6a28d8b39_1608097912.1572409.png)\\n\\nStarting from N=4, we will try every combination until we reach either 0 or a negative answer. We will then count the number of answers that we found.\\n\\nSpecifically we have:\\n* Base case: N=0, return 1, we found a unique path\\n* Base Case: N < 0, return 0, invalid path\\n* Recursive Case: Stairs(N-1) + Stairs(N-2)\\n\\nThe code for this is here:\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\\n\\nNow if you look back at the graph, you might notice that we have repeated calculations that we make, like n=1 or n=2:\\n![image](https://assets.leetcode.com/users/images/f634ccc0-09ca-4bfd-99fb-3b8a98f5b163_1608098166.53452.png)\\n\\nThe goal of DP is to save the answers we calculated at each of these sub-problems and re-use them if we ever see them again. We accomplish this by using an array to store the number of path at each stair. For example n=1 will always have 1 unique path.\\n\\nBy re-using the answer that we\\'ve calculated, we can save on runtime complexity which makes DP so powerful\\n![image](https://assets.leetcode.com/users/images/67cd3722-9e9a-4c74-ac0d-60fc510402f8_1608098320.1190197.png)\\n\\nThe only big change to our brute force recursive code is that we use an array to store the answers to each step that we calculate in the recursive case and that reuse it if we ever see it again as one of our base cases.\\n\\nHere\\'s what the code looks like:\\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```\\n\\nAs you can see, DP problems aren\\'t too hard. Once you can think of a recursive backtracking solution, you can easily implement DP to make your algorithm run faster.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n == 0) {\\n            // base case where we arrived at an answer\\n            return 1;\\n        } else if (n < 0) {\\n            // base case where we went too far\\n            return 0;  \\n        } else {\\n            // recursive case where we try taking 1 step\\n            // and 2 steps, adding the unique permuation\\n            // of steps back\\n            return helper(n-1) + helper(n-2);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] memo; \\n    public int climbStairs(int n) {\\n        // instantiate the datastructure to cache the calculation\\n        // to each of our subproblems. i.e. what step we are on\\n        memo = new int[n+1];\\n        return helper(n);\\n    }\\n    \\n    private int helper(int n) {\\n        if (n < 0) {\\n            return 0;\\n        } else if (memo[n] != 0) {\\n            // If we stored something in our cache reuse it and avoid\\n            // recalculating everything\\n            return memo[n];\\n        } else if (n == 0) {\\n            return 1;\\n        } else {\\n            // store our calculation inside our cache so we don\\'t \\n            // have to recalculate it again for memo[n]\\n            memo[n] = helper(n-1) + helper(n-2);\\n            return memo[n];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717739,
                "title": "c-yet-another-dp",
                "content": "```\\npublic class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ClimbStairs(int n) {\\n        if (n <= 2)\\n            return n;\\n        \\n        int[] res = new int[n + 1];\\n        \\n        res[1] = 1;\\n        res[2] = 2;\\n        \\n        for (int i = 3; i <= n; i++)\\n            res[i] = res[i - 1] + res[i - 2];\\n        \\n        return res[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 647444,
                "title": "c-beats-93-56",
                "content": "Runtime: 36 ms, faster than 93.56% of C# online submissions for Climbing Stairs.\\nMemory Usage: 14.4 MB, less than 5.88% of C# online submissions for Climbing Stairs.\\n```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int ClimbStairs(int n)\\n    {\\n        if (n < 3)\\n            return n;\\n\\n        int n_2 = 2;\\n        int n_1 = 1;\\n        int res = 0;\\n\\n        int i = 3;\\n        while(i++ <= n)\\n        {\\n            res = n_2 + n_1;\\n            n_1 = n_2;\\n            n_2 = res;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369330,
                "title": "ruby-fibonacci",
                "content": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef climb_stairs(n)\\n    fib = { 0 => 0, 1 => 1, 2 => 2, 3 => 3 }\\n    fib.default_proc = ->(f,n) { f[n] = f[n-1] + f[n-2] }\\n    fib[n]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 183770,
                "title": "o-1-and-1-line-python",
                "content": "### Mathematician\\'s way to solve fibonacci and shock interviewer :P beats 100%\\n```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```\\n**How to solve fibonacci mathematically:**\\n* ![alt text](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D245/sign=456a7a09b61bb0518b24b42c037ada77/503d269759ee3d6db9e6f1e046166d224f4adefd.jpg)\\n* Wiki: https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression\\n* Baidu: https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97",
                "solutionTags": [],
                "code": "```\\n    def climbStairs(self, n):\\n        return int((5**.5 / 5) * (((1 + 5**.5)/2)**(n + 1) - ((1 - 5**.5)/2)**(n + 1)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 25300,
                "title": "o-n-time-o-1-space-c",
                "content": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "solutionTags": [],
                "code": "    int climbStairs(int n) {\\n        if(n == 0||n==1)\\n            return n;\\n       int b = 1;\\n       int a = 2;    \\n       for(int i=3;i<=n;i++){\\n           a = a+b;\\n           b = a-b; \\n       }\\n       return a; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 25517,
                "title": "my-javascript-solution-fib",
                "content": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    \\ufffcvar climbStairs = function(n) {\\n    if(n === 0)  return 0\\n    if(n === 1)  return 1\\n    if(n === 2)  return 2\\n\\n    var arr = [1,2]\\n    for(int i = 2; i < n; i++) {\\n    \\tarr[i] = arr[i-1] + arr[i-2]\\n    }\\n    return arr[n-1]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 25537,
                "title": "5-lines-of-easy-code",
                "content": "    class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }\\n            return cur;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int climbStairs(int n) {\\n            int cur=1, pre=0;\\n            for(int i=0; i<n; i++){\\n                cur=pre+cur;\\n                pre=cur-pre;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 25529,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int climbStairs(int n) {\\n        if (n == 0 || n == 1 || n == 2) return n;\\n        int sum = 2, prev = 1, curr = 0;\\n        for (int i = 2; i < n; i++) {\\n            curr = sum; \\n            sum += prev;\\n            prev = curr;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3909678,
                "title": "c-four-approaches-dp-explanation-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time complexities\\n    // recursion - O(2^n) (exponential)\\n    // for toptobottom - (  O(N))\\n    // to bottomup ( tabular ) - (O(N))\\n    // optimal - (O(N))\\n\\n    // space complexities\\n    // for recursion - O(N) ( rec calll stack)\\n    // for top down - O(N) ( for dp array ) + O(N) ( for the rec call stack)\\n    // for bottomup - O(N) ( for the array only ) // as no recursion\\n    // for optimal - (O(1)) ( as we used two variables only)\\n  \\n  // approach 1\\n\\n  int recursion(int n)\\n     { \\n         // when n becomes 0 simply it means we reached the destination and when the n becomes -ve it means we reached beyond the target\\n\\n       // make a array to store the count \\n         if(n == 0)\\n         {\\n             return 1;\\n         }\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         int ans1 = recursion(n-1);\\n         int ans2 = recursion(n-2);\\n         return (ans1 + ans2);\\n\\n     }\\n\\n// approach 2\\n\\nint topdown(int n , vector<int>& dp)\\n     {\\n         // writing the base case\\n         if( n < 0)\\n         {\\n             return 0;\\n         }\\n         if( n == 0)\\n         {\\n             return 1;\\n         }\\n         // check if value already exist\\n         if(dp[n]  != -1)\\n         {\\n             return dp[n];\\n         }\\n\\n         // create the value \\n         dp[n] = topdown(n-1 , dp)+ topdown(n-2,dp);\\n         return dp[n];\\n     }\\n\\n\\n// approach 3\\n\\nint  bottomup(int n)\\n    {\\n        // create array to store\\n        vector<int> dp(n+1 , -1);\\n\\n        // observe the base cases\\n        if( n ==0 )\\n        {\\n            return 0; // as we cant go\\n        }\\n        dp[1] = 1; \\n        if( n == 1)\\n        {\\n            return 1;  // as we can go by having move of 1\\n        }\\n\\n        dp[2] = 2;  \\n        // 2 is the case which needed to be handled as (0 + 1 is 1) but for 2 the ways will be 2 (1+1) and (2)\\n        \\n        for( int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n        return dp[n];\\n    }\\n\\n //approach 4\\n\\n  int optimalsol( int n)\\n  {\\n      // if you see bottomup approach we are just using prev two values to calculate so rather then making a complete array of size n + 1 we must initilize only two variables and we will keep on updating them\\n      if( n == 0 )\\n      {\\n          return 0; // as not possible\\n      }\\n      int temp1 = 1; \\n      int temp2 = 2;\\n    if(n == 1)\\n    {\\n        return temp1;\\n    }\\n    if( n == 2)\\n    {\\n        return temp2;\\n    }\\n    int curr; // to store the current answer\\n    for( int i = 3 ; i <= n ; i++)\\n    {\\n        curr = temp1 + temp2;\\n        //update the values of temp1 and temp2\\n        temp1 = temp2;\\n        temp2 = curr;\\n    }\\n  return curr;\\n  }\\n\\n    \\n\\n\\n    int climbStairs(int n) {\\n       \\n       vector<int> dp(n+1,-1);\\n    // int ans = recursion(n);\\n    // int ans = topdown(n,dp);\\n    // int ans = bottomup(n);\\n     int ans = optimalsol(n);\\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701303,
                "title": "simple-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(int n,vector<int> &dp)\\n{\\n    if(n==0) return 1;\\n    if(n<0) return 0;\\n    if(dp[n]!=-1) return dp[n];\\n    return dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n}\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567678,
                "title": "c-using-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n//using dp\\n    int solve(int n,vector<int> &dp){\\n        if(n<=2){\\n            return n;\\n        }\\n\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1,-1);\\n\\n        return solve(n,dp);\\n    }\\n\\n};\\n\\n\\n\\n//using tabulation method\\n\\n\\n//     int climbStairs(int n) {\\n//     vector<int> dp(n+2);\\n//     dp[0]=0;\\n//     dp[1]=1;\\n//     dp[2]=2;\\n//     if(n<3){\\n//         return dp[n];\\n//     }\\n    \\n//     for(int i=3;i<=n;i++){\\n//         dp[i]=dp[i-1]+dp[i-2];\\n//     }\\n//     return dp[n];\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483669,
                "title": "easy-java-solution-beats-100-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int climbStairs(int n) {\\n      if(n<4)\\n      return n;\\n      int f=2,s=3,t=0;\\n      for(int i=3;i<n;i++){\\n          t=f+s;\\n          f=s;\\n          s=t;\\n      }\\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928339,
                "title": "m-o-1-t-o-n-4-different-approaches",
                "content": "# 4 Approachs\\n1. First recursion & Backtracking\\n2. Then Memorization \\n3. DP- Bottom up approach using Array\\n4. DP same as 3 but no space just 2 pointers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# /70. Climbing Stairs\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        one, two = 1, 1\\n        for _ in range(n-1):\\n            one, two = two, one+two\\n        return two\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908156,
                "title": "simple-java-solution-with-video-explanation",
                "content": "UPVOTE IF IT HELPS YOU, IT KEEPS ME MOTIVATED \\n```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```\\n[https://www.youtube.com/watch?v=Y0lT9Fck7qI]()",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public int climbStairs(int n) {\\n        int a = 1;\\n        int b = 1;\\n        for(int i=0; i<n-1; i++){\\n            int temp = a;\\n            a = b;\\n            b = b + temp;\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905111,
                "title": "python-3-2-versions-3-lines-each-w-explanation-t-m-94-68",
                "content": "\\'\\'\\'\\nLets use `A(n)` as the answer for `n`. Obviously, then `A(1) = 1` and `A(2) = 2`. To get to the third stair, we either take one step from `2` or two steps from `1`, which implies `A3 = A1 + A2`. In general, the inductive step to determine all values then is `A(k) = A(k-1) + A(k-2)`. Thus, the problem reduces to finding the nth Fibonacci number, given `n`.  \\n\\nVersion 1: Induction\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\\n[https://leetcode.com/problems/climbing-stairs/submissions/858745613/](http://)\\n\\nVersion 2: Binet\\'s Formula (The irrational numbers `phi` and `psi` below are the eigenvalues of the linear transformation `a,b = a+b,a+b+b` above. More complete explanations can be googled.) \\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*) on the first, and *O*(1) / *O*(1) on the second.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n\\n        a, b, (d, m) = 1, 1, divmod(n,2)\\n\\n        for _ in range(d):  a,b = a+b,a+b+b\\n\\n        return b if m else a\\n```\n```\\nclass Solution:\\n    def climbStairs(self, n):\\n\\n        phi= (1+sqrt(5))/2\\n        psi = 1 - phi\\n\\n        return int((phi**(n+1)-psi**(n+1))/sqrt(5))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570512,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1564973,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1714182,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1887814,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567350,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1567370,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1576987,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568496,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568574,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1568723,
                "content": [
                    {
                        "username": "owenxing1994",
                        "content": "For this question, there are a bunch of people who have described their mindset. Rather than list the code, I will draw the image of climbing the stairs...\\n\\nFirst things first, we human can only climb 1 start or 2 starts at the very beginning.\\nSo here is an image of telling the number of methods to climb 1 start and 2 stairs\\n![image](https://assets.leetcode.com/users/images/53f54c19-bd86-445f-a428-332b8640af74_1626335122.5701866.png)\\nAs we can see, there is only 1 way to climb 1 stair; and there are 2 ways to climb 2 stairs: 1 stair and 1 stair; 2 stairs for 1 time\\n\\nWhat if N = 3? Here is the image\\n![image](https://assets.leetcode.com/users/images/a07d8fb4-255d-460f-8393-4de4640359a2_1626335216.9479923.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways; and if we climb 2 stairs, we have 1 stair left, which is the situation for \"N = 2\", which is 1 way. So total 2 + 1 = 3 ways\\n\\nWhat if N = 4?\\n![image](https://assets.leetcode.com/users/images/93e68f1f-0a72-4d3c-b3fc-d3721917da83_1626335339.4824002.png)\\nAgain, we can only climb 1 stair or 2 stairs for the first step. If we climb 1 stair, we will have 3 stairs left, which is the situation for \"N = 3\", which is 3 ways; and if we climb 2 stairs, we will have 2 stairs left, which is the situation for \"N = 2\", which is 2 ways. So in total 3 + 2 = 5 ways.\\n\\nWe can find that if there is x stairs(x is a number), the number of ways to climb is the ways to climb x-1 plus the ways to climb x-2:\\n![image](https://assets.leetcode.com/users/images/23937255-277a-4201-9210-3a16dcd9878d_1626335589.7534728.png)\\nwhich, is the famous fibonacci sequence that \"each number is the sum of the two preceding ones, starting from 0 and 1\"\\n\\n"
                    },
                    {
                        "username": "user0141cK",
                        "content": "For 6 steps: 6-1+6-2=9. I can count 13 solutions so it does not work. \\n21111\\n2121\\n2211\\n222\\n2112\\n111111\\n11112\\n11121\\n11211\\n12111\\n1221\\n1212"
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "for 6 steps is 9 ways correct??\\n"
                    },
                    {
                        "username": "Abraree",
                        "content": "Hats Off to your explanation, you literally think out of the box."
                    },
                    {
                        "username": "ANUJ_BALU",
                        "content": "Thank you for your explanation, I spend 30 min for this problem but I cann\\'t understand.  But after your explanation about problem and  fibonacci sequence, I understood completely. "
                    },
                    {
                        "username": "updatedslug",
                        "content": "Thank you! Made it click for me."
                    },
                    {
                        "username": "itsvj",
                        "content": "wow great explanation!"
                    },
                    {
                        "username": "procoderer",
                        "content": "that was so good you gave me a braingasm"
                    },
                    {
                        "username": "Zixu_Toby_He",
                        "content": "\\u7136\\u540E\\u62A5\\u9519\"Time Limit Exceeded\"\\nAnd then it raised \"Time Limit Exceeded\"."
                    },
                    {
                        "username": "Perfect_Yang",
                        "content": "Perfect explanation, thanks!!"
                    },
                    {
                        "username": "manuel-",
                        "content": "Genius. Thanks a lot \\uD83D\\uDC4F"
                    },
                    {
                        "username": "Akira1234ma",
                        "content": "thank U"
                    },
                    {
                        "username": "ambush333",
                        "content": "Great explanation. \\uD83D\\uDC51"
                    },
                    {
                        "username": "ichigoichiehajimee",
                        "content": "thank youuuuuuu :))))"
                    },
                    {
                        "username": "LethalQ",
                        "content": "Thank you King"
                    },
                    {
                        "username": "mithindev",
                        "content": "Great Explaination"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "I see it now, very good explanation! thanks"
                    },
                    {
                        "username": "Fanie",
                        "content": "Thanks for this good explanation "
                    },
                    {
                        "username": "withrvr",
                        "content": "JOD\\nthe man, the meth, the legend\\n\\nall heal @owenxing1994\\n"
                    },
                    {
                        "username": "dostonbek_tilavov",
                        "content": "You made my day. Thank you!"
                    },
                    {
                        "username": "fannnmochi",
                        "content": "thank you for the intuitive explanation!\\n"
                    },
                    {
                        "username": "Ronit_16",
                        "content": "thanks a lot sir \\n"
                    },
                    {
                        "username": "autekroy",
                        "content": "Hi, \\nAfter thinking your code, I found the relation between the ways like a Fibonacci number.\\n\\nBut how do you guys figure this relation out?\\n\\nDoes it have logical literally explanation?\\n\\nHope anyone can help me.\\n\\nThanks a lot."
                    },
                    {
                        "username": "haroldobasi",
                        "content": "This man works for google now, if you needed inspiration this is it"
                    },
                    {
                        "username": "tdlam123",
                        "content": "at the i (i<n), there are 2 ways to climb to i:\\n        1. from (i-1), add 1-step\\n        2. from (i-2), add 2-step\\n        ==> s(i) = s(i-1) + s(i-2) ==> Fibonacci"
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "[@azuregcp](/azuregcp) oh my goodness! I have just noticed!\\n"
                    },
                    {
                        "username": "pk_03",
                        "content": "actually i used logic of permutations and combination but i dont know why my code is showing some error i am just confused it is giving right answer in local environment but wrong answer in leetcode"
                    },
                    {
                        "username": "shathaabualrob",
                        "content": "[@azuregcp](/azuregcp) it doesn\\'t matter it still makes sense to people and we need to know the answer"
                    },
                    {
                        "username": "user8173ZO",
                        "content": "[@azuregcp](/azuregcp) And you did too."
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "[@azuregcp](/azuregcp) \\uD83D\\uDC80"
                    },
                    {
                        "username": "azuregcp",
                        "content": "People here literally replying to an 8 year old comment. "
                    },
                    {
                        "username": "jayambe36",
                        "content": "this is something like partition number method logic modify and apply here,\\n\\nthink like \\nif n <= 0 then return 0\\nif n <= 2 then return 0\\nbut stairs and previous number  is respected 2 and 1\\nthen use loop between (3, n+1`)\\nhere stairs , previous number  = stairs + previous number, stairs\\nand return stairs"
                    },
                    {
                        "username": "zenfred",
                        "content": "There is a great illumination of the stair-climbing problem here on Wikipedia: https://en.wikipedia.org/wiki/Fibonacci_number#Applications (\"{1, 2}-restricted compositions\")"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "I figured it out by drawing the solutions on paper, trying to identify patterns. DP always has a pattern in it (intermediate step has the value that needs to be used in the next iteration).\\n\\nFirst i was trying to find the pattern in the combos of 1s and 2s (realised this would be a pattern used in brute force approach i.e. a pattern on inputs vs DP which uses pattern on solutions i.e. for each \"n\")\\n\\nSo looked for a pattern in the solution space and quickly realised it is following fibonacci order."
                    },
                    {
                        "username": "mojgan1987",
                        "content": "watch this and you get it! https://www.youtube.com/watch?v=Y0lT9Fck7qI"
                    },
                    {
                        "username": "vicente3j",
                        "content": "I tried a method that looks like this: \\n\\n    private int fibonacci(int n) {\\n        if (n == 1 || n == 0) {\\n            return 1;\\n        }\\n        return fibonacci(n - 1) + fibonacci(n - 2);\\n    }\\n\\nUnfortunately, this exceeds the run time limit since I guess the runtime is exponential. So you have to change it to a simple DP solution, or at least thats what I did and it worked."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "It gives TLE on recursive solution but it\\'s still categorized as an Easy problem. Interesting."
                    },
                    {
                        "username": "sikora92",
                        "content": "Got 100% with recursion+memo."
                    },
                    {
                        "username": "pratyush2331",
                        "content": "I guess, they mean easy DP problem\nThis will work\n\n```\nclass Solution {\n    // method-3 : space optimization\n    /*\n    TC : O(n)\n    SC : O(1)\n    */\n    // /*\n    public:\n    int climbStairs(int n) {\n        // from base case\n        int next1 = 1;\n        int next2 = 0;\n        int curr = 0;\n\n        for(int i = n-1; i >= 0; i--) {\n            curr = next1 + next2;\n\n            next2 = next1;\n            next1 = curr;\n        }\n\n        return next1;\n    }\n    // */\n\n\n\n    // method-2 : tabulation\n    /*\n    TC : O(n)\n    SC : O(n)\n    */\n    /*\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n+2, 0);\n\n        // from base case\n        dp[n] = 1;\n\n        for(int i = n-1; i >= 0; i--) {\n            dp[i] = dp[i+1] + dp[i+2]; // n+2 --> will solve this issue when i = n-1 => i+2 = n+1 --> out of bound\n        }\n\n        return dp[0];\n    }\n    */\n\n\n\n    // method-1 : recursion + memoization\n    /*\n    TC : O(n)\n    SC : O(n) + O(n)\n    */\n    /*\n    int solve(int n, int i, vector<int>& dp) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        if(dp[i] != -1)\n            return dp[i];\n\n        return dp[i] = solve(n, i+1, dp) + solve(n, i+2, dp);\n    }\n\n    public:\n    int climbStairs(int n) {\n        vector<int> dp(n, -1);\n\n        return solve(n, 0, dp);\n    }\n    */\n\n\n\n    // method-0 : recursion --> will give TLE\n    /*\n    TC : O(n)\n    SC : O(2^n) + O(n)\n    */\n    /*\n    int solve(int n, int i) {\n        if(i == n)\n            return 1;\n        if(i > n)\n            return 0;\n        \n        return solve(n, i+1) + solve(n, i+2);\n    }\n\n    public:\n    int climbStairs(int n) {\n        // return solve(n, 1, dp) + solve(n, 2, dp); // this will also work\n        return solve(n, 0);\n    }\n    */\n};\n```"
                    },
                    {
                        "username": "divy1607",
                        "content": "cant agree more\\n"
                    },
                    {
                        "username": "avanegas-carecloud",
                        "content": "Tail recursion does not give TLE."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Simrah](/Simrah) bro!! dont do that"
                    },
                    {
                        "username": "denniscorsi",
                        "content": "[@Simrah](/Simrah) Rewrite it with a loop instead, which is quicker than recursion. "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "[@fillipe](/fillipe) for bfs it goes upto 20-22. But doesn\\'t go to 45 which is in the constraints.\\n"
                    },
                    {
                        "username": "fillipe",
                        "content": "I tried both recursive and iterative DFS, and they both hit TLE. The association with Fibonacci is not obvious at first and it is only solution that is accepted. I was able to visually it by writing down the patterns up to n=6 using the DFS algorithm. If you write the patterns as they are first encountered in a DFS search, you can observe that the first column for each case forms the Fibonacci pattern. One just needs to count the number of unique patterns starting with step 1 and the number of unique patterns starting with two. See below:\\n// n=1\\n    // 1\\n    \\n    // n=2\\n    // 1 1\\n    // 2\\n    \\n    // n=3\\n    // 1 1 1\\n    // 1 2\\n    // 2 1\\n    \\n    // n=4\\n    // 1 1 1 1\\n    // 1 1 2\\n    // 1 2 1\\n    // 2 1 1\\n    // 2 2\\n    \\n    // n=5\\n    // 1 1 1 1 1\\n    // 1 1 1 2\\n    // 1 1 2 1\\n    // 1 2 1 1\\n    // 1 2 2\\n    // 2 1 1 1\\n    // 2 1 2\\n    // 2 2 1\\n\\n    // n=6\\n    // 1 1 1 1 1 1\\n    // 1 1 1 1 2\\n    // 1 1 1 2 1\\n    // 1 1 2 1 1\\n    // 1 1 2 2\\n    // 1 2 1 1 1\\n    // 1 2 1 2\\n    // 1 2 2 1\\n    // 2 1 1 1 1\\n    // 2 1 1 2\\n    // 2 1 2 1 \\n    // 2 2 1 1\\n    // 2 2 2"
                    },
                    {
                        "username": "Simrah",
                        "content": " if (n==0)\\n        return 1;\\n        if(n<0)\\n        return 0;\\n    int q=climbStairs(n-1);\\n    int h=climbStairs(n-2);\\n    return q+h; \\n    }\\n\\nI wrote it recursively and it is giving time TLE....any changes that I can make??"
                    },
                    {
                        "username": "mujtabah258",
                        "content": "They wanted this as an \\'easy DP\\' problem, I guess."
                    },
                    {
                        "username": "DrSaAI",
                        "content": "Stop classifying this question as easy. I graduated with CS degree and it took me 30 minutes before give up. I am very angry now."
                    },
                    {
                        "username": "yh32",
                        "content": "I figured out a better way to explain the Fibonacci solution for this this climbing stairs problem. Personally, I do think it makes more sense.\\n\\nIf we try to reach level n, we either take one step or two step for the last move. \\nFor the one step case, we need to be at the level n - 1, and say we have x1 ways to get level n - 1. For every way of reaching level n - 1, we can only take 1 step at the end to get level n. So, we have x1 ways to reach level n by taking 1 step at the last move. \\nSimilarly, for the two steps case, we need to be at the level n - 2, and say we has x2 ways to get level n - 2. For every way of reaching level n - 2, we can only take 2 stpes at the end to get level n. So, we have x2 ways to reach level n by taking 2 steps at the last move. \\nThus, to reach level n, we have x1 + x2 ways.\\n\\n\\nI hope this make sense to you as well."
                    },
                    {
                        "username": "user8166e",
                        "content": "1-> total 1\\n\\n2 -> total 2\\n1+1\\n2\\n\\n3 -> total 3\\n111\\n12\\n21\\n\\n4->5\\n1111\\n121\\n211\\n112\\n22\\n\\n5->8\\n11111\\n221\\n212\\n122\\n1112\\n1121\\n1211\\n2111\\n\\n\\n0 1 1 2 3 5 8 13 21\\n"
                    },
                    {
                        "username": "xeniawann",
                        "content": "[@tsolspb](/tsolspb) `x1` is indeed a \"subset\" of `x2`, because `x2 = x1 + x0`, `x0` is the number of distinct ways to get to the stair before `x1`. \\nHowever, it\\'s different to get to `n` from `x1` and from `x2`, so you still need to consider them separately as **distinct** ways, hence adding them together instead of doing an intersection set operation or whatever."
                    },
                    {
                        "username": "tsolspb",
                        "content": "If you try to understand the solution by your approach you find yourself wondering if x1 is subset of x2 ? In that sence the explanation from the start sounds more viable. Gosh these tests are killing me. They marked as easy, but if you tackle them with no experience you just feel awfull ("
                    },
                    {
                        "username": "kminsu1204",
                        "content": "Runtime Error Message:\\nLine 18: Char 16: runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\' (solution.cpp)\\n\\nLast executed input:\\n45\\n\\nIs there anyone who experienced overflow issues?"
                    },
                    {
                        "username": "balajiprakasam593",
                        "content": "use long long"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@echobeacon](/echobeacon) but isnt memoization only for recursion? how do u apply that to a non recursive problem???"
                    },
                    {
                        "username": "zenfred",
                        "content": "No, the correct answer for input 45 is still in signed 32-bit integer range. Think again:)"
                    },
                    {
                        "username": "echobeacon",
                        "content": "You should use memoization for this. It will make your algorithm much faster. https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/"
                    },
                    {
                        "username": "user1628bq",
                        "content": "[@kiu2022fallMama0africa](/kiu2022fallMama0africa) use \"unsigned int\"... It will solve the problem. "
                    },
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": "yah same problem"
                    },
                    {
                        "username": "Khan_Baba",
                        "content": "I think key for this problem is to understand \" then the total ways to get to the point [n] is n1 + n2. \\nBecause from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.\"\\nfrom n-1 to n (taking 1 step) and from n-2 to n (take 2 steps or just 1 step) can\\'t be counted as a new way. for n-1, \\nno matter how many ways u get n-1, you can only take 1 step to n, so there is not a new way. for n-2, if you take 2 steps, \\nit is covered by n-1 scenario, if you take 1 steps(2 stairs), same consideration as n-1 to n.\\nways_to(n) = ways_to(n-1) (ways with 1 step from n-1 to 1)+ ways_to(n-2)(ways with 2 steps from n-2 to n)\\nso ways_to(n) = ways_to(n-1) *1 + ways_to(n-2)*1\\nso ways_to(n) = ways_to(n-1) + ways_to(n-2)"
                    },
                    {
                        "username": "wangfred",
                        "content": "This is more meaningful. I was always bothered why fibonacci."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta, b = 0, 1\\n\\tfor i in range(n):\\n\\t\\ta, b = b, a + b\\n\\treturn b"
                    },
                    {
                        "username": "alicephacker",
                        "content": "[@ikikaidesu](/ikikaidesu) the map (a,b)->(b,a+b) generates a sequence which satisfies the same recurrence relation as the Fibonacci numbers; the Fibonacci numbers are the particular case when a = 0 and b = 1. For more you may want to look at problem 1.19 in SICP which is identical to this problem except it walks you through how to generate this sequence in logarithmic time."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@Emanuel071](/Emanuel071) range is just a common looping structure in python. You can do the same thing with the structure         \n\na, b = 0, 1\ni=0\nwhile i<n\n\ta, b = b, a + b\n    i+=1\nreturn b"
                    },
                    {
                        "username": "Emanuel071",
                        "content": "are we allowed to use another class such as range to get this done? is that actually utilizing data structure scheme? "
                    },
                    {
                        "username": "MaratKh",
                        "content": "hint - FIBONACCI"
                    },
                    {
                        "username": "epapillon",
                        "content": "...It\\'s figuring out that it\\'s the Fibonacci sequence that\\'s tricky. \\n\\nMost articles online will just derive a couple of examples (usually acompanied of a drawing) and extrapolate that we are dealing with the Fibonacci sequence. Does anyone know of a good proof of it?\\n\\n**Here\\'s my take at explaining it:**\\n(Assume the function f(n) returns the number of ways to get to step n). \\n\\nSuppose we have 3 steps (n=3). We can either get to step 2 and to step 3, or we can skip step 2 and go directly from 1 to 3. For the first case, there are exactly f(2) ways of going to step 3 while stepping on 2, since from step 2 there is only one way of getting to step 3. For the second case, we could have jumped over step 2. There would be f(1) ways of getting to step 1, and only one way from there to get to step 3 without stepping on 2. Therefore the total number of ways for getting to 3 is f(2)+f(1). QED. \\n\\nThis can be generalized by changing 1,2,3 in my example for n-2, n-1 and n respectively. \\n\\n\\n\\n"
                    },
                    {
                        "username": "am-leet",
                        "content": "You have proved it correctly tbh. Still,\\nyou started with f(3) = f(2) + f(1).\\nInstead start with f(n) = f(n-1) + f(n-2)\\nSince, ways to climb to step n = (take 1 step) or (take 2 steps).\\nTaking one step to reach the end means that we are at (n-1) step &\\ntaking two steps to reach the end means that we are at (n-2) step.\\nSo say there are \\'x\\' ways to reach (n-1) step & \\'y\\' to reach (n-2) steps.\\nThen ways to reach n = x+y;\\nf(n)=f(n-1) + f(n-2);\\nProof!!"
                    }
                ]
            },
            {
                "id": 1570203,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1566449,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1572841,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1916688,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1752782,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568786,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1568891,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1573230,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1713807,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1575816,
                "content": [
                    {
                        "username": "haypieman",
                        "content": "So remember that this is a combination of steps; NOT the number of steps.\\n\\nConsider drawing a staircase and putting the number of combinations to make it easier.\\n\\nSo n[i-1] is the number of COMBINATIONS to get the the last stair. Now realize that you only need extra step to get to the ith stair. Now if you are thinking about n[i-1] + 1, it is wrong because you are thinking of the number of steps, not the number of combinations. \\n\\nLet\\'s make the problem easier: You HAVE to take ONE step, not two, on the LAST step. Imagine i is 6, and you are on the 5nd step, and now just say, that when you go from the 5th step to the 6th step, you will ALWAYS just take one more step to go to the 6th step, thus the number of combinations stays the SAME. Because all the combinations where you go to the 5th step, you are just taking another step, meaning the combination for all the 6th step will be the same as the 5th step, only you are taking another step at the end, and since it\\'s # of combinations, not # of steps.\\n\\nNow going back to the solution: n[i] = n[i-1] + n[i-2], realize that you also have to take in account for the fact that someone can go up 2 steps from i-2th step to ith step. Thus that\\'s why you add n[i-2], because it\\'s the same inituition. If you can only take a double step at the end, then the # of combinations will just be n[i-2] because it\\'s the same combination as n[i-2] except you just taking 2 more steps at the end.\\n\\nSince you can take 1 step at the end or 2 steps at the end, adding the two situtations together, it is n[i] = n[i-1] + n[i-2]."
                    },
                    {
                        "username": "zyrastory",
                        "content": "Detailed Explanation :\\u2B50[Zyrastory - Climbing Stairs](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-70-climbing-stairs-solution-and-explanation-en/)\\u2B50\\n\\nExplain what is **Fibonacci**, and how we get the solution step by step.\\nHere is the submission record, each programming solution is faster than 75~85%\\n\\n![image](https://assets.leetcode.com/users/images/45f6fdd4-36c7-480e-b829-a00c257c7802_1653007698.287201.jpeg)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution on here \\u2B07\\n\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50"
                    },
                    {
                        "username": "jlbroughton",
                        "content": "[@wangfred](/wangfred) Man i wish i looked at your comment before I clicked"
                    },
                    {
                        "username": "wangfred",
                        "content": "the link has virus!"
                    },
                    {
                        "username": "poorsolutions",
                        "content": "I don\\'t really understand why this problem is the same as a fibonacci problem.. I can write out the solution fine now that I see that, but I don\\'t understand fundamentally why. Any help would be greatly appreciated."
                    },
                    {
                        "username": "Krishnaraj-shankar",
                        "content": "It is tagged as easy prob.. but giving TLE for recursion!! should be tagged as medium I think"
                    },
                    {
                        "username": "Tushar_1802",
                        "content": "I am getting this even after I have copied the code from accepted solution of other !\\n\\n\\n  Time Limit Exceeded\\nLast Executed Input\\n21 / 45 testcases passed\\nn =\\n44"
                    },
                    {
                        "username": "2030019",
                        "content": "Yeah they want you to write a DP solution to eliminate the time taken by the extra recursive calls."
                    },
                    {
                        "username": "madfcat",
                        "content": "Same here with TLE. And it also stops on n = 44. I use typescript with recursive function. Probably, there are other solutions. I have not checked any. "
                    },
                    {
                        "username": "abhinav_0107",
                        "content": "**Only Recursion gives TLE!!\\nWe have to use DP and memoize it!!**\\n\\n**T-> O(2^n) && S-> O(n)[Auxillary stack space]**\\n\\n![image](https://assets.leetcode.com/users/images/cb7b3e72-4696-497e-8f4d-59dbbb62cd30_1656770505.5908298.png)\\n"
                    },
                    {
                        "username": "user3899k",
                        "content": "You can also use iteration, it\\'s just like Fibonacci\\n```python\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n == 1 or n == 2:\\n            return n\\n        a , b = 1, 2\\n        for i in range(n-2):\\n            a, b = b, a + b\\n        return b\\n```"
                    },
                    {
                        "username": "rpmnitp",
                        "content": "Re: [Basically it&apos;s a fibonacci.](/topic/5371/basically-it-s-a-fibonacci)\\n\\nWhy ways to reach to n is sum of ways to reach (n-1) + ways to reach (n-2)?\\nShouldn't it  be  n = n1+n2 + some more steps to reach to n ?"
                    },
                    {
                        "username": "qqqxz",
                        "content": "If I am at position `i`, then either I got to `i` from `i-1` by taking 1 step, or from `i-2` by taking either 2x1step+ 1x2step. There for I should add `ways[i-1] +1` and `ways[i-2] + 2` \\nWhy isn\\'t the recursive relationship `ways[i]= (ways[i-2] + 2) + ways[i-1] + 1` ?\\n\\nI don\\'t understand how the correct answer is `ways[i] = ways[i-1] + ways[i-2]`"
                    },
                    {
                        "username": "HarshitBansal122",
                        "content": "because even if you take 2 steps , there are two ways to take those two steps , either you can climb those by taking two steps consectively , or by a single step . Even ima begineer , but thats my explanation"
                    },
                    {
                        "username": "wangfred",
                        "content": "that what I thought. But it IS fibonacci. What is the right thought process?"
                    },
                    {
                        "username": "07rjain",
                        "content": "Try to solve for some Test cases:\\n\\nI would suggest to do it for n=4,5,6\\n\\nyou should start to recognize the pattern\\n------------------------------------------------ :\\nfor n = 4 :\\n1+1+1+1 or 1+2+1 or 1+1+2 or 2+1+1 or 2+2\\ntotal no of ways = 5\\n------------------------------------------------ :\\nfor n = 5 :\\n1+1+1+1+1 or 1+1+1+2 or 1+1+2+1 or 1+2+1+1 or 2+1+1+1 or 1+2+2 or 2+1+2 or 2+2+1\\ntotal no of ways = 8\\n------------------------------------------------ :\\nfor n = 6 :\\n1+1+1+1+1+1 or 1+1+1+1+2 or 1+1+1+2+1 or 1+1+2+1+1 or 1+2+1+1+1 or 2+1+1+1+1 or 1+1+2+2 or 1+2+1+2 or 1+2+2+1 or 2+1+2+1 or 2+2+1+1 or 2+1+1+2 or 2+2+2\\ntotal no of ways = 13\\n------------------------------------------------ :\\n\\nyou will notice\\nfor n = 2 there are 2 ways\\nfor n = 3 there are 3 ways\\nfor n = 4 there are 5 ways\\nfor n = 5 there are 8 ways\\nfor n = 6 there are 13 ways\\n\\nsum of total steps for n stairs =  no. of ways in can be done for n-1 +no. of ways in can be done for n-2\\n\\nf(n) = f(n-1)+f(n-2)\\n\\nThis Fibonacci series\\n"
                    },
                    {
                        "username": "Mohsin-LC",
                        "content": "If you check the possible ways for each number, we can see the Fibonacci Series:\\n[1], [11,2], [111, 12, 21], [1111, 121, 211, 112, 22], [11111, 1211, 2111, 1121, 1112, 221, 122, 212].....\\n0, 1, 2, 3, 5, 8.... exactly like Fibonacci Sequence"
                    }
                ]
            },
            {
                "id": 1576386,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572340,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1567839,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1814546,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1714382,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1576324,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575721,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1575566,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573870,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1573063,
                "content": [
                    {
                        "username": "user7419x",
                        "content": "![image](https://assets.leetcode.com/users/images/676ebc28-3db5-4f36-bf00-eed415aac840_1644811771.2972434.png)\\n"
                    },
                    {
                        "username": "allamaprabhu7",
                        "content": "I am curios, Why everyone is jumping into fibonacci solution. Its more if pattern found in solution than solution itself.\\nAbove approach is more mathematial way of solving. Somebody with  basics of Combinatorics  it should be easy."
                    },
                    {
                        "username": "xz2737",
                        "content": "it is easy for us to use fibonacci to solve this problems, what if it changes request from 1or 2 step to 1or 2 or 3 step. Can we still solve it in the same way."
                    },
                    {
                        "username": "chinmay6",
                        "content": "Hi\\nI just wanted everyone to know that there exists log(n) solution using matrix multiplication for Fibonacci.\\nHow does it work?\\nCreate a matrix like this and take nth power:\\n![0_1500746050984_fibonaccimatrix.png](/assets/uploads/files/1500746062182-fibonaccimatrix.png) \\n\\nSo using the log n optimization for calculating power, we get log(n) solution. \\nFor more info - http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/ (look at method 4 & 5)"
                    },
                    {
                        "username": "Sjouks",
                        "content": "I just came up with this solution using a hash table to store intermediate results. It seems to be the fastest approach there is. However I did not expect this to be this fast as I am going from the top to the bottom. \\n\\nCan someone explain this?\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> memory; \\npublic:\\n    int climbStairs(int n) {\\n        if (memory.find(n) != memory.end()){\\n            return memory[n];\\n        }\\n        int steps;\\n\\n        if (n==0){\\n            steps = 1;\\n        }\\n        else if (n<0){\\n            steps = 0;\\n        }\\n        else {\\n            steps = climbStairs(n-1) + climbStairs(n-2);\\n        }\\n        memory[n] = steps;\\n        return steps;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "zenfred",
                        "content": "When calculating `climbStaris(n)`, a bottom-up solution generates exactly `n` subproblems, from 1 to n. But your top-down solution doesn\\'t necessarily generate all of them, only the needed ones. That\\'s why it can be faster than the bottom-up solution."
                    },
                    {
                        "username": "venkat077",
                        "content": "please don\\'t flud discussion tab with solutions !!!"
                    },
                    {
                        "username": "devllucifer",
                        "content": "![image](https://assets.leetcode.com/users/images/e29a521e-71a2-47b4-b91d-d1c7612d213e_1643830448.5702043.png)\\n"
                    },
                    {
                        "username": "ujjwalsotra1121",
                        "content": "This question forms a fib. series when you check for n=3,n=4,n=5. You get to know and then you can use either bottom-up, top-down approach."
                    },
                    {
                        "username": "ADGSankar",
                        "content": "1 - 1\\n2 - 2\\n3 - 3\\n4 - 5\\n5 - 8\\n6 - 13\\n7 - 21\\n8 - 34\\n9 - 55\\n\\nThis is the pattern that we are getting when we try the combinations and it is fibonacci series"
                    },
                    {
                        "username": "Kuldip123",
                        "content": "Just think what you need to reach at nth place.\\nyou have need (n-1)th place and (n-2)th place.\\nIs it similar with fibonnaci solution.\\ntry and think \\nthanks you."
                    },
                    {
                        "username": "timshea",
                        "content": "the first few outputs are 1,2,3,5,8,13\\n\\nLook familiar?\\nChances are you already know the algorithm for this sequence."
                    }
                ]
            },
            {
                "id": 1572626,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1572231,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 1570607,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2074335,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2069853,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2067489,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066431,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2066049,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2065569,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2064619,
                "content": [
                    {
                        "username": "itsme9573",
                        "content": "It is looks more like a coin change problem since we have represent the number in terms of 1\\'s or 2\\'s but it\\'s not working Can anyone sugeest me whats wrong please"
                    },
                    {
                        "username": "ctremblay",
                        "content": "Two ways to look at it:\\n\\t1) For any step n which there are f(n) possible ways to get to, you can either take 1 or 2 steps, getting you to steps n+1 and n+2, and intuitively there are f(n) ways to get these steps. Coming from step n-1 with f(n) possible ways to get to, you can get to steps n and n+1 in f(n-1) total ways. This means that you can get to step n+1 in f(n-1)+f(n) ways, so f(n+1)=f(n)+f(n-1). Understanding the base case that there is 1 way to get up 0 steps and 1 way to get up 1 steps, this gives you the fibonacci sequence. \\n\\t2) Similarly, to be at step n, where n>1, you must have come from step n-1 or step n-2. Call f(n) the number of ways to get to any step n, then f(n)=f(n-1)+f(n-2), similarly the fibonacci sequence. "
                    },
                    {
                        "username": "kgjohnst",
                        "content": "Literally just the fibonnaci numbers."
                    },
                    {
                        "username": "NNHungLong",
                        "content": "This problem is marked as easy because you have to think it the easy way.\\n* In every turn, you always have two choices: take 1 step or take 2 steps, \\n* In order to climb to n step, you either have to climb from n - 1 step , or climb from n - 2 step\\n* And in order to climb to (n - 1) step, you also have to climb from (n - 1) - 1, or climb from (n - 1) - 2 . The logic also apply to (n - 2) step and so on.\\n* You can only do so until climbing to step 2 - that is when you have 2 choices (take 2 steps from step 0 or take 1 step twice from step 0), and climbing to step 1 (take 1 step from step 0).\\n* The last part is caching, notice that n - 2 step in climbing to n step scenario is the same as (n - 1) - 1 in climbing to (n - 1) step scenario. We can cache in so it won\\'t have to re-caculate the steps required again."
                    },
                    {
                        "username": "theleetcoder_sam95",
                        "content": "At first when i started to find the logic, i felt this is not at all an easy problem but once you actually find the root cause, its pretty simple. The crux of the problem is Fibonacci series where 1,2,3,5,8,....\nI found it after some manual iterations. When the n = 5, it denotes the 5th element of the series which is 8 and it goes by :). Hope this helps !! "
                    },
                    {
                        "username": "zaccb",
                        "content": "This question should set a time complexity constraint. If you solve it in exponential time, you will not pass, causing the user to look at the wrong things. I use the same logic but optimized for linear time and it passed. Frustrating."
                    },
                    {
                        "username": "mugerwasamuel8",
                        "content": "So we just apply the factorial methodology "
                    },
                    {
                        "username": "alicephacker",
                        "content": "Tip: A clever method for doing this in logarithmic time is discussed in SICP."
                    },
                    {
                        "username": "deleted_user",
                        "content": "all my test cases passed but time limit exceeded. how to resolve?\ni used recursion \n"
                    },
                    {
                        "username": "watashiwaaditiadesu",
                        "content": "I\\'m getting this error: (Line 31: Char 5: error: redefinition of \\u2018main\\u2019 [solution.c]\\n   34 | int main(int argc, char *argv[]) {\\n      |     ^~~~) while my code ended on line 27. Whats going on?\\n"
                    }
                ]
            },
            {
                "id": 2059430,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2057594,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2054075,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2052493,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2049763,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2043103,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2041394,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2033047,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020621,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2020231,
                "content": [
                    {
                        "username": "slindauskands",
                        "content": "I do not feel like semi complex calculations involving the fibonacci sequence would clasify as \"easy\",,, probably more \"medium\""
                    },
                    {
                        "username": "Sayeed_khan101",
                        "content": "how many distinct ways are there for 6 steps? I am getting nine as the answer correct me If I am wrong"
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "think about fibonacci series. for 6 the fibonacci number is 13."
                    },
                    {
                        "username": "Anuraaga_Nath",
                        "content": "This is just a fibonacci series where they just want you to get the nth value of fibonacci series. But remember to use memorization."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Folks who feel like this is not an 'Easy' problem are completely justified--it really isn't. Dynamic programming is a difficult concept to put into practice. \n\nHowever, it is important to note that in the universe of programming problems, this problem is 'Easy' dynamic programming problem, which is why it is rated as such. However, the ability to translate DP concepts from ideas to practice is tough, and...well...takes practice. Do not beat yourself up if you cannot get it on the first try. \n\nThe overall take away here is: DO NOT CHASE GRADES!!! Some 'Hard' problems are easier than 'Easy' problems. It is all about what you're comfortable with, have seen before, and what you need to work on. Keep grinding comrades."
                    },
                    {
                        "username": "alice0217",
                        "content": "for stair i, you can choose to climb 1 step from stair i-1 (dp[i] += dp[i-1]) or you can choose to climb 2 steps from stair i - 2 (dp[i] += dp[i-2]).\n\nA good problem to do after this is decode ways."
                    },
                    {
                        "username": "pratgeesh1999",
                        "content": "Memory Limit Exceeded\\n10 / 45 testcases passed\\nLast Executed Input\\nUse Testcase\\nn =35\\n \\nI have written recursive solution, I am not able to understand why?\\n\\n\\n `class Solution:\\n    def __init__(self,):\\n        self.ans = []\\n        self.path = []\\n    def climb(self,target,total):\\n        \\n        if(total == target):\\n            valid_combination = self.path.copy()\\n            self.ans.append(valid_combination)\\n            return \\n\\n        if (total > target):\\n            return \\n\\n        self.path.append(1)\\n        total = total + 1\\n        self.climb(target,total)\\n        \\n        total = total - 1\\n        self.path.pop()\\n        \\n        self.path.append(2)\\n        total = total + 2\\n        \\n        self.climb(target,total)\\n        total = total - 2\\n        self.path.pop()\\n\\n    def climbStairs(self, n: int) -> int:\\n         self.climb(n,0)\\n         return (len(self.ans))\\n        \\n        Please help"
                    },
                    {
                        "username": "Musfik41",
                        "content": "either you can go with dinamic programming or you can use recursion, pretty simple haha. i choose recursion, all beginner should follow me  `return climbStairs(n - 1) + climbStairs(n - 2);` //dont blame me it time limit exceeds with case 45"
                    },
                    {
                        "username": "rishabhramdhave",
                        "content": "Why is this code taking 2ms of time even if it O(n) solution?\\nclass Solution\\n{\\n    public:\\n    int climbStairsHelper(int n, int *arr)\\n    {\\n        if(n<=2)\\n            return n;\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        arr[2] = 2;\\n\\n        for (int i = 3; i < n + 1; i++)\\n        {\\n            arr[i] = (arr[i - 1] + arr[i - 2]);\\n        }\\n        return arr[n];\\n    }\\n\\n    int climbStairs(int n)\\n    {\\n        int arr[46];\\n        return climbStairsHelper(n, arr);\\n    }\\n};"
                    },
                    {
                        "username": "NicholasQuinn",
                        "content": "I've seen some comments asking why it's simply `ways[i-1] + ways[i-2]`, rather than something like  `ways[i-1] +1 + ways[i-2] + 1` (or some other similar equation where something extra is added). \n\nThe thought process that helped me was to think of a \"way\" as a unique sequence of steps that ends on a particular step. For example, 1 1 1 1 would be a way to get to step 4. There are of course other ways to get to step 4 though, such as 2 1 1. \n\nSo why is it that the total number of ways to get to 4 is just the number of ways to get to 3 + the number of ways to get to 2?\n\nWell imagine you get a different person to step each of the unique ways to get to step 2. They all end up on step 2, they just took different sequences of steps to get there. Now you tell them all to take a **double** step to step 4. The key realization is that **you didn't increase the number of unique paths that have been stepped, you've just extended them all to end on 4, instead of ending on 2**. This must be the case, since each person represents one of the unique ways, and you didn't need to add any extra people, just tell them to take another step. \n\nNow imagine you repeat the process for step 3. They all end up standing on step 3 having taken a unique way there, and then you tell them all to take a **single** step to step 4. Once again, **you didn't increase the number of unique paths/ways**, you've just extended them all in length by 1 more step, so that now they end on step 4, instead of step 3.\n\nSo what `ways[i-1] + ways[i-2]` really means is that you're taking all the unique paths to step i-1 and step i-2, and then extending the i-1 paths by a single step, and extending all the i-2 by a double step, making all those unique paths now end on step i. Note that no new paths were made, you just extended already known paths.\n\nDrawing up the ways for steps 1 to 4 may help visualize this:\n\n```\nThe ways to step 1 =\n1\n\nThe ways to step 2 =\n1 1\n2\n\nThe ways to step 3 =\n   all the ways to step 1 plus a double step\n   1, 2\n   + all the ways to step 2 plus a single step\n   1 1, 1\n   2, 1\n\nThe ways to step 4 =\n   all the ways to step 2 plus a double step\n   1 1, 2\n   2, 2\n   + all the ways to step 3 plus a single step\n   1 2, 1\n   1 1 1, 1\n   2 1, 1\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "In my opinion the problem statement should state that you can take one step, two steps, or zero steps. And then the constraints should be 1<=n <=45.\\n\\nOtherwise the top down DP solution which passes all test cases makes less intuitive sense (the last index should start with a value of 1, but that doesn\\'t make sense if you cannot take 0 steps!)"
                    }
                ]
            },
            {
                "id": 2014209,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 2009119,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1999651,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1986069,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1982993,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1974310,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1973133,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1958833,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1947902,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942506,
                "content": [
                    {
                        "username": "shivx_444",
                        "content": "Initialize an array dp of size n+1 to store the number of ways to reach each step.\\nBase cases: Initialize dp[0] = 1 and dp[1] = 1, since there\\'s only one way to reach the 0th and 1st steps.\\niterate from step 2 to n and calculate a dp[i] = dp[i-1] + dp[i-2] and return  dp[n]"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Idk about Fibonacci Sequences but I solved this problem with DP and memoization. Basically, until we have no steps to take, the number of ways that you can reach N with I steps already taken is determined by the result of memo[i + 1] + memo[i + 2]. Or in other words, taking 1 step vs 2 steps. If I becomes greater than N, we return 0. If I == N, we return 1. Otherwise if we're at a spot in memo that we've already calculated (memo[i] != -1) then we can just return memo[i] without having to recalculate an answer that we've already gotten. Hope this helps someone"
                    },
                    {
                        "username": "vladimirkhlghatyan",
                        "content": "The answer is the n-th element of the Fibonacci sequence ;)"
                    },
                    {
                        "username": "AmcaOglu",
                        "content": "Can someone pls explain to me why this code exceeds the time limit? \\nShouldnt it just take O(n) because the while loop iterates n times?\\n\\n\\n\\n\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n<=2:\\n            return n\\n        else:\\n            z=2\\n            i=1\\n            while z != n:\\n                result = i+z\\n                i = z\\n                z = result\\n                \\n            return result"
                    },
                    {
                        "username": "adrshmishra123",
                        "content": "why time limit exceed when I use recursion concept??"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using Recursion approach, you need to cache the intermediary results to avoid calling the function for same input param again and again."
                    },
                    {
                        "username": "vikash_2201",
                        "content": "Think of Fibonacci Numbers"
                    },
                    {
                        "username": "abbasss",
                        "content": "just use the rule of permutation , it\\'s about how many times can you order bunch of ones and twos , \\nimport math\\n\\n\\n\\n\\nclass Solution(object):\\n    def climbStairs(self, n):\\n        count = 0\\n        a= 0\\n        b= n \\n        while b >=0 :\\n            if a == 0 or b == 0:\\n                count += 1\\n            else:\\n                // totalNumber! / NumberOfTwos! * NumbersOfOnes! \\n                count += math.factorial(a+b)/(math.factorial(a)*math.factorial(b))\\n            a += 1\\n            b-=2\\n        return count"
                    },
                    {
                        "username": "layyy",
                        "content": "store the previous values or else you will get TLE"
                    },
                    {
                        "username": "kuljotSB",
                        "content": "well this could be done by simple means of usage of factorial concept  taught in basic high school mathematics"
                    },
                    {
                        "username": "mpelzsherman",
                        "content": "This is a \"trick\" question IMHO. The trick is knowing that the Fibonnaci sequence can be used to get the answer. I\\'ve read many of the explanations posted here and they are all rather convoluted. It would take a real math whiz to recognize this without any prior knowledge. Hats off to those who figured it out without peeking at the solutions!"
                    }
                ]
            },
            {
                "id": 1942205,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1939369,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1938656,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1935802,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1925807,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1921304,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1875660,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1872889,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1866789,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1864678,
                "content": [
                    {
                        "username": "Anshpreet022",
                        "content": "I used the recursion method but there is runtime error at the testcase 45"
                    },
                    {
                        "username": "Baymax_",
                        "content": "If you are using recursion, better cache and use the previously encountered function calls to avoid executing those functions again and again."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Here are different ways to solve the problem:\nhttps://www.enjoyalgorithms.com/blog/climbing-stairs-problem\n\nThe above link shows how to solve the problem, in O(N^2), O(N) and O(LogN) runtime"
                    },
                    {
                        "username": "Baymax_",
                        "content": "I didn't think there was better way than O(N).. but then found this article.\nBut for this constraint, where n < 45.. I think Fibonacci/DP approach is good enough."
                    },
                    {
                        "username": "user9725w",
                        "content": "I am trying to use recursion for this problem, my break conditions are :  `if(n<=0):\\n       return 0\\n  if(n<=3):\\n       return n`\\nI don\\'t understand why  I have Time limit error for values greater than 40"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@Ricardommgomes](/Ricardommgomes)  I didn\\'t notice the constraint , thank you. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@Bouchra Mhamdi](/user9725w)\\nThis code snippet looks fine so far. But why are you checking if n is less or equal to 0 when the constrains are the following \"1 <= n <= 45\". You can delete the first part of this if state ( if(n<0)), the second part looks good. Btw I have this feeling that the Time limit error wasn\\'t caused by this snippet you posted, keep on trying. :)"
                    },
                    {
                        "username": "user9725w",
                        "content": "[@deepakreddyyaramala](/deepakreddyyaramala) that\\'s what i return, it doesn\\'t work "
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "Use recursive functions \\nFunction(n-1)+function (n-2)"
                    },
                    {
                        "username": "dumanlisumeyye0",
                        "content": "Even though recursion can be soluble for fibonacci numbers. It didn\\'t work here due to function calling for this question."
                    },
                    {
                        "username": "RedoUser",
                        "content": "Look up memoization and try again"
                    },
                    {
                        "username": "16andrewchang",
                        "content": "Hello, my code works for n < 21. For n>21 I will have an error that says \"signed integer overflow: 6 * 2304077777655037952 cannot be represented in type \\'long long\\'\". please help me out.\\nPlease see below code.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n    \\n  \\n    int twos;\\n    int nums = n / 2;\\n    double dnums = n / 2.0;\\n    int ones;\\n    int steps = 0;\\n    if(n==1){\\n        steps = 1;\\n    }\\n    for(int i = 1; i <= nums; i++){\\n        twos = i;\\n        ones = n - 2*twos;\\n        long long int fot = 1;\\n        long long int ft = 1;\\n        long long int fo = 1;\\n        for(int j = 1; j <= twos + ones; j++){\\n            fot*= j;\\n        } \\n        for(int k = 1; k <= twos; k++){\\n            ft *= k;\\n        } \\n        for(int l = 1; l <= ones; l++){\\n            fo *= l;\\n        } \\n        steps =(steps * 1)+(fot/(ft*fo));\\n    }\\n        steps += 1;\\n        return steps;\\n    }\\n};"
                    },
                    {
                        "username": "kamalraghav",
                        "content": "I tried to relate it to Fibonacci series and identify the base case and then build upon it.\nSeems like a minor modification of Fibonacci series, i.e. there is no F(0) in this case or could be 0 but isn't required in the solution.\nI tried top-down initially, and it seemed like an extension of Fibonacci series, i.e. you can reach the summit/top either by taking one step or by taking 2 steps.\nThis leads into replicating the same formula F(n) = F(n-1) + F(n-2)\nWe can choose Bottom-Up or Top-Down to implement the solution."
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Why is this solution of mine not working?\n\nunordered_map<int, int> dp;\nlong long climbStairs(int n)\n{\n    if (n == 1 or n == 2)\n        return 2;\n    if (dp[n] != 0)\n        return dp[n];\n    else\n        return dp[n] = max(climbStairs(n - 1) + 1, climbStairs(n - 2) + 2);\n}\n\nPlease help me out!\n\nMy approach to find the maximum number of moves to get to n will be max of maximum (no. of moves to get to n-2 + 2) and maximum (no. of moves to get to n-1 +1)"
                    },
                    {
                        "username": "mo1ok",
                        "content": "A dynamic programming problem classified as an LC-easy :\\\\"
                    },
                    {
                        "username": "spywake",
                        "content": "It takes 0 step to climb 0 stairs so based on that we can\\'t figure out that the amount of steps taken to climb 2 stairs is the amount of steps taken to climb 1 stair + 0 stairs so it makes it hard to find about Fibonacci sequence."
                    },
                    {
                        "username": "NishaKrish",
                        "content": "I using fibonacci. But still shows time limit exceeded"
                    }
                ]
            },
            {
                "id": 1852756,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849950,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849356,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849341,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1849340,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1848019,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1840751,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833965,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1833024,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1828889,
                "content": [
                    {
                        "username": "jasngh_004",
                        "content": "Hint hint hint : draw a recursive tree considering \"n\" can only have 1 step or 2 step so to reach top we need to reach n-1 or n-2 first now it might be seem to be fibonnaci series witth base condition that if (n<=2) return n but going with recursive might be bitter later as we are solving a part of problem numerous times and eventually when you submit time limit exceed to so for iterative one : \" use 2 variable  x=1 and y=2 update them in loop from 3->n  temp = y then y+=x then  x =t and last return x+y \" done happy coding:)"
                    },
                    {
                        "username": "dhyanitripti6",
                        "content": "Anybody who can rectify this code\\nint s ;\\nfor(int i = 0; i<n+1;i++)\\n{\\nn = i;\\nn = i+1;\\nreturn s;\\n}\\nint main()\\n{\\nint s; \\nprintf(\"Enter the steps\");\\nscanf(\"%d\", &s);\\nclimbstairs(n);\\nreturn 0;\\n}\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why DP is also giving TLE :\n\n`\nint ways[] = new int[n+1];\n\n        Arrays.fill(ways,-1);\n        if(n==0) return 1;  if(n<0) return 0;\n        if(ways[n] != -1) return ways[n];\n        ways[n] = climbStairs(n-1) + climbStairs(n-2);\n        return ways[n];\n`"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "why ? "
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can be only solved by DP ? Comment if not! ->  \n\nIf you think yes then Up Vote!"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "It can't run only 43,44 and 45 and all it can run all.\n\nJust 2 Lines of Code using recursion: \n\n\n\n       `if(n==0) return 1;  if(n<0) return 0;\n       return climbStairs(n-1) + climbStairs(n-2);`"
                    },
                    {
                        "username": "ankush920",
                        "content": "\\n100% FAST DP SOLUTION with readable code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nto add all additional way from each extra step.\\n\\nApproach\\ndynamic programming\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(n)\\n\\nCode\\n//find useful upvote it vro :)\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        \\n        vector<int>dp( n+1 , 0 );\\n         dp[n-1] =1; \\n         dp[n]=1;\\n        for( int i = n-2; i>=0;i--)\\n        {\\n             dp[i]=dp[i+1] + dp[i+2];\\n        }\\n\\n        return dp[0];\\n    }\\n};"
                    },
                    {
                        "username": "crobat8",
                        "content": "for those doing the recursion method I got run time errors until I hard coded in the lowest 6 numbers anyone else have that problem?"
                    },
                    {
                        "username": "itsparthmishra",
                        "content": "Got TLE?\\nIts because your solutions time complexity is O(2^n) \\n\\nHint: Use Memoization"
                    },
                    {
                        "username": "Almazino",
                        "content": "n=4 5?\\n"
                    },
                    {
                        "username": "LOGANBLUE",
                        "content": "Time limit exceeds when we use recurtion"
                    }
                ]
            },
            {
                "id": 1825437,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1808482,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1802043,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799955,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1799869,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1785211,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1783115,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1782032,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1781062,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1776547,
                "content": [
                    {
                        "username": "swisstackle",
                        "content": "Why is this solution timing out at n=45?\n```\nint climbStairs(int n) {\n\tif(n == 1) {\n\t\treturn 1;\n\t}\n\tif(n == 2) {\n\t\treturn 2;\n\t}\n\tif(n == 3) {\n\t\treturn 3;\n\t}\n\treturn climbStairs(n-2) + climbStairs(n-1);\n}\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n\\n        if(n==1 || n ==2){\\n            return n;\\n        }\\n\\n        int* dp = new int[n+1];\\n\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n\\n        for(int i=3;i<=n;i++){\\n\\n            dp[i] = dp[i-1] +dp[i-2];\\n        }\\n\\n        return dp[n];\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pk_03",
                        "content": "Can anyone tell me whats wrong with my code please\\n\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int arr[n];\\n\\t\\tarr[0]=1;\\n\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\tarr[i]=i*arr[i-1];\\n\\t\\t}\\n\\t\\tint ans=0;\\n        int ind;\\n        if((n)%2!=0){\\n            ind=(n/2)+1;\\n        }\\n        else{\\n            ind=n/2;\\n        }\\n        for(int i=n;i>=ind;i--){\\n            int fr=(i);\\n            ans+=(arr[fr])/(arr[fr-(n-i)]*arr[n-i]);\\n        }\\n        if(n%2){\\n            return ans;\\n        }\\n        return ans+1;\\n    }\\n};\\n\\nthe code is showing undefined behaviour at line below\\narr[i]=i*arr[i-1];\\n"
                    },
                    {
                        "username": "HuzaifaNaseer1",
                        "content": "Can this be solved by using the general term of the Fibonacci sequence? I am trying but only 3 test cases are passing."
                    },
                    {
                        "username": "zenfred",
                        "content": "It should be a valid solution. Try check your conversion between the floating point numbers and integers."
                    },
                    {
                        "username": "anuushka05",
                        "content": "please help with this code \\nclass Solution {\\npublic:\\n    int climbStairs(long n) \\n    {\\n        int m = 1e9+7;\\n        cin>>n;\\n        long long *ans = new long long [n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        //ans[2]=2;\\n        for(long long i =2;i <= n;i++)\\n            ans[i]=(ans[i-1]%m + ans[i-2]%m)%m;\\n        return ans[n];\\n    }\\n    \\n};\\nits giving terminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi"
                    },
                    {
                        "username": "msro11",
                        "content": "Here is a quick explanation that helped me understand why this problem results in the Fibonacci sequence: There are only two ways to get to the last step, either you are in n-1 and you climb one step or you are in n-2 and you climb 2 steps. If you have x1 ways to get to the n-1 step and x2 ways to get to the n-2 step, the number of ways to get to the n step will be the sum of these two (x1+x2). "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "NOT ACCEPTED ! TIME LIMIT EXCEEDS ! \\nMy solution uses bfs and its good for n = 20. But for 21-45 it exceeds time. I think the problem needs more than just a bfs solution. Maybe a O(N) solution.\\n   \\n`/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar climbStairs = function(n) {\\n    const q = [[n, 0]],\\n        steps = [1, 2]\\n    \\n    let result = 0\\n    \\n    while(q.length !== 0){\\n        const [source, count] = q.shift()\\n\\n        if(source === 0){\\n            result += 1\\n        }\\n\\n        for(const item of steps){\\n            const ns = source - item\\n\\n            if(ns >= 0){\\n                q.push([ns, count + 1])\\n            }\\n        }\\n    }\\n\\n    return result\\n};`"
                    },
                    {
                        "username": "rafiul29",
                        "content": " `Javascript code`\\nvar climbStairs = function(n) {\\n    let nway=[1,2]\\n    for(let i=2;i<=n;i++){\\n        nway[i]=nway[i-1]+nway[i-2]\\n    }\\n    return nway[n-1]\\n};"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "I am confused as to why am I getting a Runtime Error for this solution?\\n ```\\nclass Solution {\\npublic:\\n    int _climbstairs(int n, vector<int> &v){\\n        if(n<=1) return v[n]=1;\\n        if(v[n]!=-1) return v[n];\\n        return v[n]= _climbstairs(n-1, v)+_climbstairs(n-2, v);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> v{n+1, -1};\\n        return _climbstairs(n, v);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "sanskar_omar",
                        "content": "Update: I got my mistake. I have used {} for vector initialization."
                    },
                    {
                        "username": "kanha8433",
                        "content": "if we simply going to calculate on each step using recursion it goes fine to 40 but problem is that n can be <=45 that\\'s why related topics of this question is dynamic programming and memorization so code that we can remember steps "
                    }
                ]
            },
            {
                "id": 1773066,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1760092,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1752227,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1747538,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745802,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1745683,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1740936,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1735975,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733939,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733938,
                "content": [
                    {
                        "username": "tornike_7",
                        "content": "Aaasss"
                    },
                    {
                        "username": "ali__code",
                        "content": "use bottom up approach\\ndp[0] & dp[1]=1\\n\\ni=2 and less than n\\n  dp[i] = dp[i - 1] + dp[i - 2];\\n"
                    },
                    {
                        "username": "Tclack88",
                        "content": "The description needs updating. It gave the constraint for n: 1<n<45, in C an int type is more than enough to hold 45. But then there\\'s a test case that gives this runtime error:\\n\\n `runtime error: signed integer overflow: 1836311903 + 1134903170 cannot be represented in type \\'int\\'`\\n\\nPlease update your description if you\\'re going to test for integers of this size!!!!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705MOST OPTIMIZED APPROACH\\uD83D\\uDCA5 || FAANG INTERVIEW\\uD83D\\uDE2C\\n\\nhttps://leetcode.com/problems/climbing-stairs/solutions/3017520/most-optimized-approach-faang-interview/?orderBy=newest_to_oldest"
                    },
                    {
                        "username": "romesh19",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        if n <= 3:\\n            return n \\n        a = 1 \\n        b = 1\\n        for i in range(n):\\n            f(a) , b = b, a+b\\n        return a  `your inline code...your inline code...`\\n\\nThis is a Fibonacci series after n = 3. \\nPython allow us to write just one line of code. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Yang_Shao",
                        "content": "Let's call the number of distinct ways for number n as W(n). Then W(1)=1, W(2)=2. For n>2, we can divide climbing ways into two type: type A is where the first step is 1, leaving us the rest n-1 to climb and there are W(n-1) such ways; type B is where the first step is 2, leaving us the rest n-2 to climb and there are W(n-2) such ways. Hence W(n) = W(n-1) + W(n-2), essentially a Fibonacci sequence (I got this relation but didn't realize this IS the Fibonacci sequence lol)."
                    },
                    {
                        "username": "mohanvamsi04",
                        "content": "class Solution {\\n    public int climbStairs(int n) {\\n        if(n==1)\\n        return 1;\\n        if(n==2)\\n        return 2;\\n        if(n>=3)\\n        return climbStairs(n-1)+climbStairs(n-2);\\n\\n        return -1;\\n    }\\n}\\nIt is getting time limit exceeded.can any one help me."
                    },
                    {
                        "username": "princek890",
                        "content": "class Solution {\\npublic:\\n\\n    int solveMem(int nStairs, vector<int> dp){\\n\\n    if(nStairs==0|| nStairs==1|| nStairs==2){\\n        dp[nStairs]=nStairs;\\n        return nStairs;\\n    }\\n    \\n    if(dp[nStairs]!=-1)\\n        return dp[nStairs];\\n    \\n    dp[nStairs]= solveMem(nStairs-1, dp)+ solveMem(nStairs-2, dp);\\n    return dp[nStairs];\\n}\\n\\n    int climbStairs(int nStairs) {\\n    vector<int> dp(nStairs+1, -1);\\n    \\n    return solveMem(nStairs, dp);\\n    \\n    }\\n};\\n\\nHi, I don\\'t understand why is this solution not working and giving TLE for n=36,  It is the top down approach for dp right?\\n"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "int s1=1;\\n        int s2=1;\\n        for(int i=2;i<=n;++i){\\n            int dp = s1+s2;\\n            s2=s1;\\n            s1=dp;\\n        }\\n        return s1;"
                    },
                    {
                        "username": "deepakreddyyaramala",
                        "content": "can we use pointer\\n"
                    }
                ]
            },
            {
                "id": 1733937,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733203,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1733201,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1732245,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1727776,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1725908,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1724331,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714501,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714352,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714347,
                "content": [
                    {
                        "username": "deepakreddyyaramala",
                        "content": "why to choose two variables\\n"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "Fourierzz",
                        "content": "can somebody look into my solution and guide me to get this answer as AC .\\n\\n\\nlong long fac(long long n)\\n{\\n\\xA0\\xA0\\xA0\\xA0if(n == 0 || n == 1)\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0return n * fac(n - 1);\\n}\\nclass Solution{\\npublic:\\n    int climbStairs(int n) {\\n    long long b=n/2 ;\\n    long long ways=0LL;\\n    for(int i=0 ; i<=b ;i++){\\n       ways += (long long)fac(n-i)/(fac(n-2*i)*fac(i));\\n    }\\n    return (long long)ways;\\n    }\\n};"
                    },
                    {
                        "username": "DavalC",
                        "content": "The time complexity of the climbStairs function is O(n), where n is the number of steps in the staircase. This is because the function needs to traverse all the steps in the staircase once in order to calculate the number of ways to climb them.\\n\\nThe space complexity is also O(n), as the function stores the number of ways to climb the staircase up to each step in an array. The size of the array is equal to the number of steps in the staircase, so the space complexity is linear in the size of the input.\\n\\nIt\\'s worth noting that the space complexity of this function can be improved by using a recursive approach, which would have a space complexity of O(n) due to the use of the call stack. However, this would come at the cost of increased time complexity, as the recursive approach would require additional function calls for each level of recursion."
                    },
                    {
                        "username": "umar1207",
                        "content": "Firstly its important to notice that it follows the fibonacci series.\\nNow since the number of test cases are very less (45) create a map in O(n) time, and return the required value. \\n"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "I really like this problem, solving it was so fun.\\nIt was a great moment when magically ended up with a Fibonacci sequence, I was like \\u201Chow did I end up here?\\u201D.\\nThe way I thought about it was like this, I start at the end (n), I look back then ask \\u201Cwhat are the only two possible previous steps?\\u201D \\nAnswer \\u2192 (n - 1) and (n - 2), and suddenly it seemed suspiciously recursive.\\nAfter that realization, the solution was straightforward."
                    },
                    {
                        "username": "ditno",
                        "content": "I\\'ve tried this problem with recursion but it\\'s exceeding the time limit can someone provide with possible recommendation .\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        int a = climbStairs(n-1);\\n        int b = climbStairs(n-2);\\n        return a+b;\\n    }\\n};\\nfailing at n=45"
                    },
                    {
                        "username": "non7775",
                        "content": "[@marouane98](/marouane98)     int climbStairs(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n == 1){\\n            return 1;\\n        }\\n        if(n == 2 ){\\n            return 2;\\n        }\\n\\n        int a = n-1;\\n        int b = n-2;\\n        return a + b;\\n    }"
                    },
                    {
                        "username": "marouane98",
                        "content": "If, for example, you call climbStairs(4), this will in turn call climbStairs(3) and climbStairs(2); and inside climbStairs(3) you will also end up calling climbStairs(2) again needlessly. This gets worse very quickly as n grows. Calling climbStairs(6) for example goes as follows (cS = climbStairs for short):\n\ncS(6) -> cS(5), cS(4)\ncS(5) -> cS(4), cS(3)\ncS(4) -> cS(3), cS(2)\ncS(4) -> cS(3), cS(2)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\ncS(3) -> cS(2), cS(1)\n\nYou end up calling 3 x cS(1), 5 x cS(2), 3 x cS(3), 2 x cS(4). You can imagine how bad it will be for n = 45.\nThe trick is to record previous results so you don't call the function again. This technique is called \"dynamic programming\". Google it, there are a lot of resources on it."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Quite easy question if you get the point of question."
                    },
                    {
                        "username": "auth_4",
                        "content": "why it gives Time Limit Exceeded??\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        \\n        if(n==0){\\n            return 1;\\n        } else if (n==1){\\n            return 1;\\n        } else if (n==2){\\n            return 2;\\n        \\n\\n        int x = climbStairs(n-1);\\n        int y = climbStairs(n-2);\\n        int sumAns = x + y;\\n        return sumAns;\\n    }\\n}"
                    },
                    {
                        "username": "marouane98",
                        "content": "Check my answer here https://leetcode.com/problems/climbing-stairs/discussion/comments/1729072"
                    },
                    {
                        "username": "venkat077",
                        "content": "it is  1D dynamic programming question dude! apply memoization to your recursion or try tabulation!"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Because it\\'s exponential time complexity.\\nDo some memorization and it will be accepted."
                    },
                    {
                        "username": "lampuiho",
                        "content": "basically a problem about optimizing for return climbStairs(n-1) + climbStairs(n-2);"
                    }
                ]
            },
            {
                "id": 1714322,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714309,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714280,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714237,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714178,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714116,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1714081,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713959,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713955,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713783,
                "content": [
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int a =0;\\n       int b =1;\\n       int c;\\n\\n       for(int i =0; i<n; i++)\\n       {\\n           c =a+b;\\n           a =b;\\n           b =c;\\n       }\\n        return c;\\n      }\\n       \\n};\\n\\n\\n\\nsimple and easy concept of fabonacii "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple and easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Chandram",
                        "content": "`class Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int step[45]={0};\\n        step[0]=1;\\n        step[1]=2;\\n        for(int i=2;i<n;i++){\\n            step[i]=step[i-1]+step[i-2];\\n        }\\n        return step[n-1];\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kumarmanoj13",
                        "content": "c++ solution :-\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n       int t1=0,t2=1;\\n       int sum=0;\\n       for(int i=0;i<n;i++){\\n           sum=t1+t2;\\n           t1=t2;\\n           t2=sum;\\n       } \\n       return sum;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "class Solution {\\n  public int climbStairs(int n) {\\n    // dp[i] := # of distinct ways to climb to i-th stair\\n    int[] dp = new int[n + 1];\\n    dp[0] = 1;\\n    dp[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i)\\n      dp[i] = dp[i - 1] + dp[i - 2];\\n\\n    return dp[n];\\n  }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "space_invader",
                        "content": "fib"
                    },
                    {
                        "username": "garabed99",
                        "content": "Having ((Time Limit Exceeded)) with recurisive fibonacci function in JS, I wonder why?\n\nvar climbStairs = function(n) {\n    if(n === 0) return 1\n    if(n === 1) return 1\n    return climbStairs(n-1) + climbStairs(n-2)\n};"
                    },
                    {
                        "username": "avalos010",
                        "content": "add some recursive memoization and it should pass."
                    },
                    {
                        "username": "rent4400",
                        "content": "Like Ice Cube says, \"You can do it, put your fib. into it\""
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Can we say that, if 1,2 or 3 steps are allowed, then  the number of ways = x1+x2+x3\nwhere,\nx1 = number of ways to reach n-1\nx2 = number of ways to reach n-2\nx3 = number of ways to reach n-3\n\nor we have to consider the different combination to reach n-1, n-2 & n-3 among themselves\nWhat do you think?!!"
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "I never found a better real-world usage of Fibonacci series than this problem. It is intimidating how tiny things require so much of conceptual understanding and ofcourse open eyes. Even climbing staircase can be difficult if you don\\'t know the math :P "
                    },
                    {
                        "username": "ankit_9713",
                        "content": "Hi, \\ni am not also understand the code of the problem but i figure out what is the meaning of Fibonacci.\\n\\nFibonacci means - \"an integer in the infinite sequence 1, 1, 2, 3, 5, 8, 13, \\u2026 of which the first two terms are 1 and 1 and each succeeding term is the sum of the two immediately preceding. See the full definition.\"\\n       it means first to integers are 1,1 and after these sum of last two numbers was the next number."
                    }
                ]
            },
            {
                "id": 1713748,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713739,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713729,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713695,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1713659,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1711045,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1709022,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1693294,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1689605,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1688135,
                "content": [
                    {
                        "username": "kamleshchauhan",
                        "content": "We can use a single loop with 2 variables\\na=0\\nb=1\\nin each iteration make a\\'=b and b\\'=a+b i.e. a=1 b=1 and so on. "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "For n==1: Ans=1\\nFor n==2: Ans=2\\nfrom 3 onwards: climbStairs(n-1)+climbStairs(n-2)\\n\\nThis sol is giving me Time Limit Exceeded Error.  Time Complexity is O(n),  Am I missing something? "
                    },
                    {
                        "username": "deleted_user",
                        "content": "java dp\\n `class Solution {\\n    public int climbStairs(int n) {\\n        int[] dp = {1, 1};\\n        for (int i = 1; i < n; i++) {\\n            int one = dp[0];\\n            dp[0] = dp[1];\\n            dp[1] = one + dp[0];\\n        }\\n        return dp[1];\\n    }\\n}   `"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "Any idea how to solve this problem in O(logn) Time.\\nCan\\'t think about this. Is it Possible or not?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "[@bs93](/bs93) Thanks for your information.\\n"
                    },
                    {
                        "username": "zenfred",
                        "content": "Definitely possible. Check out fast matrix multiplication. https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip\\nHowever, like I said, that O(logn) algorithm has a high overhead and is even slower than naive O(n) on such small input set."
                    },
                    {
                        "username": "zenfred",
                        "content": "Bored, I tried the fast matrix multiplication method to calculate the Fibonacci sequence for this problem... Turns out SLOWER than the straightforward approach:)"
                    },
                    {
                        "username": "braads07",
                        "content": "class Solution {\\npublic:\\n    void solve(int n , vector<int>v , int sum, int &count , map<vector<int> , int>&mp)\\n    {\\n        if(n==0)\\n        {\\n            count++;\\n            mp[v]++;\\n            return;\\n        }\\n        \\n        if(mp[v]!=0)\\n        {\\n            return ;\\n        }\\n        vector<int>v1=v;\\n        int sum1=sum+1;\\n        v1.push_back(1);\\n        int n1=n-1;\\n        if(mp[v1]!=0)\\n        {\\n            return ;\\n        }\\n        else\\n        solve(n1 , v1 ,sum1 , count , mp);\\n        \\n        //mp[v1]++;\\n        if(n>=2)\\n        {\\n            int sum2=sum+2;\\n            vector<int>v2=v;\\n            v2.push_back(2);\\n            int n2=n-2;\\n            if(mp[v2]!=0)\\n            {\\n                return ;\\n            }\\n            else\\n            solve(n2, v2 , sum2 , count  , mp);\\n            //mp[v2]++;\\n        }\\n        return ;\\n\\n    }\\n    int climbStairs(int n) {\\n\\n        int sum=0;\\n        map<vector<int> , int>mp;\\n        vector<int>inp;\\n        int c=0;\\n        solve(n , inp , sum ,c ,mp);\\n        return c;\\n        \\n    }\\n};\\n\\n\\n// how to control TLE?"
                    },
                    {
                        "username": "khalid_4th",
                        "content": "Please add Github sharing also by which  we can create repo and share our solutions on github"
                    },
                    {
                        "username": "19ucs235",
                        "content": "[leetcode](https://leetcode.com) `your inline"
                    },
                    {
                        "username": "ankitaniket",
                        "content": "    static int[] arr = new int[46];\\n\\n    public int climbStairs(int n) {\\n          if(n == 0){\\n            return 1;\\n        }\\n        if(n < 0){\\n            return 0;\\n        }\\n\\n        if(arr[n] != 0){    // using concept of dp and \\n            return arr[n];  //check if the problem is already solved.\\n        }\\n\\n        int p1 = climbStairs(n-1);\\n        int p2 = climbStairs(n-2);\\n\\n        arr[n] = p1 + p2;\\n\\n        return p1 + p2;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "user0467H",
                        "content": "I find this little similar to coin change problem .. "
                    }
                ]
            },
            {
                "id": 1685816,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1683672,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1681575,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1679574,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1675424,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1670220,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1668813,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1665161,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1664945,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            },
            {
                "id": 1663491,
                "content": [
                    {
                        "username": "manojkumar531564",
                        "content": "without Dynamic programming, using recursion\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n\\tif(n==0){\\n\\t   return 1;\\n\\t}\\n    else if(n<0){\\n        return 0; \\n    }\\n    int result=0;\\n\\tfor(int i=1; i<=2 ; i++){\\n        result = result + climbStairs(n-i);\\n\\t}\\n    return result;\\n}\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "amanchopra2003",
                        "content": "(Only 11 Lines code) Best Solution(Java) Tabulation(Bottom-Up Approach)\\n\\nclass Solution {\\n    public int climbStairs(int n) {\\n        n=n+1;\\n        int f[];\\n        f=new int[n+1];\\n        f[0]=0;\\n        f[1]=1;\\n        for(int i=2;i<=n;i++){\\n            f[i]=f[i-1]+f[i-2];\\n        }\\n        return f[n]; }}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VBekasovs",
                        "content": "Unfortunately, recursion fails on 43 steps :( "
                    },
                    {
                        "username": "abytespaceneeded",
                        "content": "```\\n// recursive \\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        return climbStairs(n-1) + climbStairs(n-2);\\n    }\\n};\\n```\\n\\n```\\n// memoization\\nclass Solution {\\npublic:\\n    int climbStairsHelper(int n, vector<int> &dp) {\\n        if(n == 0) return 1;\\n        if(n < 0) return 0;\\n\\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = climbStairsHelper(n-1, dp) + climbStairsHelper(n-2, dp);\\n    }\\n\\n    int climbStairs(int n) {\\n        vector<int> dp(n+1, -1);\\n        return climbStairsHelper(n, dp);\\n    }\\n};\\n```\\n\\n```\\n// tabulation\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        vector<int> dp(n+2, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for(int i=2;i<=n;i++) {\\n            dp[i] = dp[i-1] + dp[i-2];\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\n// space optimized\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        int a = 1, b = 1, c = 0;\\n\\n        for(int i=2;i<=n;i++) {\\n            c = a + b;\\n            a = b;\\n            b = c;\\n        }\\n        return b;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "hhw215",
                        "content": "Thought it\\'s a brilliant way of logical thinking but it\\'s not working lol....\\n\\nfor the stairs of n-steps, we can take i times of 2-steps which can be from 0 to n/2, then of 1-step walk we should take exactly j = n - 2*i times;\\n\\nwhile (i,j) is different the way is changed, so for every possible (i,j) i calculate the possible COMBINATION methods, it should be (i+j)!/i!*j!\\n\\nI think to make sense but it doesn\\'t give me the right answer.... I even manually tested this method it should work?\\n \\n`class Solution {\\n    public int climbStairs(int n) {\\n        if(n == 1) return 1;\\n        if(n == 2) return 2;\\n        int count = 0;\\n\\n        for(int i = 0; i <= n/2; i++){\\n            int j = n - i*2;\\n            int res = 1;\\n            for(int k = 1; k <= n - i; k++){\\n                res *= k;  \\n            }\\n            for(int k = 1; k <= i; k++){\\n                res /= k;  \\n            }\\n            for(int k = 1; k <= n - 2*i; k++){\\n                res /= k;  \\n            }\\n            count += res;\\n        }\\n        return count;\\n    }\\n}`"
                    },
                    {
                        "username": "dheerendra123",
                        "content": "```\\nclass Solution\\n{\\n    public int climbStairs(int n)\\n    {\\n\\n        if(n<=2)\\n            return n;\\n        int a= 1;\\n        int b = 2;\\n        for(int i = 3; i<=n; i++)\\n        {\\n            \\n            int sum = a+b;\\n            a = b;\\n            b = sum;\\n                \\n        }\\n        return b;\\n    \\n    }\\n\\n}\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bhuvanpolimera1998",
                        "content": "class Solution:\\n    def climbStairs(self, n: int) -> int:\\n        a,b=1,1\\n        if n==1:\\n            return n\\n        for i in range(n-1):\\n            c=a+b\\n            a=b\\n            b=c\\n        return c"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mattkins99",
                        "content": "It matches the Fibonacci sequence because the stair climber is constrained to only taking at most two steps at a time, meaning at any given step there are only two possible steps the stair climber could have come from which just happens to be how the Fibonacci sequence works.  If the stair climber was allowed to take up to 3 steps at a time, the logic is still basically the same, but it no longer fits the Fibonacci pattern.  1,1, 2, 4, 7, 13, 23, 43......"
                    },
                    {
                        "username": "20032000Gk",
                        "content": "Hi,\\nAs a beginner spending some time I solved this problem by using the fibonacci but it will give time complexity but we can go with the memorization concept that will help you to decries the time complexity. #GK"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I think it\\'s weird that, in JavaScript at least, you cannot even use arrays at all.\\nYou get out of memory even for using an array with a couple of elements.\\nThis is a pretty neat constraint, and I enjoyed solving the puzzle, but it would make more sense if you could answer this in a wider variety of ways."
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Sum III - Data structure design",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566759,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1568994,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1568462,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            },
            {
                "id": 1573404,
                "content": [
                    {
                        "username": "boa1150",
                        "content": "I copied and pasted solution directly from Handbook, but it returns TLE for the long input test case. The test case is too long to paste here. Please fix it."
                    },
                    {
                        "username": "OldCodingFarmer",
                        "content": "I tried many times to solve this problem using Python, always TLE, is there anyone who knows how to solve it? Thanks."
                    },
                    {
                        "username": "hiepit",
                        "content": "Following is constraint from Leetcode (last updated 08/10/2020):\\n\\n**Constraints:**\\n- `-10^5 <= number <= 10^5`\\n- `-2^31 <= value <= 2^31 - 1`\\n- At most `5 * 10^4` calls will be made to add and find.\\n\\n**Time complexity** of Official Solution and other discussions are `O(1)` for `Add`, `O(N)` for `Find`. I wonder if I have the testcase:  \\n- Call `Add` to add `2*10^4` different numbers\\n- Call `Find` `3*10^4` times.\\n=> Each of `Find` operation take O(N) ~ `2*10^4` times\\n=> Total = `(3*10^4) * (2*10^4) = 6 * 10^8`\\n=> `Time Limit Exceeded!` occurs.\\n\\nSo I wonder, if the constraint is correct for this problem?"
                    },
                    {
                        "username": "NelzkieCoder",
                        "content": "Both solution when submitted will result in error."
                    }
                ]
            }
        ]
    },
    {
        "title": "Closest Binary Search Tree Value",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1880668,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1571514,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 2056836,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1968665,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            },
            {
                "id": 1685046,
                "content": [
                    {
                        "username": "caspar123456",
                        "content": "this one comes with bug"
                    },
                    {
                        "username": "jasonBourneAgain",
                        "content": "For example, if all the values in the BST are negative integer, and the input double value is Double.MAX_VALUE as shown below:\\n\\n[-4, -6, -2, -7, -5, -3, -1]\\n179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0\\n\\nHow will that affect the result of a recursive solution without checking potential overflow issue?"
                    },
                    {
                        "username": "chinu97",
                        "content": "Why wouldnt this heap solution pass all test cases\\n```import heapq\\nclass Solution:\\n    def closestValue(self, root: Optional[TreeNode], target: float) -> int:\\n        closestValueToRootStack=[]\\n        def dfs(root,target):\\n            if not root: \\n                return\\n            if target>root.val:\\n                dfs(root.right,target)\\n            elif target<root.val:\\n                dfs(root.left,target)\\n            else:\\n                return \\n            heapq.heappush(closestValueToRootStack,(abs(target-root.val),root.val))\\n            return \\n        dfs(root,target)\\n        return heapq.heappop(closestValueToRootStack)[1]```"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Please note:\\n\\nThe editorial solutions to this question fail test cases"
                    },
                    {
                        "username": "Batman01",
                        "content": "`class Solution {\n\nprivate:\n\n    void dfs(TreeNode* root, double target, int& rootKey){\n\n        if(!root)\n            return;\n\n        if(abs(root->val - target) < abs(target - rootKey)){\n            rootKey = root->val;\n        }\n\n        if(root->val > target){\n            dfs(root->left, target, rootKey);\n        }\n        else{\n            dfs(root->right, target, rootKey);\n        }\n    }\n\npublic:\n    int closestValue(TreeNode* root, double target) {\n        \n        int rootKey;\n        dfs(root, target, rootKey);\n        // cout << rootKey << endl;\n        return rootKey;\n    }\n};`\n\nThe above code is not working.\nStrangely, as soon as remove comment from cout line it starts failing, what might be the issue here?\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "hey, (if you have already found the solution to this then please ignore).....\nin your case, the wrong output is because you didn't initialize the rootKey variable with some value, hence it is taking garbage value. if you do something like this \n`int rootKey = -1; `, then you wont get this error.\nAlso the code has some other errors too, and it won't pass all test cases."
                    }
                ]
            }
        ]
    },
    {
        "title": "Range Addition",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565138,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1569272,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1817516,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 1573554,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            },
            {
                "id": 2017489,
                "content": [
                    {
                        "username": "willcomeback",
                        "content": "Just use the first position and the __last + 1__ position. The last + 1 position add the opposite value. So when you add the numbers from start to end you will have correct result."
                    },
                    {
                        "username": "305326653",
                        "content": "Same as title.\\n\\nIf someone comeup with the optimized solution by your own, please share your thought ! "
                    },
                    {
                        "username": "ryabkin",
                        "content": "Search and learn \"Line Sweep\" algorithm and what is prefix sum, try to apply.  if still stuck try to solve this first https://leetcode.com/problems/maximum-population-year and check alternative ways of solving it in solutions section"
                    },
                    {
                        "username": "jventura3",
                        "content": "Thanks for this!"
                    },
                    {
                        "username": "kkzeng",
                        "content": "I want to try applying this concept to other problems. Surprisingly, this is the first time I\\'ve been exposed to caching in this form."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This problem is the  same as Leetcode-1109 Corporate Flight Bookings.  Other Line Sweep problem: 253. Meeting Rooms II"
                    }
                ]
            }
        ]
    },
    {
        "title": "Implement Rand10() Using Rand7()",
        "question_content": "<p>Given the <strong>API</strong> <code>rand7()</code> that generates a uniform random integer in the range <code>[1, 7]</code>, write a function <code>rand10()</code> that generates a uniform random integer in the range <code>[1, 10]</code>. You can only call the API <code>rand7()</code>, and you shouldn&#39;t call any other API. Please <strong>do not</strong> use a language&#39;s built-in random API.</p>\n\n<p>Each test case will have one <strong>internal</strong> argument <code>n</code>, the number of times that your implemented function <code>rand10()</code> will be called while testing. Note that this is <strong>not an argument</strong> passed to <code>rand10()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [2,8]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [3,8,10]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What is the <a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">expected value</a> for the number of calls to <code>rand7()</code> function?</li>\n\t<li>Could you minimize the number of calls to <code>rand7()</code>?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 150301,
                "title": "three-line-java-solution-the-idea-can-be-generalized-to-implement-randm-using-randn",
                "content": "Idea: ```rand7()``` -> ```rand49()``` -> ```rand40()``` -> ```rand10()```\\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n}\\n```\\n#\\n### **Time Complexity**\\n#\\nThe total number of iterations follows **geometric distribution**. For each iteration in the ```while``` loop, the probabilty of exiting the loop is *p* = 40/49. So the average time complexity T(n) = O(1/*p*) = O(49/40) = O(1).\\n#\\n### **Correctness**\\n#\\nNote that rand49() generates a uniform random integer in [1, 49], so any number in this range has the same probability to be generated. Suppose *k* is an integer in range [1, 40], *P*(```rand49()``` = *k*) = 1/49.\\n\\n&nbsp;&nbsp;&nbsp;*P*(result = *k*)\\n= *P*(```rand49()``` = *k* in the 1st iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` = *k* in the 2nd iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` > 40 in the 2nd iteration) * *P*(```rand49()``` = *k* in the 3rd iteration) +\\n&nbsp;&nbsp;&nbsp;*P*(```rand49()``` > 40 in the 1st iteration) * *P*(```rand49()``` > 40 in the 2nd iteration) * *P*(```rand49()``` > 40 in the 3rd iteration) * *P*(```rand49()``` = *k* in the 4th iteration) +\\n&nbsp;&nbsp;&nbsp;...\\n= (1/49) + (9/49) * (1/49) + (9/49)^2 * (1/49) + (9/49)^3 * (1/49) + ...\\n= (1/49) * [1 + (9/49) + (9/49)^2 + (9/49)^3 + ... ]\\n= (1/49) * [1/(1-9/49)]\\n= (1/49) * (49/40)\\n= 1/40\\n#\\n### **Generalization**\\n#\\nImplement ```randM()``` using ```randN()``` when M > N:\\n**Step 1:** Use ```randN()``` to generate ```randX()```, where X >= M. In this problem,  I use ```7 * (rand7() - 1) + (rand7() - 1)``` to generate ```rand49() - 1```.\\n**Step 2:** Use ```randX()``` to generate ```randM()```. In this problem,  I use ```rand49()``` to generate ```rand40()``` then generate ```rand10```.\\n\\n**Note:** ```N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1)``` generates ```randX() - 1```, where ```X = N^(b + 1)```.\\n#\\n### **More Examples**\\n#\\n(1) Implement ```rand11()``` using ```rand3()```: \\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\\nIdea: ```rand3()``` -> ```rand27()``` -> ```rand22``` -> ```rand11```\\nTime Comlexity: O(27/22)\\n# \\n(2) Implement ```rand9()``` using ```rand7()```: \\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\\nIdea: ```rand7()``` -> ```rand49()``` -> ```rand45()``` -> ```rand9()```\\nTime Comlexity: O(49/45)\\n# \\n(3) Implement ```rand13()``` using ```rand6()```: \\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\\nIdea: ```rand6()``` -> ```rand36()``` -> ```rand26``` -> ```rand13()```\\nTime Comlexity: O(36/26)",
                "solutionTags": [],
                "code": "```rand7()```\n```rand49()```\n```rand40()```\n```rand10()```\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n}\\n```\n```while```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```rand49()```\n```randM()```\n```randN()```\n```randN()```\n```randX()```\n```7 * (rand7() - 1) + (rand7() - 1)```\n```rand49() - 1```\n```randX()```\n```randM()```\n```rand49()```\n```rand40()```\n```rand10```\n```N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1)```\n```randX() - 1```\n```X = N^(b + 1)```\n```rand11()```\n```rand3()```\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\n```rand3()```\n```rand27()```\n```rand22```\n```rand11```\n```rand9()```\n```rand7()```\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\n```rand7()```\n```rand49()```\n```rand45()```\n```rand9()```\n```rand13()```\n```rand6()```\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\n```rand6()```\n```rand36()```\n```rand26```\n```rand13()```",
                "codeTag": "Unknown"
            },
            {
                "id": 151567,
                "title": "c-java-python-1-183-call-of-rand7-per-rand10",
                "content": "# Solution 0: Easy Solution with random 49\\n\\n`rand7()` will get random 1 ~ 7\\n`(rand7() - 1) * 7 + rand7() - 1` will get random 0 ~ 48\\nWe discard `40 ~ 48`, now we have `rand40` equals to random 0 ~ 39.\\nWe just need to return `rand40 % 10 + 1` and we get random 1 ~ 10.\\n\\nIn `9/49` cases, we need to start over again.\\nIn `40/49` cases, we call `rand7()` two times.\\n\\nOverall, we need `49/40*2 = 2.45` calls of `rand7()` per `rand10()`.\\n\\n\\n**Java:**\\n```java\\n    public int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def rand10(self):\\n        rand40 = 40\\n        while rand40 >= 40:\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1\\n        return rand40 % 10 + 1\\n```\\n<br>\\n\\n# **Intuition of Improvement**:\\nSolution 0 is a good answer and you may pass a interview with this solution.\\nThe average call of `rand7` here is 2.45 calls.\\n\\nHowever, we may think about, what is the limit?\\nIs that possible to get an average of 2 calls.\\n<br>\\n\\n# **What is the Limit**\\nIt may seem impossible, but unfortunately, even average 2 is still far from the best answer.\\n\\nThe problem is that you generate 49 random states, waste 9 of them.\\nAnd we arrange the rest 40 states into 10 states.\\nYou can see that in that solution,\\n80% of random states waste and we satisfy with only 20% efficiency.\\n\\nDid a quick math for the limit `log10 / log7 = 1.1833`,\\nwhich lead me to find the following solution.\\n<br>\\n\\n# **Solution 1: instead of 49, we use bigger pow of 7**:\\n\\n`rand10()` will consume the generated random integer from stack `cache`.\\nIf `cache` is empty, it will call function `generate()`.\\n\\nIn `generate()`, it will generate an integer in range `[0, 7^19]`.\\n7^19 = 11398895185373143, and close to an pow of 10.\\nSo in 11398895185373140 / 11398895185373143 = 99.99999999999997% cases, it will generate at least 1 integer.\\nAnd in 10000000000000000 / 11398895185373143 = 87.73% cases, it will generate 16 integers.\\n\\n`N = 19` is the best we can choose in long integer range,\\nand `N = 7` is another good choice for 32 bits integer range.\\n\\nThis solution got average 1.199 calls, it\\'s really close to theoretic limit.\\n\\n**C++:**\\n```cpp\\n    stack<int> cache;\\n    int rand10() {\\n        while (cache.size() == 0) generate();\\n        int res = cache.top(); cache.pop();\\n        return res;\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = long(pow(7, n));\\n        for (int i = 0; i < n; ++i) cur += long(pow(7, i)) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push(cur % 10 + 1);\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\\n\\n**Java:**\\n```java\\n    Stack<Integer> cache = new Stack<Integer>();\\n    public int rand10() {\\n        while (cache.empty()) generate();\\n        return cache.pop();\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = (long)Math.pow(7, n);\\n        for (int i = 0; i < n; ++i) cur += (long)Math.pow(7, i) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push((int)(cur % 10 + 1));\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\\n**Python:**\\n```python\\n    cache = []\\n    def rand10(self):\\n        while not self.cache: self.generate()\\n        return self.cache.pop()\\n\\n    def generate(self):\\n        n = 19  # 1.199\\n        cur = sum((self.rand7() - 1) * (7**i) for i in range(n))\\n        rang = 7 ** n\\n        while cur < rang / 10 * 10:\\n            self.cache.append(cur % 10 + 1)\\n            cur /= 10\\n            rang /= 10\\n```\\n\\n\\n# Solution 2: No need to decide the pow in advance\\nSomeone may have a concern,\\nhow can we find a magic pow like 19 or 7?\\n\\nActually, we don\\'t need to.\\nContinue to improve the solution 1,\\nwe cache a big random number.\\nAnd when we need a rand10, we take a part from it.\\n\\n**Python**\\n```py\\n    cache, upper = 0, 1\\n    def rand10(self):\\n        cache, upper = self.cache, self.upper\\n        while upper < 10**9:\\n            cache, upper = cache * 7 + self.rand7() - 1, upper * 7\\n        res = cache % 10 + 1\\n        self.cache, self.upper = cache / 10, upper / 10\\n        self.count10 += 1  # test\\n        self.count[res] += 1  # test\\n        return res\\n```\\nThis solution will achieve 1.183 calls of `rand7()` per `rand10()`.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\n```cpp\\n    int rand10() {\\n        int rand40 = 40;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n```\n```python\\n    def rand10(self):\\n        rand40 = 40\\n        while rand40 >= 40:\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1\\n        return rand40 % 10 + 1\\n```\n```cpp\\n    stack<int> cache;\\n    int rand10() {\\n        while (cache.size() == 0) generate();\\n        int res = cache.top(); cache.pop();\\n        return res;\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = long(pow(7, n));\\n        for (int i = 0; i < n; ++i) cur += long(pow(7, i)) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push(cur % 10 + 1);\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\n```java\\n    Stack<Integer> cache = new Stack<Integer>();\\n    public int rand10() {\\n        while (cache.empty()) generate();\\n        return cache.pop();\\n    }\\n\\n    void generate() {\\n        int n = 19;\\n        long cur = 0, range = (long)Math.pow(7, n);\\n        for (int i = 0; i < n; ++i) cur += (long)Math.pow(7, i) * (rand7() - 1);\\n        while (cur < range / 10 * 10) {\\n            cache.push((int)(cur % 10 + 1));\\n            cur /= 10;\\n            range /= 10;\\n        }\\n    }\\n```\n```python\\n    cache = []\\n    def rand10(self):\\n        while not self.cache: self.generate()\\n        return self.cache.pop()\\n\\n    def generate(self):\\n        n = 19  # 1.199\\n        cur = sum((self.rand7() - 1) * (7**i) for i in range(n))\\n        rang = 7 ** n\\n        while cur < rang / 10 * 10:\\n            self.cache.append(cur % 10 + 1)\\n            cur /= 10\\n            rang /= 10\\n```\n```py\\n    cache, upper = 0, 1\\n    def rand10(self):\\n        cache, upper = self.cache, self.upper\\n        while upper < 10**9:\\n            cache, upper = cache * 7 + self.rand7() - 1, upper * 7\\n        res = cache % 10 + 1\\n        self.cache, self.upper = cache / 10, upper / 10\\n        self.count10 += 1  # test\\n        self.count[res] += 1  # test\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 338395,
                "title": "in-depth-straightforward-detailed-explanation-short-java-solution",
                "content": "Inspired by Vivekanand Kiruban from [link](https://www.quora.com/How-do-you-design-a-rand7-function-using-a-rand5-function).\\n\\nThere are three concepts in geometric distribution you need to know before you solve these kind of questions. They are very easy to understand.\\n\\n# Expanding a zero-based `random`\\n\\nLet\\'s say you have a `random10` which return a number from 0 to 9. How would you build `random100` which return from 0 to 99? \\nYou can call `random10` to generate each digit.  Specifically, `10*random10()` will generate the tens\\' place for a two digit number, and `1*random10()` will generate the ones\\' place. Then the biggest number `10*random10() + 1*random10()`  could produce is 10*9+1*9 = 99. The smallest number is `0`\\n```\\nrandom100 = 10*random10() + 1*random10()\\nrandom1000 = 100*random10() + 10*random10() + 1*random10()\\n```\\n\\nIf we change our definition of `random`, now `random10` will return a number from 1 to 10. Can we use the above formula to generate `random100`(1 to 100)? \\n\\nThe answer is **NO**.\\n\\nIf you think about it, the `10*random10() + 1*random10()` can only return a number from ~~2 to 101~~ 11 to 110., instead of 1 to 100.\\n\\nYou need to tweak the formula a little bit. Specifically, you need to zero-based your `random`.\\n\\n```\\nrandom100 = 10*(random10()-1) + 1*(random10()-1) + 1\\n```\\n\\nNotice that we need to `add 1` in the end because `10*(random10()-1) + 1*(random10()-1)` will result in a number from 0 to 99, and what we want is actually 1 to 100.\\n\\n# Discarding and Rolling again\\nIf you have a 6 sided dice and want to use it determine \"Head or Tail\" using this side, and if you get 1, say heads, if you get 2, say tails, and if you get anything else, you discard them by rolling again. This approach will guarantee an equivalent to H/T, but notice you may be rolling the die many times.\\n\\n# Folding to Map\\nIn the above example of dice, an another solution you have is mapping the other values into `H` or `T`. For example, 1,2,3 (= heads), 4,5,6 (= tails). When it comes to implementation, we can use module operator to do that.\\nE.g,\\n```\\nrandom3 = random6 % 3 // Assuming the random here is zero-based\\n```\\n\\n# Use the three concepts\\nWhat we have right now is 1-based random7, and we need to generate random10. Here are the steps we gonna go through:\\n1. zero-based `random7`: `random7-1`(0..6)\\n2. expanding zero-based `random7` to zero-based `random49`: `(random7-1)*7 + (random7-1)`\\n3. discarding the number over 40 by rolling again, then we get zero-based `random40`: \\n\\t```\\n\\twhile(random40>=40){\\n\\t\\trandom40 = (random7-1)*7 + (random7-1)\\n\\t}\\n\\t```\\n4. folding zero-based `random40` to one-based `random10`\\n\\t```\\n\\trandom10 = random40%10+1\\n\\t```\\n\\n\\nThe complete code:\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int rand40 = Integer.MAX_VALUE;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nrandom100 = 10*random10() + 1*random10()\\nrandom1000 = 100*random10() + 10*random10() + 1*random10()\\n```\n```\\nrandom100 = 10*(random10()-1) + 1*(random10()-1) + 1\\n```\n```\\nrandom3 = random6 % 3 // Assuming the random here is zero-based\\n```\n```\\n\\twhile(random40>=40){\\n\\t\\trandom40 = (random7-1)*7 + (random7-1)\\n\\t}\\n\\t```\n```\\n\\trandom10 = random40%10+1\\n\\t```\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int rand40 = Integer.MAX_VALUE;\\n        while (rand40 >= 40) {\\n            rand40 = (rand7() - 1) * 7 + rand7() - 1;\\n        }\\n        return rand40 % 10 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816210,
                "title": "python-rejection-sampling-2-lines-explained",
                "content": "What we can do here is to generate numbers between `1` and `7` and this makes this problems both easy and difficult. Easy, because you do not have a lot of choice what to do, difficult, because we need to use not very big number of generations. Can we use one number between `1` and `7` to generate number between `1` and `10`? I do not think so, we have very small choice. Can we use `2`? Yes, we can, here is the strategy:\\n1. Generate `a` from `1` to `7` and `b` from `1` to `7`, then we have `7x7 = 49` options. Let us create number `c = (a-1)*7 + b-1`, then we can show that `c` is number between `0` and `48`: substitute all possible values for `a` and `b` and you will see. \\n2. Now, let us divide these number into groups: `[0,9]; [10;19]; [20;29]; [30;39]; [40;48]`. If we get into one of the first four group we are happy: there is ten number in each group, so we just return `c%10 + 1`.\\n3. If we are in the fifth group, we are not happy, there are only `9` numbers in this group and we need `10`, use `9` is not fair. So in these case, we say, that our experiment was not working, and we just start it all over again! That is all.\\n\\n**Complexity**: what we do here is called sampling with rejection. Success of first sampling is `p = 40/49`. If first time our sampling was not working and it worked second time we have `(1-p)*p`, if it worked third time it is `(1-p)*(1-p)*p` and so on. Each time we use two `rand7()` generation. So, overall our **expectation** is `2*p + 4*(1-p)*p + 6*(1-p)^2*p + ...` How to compute it? Note, that it is nothing else than geometrical distribution: https://en.wikipedia.org/wiki/Geometric_distribution, so the answer is just `2/p` = `98/40 = 2.45`.\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        c = (rand7() - 1)*7 + rand7() - 1\\n        return self.rand10() if c >= 40 else (c % 10) + 1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        c = (rand7() - 1)*7 + rand7() - 1\\n        return self.rand10() if c >= 40 else (c % 10) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373574,
                "title": "adding-two-random-numbers-won-t-produce-a-uniformly-distributed-new-random-number",
                "content": "A very important fact here is, adding two random numbers won\\'t make a new random number that is uniformly distributed.\\ne.g. \\nrandom1: 0~3\\nrandom2: 1~7\\nrandom1+random2 doesn\\'t make a random 1~10\\nThe combinations of random1 and random2 are uniformly distributed, but their sum are not, because some different combinations can have the same sum, this increases the probability of certain sum values.\\n\\nHowever, we can make a uniformly distributed 49 from random 7 this way:\\n(random7-1)\\\\*7+random7\\n\\nActually for any random \"n\":\\n\"(randomN-1)\\\\*n+randomN\" is uniformly distributed random n^2.\\n\\nAlso be aware that \"mod\" operation on a random doesn\\'t guarante a uniformly distributed result either. \"randomN%m\" is uniformly distributed only when n%m==0, that\\'s why rand40%10 works here.\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        rand40=40\\n        while rand40>=40:\\n            rand40=(rand7()-1)*7+rand7()-1\\n        return rand40%10+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        rand40=40\\n        while rand40>=40:\\n            rand40=(rand7()-1)*7+rand7()-1\\n        return rand40%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150312,
                "title": "easy-solution",
                "content": "```\\nint rand10() {\\n    int i,j;\\n    while( (i = rand7()) > 6);  // P(i is even) = P(i is odd) = 0.5\\n    while( (j = rand7()) > 5);  // P(j==1) = P(j==2) = P(j==3) = P(j==4) = P(j==5) = 0.2\\n    return (i&1) ? j : j+5;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n    int i,j;\\n    while( (i = rand7()) > 6);  // P(i is even) = P(i is odd) = 0.5\\n    while( (j = rand7()) > 5);  // P(j==1) = P(j==2) = P(j==3) = P(j==4) = P(j==5) = 0.2\\n    return (i&1) ? j : j+5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 322262,
                "title": "intuition-for-magic-number-40",
                "content": "Please go through https://leetcode.com/problems/implement-rand10-using-rand7/solution/ first.\\n![image](https://assets.leetcode.com/users/naveenkothamasu/image_1561741290.png)\\n*Credit*: https://leetcode.com/problems/implement-rand10-using-rand7/solution/\\n\\nNow, we have 49 cells and we want to randomly pick a number from 1 to 10. That means, any number from 1 to 10 should have equal chance of being picked that is `1/10`.\\nBut we have 49 cells and only 10 numbers, so only way for uniform distribution is to number them by repeating the 1 to 10 sequences but after 40, we do not have enough cells to complete the 1 to 10 sequnce.\\nUp to 40, we have four 1\\'s and four 2\\'s...four 10\\'s so they all have equal chance namely `4/40`. So we have to discard in order to not skew the distribution (without this part, it is not fair for 8, 9, 10 as they have smaller chance compared to numbers from 1 to 7).\\n\\n```\\npublic int rand10() {\\n        int r = 0, c = 0, num = 0;\\n        do{\\n            r = rand7();\\n            c = rand7();\\n            num = c+(r-1)*7;\\n        }while(num > 40);\\n        return 1 + num % 10;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rand10() {\\n        int r = 0, c = 0, num = 0;\\n        do{\\n            r = rand7();\\n            c = rand7();\\n            num = c+(r-1)*7;\\n        }while(num > 40);\\n        return 1 + num % 10;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816213,
                "title": "c-simple-2-steps-solution-explained-100-time-60-space",
                "content": "My main intuition was that `7 == 2 + 5` and `2 * 5 == 10`.\\n\\nSeems still too abstract (or absurd)? Bear with me!\\n\\nFirst of all we declare 2 variables, `n` and `m`, settimg them initially to be `rand7()` and `7`.\\n\\nThen we make sure tha `n` is only in the `1 - 5` range and, if not, we regenerate it and assign `n - 5` to `m`, that thus would be in the `1 - 2` range. Notice that in this way `n` and `m` have the same probabiliy of still being each specific number in their own range.\\n\\nIn the second loop, we make sure that `m` has a `1 - 6` value, with similar logic of regenerating numbers until we need them.\\n\\nFinally we return `n` + either `0` or `5`, depending if `m` is even or odd, respectively.\\n\\nThis gives us perfectly distributed numbers :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    int rand10() {\\n        // initialising the values\\n\\t\\tn = rand7(), m = 7;\\n        // making sure n is in the right 1-5 range and, if we can, we settle m too\\n\\t\\twhile (n > 5) {\\n            m = n - 5;\\n            n = rand7();\\n        }\\n        // if m was not settled, we do it here\\n\\t\\twhile (m == 7) m = rand7();\\n        return (m % 2 ? 5 : 0) + n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int n, m;\\n    int rand10() {\\n        // initialising the values\\n\\t\\tn = rand7(), m = 7;\\n        // making sure n is in the right 1-5 range and, if we can, we settle m too\\n\\t\\twhile (n > 5) {\\n            m = n - 5;\\n            n = rand7();\\n        }\\n        // if m was not settled, we do it here\\n\\t\\twhile (m == 7) m = rand7();\\n        return (m % 2 ? 5 : 0) + n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175450,
                "title": "java-solution-explain-this-problem-with-2d-matrix",
                "content": "```\\npublic int rand10() {\\n        while (true) {\\n            int num = (rand7() - 1) * 7 + (rand7() - 1);\\n            if (num < 40) {\\n                return num % 10 + 1;\\n            }\\n        }\\n    }\\n```\\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    10   11   12   13\\n2    14   15   16   17   18   19   20\\n3    21   22   23   24   25   26   27\\n4    28   29   30   31   32   33   34\\n5    35   36   37   38   39   40   41\\n6    42   43   44   45   46   47   48\\n```\\nwe just do the mod operation in the first 40 element\\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    0    1    2    3\\n2    4    5    6    7    8    9    0\\n3    1    2    3    4    5    6    7\\n4    8    9    0    1    2    3    4\\n5    5    6    7    8    9    0    X\\n6    X    X    X    X    X    X    X\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int rand10() {\\n        while (true) {\\n            int num = (rand7() - 1) * 7 + (rand7() - 1);\\n            if (num < 40) {\\n                return num % 10 + 1;\\n            }\\n        }\\n    }\\n```\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    10   11   12   13\\n2    14   15   16   17   18   19   20\\n3    21   22   23   24   25   26   27\\n4    28   29   30   31   32   33   34\\n5    35   36   37   38   39   40   41\\n6    42   43   44   45   46   47   48\\n```\n```\\n     0    1    2    3    4    5    6\\n0    0    1    2    3    4    5    6\\n1    7    8    9    0    1    2    3\\n2    4    5    6    7    8    9    0\\n3    1    2    3    4    5    6    7\\n4    8    9    0    1    2    3    4\\n5    5    6    7    8    9    0    X\\n6    X    X    X    X    X    X    X\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817311,
                "title": "java-code-with-comments-explained-for-begineer-like-me",
                "content": "* ***Please upvote if helpful!!***\\n* This approach is known as rejection sampling.\\n```\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n      \\n        //we try to pick values in the range from 7 * 7 = 49 values\\n        //as we want 1 - 10 uniform random values. we can only go till 40 as\\n        //41- 49 only has 9 numbers and hence our uniformity will be broken.\\n        \\n        int column = rand7();\\n        int row = rand7();\\n\\n        int val = (column) + (row - 1) * 7; // if u make a grid of 7 * 7 u will observe that values from all the columns are possible\\n        // and value from last row is not possible as it belongs in the range greater than 40.\\n        //we find the value using the above formula column + (row - 1) * 7.\\n        \\n        if (val <= 40) {\\n            return (val - 1) % 10 + 1; // this needs to be done to handle edge case if we encounter 10. if we just do 10 % 10 we get 0. and we want 1-10.\\n        } else {\\n            return rand10(); //recursive call if we dont find value less than or equal to 40 for uniform distribution.\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n      \\n        //we try to pick values in the range from 7 * 7 = 49 values\\n        //as we want 1 - 10 uniform random values. we can only go till 40 as\\n        //41- 49 only has 9 numbers and hence our uniformity will be broken.\\n        \\n        int column = rand7();\\n        int row = rand7();\\n\\n        int val = (column) + (row - 1) * 7; // if u make a grid of 7 * 7 u will observe that values from all the columns are possible\\n        // and value from last row is not possible as it belongs in the range greater than 40.\\n        //we find the value using the above formula column + (row - 1) * 7.\\n        \\n        if (val <= 40) {\\n            return (val - 1) % 10 + 1; // this needs to be done to handle edge case if we encounter 10. if we just do 10 % 10 we get 0. and we want 1-10.\\n        } else {\\n            return rand10(); //recursive call if we dont find value less than or equal to 40 for uniform distribution.\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816927,
                "title": "python-generalised-solution-for-randm-using-randn",
                "content": "**Solution for creating rand10() using rand7()**\\n\\n```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = 40\\n        while curr >= 40:\\n            curr = (rand7() - 1) * 7 + rand7() - 1\\n        return curr % 10 + 1\\n```\\n    \\n**Generalised solution for creating randM() using randN()**\\n\\n```python\\n# The randN() API is already defined for you.\\n# def randN():\\n# @return a random integer in the range 1 to M\\n\\nclass Solution:\\n    def randM(self, N, M):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # acceptable is the desired range which can generate required integer directly\\n        curr = acceptable = N * N - (N * N) % M \\n        # if current no is not in the acceptable range, discard it and repeat the process again\\n        while curr >= acceptable:\\n            curr = (randN() - 1) * N + randN() - 1\\n        return curr % M + 1\\n\\t\\t\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        curr = 40\\n        while curr >= 40:\\n            curr = (rand7() - 1) * 7 + rand7() - 1\\n        return curr % 10 + 1\\n```\n```python\\n# The randN() API is already defined for you.\\n# def randN():\\n# @return a random integer in the range 1 to M\\n\\nclass Solution:\\n    def randM(self, N, M):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # acceptable is the desired range which can generate required integer directly\\n        curr = acceptable = N * N - (N * N) % M \\n        # if current no is not in the acceptable range, discard it and repeat the process again\\n        while curr >= acceptable:\\n            curr = (randN() - 1) * N + randN() - 1\\n        return curr % M + 1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278864,
                "title": "470-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named rand10() that takes no arguments and returns an integer between 1 and 10.\\n2. Use a while loop that runs indefinitely until a suitable random number is generated.\\n3. Within the loop, use the rand7() function twice to generate a random number num in the range [1, 49].\\n4. Check if num is within the range [1, 40]. If not, continue to the next iteration of the while loop.\\n5. If num is within the range [1, 40], exit the while loop and return a value between 1 and 10.\\n6. To obtain the random integer within the range [1, 10], use the modulus operator to find the remainder of dividing num by 10 and add 1 to the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice\\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus\\n        return num % 10 + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice\\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus\\n        return num % 10 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151045,
                "title": "generalize-implement-randm-using-randn",
                "content": "## Idea\\n\\nMore general case for this kind of problem is this: \\n\\nSuppose we are given `randM()` which generates `[1, 2, ..., M]`, we want to generate `randN()` which generates `[1, 2, ..., N]`. Here are different cases:\\n\\n1. if N < M, then we can select 1, 2, ..., N, ~~N+1, N+2, ..., M~~ from `randM()`, as we know that `[1, 2, ..., N]` each with prob `1/M`, since the algorithm terminates when the generated number less than `N+1`. Hence we have the uniform distribution. \\n2.  M < N < M^2, then we can construct `randM^2() = M * (randM()-1) + randM()`, still we can select 1, 2, M, ..., N, ~~N+1, N+2, ..., M^2~~, as we know that `[1, 2, ..., N]` each with prob `1/M^2`, since the algorithm terminates when the generated number less than `N+1`. Hence we have the uniform distribution. \\n3. ......\\n\\nThe idea is that we can construct `randM^n = M * (randM^(n-1)-1) + randM^(n-1)` recursively. And then select accordingly. \\n\\n```\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 11\\n        while res > 10:\\n            res = (rand7() - 1) * 7 + rand7()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 11\\n        while res > 10:\\n            res = (rand7() - 1) * 7 + rand7()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150700,
                "title": "very-easy-3-lines-solution-in-c-explained",
                "content": "Since `rand7()` generate `1 to 7`, I subtract `1` everytime to get numbers from `0 to 6`.\\nNow the combination `7*(rand7()-1) + rand7()-1` will generate `0 to 48`, since we are targeting `0 to 39` as a multiple of `0 to 9` ( we can add 1 later to make it `1 to 10`) we need to discard anything above `39`. In that case we regenerate the number.\\n**If you have any question, ask me in comment. Thanks.**\\n\\n```\\n        int num;\\n        \\n        while((num = (7*(rand7()-1) + rand7()-1)) >= 40) ;\\n        \\n        return (num%10 + 1);        \\n```",
                "solutionTags": [],
                "code": "```\\n        int num;\\n        \\n        while((num = (7*(rand7()-1) + rand7()-1)) >= 40) ;\\n        \\n        return (num%10 + 1);        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816612,
                "title": "python-o-1-1-call-linear-congruential-generator",
                "content": "Detail and formula referred [https://en.wikipedia.org/wiki/Linear_congruential_generator](https://en.wikipedia.org/wiki/Linear_congruential_generator)\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.pre=0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        cur=(self.pre*7+rand7())%10+1\\n        self.pre=cur\\n        return cur\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.pre=0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        cur=(self.pre*7+rand7())%10+1\\n        self.pre=cur\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972843,
                "title": "c-recursion-intuition-explanation",
                "content": "# Intuition\\nFor understanding the intuition let\\'s first see why simple sampling ``` rand7()*rand7() ``` didn\\'t work:\\n![Screenshot (15).png](https://assets.leetcode.com/users/images/a8e8815a-8423-4eb6-b6bd-a54f5f35122f_1672430161.8377426.png)\\n(Note: Above example is only for intuition and consider output sample space as `[1-49]`, not just `[1-10]`)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter Trying some of the other sampling methods``` (7*(rand7()-1) + rand7())%10 + 1 ``` seemed to work really fine. Here is the comparision between the two sampling I mentioned `rand7()*rand7()` and `7*(rand7()-1) + rand7()` after applying `mod 10 + 1` operation:\\n```\\nfor (7*(rand7()-1) + rand7())%10 + 1 (uniformly distributed):\\n1 occurs : 4 times.\\n2 occurs : 5 times.\\n3 occurs : 5 times.\\n4 occurs : 5 times.\\n5 occurs : 5 times.\\n6 occurs : 5 times.\\n7 occurs : 5 times.\\n8 occurs : 5 times.\\n9 occurs : 5 times.\\n10 occurs : 5 times.\\n\\nfor (rand7()*rand7())%10 + 1 (not uniformly distributed):\\n1 occurs : 6 times.\\n2 occurs : 3 times.\\n3 occurs : 8 times.\\n4 occurs : 2 times.\\n5 occurs : 7 times.\\n6 occurs : 7 times.\\n7 occurs : 6 times.\\n8 occurs : 2 times.\\n9 occurs : 6 times.\\n10 occurs : 2 times.\\n\\n```\\n**NOTE :**\\n> **$$Question 1.$$ : All things considered, We still haven\\'t figured out why use `mod 10 + 1`?**\\n$$Answer$$ : To perform optimized Rejection Sampling!, As each of the number in our sampling has equal probability of occuring, we try to make `provability of failure(repeat the experiment) as small as possible and probability of success as much as possible`. We are doing this by decreasing the size of rejected samples. Here we are rejecting only 9 of the outputs (from 41 to 49) using `mod 10 + 1` and other `[1, 40]` are accepted, because these outputs are of same size `10 + 10 + 10 + 10`.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // probability of success -- (40/49)\\n        // probability of failure(repeat) -- (9/49)\\n        return (temp > 40 ? rand10() : temp%10 + 1);\\n    }\\n};\\n```\\n# Code 2\\n##### not performing optimized rejection sampling \\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // Simply rejecting all outputs other than [1,10];\\n        // probability of success -- (10/49)\\n        // probability of failure(repeat) -- (39/49)\\n        return (temp > 10 ? rand10() : temp);\\n    }\\n};\\n```\\n**NOTE: Here Optimization can also be thought of `probability of succes event!!!`**\\n\\nP.S. If helpful, consider upvoting\\u2763\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion",
                    "Rejection Sampling",
                    "Probability and Statistics"
                ],
                "code": "``` rand7()*rand7() ```\n``` (7*(rand7()-1) + rand7())%10 + 1 ```\n```\\nfor (7*(rand7()-1) + rand7())%10 + 1 (uniformly distributed):\\n1 occurs : 4 times.\\n2 occurs : 5 times.\\n3 occurs : 5 times.\\n4 occurs : 5 times.\\n5 occurs : 5 times.\\n6 occurs : 5 times.\\n7 occurs : 5 times.\\n8 occurs : 5 times.\\n9 occurs : 5 times.\\n10 occurs : 5 times.\\n\\nfor (rand7()*rand7())%10 + 1 (not uniformly distributed):\\n1 occurs : 6 times.\\n2 occurs : 3 times.\\n3 occurs : 8 times.\\n4 occurs : 2 times.\\n5 occurs : 7 times.\\n6 occurs : 7 times.\\n7 occurs : 6 times.\\n8 occurs : 2 times.\\n9 occurs : 6 times.\\n10 occurs : 2 times.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // probability of success -- (40/49)\\n        // probability of failure(repeat) -- (9/49)\\n        return (temp > 40 ? rand10() : temp%10 + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int temp = 7*(rand7()-1)+rand7();\\n        // Simply rejecting all outputs other than [1,10];\\n        // probability of success -- (10/49)\\n        // probability of failure(repeat) -- (39/49)\\n        return (temp > 10 ? rand10() : temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673547,
                "title": "c-solution-2-lines-beats-92-in-the-running-time",
                "content": "Idea : \\nGenerate uniform distribution between [0, 1], Then using this distribution we can generate rand10()\\n\\n```class Solution {\\npublic:\\n    int rand10() {\\n        double b =  (49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)) /  343.0;\\n        return (int)(b * 10) + 1; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int rand10() {\\n        double b =  (49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)) /  343.0;\\n        return (int)(b * 10) + 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373385,
                "title": "javascript-solution-straightforward",
                "content": "The idea is to play around with probalibilities (see comments in code below).\\nAdopted from [@niwota](https://leetcode.com/niwota) and [@hwei002](https://leetcode.com/hwei002) --> [here](https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150312/Easy-solution). \\n```\\nvar rand10 = function() {\\n  let i = 7;\\n  let j = 6;\\n  while (i > 6) i = rand7(); // i could be 1, 2, 3, 4, 5, or 6\\n  while (j > 5) j = rand7(); // j could be 1, 2, 3, 4, or 5\\n  if (i % 2 === 0) { // if i end up being even (50% the chance because it could be 2, 4, 6)\\n    return j; // return 1, 2, 3, 4, or 5\\n  } else { //if i end up being odd (also 50% of the chance because it could be 1, 3, 5)\\n    return j + 5; // return 6, 7, 8, 9, or 10\\n  }\\n};\\n```\\n\\nI found this solution better in terms of understanding. Hope it also helps you guys!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rand10 = function() {\\n  let i = 7;\\n  let j = 6;\\n  while (i > 6) i = rand7(); // i could be 1, 2, 3, 4, 5, or 6\\n  while (j > 5) j = rand7(); // j could be 1, 2, 3, 4, or 5\\n  if (i % 2 === 0) { // if i end up being even (50% the chance because it could be 2, 4, 6)\\n    return j; // return 1, 2, 3, 4, or 5\\n  } else { //if i end up being odd (also 50% of the chance because it could be 1, 3, 5)\\n    return j + 5; // return 6, 7, 8, 9, or 10\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826682,
                "title": "easy-python",
                "content": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        total_sum = 0\\n        \\n        for i in range(10):\\n            total_sum += rand7()\\n        \\n        return (total_sum % 10) + 1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        total_sum = 0\\n        \\n        for i in range(10):\\n            total_sum += rand7()\\n        \\n        return (total_sum % 10) + 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492184,
                "title": "wrong-solution",
                "content": "**UPD:** I figured out that this solution is wrong. My mistake was here:\\n* `6` with probability ~~`3`/9~~ `2`/8\\n\\nAnd this mistake invalidates everything. So, don\\'t read this, you will not find anything useful here. I just retain text below for history.\\n\\n---\\n---\\n---\\n\\n**Previous title:** `O(constant) worst-case. Never presented before!`\\n\\nWe know how to generate smaller `rand` using larger `rand` using rejection sampling. But can you do reverse without generating a larger `rand`? Yes, and this approach works without `O(\\u221E)` time worst-case.\\n\\nImagine you want to generate `rand3` by knowing `rand2`. We need to distribute same probabilities on `1`, on `2` and on `3`. Let\\'s call `rand2` three times and smartly map our numbers:\\n* `rand2` \\u2192 `{1, 2}` = `a`\\n* `rand2` \\u2192 `{1, 3}` = `b`\\n* `rand2` \\u2192 `{2, 3}` = `c`\\n\\nEach number in `[1, 3]` range shows exactly twice. What next can we do with these numbers? We can sum them up. If we do so, then we will get these numbers:\\n`s` = `a + b + c` =\\n* `4` with probability `1`/9\\n* `5` with probability `2`/9\\n* `6` with probability `3`/9\\n* `7` with probability `2`/9\\n* `8` with probability `1`/9\\n\\nIf we make `(s-1) % 3` then we will get these numbers and probabilities:\\n* `0` with probability `3`/9 (from `4` and `7`)\\n* `1` with probability `3`/9 (from `5` and `8`)\\n* `2` with probability `3`/9 (from `6`)\\n\\nNow you know how to generate `rand3` using `rand2` by calling it exactly 3 times!\\n\\n---\\n\\nAnd let\\'s define a **mapping matrix** for this case:\\n```\\n1 1 0\\n1 0 1\\n0 1 1\\n```\\n\\nProperties\\n* Count of ones in each row represent source random degree. \\n\\t* In this case it\\'s 2.\\n* Count of zeros represent target random degree minus source random degree. \\n\\t* In this case it\\'s 3-2 = 1.\\n* Each line is a permutation of string got from the previous two items. \\n\\t* In this case it\\'s `110`.\\n* If we sum numbers in each column, we will get the same numbers, which means that each number has the same probability to occur.\\n\\t* In this case sum equals 2.\\n* We can use this matrix to map smartly map numbers from source random generator.\\n\\t* In our case it was:\\n\\t\\t* `rand2` \\u2192 `{1, 2}` = `a`\\n\\t\\t* `rand2` \\u2192 `{1, 3}` = `b`\\n\\t\\t* `rand2` \\u2192 `{2, 3}` = `c`\\n\\n---\\n\\nNow, image if we want to generate `rand5` using `rand3`, we will get this mapping matrix:\\n```\\n00111\\n01011\\n01101\\n01110\\n10011\\n10101\\n10110\\n11001\\n11010\\n11100\\n```\\n\\nWhich are just all permutations of `00111`.\\n\\nIf you sum numbers in each column, you will get 6, which means that every number has the same probability to occur in the target sum.\\n\\nAnd by this, you can get `rand5` from `rand7` by calling it 10 times.\\n\\n---\\n\\nAnd the general formula is:\\n\\nIf we want to generate `randN` from `randK` where `K` < `N`, we will call `randK` exactly `N choose K` times( `N!/(K!*(N-K)!)`) ([combination](https://en.wikipedia.org/wiki/Combination)).\\n\\nWhich is equal to `N` when `N = K+1`, but getting worse when `K` approaches `N/2`.\\n\\nIn our original task, it will be equal to `10 choose 7 = 120`. But has no worst-case scenario! :)",
                "solutionTags": [],
                "code": "```\\n1 1 0\\n1 0 1\\n0 1 1\\n```\n```\\n00111\\n01011\\n01101\\n01110\\n10011\\n10101\\n10110\\n11001\\n11010\\n11100\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817220,
                "title": "python-2-ways-w-explanation",
                "content": "**METHOD 1: Expanding a zero based random**\\n\\nSay that the range of rand10() is [0,9], then, to produce rand100(), we would need a 2 digit number. \\nThus, we can do the follows: \\nrand100() = 10 * rand10() + rand10()\\n\\nIf the range were [1,10], the above can be modified as rand100() = 10 * ( rand10() - 1) + ( rand10() - 1)\\nUsing the same logic, rand10() using rand7() can be formulated as generating rand49() and then ensuring that it is within the output range i.e. [1,10]. \\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rand49 = float(\\'inf\\')\\n        while rand49 >= 40:\\n            rand49 = 7 * (rand7() - 1) + (rand7() - 1)\\n        # Since rand49 % 10 => [0, 9] and the output has to be in range [1,10]\\n        return rand49 % 10 + 1 \\n```\\n\\n**METHOD 2: Mapping Rule**\\n\\nThe range of rand7() is [1,7] i.e. {1,2,3,4,5,6,7}\\nThe range of rand10() is [1,10] i.e. {1,2,3,4,5,6,7,8,9,10}\\n\\nHere, we need to map 7 values to 10 values. Thus, we divide the output values into two parts [1,5] and [6,10]. \\n(Further explanation in the code) \\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Method 2: Mapping Rule \\n        val1, val2 = rand7(), rand7()\\n\\t\\t\\n\\t\\t# val1 : {1,2,3,4,5,6,7} : Here, {6,7} are ignored to ensure equal probability for [1,5]\\n        while val1 > 5: val1 = rand7()\\n\\t\\t\\n\\t\\t# val2: {1,2,3,4,5,6,7} : Here, [1,3] correspond to [1,5] in the output and [4,6] correspond to [6,10]\\n\\t\\t# {7} has been ignored to ensure equal probability distribution\\n        while val2 == 7: val2 = rand7()\\n\\t\\t\\n        return val1 if val2 <= 3 else val1 + 5\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        rand49 = float(\\'inf\\')\\n        while rand49 >= 40:\\n            rand49 = 7 * (rand7() - 1) + (rand7() - 1)\\n        # Since rand49 % 10 => [0, 9] and the output has to be in range [1,10]\\n        return rand49 % 10 + 1 \\n```\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n\\t\\t# Method 2: Mapping Rule \\n        val1, val2 = rand7(), rand7()\\n\\t\\t\\n\\t\\t# val1 : {1,2,3,4,5,6,7} : Here, {6,7} are ignored to ensure equal probability for [1,5]\\n        while val1 > 5: val1 = rand7()\\n\\t\\t\\n\\t\\t# val2: {1,2,3,4,5,6,7} : Here, [1,3] correspond to [1,5] in the output and [4,6] correspond to [6,10]\\n\\t\\t# {7} has been ignored to ensure equal probability distribution\\n        while val2 == 7: val2 = rand7()\\n\\t\\t\\n        return val1 if val2 <= 3 else val1 + 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816438,
                "title": "a-simple-explanation-of-rejection-sampling",
                "content": "Generate a random number between 1 and 7. If it\\'s 1, 2, or 3, generate a number between 1 and 5 (which is explained later). If 4, 5, or 6, generate a number between 6 and 10. If 7, simply try again. It\\'s that dumb.\\n\\nNow how to generate a number between 1 and 5? The same method. Generate a number between 1 and 7. If it\\'s 1, 2, 3, 4, or 5, return it. If 6 or 7, try again.\\n\\n```golang\\nfunc rand10() int {\\n\\tx := rand7()\\n\\tif x <= 3 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn y\\n\\t}\\n\\tif x <= 6 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn 11 - y\\n\\t}\\n\\treturn rand10()\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nfunc rand10() int {\\n\\tx := rand7()\\n\\tif x <= 3 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn y\\n\\t}\\n\\tif x <= 6 {\\n\\t\\ty := rand7()\\n\\t\\tif y > 5 {\\n\\t\\t\\treturn rand10()\\n\\t\\t}\\n\\t\\treturn 11 - y\\n\\t}\\n\\treturn rand10()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816392,
                "title": "incorrect-implementation-of-rand7-in-rust",
                "content": "It seems that rand7() in Rust returns a number from 1 to 6 inclusive. To fix this just create your own rand7() function, for example like the following code:\\n```\\n// call mrand7() instead of rand7() in your solution\\nfn mrand7() -> i32 {\\n    use rand::{thread_rng, Rng};\\n    let mut rng = thread_rng();\\n    rng.gen_range(1, 8)\\n}\\n\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n\\t\\t...\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// call mrand7() instead of rand7() in your solution\\nfn mrand7() -> i32 {\\n    use rand::{thread_rng, Rng};\\n    let mut rng = thread_rng();\\n    rng.gen_range(1, 8)\\n}\\n\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n\\t\\t...\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151058,
                "title": "1-18-rand7-calls-per-rand10",
                "content": "If we assume that ```rand7()``` calls are expensive and that we need to call rand10 at least a few hundred times, we can do better than the CTCI solution, which wastes bits by applying a modulus. The tradeoff is that the startup is more expensive, since we need to call ```rand7``` multiple times and cache some results.\\n\\nIf we treat n calls to rand7() as a base 7 number, we can get an equivalent base10 number.\\n\\n```\\nd0 = 7**0*(rand7() - 1)\\nd1 = 7**1*(rand7() - 1)\\ndlast = 7**(n-1)*(rand7()-1)\\ntotal = d0+d1+...+dlast\\n```\\n\\nThis total number gives us a uniform range of ```[0, 7**n-1]```.\\n\\nTo get a uniform range of ```[0, 10**i]```, we need to throw away the top range. So we need to find a ```7**n``` that wastes the least numbers.\\n\\nOn a whiteboard, you can probably hand-wave this number. In a setting where you can run scripts, you can scan for favorable numbers by looking through this list:\\n\\n```\\nfor i in range(1000):\\n  result = 7**i\\n  if str(result).startswith(\\'100\\'):\\n\\t  print(i, result, len(str(result))) # print power, number, and the number of base 10 digits\\n```\\n\\nWe see some output:\\n\\n```510, <big number starting with 10000009>, 432```\\n\\nWhich means:\\n\\n```7**510 ~= 1.0000009*10**431```\\n\\nSo, when we call ```rand7``` 510 times, we get a uniform range ```[0, 7**510-1]``` which is ```[0, 1.0000009*10**431]```\\n\\nWhenever the result is within our designed range, we win! We got 431 ```rand10``` numbers that we can cache.\\n\\nWhenever the result is greater than or equal to ```10**431```, we throw it away and call ```rand7``` another 510 times. This is expensive, but it should happen very rarely since we chose the number of ```rand7``` calls optimally `P=0.0000009/1.0000009 ~= 1 out of 100,000 times`\\n\\nThis way, we have an efficiency of ```1.18``` ```(510/431)```, because we get 431 ```rand10()``` calls for every 510 ```rand7()``` calls.\\n\\nThe wastage is negligible because the top range is so small.\\n\\n```\\ntotal calls (510k/431)\\nk = 1 + 0.0000009^1 + 0.0000009^2 + ...\\n0.0000009k = 0.0000009^1 + 0.0000009^2 + 0.0000009^3 + ...\\n0.9999991k = 1\\nk = 1/0.9999991 ~= 1.0000009\\n510k/431 = 1.0000009*510/431 ~= 1.18\\n```\\n\\nHere\\'s the code in Python:\\n```\\nclass Entropy:\\n\\tdef __init__(self):\\n\\t\\tself._store = []\\n\\t\\n\\tdef get(self):\\n\\t\\twhile not len(self._store):\\n\\t\\t\\tself._generate()\\n\\t\\treturn self._store.pop()\\n\\t\\n\\tdef _generate(self):\\n\\t\\tresult = sum([(rand7()-1)*(7**i) for i in range(510)])\\n\\t\\tif result >= 10**431:\\n\\t\\t\\treturn\\n\\t\\tfor i in range(431):\\n\\t\\t\\tself._store.append(1+(result % 10))\\n\\t\\t\\tresult //= 10\\n\\t\\t\\t\\nclass Solution:\\n\\tdef __init__(self):\\n\\t\\tself._entropy = Entropy()\\n\\t\\n\\tdef rand10(self):\\n\\t\\treturn self._entropy.get()\\n```",
                "solutionTags": [],
                "code": "```rand7()```\n```rand7```\n```\\nd0 = 7**0*(rand7() - 1)\\nd1 = 7**1*(rand7() - 1)\\ndlast = 7**(n-1)*(rand7()-1)\\ntotal = d0+d1+...+dlast\\n```\n```[0, 7**n-1]```\n```[0, 10**i]```\n```7**n```\n```\\nfor i in range(1000):\\n  result = 7**i\\n  if str(result).startswith(\\'100\\'):\\n\\t  print(i, result, len(str(result))) # print power, number, and the number of base 10 digits\\n```\n```510, <big number starting with 10000009>, 432```\n```7**510 ~= 1.0000009*10**431```\n```rand7```\n```[0, 7**510-1]```\n```[0, 1.0000009*10**431]```\n```rand10```\n```10**431```\n```rand7```\n```rand7```\n```1.18```\n```(510/431)```\n```rand10()```\n```rand7()```\n```\\ntotal calls (510k/431)\\nk = 1 + 0.0000009^1 + 0.0000009^2 + ...\\n0.0000009k = 0.0000009^1 + 0.0000009^2 + 0.0000009^3 + ...\\n0.9999991k = 1\\nk = 1/0.9999991 ~= 1.0000009\\n510k/431 = 1.0000009*510/431 ~= 1.18\\n```\n```\\nclass Entropy:\\n\\tdef __init__(self):\\n\\t\\tself._store = []\\n\\t\\n\\tdef get(self):\\n\\t\\twhile not len(self._store):\\n\\t\\t\\tself._generate()\\n\\t\\treturn self._store.pop()\\n\\t\\n\\tdef _generate(self):\\n\\t\\tresult = sum([(rand7()-1)*(7**i) for i in range(510)])\\n\\t\\tif result >= 10**431:\\n\\t\\t\\treturn\\n\\t\\tfor i in range(431):\\n\\t\\t\\tself._store.append(1+(result % 10))\\n\\t\\t\\tresult //= 10\\n\\t\\t\\t\\nclass Solution:\\n\\tdef __init__(self):\\n\\t\\tself._entropy = Entropy()\\n\\t\\n\\tdef rand10(self):\\n\\t\\treturn self._entropy.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767851,
                "title": "easy-python-solution-with-multiple-approaches-faster-than-99",
                "content": "* **Generated Random Number without using rand7() API**\\n* ps: i just generated a random number in the range [1,10]\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    count = 0;\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        random = [1,2,3,4,5,6,7,8,9,10]\\n        self.count += 1; c = 0\\n        if (self.count & 1):\\n            for i in range(2,10,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n        else:\\n            for i in range(1,9,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n            \\n```\\n* time Complexity: O(1)  => Constant time\\n\\n* **Approach 2: Using rand7() API**\\n```\\ndef rand10(self):\\n        rand = 40\\n        while rand >= 40:\\n            rand = (rand7() - 1) * 7 + rand7() - 1\\n        return rand % 10 + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    count = 0;\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        random = [1,2,3,4,5,6,7,8,9,10]\\n        self.count += 1; c = 0\\n        if (self.count & 1):\\n            for i in range(2,10,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n        else:\\n            for i in range(1,9,2):\\n                c += i;\\n            return random[(self.count+c)%10];\\n            \\n```\n```\\ndef rand10(self):\\n        rand = 40\\n        while rand >= 40:\\n            rand = (rand7() - 1) * 7 + rand7() - 1\\n        return rand % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067513,
                "title": "python-at-max-5-rand-calls",
                "content": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        v1 = rand7()\\n        while v1 == 6 or v1 == 7:\\n            v1 = rand7()\\n            \\n        \\n        v2 = rand7()\\n        while v2 == 7:\\n            v2 = rand7()\\n            \\n        \\n        if(v2 <= 3):\\n            return v1\\n        \\n        return v1+5\\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        \\n        v1 = rand7()\\n        while v1 == 6 or v1 == 7:\\n            v1 = rand7()\\n            \\n        \\n        v2 = rand7()\\n        while v2 == 7:\\n            v2 = rand7()\\n            \\n        \\n        if(v2 <= 3):\\n            return v1\\n        \\n        return v1+5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816490,
                "title": "implement-rand10-using-rand7-very-simple-explanation",
                "content": "```\\n\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        #we can genearate numbers 8 to 56 using (c)= 7*rand7()+rand7()\\n        #with equal probalilty   we need to genearte    from one to 10\\n        # so all sholuld be gen with eq probailty\\n        #so to occur\"1\" there are numbers{11,21,...51} which are 5 choices when we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n**      So here we have  probability different for number \"1\" and \"8\"\\n**        # inorder to make equal we take cut of from 11 to 50\\n        \\n         #so to occur\"1\" there are numbers{11,21,...41} which are 4 choiceswhen we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {20,......50}  only 4 choices when we do mod(10)\\n        # so all 1 to 10 will equally occur\\n        val=7*rand7()+rand7()\\n        print(val)\\n        while val>50 or val<11:\\n            print(val,\"sd\")\\n            val=7*rand7()+rand7()\\n            \\n        \\n        return val%10 if val%10!=0 else 10\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        #we can genearate numbers 8 to 56 using (c)= 7*rand7()+rand7()\\n        #with equal probalilty   we need to genearte    from one to 10\\n        # so all sholuld be gen with eq probailty\\n        #so to occur\"1\" there are numbers{11,21,...51} which are 5 choices when we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n**      So here we have  probability different for number \"1\" and \"8\"\\n**        # inorder to make equal we take cut of from 11 to 50\\n        \\n         #so to occur\"1\" there are numbers{11,21,...41} which are 4 choiceswhen we do mod(10)\\n        # but for \"8\"   ther are {18,28,......48}  only 4 choices when we do mod(10)\\n        # but for \"10\"   ther are {20,......50}  only 4 choices when we do mod(10)\\n        # so all 1 to 10 will equally occur\\n        val=7*rand7()+rand7()\\n        print(val)\\n        while val>50 or val<11:\\n            print(val,\"sd\")\\n            val=7*rand7()+rand7()\\n            \\n        \\n        return val%10 if val%10!=0 else 10\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816365,
                "title": "c-super-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int res = 0;\\n        for (int i=0; i<7; i++)\\n            res += rand7();\\n        return res%10 + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int res = 0;\\n        for (int i=0; i<7; i++)\\n            res += rand7();\\n        return res%10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816238,
                "title": "c-c-simple-solution-96-faster-with-explanation",
                "content": "```\\nint rand10() \\n{\\n    int random = 0;\\n    for(int i = 0; i < 7; i++)\\n        random += rand7();\\n        \\n\\t//random can be max 49 so if we do modulo 10 and add 1 we can get any number between 1 till 10\\n    return random % 10 + 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() \\n{\\n    int random = 0;\\n    for(int i = 0; i < 7; i++)\\n        random += rand7();\\n        \\n\\t//random can be max 49 so if we do modulo 10 and add 1 we can get any number between 1 till 10\\n    return random % 10 + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758128,
                "title": "simple-c-solution-easy-to-understand-with-comments",
                "content": "```\\n// problem is like throwing a dice having 7 outcome\\n    // we want a total of 10 outcome\\n    // so we throw two time=> total outcome=>7*7=49\\n    // map first 40 outcome to 1 to 10\\n    // we can also map first 10,20,30 outcome to 1 to 10 but to get outcome in range (1 to 20) we may     // need to throw much more time\\n    // getting a number in range 1to40 is 40/49\\n    // if we take first 20 outcome ...then probability of getting a number in range 1to20 is 20/49\\n\\t\\n\\tclass Solution {\\npublic:\\n    int rand10() {\\n        int num=40;\\n        while(num>=40){\\n            num=7*(rand7()-1)+rand7()-1;\\n        }\\n        \\n        num=num%10+1;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// problem is like throwing a dice having 7 outcome\\n    // we want a total of 10 outcome\\n    // so we throw two time=> total outcome=>7*7=49\\n    // map first 40 outcome to 1 to 10\\n    // we can also map first 10,20,30 outcome to 1 to 10 but to get outcome in range (1 to 20) we may     // need to throw much more time\\n    // getting a number in range 1to40 is 40/49\\n    // if we take first 20 outcome ...then probability of getting a number in range 1to20 is 20/49\\n\\t\\n\\tclass Solution {\\npublic:\\n    int rand10() {\\n        int num=40;\\n        while(num>=40){\\n            num=7*(rand7()-1)+rand7()-1;\\n        }\\n        \\n        num=num%10+1;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221272,
                "title": "test-cases-do-not-test-for-randomness",
                "content": "After looking at other people\\'s submissions, I noticed that the following code (in Java) is accepted. Clearly, this code does not generate random numbers; it simply counts from 1-10 repeatedly.\\n```\\nclass Solution extends SolBase {\\n    static int spot = 0;\\n    public int rand10() {\\n        int s[] = {1,2,3,4,5,6,7,8,9,10};\\n\\t\\tspot = (spot+1)%10;\\n\\t\\treturn s[spot];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    static int spot = 0;\\n    public int rand10() {\\n        int s[] = {1,2,3,4,5,6,7,8,9,10};\\n\\t\\tspot = (spot+1)%10;\\n\\t\\treturn s[spot];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 210021,
                "title": "special-amazing-mathematical-solution-1-line",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n    }\\n};\\n```\\nIt\\'s a bit slow, but it\\'s very interesting. If you can read in Chinese, you can read my [mathematical explanation](https://zhuanlan.zhihu.com/p/51057259) of this method in Zhihu. My article mainly explains this method mathematically from two perspectives \\uFF1A\\n* Algebra\\uFF1AConvergence of m-order cyclic matrices\\n* Stochastic Process\\uFF1AStationary Distribution of Markov Chains\\n\\nBecause we cannot use Latex here, this algorithm cannot be explained in more detail. Generally\\uFF0Cfor the problem like \"Implement RandM() Using RandN()\", we can use this code:\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def randM(self):\\n        k = 2333333 #an enough large number \\n        temp = 0\\n        for i in range(k):\\n            temp += randN()\\n        return temp%M+1\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n    }\\n};\\n```\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def randM(self):\\n        k = 2333333 #an enough large number \\n        temp = 0\\n        for i in range(k):\\n            temp += randN()\\n        return temp%M+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413715,
                "title": "using-rand5-and-rand2-to-implement-rand10",
                "content": "we can generate ```randA()``` from ```randB()``` very easily when A<=B, using **discarded sampling**\\ni.e, we keep calling ```randB()``` untill it gives you a value in range ```[1, A]```. (means we discard values ```{A+1,A+2,....B}``` if we get it using ```randB()```\\n\\n```\\ndef randA():\\n\\twhile True:\\n\\t\\tans = randB()\\n\\t\\tif ans<=A:\\n\\t\\t\\treturn ans\\n```\\n\\n\\nHence, from ```rand7()```, we can generate ```rand2()``` and ```rand5()```, and use these two to get ```rand10()```. By this formula:\\n\\n`rand10() = 2*( rand5() - 1) + rand2()`\\n\\nor\\n\\n`rand10() = 5*( rand2() - 1) + rand5()`\\n\\n\\nExplaination on why this works?\\n\\n As ```rand5()``` gives values in set `{1,2,3,4,5}` with equal probability,\\n\\n```2*( rand5() - 1)``` gives values in set ```{0,2,4,6,8}``` with equal probability. (Simple magnification and translation)\\n\\nwe just need an additional randomness of `{+1,+2}`  in this set which we can get from `+rand2()`\\n\\nThus, `rand10() = 2*( rand5() - 1) + rand2()`\\nin other words: `rand({1,2,3,4,5,6,7,8,9,10}) = rand({0,2,4,6,8}) + rand({1,2})`\\n\\n\\n\\n\\n```\\ndef rand10(self):\\n        \\n\\tdef randn(n):\\n\\t\\twhile True:\\n\\t\\t\\tans = rand7()\\n\\t\\t\\tif ans<=n:\\n\\t\\t\\t\\treturn ans\\n\\n\\treturn 2*(randn(5)-1) + randn(2)\\n```\\n\\nFurther optimization: You can notice that rand2() will be slower than rand5(). We can make rand2() faster by implementing rand2() from rand6(), which is faster as it is close to 7.\\n\\nrand2() = (rand6()+2)//3",
                "solutionTags": [
                    "Python"
                ],
                "code": "```randA()```\n```randB()```\n```randB()```\n```[1, A]```\n```{A+1,A+2,....B}```\n```randB()```\n```\\ndef randA():\\n\\twhile True:\\n\\t\\tans = randB()\\n\\t\\tif ans<=A:\\n\\t\\t\\treturn ans\\n```\n```rand7()```\n```rand2()```\n```rand5()```\n```rand10()```\n```rand5()```\n```2*( rand5() - 1)```\n```{0,2,4,6,8}```\n```\\ndef rand10(self):\\n        \\n\\tdef randn(n):\\n\\t\\twhile True:\\n\\t\\t\\tans = rand7()\\n\\t\\t\\tif ans<=n:\\n\\t\\t\\t\\treturn ans\\n\\n\\treturn 2*(randn(5)-1) + randn(2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1477866,
                "title": "rand7-2-floor-div-python-99-faster-expected-calls-0-525",
                "content": "***Use knowledge of statistics***... proving any distribution is not easy...\\n\\nKey points:\\n* `rand7()` \\u2192 inclusive interval [1, 7]\\n* `7 + rand7() // 2` \\u2192 inclusive interval [7, 10]\\n* Every 1...7th call, return `rand7()`\\n* Every 8...10th call, return `7 + rand7() // 2` when this value is not `7`\\n  * Store `rand7()` in deque for 1...7th call later\\n\\nThis method calls `rand7()` nominally 7/10 times but can be further reduced by storing a duplicate each and every single time `rand7()` is called.  Intuitively, this is not a uniform distribution, but any test for uniform distribution (chi-square, KS, etc.) will ***fail to reject the null hypothesis*** that the parameter/metric of proof for this distribution is different from that of a true uniform distribution, within a certain confidence level.  Thus, the expected calls for `rand7()` is `7/10 - 7/40 = 0.525` on average due to the fact that the confidence interval for small `n` is huge, and for larger `n`, the occurrence of consecutive duplicates are no different from what would/could actually be obtained from a \"true\" uniform generator.\\n\\nThe concept for storing `rand7()` during the 8...10th calls is that the distribution of `rand7() // 2` is also uniform, and within the context of `rand7()` being in the inclusive range of [1,7], the fact that it is added to the deque only when it is `1` still has a 1 in 7 probability (aka uniform for the purpose of this problem).\\n\\nThis solution is gaming the system... just like y\\'all are trying to game the interview process \\uD83D\\uDE02\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def __init__(self):\\n        self.dq = deque(maxlen=20)\\n        self.rand10_calls = 0\\n\\n    def get_1_from_dq(self):\\n        if len(self.dq) == 0:\\n\\t\\t    #return rand7()\\n            return self.add_new_to_dq() #reduce 7/40th calls to rand7()\\n        return self.dq.popleft()\\n\\n    def add_new_to_dq(self):\\n        out = rand7()\\n        self.dq.append(out)\\n        return out\\n\\n    def rand10(self):\\n        self.rand10_calls += 1\\n        opt = self.rand10_calls % 10\\n        if opt < 7:\\n            out = self.get_1_from_dq()\\n        else:\\n            out = 7\\n            while out < 8:\\n                e0 = self.add_new_to_dq()\\n                out = 7 + e0 // 2\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def __init__(self):\\n        self.dq = deque(maxlen=20)\\n        self.rand10_calls = 0\\n\\n    def get_1_from_dq(self):\\n        if len(self.dq) == 0:\\n\\t\\t    #return rand7()\\n            return self.add_new_to_dq() #reduce 7/40th calls to rand7()\\n        return self.dq.popleft()\\n\\n    def add_new_to_dq(self):\\n        out = rand7()\\n        self.dq.append(out)\\n        return out\\n\\n    def rand10(self):\\n        self.rand10_calls += 1\\n        opt = self.rand10_calls % 10\\n        if opt < 7:\\n            out = self.get_1_from_dq()\\n        else:\\n            out = 7\\n            while out < 8:\\n                e0 = self.add_new_to_dq()\\n                out = 7 + e0 // 2\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056666,
                "title": "python-using-2-rand7-calls",
                "content": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 1\\n        grid = []\\n        for i in range(7):\\n            temp = []\\n            for _ in range(7):\\n                temp.append(val)\\n                val+=1\\n                if val==11:\\n                    val = 1\\n            grid.append(temp)\\n\\n        row = rand7()-1\\n        col = rand7()-1\\n\\n        if row<=4 or (row==5 and col<=4):\\n            return grid[row][col]\\n\\n        return self.rand10()\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 1\\n        grid = []\\n        for i in range(7):\\n            temp = []\\n            for _ in range(7):\\n                temp.append(val)\\n                val+=1\\n                if val==11:\\n                    val = 1\\n            grid.append(temp)\\n\\n        row = rand7()-1\\n        col = rand7()-1\\n\\n        if row<=4 or (row==5 and col<=4):\\n            return grid[row][col]\\n\\n        return self.rand10()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 817177,
                "title": "python-easy-to-understand-best-and-worst-time-o-1-worst-space-o-1-with-detailed-explaination",
                "content": "### Step #1: Realize that we can generate a random base-7 number.\\nSince we have the ability to randomly generate numbers 0-6 (rand7()-1), therefore we can randomly generate any number in base-7 number system. Since each bit correspoding to each power of 7 will be randomly generated therefore we can always trust that generated number will be truly random.\\n\\n### Step #2: Realize that we can generate a random number between 0-2400\\nWe know:\\n`0 = 0 [ 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3)]`\\n`2400 = 6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3)`\\n\\nSince `2400 = 6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3)`, we can try to randomly generate a base-7 number between 0 to 2400. In order to do so, we just have to generate a random number (0-6) 4 times, corresponding to each exponential power of 7.  Therefore:\\n\\n`rand_0_to_2400() = (7**0)*(rand7()-1)+(7**1)*(rand7()-1)+(7**2)*(rand7()-1)+(7**3)*(rand7()-1)`\\n\\n### Step #3: Convert the Random Number between 0-2400 to a random number between 0-10\\nNow since we have a random number between 0 - 2400 where each number is equally likely to occur. We can argue that last digit of this generated number is equally likely to be 0-9. So we can argue `rand_1_to_10 = rand_0_to_2400() %10 +1`\\n\\n\\n```\\nclass Solution:\\n    def rand10(self): \\n        result = 0\\n\\t\\t\\n\\t\\t# generate random 4-digit base-7 number [range 0-2800]\\n\\t\\t#  from 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3) = 0  ->  6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3) = 2400 \\n\\t\\t\\n        for i in range(4):\\n            result*=7\\n            result+=rand7()-1\\n\\t\\t# since each number from 0-2400 is equally likely to be generated\\n\\t\\t# therefore last digit of the generated number is equally likely to be any number 0-9\\n\\t\\t# calculate the modulus => we can calculate truly random number 0-9\\n        return result%10+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self): \\n        result = 0\\n\\t\\t\\n\\t\\t# generate random 4-digit base-7 number [range 0-2800]\\n\\t\\t#  from 0*(7^0)+0*(7^1)+0*(7^2)+0*(7^3) = 0  ->  6*(7^0)+6*(7^1)+6*(7^2)+6*(7^3) = 2400 \\n\\t\\t\\n        for i in range(4):\\n            result*=7\\n            result+=rand7()-1\\n\\t\\t# since each number from 0-2400 is equally likely to be generated\\n\\t\\t# therefore last digit of the generated number is equally likely to be any number 0-9\\n\\t\\t# calculate the modulus => we can calculate truly random number 0-9\\n        return result%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817108,
                "title": "very-basic-4-line-accepted-solution-with-explanation",
                "content": "I was expecting this solution to give time limit exception but it was accepted!! \\n\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int ans =0;\\n        for(int i=0; i<10; i++)\\n            ans+=rand7();\\n        return (ans%10)+1;\\n    }\\n}\\n```\\n\\nlogic is simple, Im adding rand(7) 10 times, so the sum can be anything between 1 to 70 with equal probability. \\nNext Im doing % 10, which should be between 0-9. and finally ading 1 because we want range 1-10.",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int ans =0;\\n        for(int i=0; i<10; i++)\\n            ans+=rand7();\\n        return (ans%10)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816611,
                "title": "simple-python-and-c-code-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=Hvx2wXMnZGg)\\nhttps://www.youtube.com/watch?v=Hvx2wXMnZGg\\n## Python\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        indx = 41\\n        while indx > 40:\\n            indx = (rand7() - 1) * 7 + rand7()\\n        return ((indx - 1) % 10) + 1\\n```\\n## C\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int indx = 41;\\n    while (indx > 40){\\n        indx = (rand7() - 1) * 7 + rand7();\\n    }\\n    return ((indx - 1) % 10) + 1;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        indx = 41\\n        while indx > 40:\\n            indx = (rand7() - 1) * 7 + rand7()\\n        return ((indx - 1) % 10) + 1\\n```\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int indx = 41;\\n    while (indx > 40){\\n        indx = (rand7() - 1) * 7 + rand7();\\n    }\\n    return ((indx - 1) % 10) + 1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816452,
                "title": "why-this-1-line-solution-works",
                "content": "\\n    int rand10() {\\n        return 1+(rand7() + rand7() + rand7() + rand7() +rand7())%10;\\n    }",
                "solutionTags": [],
                "code": "\\n    int rand10() {\\n        return 1+(rand7() + rand7() + rand7() + rand7() +rand7())%10;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 816314,
                "title": "c-yet-another-uniform-random-selection-method",
                "content": "In here, first I generate a random number to determine the number that I choose is going to be from [1-5] or [6-10]. For this purpose, I roll the rand7() and while I get 7 I will discard it and if I finally get between [1-6] I will mod it to 2. The mod result can only be 0 or 1: If the mod result is 0, then I will choose from [1-5], if the mod result is 1, I will choose from [6-10].\\n\\nOn average 2.56667 times of calling to rand7(): \\n     1 + (1/7 + 1/7 * 1/7 + .... ) +1 + (2/7+2/7 * 2/7+.....) = 2.56667\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();   // ----> Determines to choose from [1-5] or [6-10]\\n        while(x==7){   // redo the selection while the chosen number is 7.\\n            x = rand7(); // The number with equal chances will be either even (2,4,6) or odd (1,3,5). Note that 7 is excluded\\n        }\\n\\t\\tint r1_5 = rand7();  // In here I generate a number between 1 and 5\\n        while(r1_5>5){  // redo if  >5\\n            r1_5 = rand7();\\n        }\\n        return r1_5 + (x%2)*5; // return the number getting help from x%2.\\n\\t\\t\\t// So either \"r1_5 + 0\" or \"r1_5 + 5\" is the return. Meaining, either the number is going to be\\n\\t\\t\\t//Between [1,5] or [6,10]. This way, the solution has a uniform distribution.\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();   // ----> Determines to choose from [1-5] or [6-10]\\n        while(x==7){   // redo the selection while the chosen number is 7.\\n            x = rand7(); // The number with equal chances will be either even (2,4,6) or odd (1,3,5). Note that 7 is excluded\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 667487,
                "title": "rust-approach-1-not-accepted",
                "content": "Trying to get Approach 1 from the Solutions working in Rust, it\\'s working for me off-line and my distribution for 10,000 samples is pretty uniform, but it\\'s not accepted. Any ideas?\\n\\n```\\n// rand7 for testing\\nuse rand::Rng;\\nfn rand7() -> i32 {\\n    let mut rng = rand::thread_rng();\\n    return rng.gen_range(1, 8);\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        let mut val = 50;\\n        while val > 40 {\\n            let a = rand7();\\n            let b = rand7();\\n            val = a + (b-1)*7;\\n        }\\n        1 + (val - 1) % 10 // 1-indexing\\n    }\\n}\\n\\nfn test_dist() {\\n    let mut freq = vec![0; 10];\\n    let samples = 10000;\\n\\n    println!(\"Testing distribution with {:?} samples\", samples);\\n\\n    for _ in 0..samples {\\n        let bin = Solution::rand10() - 1;\\n        freq[bin as usize] += 1;\\n    }\\n\\n    for f in freq {\\n        print!(\"{} \", (f as f32)/(samples as f32));\\n    }\\n    println!();\\n}\\n\\nfn main() {\\n    test_dist();\\n}\\n```\\n\\nOutput:\\n```\\nTesting distribution with 10000 samples\\n0.0987 0.1009 0.1006 0.1025 0.1023 0.0942 0.0945 0.0977 0.1062 0.1024\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// rand7 for testing\\nuse rand::Rng;\\nfn rand7() -> i32 {\\n    let mut rng = rand::thread_rng();\\n    return rng.gen_range(1, 8);\\n}\\n\\nstruct Solution;\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        let mut val = 50;\\n        while val > 40 {\\n            let a = rand7();\\n            let b = rand7();\\n            val = a + (b-1)*7;\\n        }\\n        1 + (val - 1) % 10 // 1-indexing\\n    }\\n}\\n\\nfn test_dist() {\\n    let mut freq = vec![0; 10];\\n    let samples = 10000;\\n\\n    println!(\"Testing distribution with {:?} samples\", samples);\\n\\n    for _ in 0..samples {\\n        let bin = Solution::rand10() - 1;\\n        freq[bin as usize] += 1;\\n    }\\n\\n    for f in freq {\\n        print!(\"{} \", (f as f32)/(samples as f32));\\n    }\\n    println!();\\n}\\n\\nfn main() {\\n    test_dist();\\n}\\n```\n```\\nTesting distribution with 10000 samples\\n0.0987 0.1009 0.1006 0.1025 0.1023 0.0942 0.0945 0.0977 0.1062 0.1024\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541239,
                "title": "c-solution",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int n = (rand7()-1)*7+rand7();\\n        while(n>40)\\n            n = (rand7()-1)*7+rand7();\\n        return (n-1)/4+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int n = (rand7()-1)*7+rand7();\\n        while(n>40)\\n            n = (rand7()-1)*7+rand7();\\n        return (n-1)/4+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538338,
                "title": "java-use-uniform-distribution",
                "content": "```\\n    public int rand10() {\\n        int sum = 49; // 2 rand7, even will be smaller than odd.\\n        while (sum >= 40) sum = 7 * (rand7() - 1) + rand7() - 1;\\n        return sum % 10 + 1;\\n    }\\n```\\nRef: https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22",
                "solutionTags": [],
                "code": "```\\n    public int rand10() {\\n        int sum = 49; // 2 rand7, even will be smaller than odd.\\n        while (sum >= 40) sum = 7 * (rand7() - 1) + rand7() - 1;\\n        return sum % 10 + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351302,
                "title": "solve-rand2-instead",
                "content": "Instead of solving rand10, we can solve rand2 instead: \\n\\nDefine five buckets: [1-2], [3-4], [5-6], [7-8], [9-10]. Call rand7() until you get a number between 1 and 5. Once you have such a number, you have picked one of the five buckets and must now decide which of the two numbers wins - the odd or the even number. To solve that, you call rand7() until you get a number between 1 and 6. Once you have it, you have your answer. \\n\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int f, g;\\n\\t\\t\\n\\t\\t// pick which bucket: 1-2, 3-4, ..., 9-10\\n        while ((f=rand7())>5); \\n\\t\\t\\n\\t\\t// pick odd or even\\n        while ((g=rand7())>6);\\n        \\n\\t\\t// combine the two choices\\n        return 2*f - (g%2);\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int f, g;\\n\\t\\t\\n\\t\\t// pick which bucket: 1-2, 3-4, ..., 9-10\\n        while ((f=rand7())>5); \\n\\t\\t\\n\\t\\t// pick odd or even\\n        while ((g=rand7())>6);\\n        \\n\\t\\t// combine the two choices\\n        return 2*f - (g%2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239916,
                "title": "super-easy-4-lines-solution",
                "content": "Range of `a` is from 1 to 6, range of `b` is from 1 to 5, probability of `a < 4` is 1/2, probability of `b  = 1|2|3|4|5` is 1/5. Then, `b + (a < 4 ? 5 : 0) = 1|2|...|10`, their probability is 1/10.\\n\\n```\\nvar rand10 = function() {\\n    var a = 7, b = 7\\n    while (a === 7) { a = rand7() }\\n    while (b > 5 ) { b = rand7() }\\n    return b + (a < 4 ? 5 : 0)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rand10 = function() {\\n    var a = 7, b = 7\\n    while (a === 7) { a = rand7() }\\n    while (b > 5 ) { b = rand7() }\\n    return b + (a < 4 ? 5 : 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237716,
                "title": "python-solution-using-matrix",
                "content": "The overall idea is to achieve a uniform chance of a number being returned. Every number returned has to have the same chance of being returned. One way to achieve this is to visualize the series of numbers in a 2 dimensional matrix containing a repeated series of numbers in the range we are looking for. Note the matrix may contain elements which are not part of a complete range of numbers 1-10. So, we need to reject those elements.\\n\\n**Steps to reach solution**\\n1. Create a matrix of size 7 x 7\\n2. Populate it with numbers 1-10 continuously\\n3. Blank out the last few elements (1-9) which do not form the full range 1-10 (optional)\\n4. In a `white True:` loop, call rand7() and get row & column indexes of the matrix\\n5. If you get a row or column in the invalid range, try calling rand7() again\\n6. Otherwise, return the value found by `matrix[row][column]`\\n```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        matrix = [[1, 2, 3, 4, 5, 6, 7],\\n                  [8, 9,10, 1, 2, 3, 4],\\n                  [5, 6, 7, 8, 9,10, 1],\\n                  [2, 3, 4, 5, 6, 7, 8],\\n                  [9,10, 1, 2, 3, 4, 5],\\n                  [6, 7, 8, 9,10, 0, 0], # Last 2 elements are invalid\\n                  [0, 0, 0, 0, 0, 0, 0]] # Entire row is invalid\\n        while True:\\n            row = rand7() - 1\\n            col = rand7() - 1\\n            if row == 5 and col >= 5:\\n                continue\\n            elif row == 6:\\n                continue\\n            return matrix[row][col]\\n```",
                "solutionTags": [],
                "code": "```python\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        matrix = [[1, 2, 3, 4, 5, 6, 7],\\n                  [8, 9,10, 1, 2, 3, 4],\\n                  [5, 6, 7, 8, 9,10, 1],\\n                  [2, 3, 4, 5, 6, 7, 8],\\n                  [9,10, 1, 2, 3, 4, 5],\\n                  [6, 7, 8, 9,10, 0, 0], # Last 2 elements are invalid\\n                  [0, 0, 0, 0, 0, 0, 0]] # Entire row is invalid\\n        while True:\\n            row = rand7() - 1\\n            col = rand7() - 1\\n            if row == 5 and col >= 5:\\n                continue\\n            elif row == 6:\\n                continue\\n            return matrix[row][col]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832432,
                "title": "java-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177938,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172860,
                "title": "solutions-with-examples",
                "content": "# Idea: rand7() -> rand49() -> rand40() -> rand10()\\n```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n} \\n```\\n## Time Complexity\\nThe total number of iterations follows geometric distribution. For each iteration in the while loop, the probabilty of exiting the loop is p = 40/49. So the average time complexity T(n) = O(1/p) = O(49/40) = O(1).\\n\\n### Correctness\\nNote that rand49() generates a uniform random integer in [1, 49], so any number in this range has the same probability to be generated. Suppose k is an integer in range [1, 40], P(rand49() = k) = 1/49.\\n\\n P(result = k) =>>>>>> P(rand49() = k in the 1st iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() = k in the 2nd iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() = k in the 3rd iteration) +\\nP(rand49() > 40 in the 1st iteration) * P(rand49() > 40 in the 2nd iteration) * P(rand49() > 40 in the 3rd iteration) * P(rand49() = k in the 4th iteration) +\\n...\\n= (1/49) + (9/49) * (1/49) + (9/49)^2 * (1/49) + (9/49)^3 * (1/49) + ...\\n= (1/49) * [1 + (9/49) + (9/49)^2 + (9/49)^3 + ... ]\\n= (1/49) * [1/(1-9/49)]\\n= (1/49) * (49/40)\\n= 1/40\\n\\n##### Generalization\\nImplement randM() using randN() when M > N:\\nStep 1: Use randN() to generate randX(), where X >= M. In this problem, I use 7 * (rand7() - 1) + (rand7() - 1) to generate rand49() - 1.\\nStep 2: Use randX() to generate randM(). In this problem, I use rand49() to generate rand40() then generate rand10.\\n\\nNote: N^b * (randN() - 1) + N^(b - 1) * (randN() - 1) + N^(b - 2) * (randN() - 1) + ... + N^0 * (randN() - 1) generates randX() - 1, where X = N^(b + 1).\\n\\n# More Examples\\n(1) Implement rand11() using rand3():\\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\\nIdea: rand3() -> rand27() -> rand22 -> rand11\\nTime Comlexity: O(27/22)\\n\\n(2) Implement rand9() using rand7():\\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\\nIdea: rand7() -> rand49() -> rand45() -> rand9()\\nTime Comlexity: O(49/45)\\n\\n(3) Implement rand13() using rand6():\\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```\\nIdea: rand6() -> rand36() -> rand26 -> rand13()\\nTime Comlexity: O(36/26)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int rand10() {\\n    int result = 40;\\n    while (result >= 40) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 10 + 1;\\n} \\n```\n```\\npublic int rand11() {\\n    int result = 22;\\n    while (result >= 22) {result = 3 * 3 * (rand3() - 1) + 3 * (rand3() - 1) + (rand3() - 1);}\\n    return result % 11 + 1;\\n}\\n```\n```\\npublic int rand9() {\\n    int result = 45;\\n    while (result >= 45) {result = 7 * (rand7() - 1) + (rand7() - 1);}\\n    return result % 9 + 1;\\n}\\n```\n```\\npublic int rand13() {\\n    int result = 26;\\n    while (result >= 26) {result = 6 * (rand6() - 1) + (rand6() - 1);}\\n    return result % 13 + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645999,
                "title": "o-1-average-time-o-inf-worst-case-o-1-space-rejection-sampling",
                "content": "![image](https://assets.leetcode.com/users/images/d7fce538-26d1-4b02-8609-5734134aaa82_1664630424.3960588.png)\\n\\nrecursive\\n\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n        return self.rand10() if x > 40 else (x - 1) % 10 + 1\\n\\t\\t\\niterative\\t\\t\\n\\t\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = math.inf\\n\\n        while x > 40:\\n            x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n\\n        return 1 + (x - 1) % 10  # 1+[0..9] num",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/d7fce538-26d1-4b02-8609-5734134aaa82_1664630424.3960588.png)\\n\\nrecursive\\n\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n        return self.rand10() if x > 40 else (x - 1) % 10 + 1\\n\\t\\t\\niterative\\t\\t\\n\\t\\n    def rand10(self):\\n        \"\"\" O(1)T_avg   O(inf)T_worst_case O(1)S  \"\"\"\\n        x = math.inf\\n\\n        while x > 40:\\n            x = (rand7() - 1) * 7 + rand7()  # generate [1..40] num\\n\\n        return 1 + (x - 1) % 10  # 1+[0..9] num",
                "codeTag": "Python3"
            },
            {
                "id": 2502829,
                "title": "python-rand2-and-rand5-because-2-5-10",
                "content": "\\n```\\nclass Solution:\\n    def rand10(self):\\n\\n        def rand2():\\n\\t\\t\\t# uniformly generate [True, False]\\n            n = rand7()\\n            while n == 4:\\n                n = rand7()\\n            return n > 4\\n\\n        def rand5():\\n\\t\\t\\t# uniformly generate 1-5\\n            n = rand7()\\n            while n in (6, 7):\\n                n = rand7()\\n            return n\\n\\t\\t\\n\\t\\t# each number between 1-10 has probablity of 1/2 * 1/5 = 1/10 to be chosen\\n        n = rand5()\\n        if rand2():\\n            n += 5\\n        return n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n\\n        def rand2():\\n\\t\\t\\t# uniformly generate [True, False]\\n            n = rand7()\\n            while n == 4:\\n                n = rand7()\\n            return n > 4\\n\\n        def rand5():\\n\\t\\t\\t# uniformly generate 1-5\\n            n = rand7()\\n            while n in (6, 7):\\n                n = rand7()\\n            return n\\n\\t\\t\\n\\t\\t# each number between 1-10 has probablity of 1/2 * 1/5 = 1/10 to be chosen\\n        n = rand5()\\n        if rand2():\\n            n += 5\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426780,
                "title": "easy-using-c-90-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        while(1)\\n        {\\n            int temp = rand7();\\n            int till_last= (rand7() - 1)*7;\\n            int ans = till_last+temp;\\n            if(ans<=40)\\n            {\\n                return (ans-1)%10 + 1;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        while(1)\\n        {\\n            int temp = rand7();\\n            int till_last= (rand7() - 1)*7;\\n            int ans = till_last+temp;\\n            if(ans<=40)\\n            {\\n                return (ans-1)%10 + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2404316,
                "title": "python-beats-91-detailed-explanation-proof-of-correctness",
                "content": "In problems like this, **there\\'s no single correct solution**. That\\'s why the solutions posted differ so much.\\nHowever, the task is not to implement *the best possible* random number generator. The task is to create a *valid* one.\\n\\nThe only criterion of validity is the uniform distribution of generated values, meaning that each value from range `[1, 10]` has an equal probability of being returned.\\n\\nNow, we are provided with a function `rand7()` that is guaranteed to have a uniform distribution, so its return values from the range `[1, 7]` satisfy the equal probability condition.\\n\\nBelow is a sample solution. Remember, there are other valid solutions, some may be more optimal, but this one is easy to analyse:\\n\\n```\\nclass Solution:\\n    def rand10(self) -> int:        \\n        while (offset := rand7()) > 5:\\n            offset = rand7()        \\n        \\n        while (segment := rand7()) == 4:\\n            segment = rand7()\\n        \\n        return 5 * (segment > 4) + offset\\n```\\nThe logic is simple: we split the range `[1, 10]` in two segments, `[1, 5]` and `[6, 10]`, then we use `rand7()` to pick one of these segments and to generate an offset within it to determine the final return value.\\n\\nFirst we call `rand7()` to generate a number between `1` and `5`. If the generator returns such a value, we just use it as an offset. Indeed, since the probability of picking any number from `[1, 5]` is the same, the distribution for the offset value is uniform.\\nThe tricky part is when `rand7()` returns either `6` or `7`. In this case *we just roll the dice again*, and keep doing it until we finally hit a number from `[1, 5]`. Since every time we call `rand7()` it picks a value randomly, there\\'s no deterministic answer to when a number from `[1, 5]` will be returned, but what\\'s important is that *the probability of each outcome is the same*.\\n\\nNow we do the same for picking one of two segments. This time we use `4` as a pivot, picking the lower segment for any value smaller than `4`, the higher one for any value greater than `4`, and rolling the dice again when it was exactly `4`. The same rules apply, since numbers from `[1, 3]` have the same probability of being picked as numbers from `[5, 7]`, the overall distribution is uniform.\\n\\nThe final step is combining two independently generated uniformly distributed random values, which is again a random number with uniform distribution. And that\\'s exactly what we needed! =)\\n\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self) -> int:        \\n        while (offset := rand7()) > 5:\\n            offset = rand7()        \\n        \\n        while (segment := rand7()) == 4:\\n            segment = rand7()\\n        \\n        return 5 * (segment > 4) + offset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120414,
                "title": "python3-simple-rejection-sampling-based-solution-beats-85-solutions",
                "content": "```\\n\"\"\"https://leetcode.com/problems/implement-rand10-using-rand7/\"\"\"\\n\\n\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        number = -1\\n        number_not_sampled_in_range = True\\n        while number_not_sampled_in_range:\\n            number = 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 40:\\n                number_not_sampled_in_range = False\\n            # note that one can also use something like the following:\\n            \"\"\"number = 49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 340:\\n                number_not_sampled_in_range = False\"\"\"\\n\\n        return 1 + number % 10\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/implement-rand10-using-rand7/\"\"\"\\n\\n\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\n\\nclass Solution:\\n    def rand10(self):\\n        number = -1\\n        number_not_sampled_in_range = True\\n        while number_not_sampled_in_range:\\n            number = 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 40:\\n                number_not_sampled_in_range = False\\n            # note that one can also use something like the following:\\n            \"\"\"number = 49 * (rand7() - 1) + 7 * (rand7() - 1) + (rand7() - 1)\\n            if number < 340:\\n                number_not_sampled_in_range = False\"\"\"\\n\\n        return 1 + number % 10\\n",
                "codeTag": "Java"
            },
            {
                "id": 2119081,
                "title": "java-easy-and-efficient-solution",
                "content": "We are to map the range from 1 to 7 inclusive to a bigger range from 1 to 10 inclusive \\nSo we create a map (2d array) of the size (7x7) and distrubte the element across it, starting from 1 up to 10, after reaching 10 we start again from 1 to 10, we repeat the same process, till there\\'re no enough places to take all of our range (1-10), then we start to fill cells with zeros \\nafter that we pick a number from our distribution using uniformally distributed rand7, because of that our solution will be always unifromally distributed\\n\\n```java \\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 }",
                "codeTag": "Java"
            },
            {
                "id": 2111196,
                "title": "python-easy-solution-faster-then-99-85",
                "content": "![image](https://assets.leetcode.com/users/images/ba28d37e-d4f9-46f6-b4d8-3378cd70902d_1654374278.167117.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/ba28d37e-d4f9-46f6-b4d8-3378cd70902d_1654374278.167117.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1831927,
                "title": "java-solution",
                "content": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int result = ((rand7() - 1)*7) + rand7();\\n        if(result > 40)\\n            return rand10();\\n        return (result%10) + 1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int result = ((rand7() - 1)*7) + rand7();\\n        if(result > 40)\\n            return rand10();\\n        return (result%10) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800231,
                "title": "return-rand7-rand7-rand7-rand7-10-1",
                "content": "```\\nreturn (rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n```\\n\\nThank you.",
                "solutionTags": [],
                "code": "```\\nreturn (rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7()+rand7())%10+1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482098,
                "title": "c-easy-to-understand-brute-force-solution",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        //We use two calls to rand(7) for 49 posssible values w/ equal chance of occuring\\n        \\n        //Example values: \"11\" \"12\" \"21\" \"77\"\\n        //Then, we can form 10 groups of 4 values for our rand10().\\n        \\n        //40 values of 49 are used as possible values for our rand generator\\n        \\n        //If we generate one of the remaining 9 values, call rand10() again\\n        int firstRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int secondRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int appendedVals = stoi(to_string(firstRandomVal) + to_string(secondRandomVal)); //11 12 13 14 15 16 17, 21 22 23 24 25 26 27, etc ...\\n        \\n        if(appendedVals >= 11 && appendedVals <= 14) {\\n            return 1;\\n        } else if(appendedVals >= 15 && appendedVals <= 21) {\\n            return 2;\\n        } else if(appendedVals >= 22 && appendedVals <= 25) {\\n            return 3;\\n        } else if(appendedVals >= 26 && appendedVals <= 32) {\\n            return 4;\\n        } else if(appendedVals >= 33 && appendedVals <= 36) {\\n            return 5;\\n        } else if(appendedVals >= 37 && appendedVals <= 43) {\\n            return 6;\\n        } else if(appendedVals >= 44 && appendedVals <= 47) {\\n            return 7;\\n        } else if(appendedVals >= 51 && appendedVals <= 54) {\\n            return 8;\\n        } else if(appendedVals >= 55 && appendedVals <= 61) {\\n            return 9;\\n        } else if(appendedVals >= 62 && appendedVals <= 65) {\\n            return 10;\\n        } else {\\n            //Remaining 9 values are \"invalid\", call our function again.\\n            return rand10();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        //We use two calls to rand(7) for 49 posssible values w/ equal chance of occuring\\n        \\n        //Example values: \"11\" \"12\" \"21\" \"77\"\\n        //Then, we can form 10 groups of 4 values for our rand10().\\n        \\n        //40 values of 49 are used as possible values for our rand generator\\n        \\n        //If we generate one of the remaining 9 values, call rand10() again\\n        int firstRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int secondRandomVal = rand7(); //Can be 1,2,3,4,5,6,7\\n        int appendedVals = stoi(to_string(firstRandomVal) + to_string(secondRandomVal)); //11 12 13 14 15 16 17, 21 22 23 24 25 26 27, etc ...\\n        \\n        if(appendedVals >= 11 && appendedVals <= 14) {\\n            return 1;\\n        } else if(appendedVals >= 15 && appendedVals <= 21) {\\n            return 2;\\n        } else if(appendedVals >= 22 && appendedVals <= 25) {\\n            return 3;\\n        } else if(appendedVals >= 26 && appendedVals <= 32) {\\n            return 4;\\n        } else if(appendedVals >= 33 && appendedVals <= 36) {\\n            return 5;\\n        } else if(appendedVals >= 37 && appendedVals <= 43) {\\n            return 6;\\n        } else if(appendedVals >= 44 && appendedVals <= 47) {\\n            return 7;\\n        } else if(appendedVals >= 51 && appendedVals <= 54) {\\n            return 8;\\n        } else if(appendedVals >= 55 && appendedVals <= 61) {\\n            return 9;\\n        } else if(appendedVals >= 62 && appendedVals <= 65) {\\n            return 10;\\n        } else {\\n            //Remaining 9 values are \"invalid\", call our function again.\\n            return rand10();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410646,
                "title": "c-faster-than-100",
                "content": "```\\nint rand10() {\\n        int rand40 = 40;\\n        while(rand40 >= 40) {\\n            rand40 = (rand7()-1)*7 + rand7()-1;\\n        }\\n        return rand40%10 + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        int rand40 = 40;\\n        while(rand40 >= 40) {\\n            rand40 = (rand7()-1)*7 + rand7()-1;\\n        }\\n        return rand40%10 + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385546,
                "title": "xorshift-by-rand7-with-analysis-3-lines-1-rand7-call-per-output",
                "content": "So xorshift algorithms are fairly well known for being good pseudo-random number generators (https://en.wikipedia.org/wiki/Xorshift), all I did here was replace the 3 fixed-shift operations with a single random-shift operation and got pretty good results (analysis after the code, which includes as separate implementation of rejection sampling for reference). I\\'ve implemented everything here in python, but this has also worked in c++, c#, and java with the seed 194693639, but otherwise essentially identical code (a good seed is any number with a good number of bits, and some variety in its bit string).\\n\\nBest Performance: 228 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n\\t#Generate a Number Using a Random XorShift\\n\\tseed = 10**9 + 7\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed ^= self.seed >> rand7()\\n        \\n        #Return the Random Value\\n        return 1 + self.seed%10\\n\\t\\n\\t#Generate a Number Using Rejection Sampling\\n    def rand10(self) -> int:\\n        #Select a Range\\n        r1 = rand7()\\n        while r1 == 4:\\n            r1 = rand7()\\n        \\n        #Select a Number Within that Range\\n        r2 = rand7()\\n        while r2 > 5:\\n            r2 = rand7()\\n        \\n        #Return the Number\\n        return (5 if r1 > 4 else 0) + r2\\n\\'\\'\\'\\n\\nTo evaluate any sample functions I wrote I used 2 metrics. The first is a simple histogram of the numbers produced, the second is to look at the stochastic transition matrix produced by the sample (.i.e. if the previous sample returned x how likely is the next sample to return y?). For reference, here are some plots made by generating 100000 random numbers using rejection sampling (note that I changed the range from [1-10] to be [0-9] for convenience).\\n\\n![image](https://assets.leetcode.com/users/images/e1447b26-d1c2-41d3-9c59-3c6311235eed_1628181641.656291.png)\\n![image](https://assets.leetcode.com/users/images/440bc62f-705d-4e18-97a2-41214518c283_1628181682.8810203.png)\\n\\n\\nAs you can see, the histogram is essentially flat, which indicates that all numbers have an equal chace of being drawn. Furthermore, all the transition probabilities are very close to 1/10, indicating that the output doesn\\'t have an easilly discernable pattern.\\n\\nNext, here are are some plots made by generated 100000 random numbers using my modified xorshift:\\n\\n![image](https://assets.leetcode.com/users/images/582bce58-14c2-4aab-a351-088533de79e7_1628181764.9948664.png)\\n![image](https://assets.leetcode.com/users/images/c0716b00-f47e-45d7-8456-7ea9fa6ea196_1628181886.6024754.png)\\n\\nAs you can see, by these metrics, the performance of the random xorshift is essentially identical to the performance of rejection sampling. That does not mean that this algorithm is cryptographically secure, or that it could pass BigCrush, but it was definitely random enough for LeetCode, and random enough that I couldn\\'t easilly break it! If I wanted to make it stronger I\\'d consider adding one or two fixed xor shifts, and/or use bits from the middle of the bit string to generate the outputs.\\n\\n-------------------------------------------\\nNext, just to present a something which obviously fails, here\\'s some code which also passed LeetCode\\'s test cases.\\n\\nBest Performance : 236 ms/16.9 MB : 97%/41%\\n\\'\\'\\'\\n\\n    seed = 2999\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed += 3001\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed%10\\n\\'\\'\\'\\n\\nJust by intuition we already know that this random number generator should be terrible, since it produces the exact same sequence of numbers every time, and the next number is easy to calculate from the previous number. Here are the plots it generates:\\n\\n![image](https://assets.leetcode.com/users/images/22738aee-7041-494f-ad3a-c4dc48ea47b9_1628182551.0322888.png)\\n![image](https://assets.leetcode.com/users/images/3e550cc8-3328-4b13-9789-a766c1ef3f6a_1628182825.0660825.png)\\n\\n\\nSo, it\\'s distribution is perfectly uniform (tbh it\\'s so uniform that that should be a red flag), and it\\'s transition matrix clearly indicates what\\'s happening: a pointer which is being updated by 1 (mod 10) between each sample. The fact that this still passed LeetCode\\'s test cases tells us that they\\'re probably only looking at a histogram of the numbers you generate, and whether or not the standard deviation on the height of the histogram bins is small enough. Were they using anything more sophisticated then they should\\'ve caught this.\\n\\nWhat happens if we make this a little more sophisticated though?\\n\\nBest Performance : 224 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n    seed = 9\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed = (self.seed + rand7())%10\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/abf9ca0b-78d2-4a50-a93e-103daab75eb1_1628183431.6355002.png)\\n![image](https://assets.leetcode.com/users/images/5d78c97c-1da5-4946-999f-44828b865069_1628183480.924376.png)\\n\\nThis time there isn\\'t anything obviously wrong with the histogram! But when you look at the transition matrix there\\'s an obvious pattern (so obvious that you could easilly figure out how the numbers are being generated).\\n\\nAnd actually, every other method I tried which used a single rand7 call per update failed this transition matrix test (even if it passed LeetCode\\'s test cases), except for this final solution, which I don\\'t like because it really just plays to the test (I pretty much just kept finding more old random numbers to add until it\\'s transition matrix looked decent).\\n\\nBest Performance: 272 ms/17 MB : 97%/6%\\n\\n\\'\\'\\'\\n\\n    queue = deque([1, 2, 5, 4, 3, 5, 3, 7, 7, 1])\\n    seed = 8\\n    def rand10(self) -> int:\\n        #Generate a Random Number\\n        r = rand7()\\n        \\n        #Increment the Sum\\n        self.seed = (self.seed + self.queue[self.seed] + r + self.queue[r] + self.queue.popleft())%10\\n        \\n        #Record the Latest Random Number\\n        self.queue.append(r)\\n        \\n        #Return the Random Number\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/5bf15d38-b275-4291-b8cf-122a17937016_1628188466.5762591.png)\\n![image](https://assets.leetcode.com/users/images/99048987-e6f2-4615-a3ad-851cf2cc6ce1_1628188503.325822.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "So xorshift algorithms are fairly well known for being good pseudo-random number generators (https://en.wikipedia.org/wiki/Xorshift), all I did here was replace the 3 fixed-shift operations with a single random-shift operation and got pretty good results (analysis after the code, which includes as separate implementation of rejection sampling for reference). I\\'ve implemented everything here in python, but this has also worked in c++, c#, and java with the seed 194693639, but otherwise essentially identical code (a good seed is any number with a good number of bits, and some variety in its bit string).\\n\\nBest Performance: 228 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n\\t#Generate a Number Using a Random XorShift\\n\\tseed = 10**9 + 7\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed ^= self.seed >> rand7()\\n        \\n        #Return the Random Value\\n        return 1 + self.seed%10\\n\\t\\n\\t#Generate a Number Using Rejection Sampling\\n    def rand10(self) -> int:\\n        #Select a Range\\n        r1 = rand7()\\n        while r1 == 4:\\n            r1 = rand7()\\n        \\n        #Select a Number Within that Range\\n        r2 = rand7()\\n        while r2 > 5:\\n            r2 = rand7()\\n        \\n        #Return the Number\\n        return (5 if r1 > 4 else 0) + r2\\n\\'\\'\\'\\n\\nTo evaluate any sample functions I wrote I used 2 metrics. The first is a simple histogram of the numbers produced, the second is to look at the stochastic transition matrix produced by the sample (.i.e. if the previous sample returned x how likely is the next sample to return y?). For reference, here are some plots made by generating 100000 random numbers using rejection sampling (note that I changed the range from [1-10] to be [0-9] for convenience).\\n\\n![image](https://assets.leetcode.com/users/images/e1447b26-d1c2-41d3-9c59-3c6311235eed_1628181641.656291.png)\\n![image](https://assets.leetcode.com/users/images/440bc62f-705d-4e18-97a2-41214518c283_1628181682.8810203.png)\\n\\n\\nAs you can see, the histogram is essentially flat, which indicates that all numbers have an equal chace of being drawn. Furthermore, all the transition probabilities are very close to 1/10, indicating that the output doesn\\'t have an easilly discernable pattern.\\n\\nNext, here are are some plots made by generated 100000 random numbers using my modified xorshift:\\n\\n![image](https://assets.leetcode.com/users/images/582bce58-14c2-4aab-a351-088533de79e7_1628181764.9948664.png)\\n![image](https://assets.leetcode.com/users/images/c0716b00-f47e-45d7-8456-7ea9fa6ea196_1628181886.6024754.png)\\n\\nAs you can see, by these metrics, the performance of the random xorshift is essentially identical to the performance of rejection sampling. That does not mean that this algorithm is cryptographically secure, or that it could pass BigCrush, but it was definitely random enough for LeetCode, and random enough that I couldn\\'t easilly break it! If I wanted to make it stronger I\\'d consider adding one or two fixed xor shifts, and/or use bits from the middle of the bit string to generate the outputs.\\n\\n-------------------------------------------\\nNext, just to present a something which obviously fails, here\\'s some code which also passed LeetCode\\'s test cases.\\n\\nBest Performance : 236 ms/16.9 MB : 97%/41%\\n\\'\\'\\'\\n\\n    seed = 2999\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed += 3001\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed%10\\n\\'\\'\\'\\n\\nJust by intuition we already know that this random number generator should be terrible, since it produces the exact same sequence of numbers every time, and the next number is easy to calculate from the previous number. Here are the plots it generates:\\n\\n![image](https://assets.leetcode.com/users/images/22738aee-7041-494f-ad3a-c4dc48ea47b9_1628182551.0322888.png)\\n![image](https://assets.leetcode.com/users/images/3e550cc8-3328-4b13-9789-a766c1ef3f6a_1628182825.0660825.png)\\n\\n\\nSo, it\\'s distribution is perfectly uniform (tbh it\\'s so uniform that that should be a red flag), and it\\'s transition matrix clearly indicates what\\'s happening: a pointer which is being updated by 1 (mod 10) between each sample. The fact that this still passed LeetCode\\'s test cases tells us that they\\'re probably only looking at a histogram of the numbers you generate, and whether or not the standard deviation on the height of the histogram bins is small enough. Were they using anything more sophisticated then they should\\'ve caught this.\\n\\nWhat happens if we make this a little more sophisticated though?\\n\\nBest Performance : 224 ms/16.8 MB : 98%/41%\\n\\n\\'\\'\\'\\n\\n    seed = 9\\n    def rand10(self) -> int:\\n        #Update the Seed\\n        self.seed = (self.seed + rand7())%10\\n        \\n        #Return the Random Value (mod 10)\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/abf9ca0b-78d2-4a50-a93e-103daab75eb1_1628183431.6355002.png)\\n![image](https://assets.leetcode.com/users/images/5d78c97c-1da5-4946-999f-44828b865069_1628183480.924376.png)\\n\\nThis time there isn\\'t anything obviously wrong with the histogram! But when you look at the transition matrix there\\'s an obvious pattern (so obvious that you could easilly figure out how the numbers are being generated).\\n\\nAnd actually, every other method I tried which used a single rand7 call per update failed this transition matrix test (even if it passed LeetCode\\'s test cases), except for this final solution, which I don\\'t like because it really just plays to the test (I pretty much just kept finding more old random numbers to add until it\\'s transition matrix looked decent).\\n\\nBest Performance: 272 ms/17 MB : 97%/6%\\n\\n\\'\\'\\'\\n\\n    queue = deque([1, 2, 5, 4, 3, 5, 3, 7, 7, 1])\\n    seed = 8\\n    def rand10(self) -> int:\\n        #Generate a Random Number\\n        r = rand7()\\n        \\n        #Increment the Sum\\n        self.seed = (self.seed + self.queue[self.seed] + r + self.queue[r] + self.queue.popleft())%10\\n        \\n        #Record the Latest Random Number\\n        self.queue.append(r)\\n        \\n        #Return the Random Number\\n        return 1 + self.seed\\n\\'\\'\\'\\n\\n![image](https://assets.leetcode.com/users/images/5bf15d38-b275-4291-b8cf-122a17937016_1628188466.5762591.png)\\n![image](https://assets.leetcode.com/users/images/99048987-e6f2-4615-a3ad-851cf2cc6ce1_1628188503.325822.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 817188,
                "title": "javascript-with-beginners-explanation-of-math",
                "content": "**PREAMBLE**\\n\\nGiven rand7( ), the function alone is not enough to provide a fine-grained enough variation of integer results to directly create rand10( ). That is, if we did\\n```\\n\\tconst rand10 = () => 10*Math.round(rand7()/7);\\n```\\nthe scope of possible results taking [10*(1/7), 10*(2/7)..., 10*(7/7)] would be limited to [1,3,4,6,7,9,10], i.e. it\\'s impossible to get the numbers  [2,5,8]. If the problem was to go from some function with more fine-grained set of possibilities to a smaller one (like creating rand7( ) from rand10( )) then the above approach would potentially be viable:\\n```\\n\\tconst rand7 = () => 7*Math.round(rand10/10);\\n```\\nas it creates the results [1,1,2,3,4,4,5,6,6,7] -- all required possible outcomes 1-7 are reachable but the probability is still not totally even as it should be (some numbers occur with 2/10 frequency while others occur with 1/10 frequency) and this distribution would be exposed for large numbers of tries of rand7( ).\\n\\n**THIS PROBLEM\\'S SOLUTIONS**\\n\\nThe key is to use multiple calls of rand7( ) to generate a large enough range of numbers that can be reduced down to the integers ranging from 1 - 10 inclusive with fairly even probability consistently. This means calls of rand7( ) must be increased in such a way that the result \"gaps\" noticed before are somehow overcome without skewing the distribution unfairly.\\n\\nOne approach is to sum rand7( ) calls and combine with modulo 10, creating a larger and larger possible range of rand7( ) sums between some lower and some upper bound until the breadth and variation in possible sums produced (in combination with modulo) satisfies all the test cases like so:\\n```\\n const rand10 = () => (rand7() + rand7() + ..... + rand7()) % 10 + 1;\\n const rand10 = () => (rand7() + rand7() + rand7() + rand7() + rand7()) % 10 + 1;   //final answer from trial and error\\n```\\nwhere rand7( )\\'s are added until the submit passes. By trial and error, a minimum of five calls to rand7( ) appear to be required to pass. \\n\\nAs others have pointed out, this appears to be because this is the threshold at which the probability distribution for (7 sided die)^5 producing sums 5 to 35 (see Wolfram: https://www.wolframalpha.com/input/?i=7+sided+die+rolled+5+times+distribution ), has been divided roughly equally after the modulo 10 which groups the probabilities by their last digit.\\n\\nEach outcome from 1 to 10 for rand10( ) gets three slices of the probability distribution (sums) above, spaced roughly evenly: from a cursory visual inspection you can see that P(5) + P(15) + P(25) is about equal to P(6)+P(16)+P(26) and so on. The even spacing of each last digit group in the distribution compensates for variations in adjacent values between one digit group and the next.\\n\\nLower numbers of dice do not work because they create distributions that are not as finely divided into different sums and can not be as evenly distributed to the 10 answers. When the discrepancies are pronounced to some arbitrary extent, the runs fail.\\n\\nThe five rand7( ) calls create the minimum necessary refinement of the range of answers. Additional rand7( ) calls would further refine the range of answers beyond the requirement and still pass but represent an unnecessary expenditure of speed and memory.\\n\\nAnother approach is to square two rand7( ) calls and calculate an answer like so:\\n\\n```\\nconst rand10 = () => {\\n    let random = 41;\\n    while (random > 40) random = 7 * (rand7() - 1) + rand7();\\n    return (random % 10) + 1; \\n};\\n```\\nthe range of possible square results, before the modulo 10 step, is 1 to 49. The largest full multiple of 10 within this range is 40 and is used as a bound for rejecting samples. \\n\\nIncluding samples ranging from 41 to 49 would unfairly add outcomes for rand10 => 2 to 10 to the answer pool, so the answer is only taken when the squared value is <= 40 to maintain even probability for rand10 => 1 to 10.",
                "solutionTags": [],
                "code": "```\\n\\tconst rand10 = () => 10*Math.round(rand7()/7);\\n```\n```\\n\\tconst rand7 = () => 7*Math.round(rand10/10);\\n```\n```\\n const rand10 = () => (rand7() + rand7() + ..... + rand7()) % 10 + 1;\\n const rand10 = () => (rand7() + rand7() + rand7() + rand7() + rand7()) % 10 + 1;   //final answer from trial and error\\n```\n```\\nconst rand10 = () => {\\n    let random = 41;\\n    while (random > 40) random = 7 * (rand7() - 1) + rand7();\\n    return (random % 10) + 1; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817075,
                "title": "c-simple-solution-faster-than-97-less-memory-than-93-explained-true-1-7-probability",
                "content": "We will generate number from 1 to 5,lets call it `b`,and then,we will decide if we want to add 5,or not using one more number,we will call it `a`\\nBut that decision must have same probability,50-50.\\nSo,i will generate `a`,its range is from 1 to 7,how can we get 50-50?\\nWe can take for example next rule:\\nIf `a==1` we will not add 5\\nIf `a==2` we will add 5\\nIf `a>2` lets generate `a` again,but that is not good solution,because probability that we will need to generate `a` again is 5/7,we want it to be as small as possible.\\nSo,lets use next rule\\nIf `a<4` we will not add 5\\nIf `a>4` we will add 5\\nIf `a==4` lets generate `a` again\\n\\nSimilar solution is to generate b from 1 to 5 using rand7\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a,b;\\n        do {\\n            a = rand7();\\n        } while (a==4);\\n        do {\\n            b = rand7();\\n        } while (b>5);\\n        return a>4?b+5:b;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a,b;\\n        do {\\n            a = rand7();\\n        } while (a==4);\\n        do {\\n            b = rand7();\\n        } while (b>5);\\n        return a>4?b+5:b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816956,
                "title": "why-is-my-solution-false-for-rand10",
                "content": "So here I roll rand7() until i get an integer in a 1 to 5 range\\n\\nthen I roll again between a range of 1 to 6. if the number is between 1-3 we return the pick and if it\\'s between 4-6 we double the result\\n\\nTo me each number have equal chances to get picked, enlight me please\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        pick = 10\\n        while pick > 5:\\n            pick = rand7()\\n        double = 10\\n\\t\\twhile double > 6:\\n\\t\\t\\tdouble = rand7()\\n        if double > 3:\\n            return pick * 2\\n        return pick\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        pick = 10\\n        while pick > 5:\\n            pick = rand7()\\n        double = 10\\n\\t\\twhile double > 6:\\n\\t\\t\\tdouble = rand7()\\n        if double > 3:\\n            return pick * 2\\n        return pick\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816904,
                "title": "java-1-line-beats-100-zero-calls-to-rand7-made",
                "content": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n\\n    /**\\n    Lets take input is 1000.\\n    The count will get incremented by 1, everytime the method rand10() is called.\\n    The idea here is to distribute values 1 to 10 equally.\\n    \\n    Let\\'s say rand10() is called for 447th time.\\n    At this point c = 447\\n    and 447%10 + 1 = 7 + 1 = 8 will be returned.\\n    \\n    \\n    */\\n    int count = 1;\\n    \\n    public int rand10() {\\n        return (count++)%10 + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n\\n    /**\\n    Lets take input is 1000.\\n    The count will get incremented by 1, everytime the method rand10() is called.\\n    The idea here is to distribute values 1 to 10 equally.\\n    \\n    Let\\'s say rand10() is called for 447th time.\\n    At this point c = 447\\n    and 447%10 + 1 = 7 + 1 = 8 will be returned.\\n    \\n    \\n    */\\n    int count = 1;\\n    \\n    public int rand10() {\\n        return (count++)%10 + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816759,
                "title": "python-three-different-solutions-with-comments",
                "content": "```\\nclass Solution:\\n    # Three helper functions\\n    \\n    def rand49(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 48\\n        Expected value of rand7() calls equal to 2 (It is deterministic) \\n        \\'\\'\\'\\n        multiple = rand7() - 1\\n        remainder = rand7() - 1\\n        return 7*multiple + remainder\\n    \\n    def rand2(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 1\\n        Expected value of rand7() calls equal to 1 + 1/6 = 7/6 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x == 7:\\n            x = rand7()\\n        return x % 2\\n\\n    def rand5(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 4\\n        Expected value of rand7() calls equal to 1 + 2/5 = 7/5 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x in [6,7]:\\n            x = rand7()\\n        return x % 5\\n        \\n    # Three solutions\\n    \\n    def rand10_method_1(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2 * (9/40) = 2.45 \\n        \\'\\'\\'\\n        x = self.rand49()\\n        while x in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n            x = self.rand49()\\n        return 1 + x % 10\\n    \\n    def rand10_method_2(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2/7(7/5) + (5/7)(7/6) = 2.2(3) \\n        \\'\\'\\'\\n        x = rand7()\\n        if x in [1,2]:\\n            y = self.rand5()\\n            return 5*(x-1) + y + 1 \\n        if x in [3,4,5,6,7]:\\n            y = self.rand2()\\n            return 5*y + (x-3) + 1\\n\\n    def rand10_method_3(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 2.19(3) \\n        \\'\\'\\'\\n        while True:\\n            x = rand7() - 1 #  Uniform Distribution (UD) on 0,...,6\\n            y = rand7() - 1 # UD on 0,...,6\\n            result = (x)*7 + y # UD on 0,1,...,48\\n            if result not in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n                # result conditionally uniformly distributed on 0,...,49\\n                return result % 10 + 1 # result % 10 UD on 0,...,9 \\n            else:\\n                x = result - 40 # UD on 0,...,8\\n                y = rand7() - 1 # UD on 0,...,6\\n                result = x * 7 + y # UD on 0,...,62\\n                if result not in range(60,63): #[60,61,62]\\n                    # result conditionally uniformly distributed on 0,...,59\\n                    return result % 10 + 1 # result % 10 UD on 0,...,9\\n                else:\\n                    x = result - 60 # UD on 0,...,2\\n                    y = rand7() - 1# UD on 0,...,6\\n                    result = (x)*7 + y # UD on 0,1,...,20\\n                    if result != 20:\\n                        # conditionally uniformly distributed on 0,...,19\\n                        return result % 10 + 1 # result % 10 has uniform distribution on 0,...,9\\n                    else: continue\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # Three helper functions\\n    \\n    def rand49(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 48\\n        Expected value of rand7() calls equal to 2 (It is deterministic) \\n        \\'\\'\\'\\n        multiple = rand7() - 1\\n        remainder = rand7() - 1\\n        return 7*multiple + remainder\\n    \\n    def rand2(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 1\\n        Expected value of rand7() calls equal to 1 + 1/6 = 7/6 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x == 7:\\n            x = rand7()\\n        return x % 2\\n\\n    def rand5(self):\\n        \\'\\'\\'\\n        Returns a random number from 0 to 4\\n        Expected value of rand7() calls equal to 1 + 2/5 = 7/5 \\n        \\'\\'\\'\\n        x = rand7()\\n        while x in [6,7]:\\n            x = rand7()\\n        return x % 5\\n        \\n    # Three solutions\\n    \\n    def rand10_method_1(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2 * (9/40) = 2.45 \\n        \\'\\'\\'\\n        x = self.rand49()\\n        while x in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n            x = self.rand49()\\n        return 1 + x % 10\\n    \\n    def rand10_method_2(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 1 + 2/7(7/5) + (5/7)(7/6) = 2.2(3) \\n        \\'\\'\\'\\n        x = rand7()\\n        if x in [1,2]:\\n            y = self.rand5()\\n            return 5*(x-1) + y + 1 \\n        if x in [3,4,5,6,7]:\\n            y = self.rand2()\\n            return 5*y + (x-3) + 1\\n\\n    def rand10_method_3(self):\\n        \\'\\'\\'\\n        Returns a random number from 1 to 10\\n        Expected value of rand7() calls equal to 2.19(3) \\n        \\'\\'\\'\\n        while True:\\n            x = rand7() - 1 #  Uniform Distribution (UD) on 0,...,6\\n            y = rand7() - 1 # UD on 0,...,6\\n            result = (x)*7 + y # UD on 0,1,...,48\\n            if result not in range(40,49): # [40,41,42,43,44,45,46,47,48]\\n                # result conditionally uniformly distributed on 0,...,49\\n                return result % 10 + 1 # result % 10 UD on 0,...,9 \\n            else:\\n                x = result - 40 # UD on 0,...,8\\n                y = rand7() - 1 # UD on 0,...,6\\n                result = x * 7 + y # UD on 0,...,62\\n                if result not in range(60,63): #[60,61,62]\\n                    # result conditionally uniformly distributed on 0,...,59\\n                    return result % 10 + 1 # result % 10 UD on 0,...,9\\n                else:\\n                    x = result - 60 # UD on 0,...,2\\n                    y = rand7() - 1# UD on 0,...,6\\n                    result = (x)*7 + y # UD on 0,1,...,20\\n                    if result != 20:\\n                        # conditionally uniformly distributed on 0,...,19\\n                        return result % 10 + 1 # result % 10 has uniform distribution on 0,...,9\\n                    else: continue\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 816505,
                "title": "video-solution-with-easy-explaination",
                "content": "https://www.youtube.com/watch?v=idQvHZPeWMI\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int noLesser40 = 41;\\n        while(noLesser40 >= 40) { // till the time it is not less than 40\\n            noLesser40 = (rand7() -1)*7 + rand7() -1; \\n        }\\n        return noLesser40% 10 + 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends SolBase {\\n    public int rand10() {\\n        int noLesser40 = 41;\\n        while(noLesser40 >= 40) { // till the time it is not less than 40\\n            noLesser40 = (rand7() -1)*7 + rand7() -1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816458,
                "title": "rand10-c-very-simple",
                "content": "```\\nstatic int num = INT_MAX;\\nclass Solution {\\npublic:\\n    int rand10() {\\n        num = num - 7;\\n        return (num + rand7()) % 10 + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int num = INT_MAX;\\nclass Solution {\\npublic:\\n    int rand10() {\\n        num = num - 7;\\n        return (num + rand7()) % 10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816358,
                "title": "c-why-wrong",
                "content": "I just want to ask what is wrong with this solution\\n\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n      \\n        while(1){\\n              int s=0;\\n        for(int i=0;i<10;i++)\\n        s=s+rand7();\\n        if(s==70)\\n            continue;\\n            s=s-10;\\n            return s/6+1;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n      \\n        while(1){\\n              int s=0;\\n        for(int i=0;i<10;i++)\\n        s=s+rand7();\\n        if(s==70)\\n            continue;\\n            s=s-10;\\n            return s/6+1;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816281,
                "title": "expand-and-fill",
                "content": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        a = 6\\n        while a >= 6:\\n            a = rand7()\\n        b = 7\\n        while b == 7:\\n            b = rand7()\\n        return 2*a-(b%2)\\n```\\nLet `a` be one of  `{1, 2, 3, 4, 5}`\\uFF0Cthen we have `2a` being one of `{2, 4, 6, 8, 10}`, each with a probability  of `0.2`. Then find another number `b` which is not `7`, being one of `{1, 2, 3, 4, 5, 6}`, so that it has a fair chance of being even or odd. Consequently we can get a `0` or `1` out of `b` by taking its modulus of 2. Finally, subtraction of `a` and `b%2` yields an integer with in the range `[1, 10]`. The generations of `a` and `b` are independent, so the probability of each combination is `0.2*0.5=0.1`. Thus we have a uniform distribution.\\n\\nThe crux to this problem is `UNIFORM`. The most simplistic way to guarantee that is to make sure there is one and only one way to generate a specific number. So that\\'s what I did. First, you need a range `at least` as long as 10.   \\n\\nThat\\'s easy, a multiplication by 2 will do. Then you realize not all numbers in this range are accessible: 3, 9 .etc.  \\n\\nHow do we fix that ? We try to shift the result by at most 1. And that\\'s what `b` is for.  \\n\\nBy `at least`, I mean there are other ways. Like if we multiply the range by 3, it works too. The important thing here is to make sure no overlapping happens.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        a = 6\\n        while a >= 6:\\n            a = rand7()\\n        b = 7\\n        while b == 7:\\n            b = rand7()\\n        return 2*a-(b%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816248,
                "title": "python-by-random-variable-mapping-w-comment",
                "content": "**Hint**\\n\\nFirst of all, [rand7() is provided by description](https://leetcode.com/problems/implement-rand10-using-rand7/), and it is guaranteed to yield unifrom random number in 1 ~ 7.\\n\\nOur objective is to make rand10( ) from rand7( )\\n\\nThink of number representation in base 7.\\n\\nWhen we run rand7( ) once, we can get 1 ~ 7^1 = 1 ~ 7\\nRange 1 ~ 7 is too small for re-mapping to 1 ~ 10.\\n\\nWhen we run rand7( ) twice, we can get 1 ~ 7^2 = 1 ~ 49\\nRange 1 ~ 49 is large enough.\\n\\nGenerate uniform random number by invoking rand7( ) twice, called **random_num**, from 1 ~ 49\\nKeep doing so until random number is in range 1 ~ 40\\n\\nNext, map random_num from 1 ~ 40 down to 1 ~ 10 by modulo with offset ( i.e., **random_num** %10 + 1)\\n\\nFinally, we implement rand10( ) by calling rand7( ), and output number 1 ~ 10 with uniform distribution.\\n\\n---\\n\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        \\n        while True:\\n\\t\\t\\n\\t\\t\\t# generate a random number from 1 ~ 49 with uniform distribution\\n            random_num = ( rand7() - 1 ) * 7 + rand7()\\n            \\n            if random_num <= 40:\\n\\t\\t\\t\\n\\t\\t\\t    # map 1 ~ 40 to 1 ~ 10 by modulo operation with offset\\n                return random_num % 10 + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        \\n        while True:\\n\\t\\t\\n\\t\\t\\t# generate a random number from 1 ~ 49 with uniform distribution\\n            random_num = ( rand7() - 1 ) * 7 + rand7()\\n            \\n            if random_num <= 40:\\n\\t\\t\\t\\n\\t\\t\\t    # map 1 ~ 40 to 1 ~ 10 by modulo operation with offset\\n                return random_num % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693434,
                "title": "why-does-this-simple-solution-work-and-beat-60",
                "content": "I submitted this solution thinking no way this will get accepted but this beat 60% of C++ submissions.\\n\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0;i<10;i++) {\\n            sum += rand7();\\n        }\\n        return sum%10 + 1;\\n    }\\n};\\n```\\n\\nMy thought process was first make sure we can get a multiple of 10 from 7 by repeatedly adding rand7() 10 times, then if we mod that by 10 we should be getting a number from 0 to 9 with equal probability.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0;i<10;i++) {\\n            sum += rand7();\\n        }\\n        return sum%10 + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635094,
                "title": "why-my-implementation-doesn-t-work",
                "content": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int out=(rand7()+rand7())%11;\\n        return out==0 ? rand10():out;\\n    }\\n}\\n```\\nwhy does this implementation fails for test case input 1000?\\nalthough it passes 7/10 test cases.\\ncan someone explain",
                "solutionTags": [],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int out=(rand7()+rand7())%11;\\n        return out==0 ? rand10():out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544599,
                "title": "quick-n-easy-ruby-solution",
                "content": "This was inspired by some other folks answers in other languages. I\\'m stiiilllll trying to wrap my head around this one, a bit, but wanted to contribute a Ruby solution since (a) there weren\\'t any yet and (b) to help myself better parse this problem.\\n\\n```ruby\\ndef rand10\\n  r = (rand7 - 1) * 7 + (rand7 - 1)\\n\\n  if r < 40\\n    return (r % 10) + 1\\n  else\\n    rand10\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\ndef rand10\\n  r = (rand7 - 1) * 7 + (rand7 - 1)\\n\\n  if r < 40\\n    return (r % 10) + 1\\n  else\\n    rand10\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 514398,
                "title": "470-implement-rand10-using-rand7-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Radom a Greater Range then Mod**\\n| O(T): O(1) | O(S): O(1) | Rt: 340ms | \\n```python\\nclass Solution:\\n    def rand10(self):\\n        while True:\\n            #random [0, 48] or [0, 49)\\n            candidate = 7 * (rand7() - 1) + (rand7() - 1)  \\n            #random [0, 39] or [0, 40)\\n            if candidate < 40: return candidate % 10 + 1\\n```\\nReferrence: https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rand10(self):\\n        while True:\\n            #random [0, 48] or [0, 49)\\n            candidate = 7 * (rand7() - 1) + (rand7() - 1)  \\n            #random [0, 39] or [0, 40)\\n            if candidate < 40: return candidate % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483816,
                "title": "c-10",
                "content": "// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution \\n{\\n    public:\\n        \\n    int rand10()     \\n    {   \\n        while(true)\\n        {\\n            const int a1 = rand7();\\n            const int a2 = rand7();\\n            \\n            if(a1 == 1 && a2 == 1)\\n            {\\n                return 1;\\n            }\\n            else if(a1 == 1 && a2 == 2)\\n            {\\n                return 2;\\n            }\\n            else if(a1 == 1 && a2 == 3)\\n            {\\n                return 3;\\n            }\\n            else if(a1 == 1 && a2 == 4)\\n            {\\n                return 4;\\n            }\\n            else if(a1 == 1 && a2 == 5)\\n            {\\n                return 5;\\n            }\\n            else if(a1 == 1 && a2 == 6)\\n            {\\n                return 6;\\n            }\\n            else if(a1 == 1 && a2 == 7)\\n            {\\n                return 7;\\n            }\\n            else if(a1 == 2 && a2 == 7)\\n            {\\n                return 8;\\n            }\\n            else if(a1 == 3 && a2 == 7)\\n            {\\n                return 9;\\n            }\\n            else if(a1 == 4 && a2 == 7)\\n            {\\n                return 10;\\n            }\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n        \\n    int rand10()     \\n    {   \\n        while(true)\\n        {\\n            const int a1 = rand7();\\n            const int a2 = rand7();\\n            \\n            if(a1 == 1 && a2 == 1)\\n            {\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 462832,
                "title": "python3-solution-accepted-but-not-sure-why",
                "content": "it was accepted, and my simulation showed that it is uniformly distributed, but i can\\'t prove it. it\\'d be great if someone can help me to explain....\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(10):\\n            res += rand7()\\n        return res%10+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(10):\\n            res += rand7()\\n        return res%10+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443152,
                "title": "brand-new-and-easier-way-in-python3",
                "content": "This way is not that fast, because the result it need is 10/49 and other results will be throwed away. \\n```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            t1 = rand7()\\n            t2 = rand7()\\n            if t1 in range(1, 6) and t2 in range(6, 8):\\n                if t2 == 6:\\n                    return t1\\n                else:\\n                    return t1+5\\n            elif t2 in range(1, 6) and t1 in range(6, 8):\\n                if t1 == 6:\\n                    return t2\\n                else:\\n                    return t2+5\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            t1 = rand7()\\n            t2 = rand7()\\n            if t1 in range(1, 6) and t2 in range(6, 8):\\n                if t2 == 6:\\n                    return t1\\n                else:\\n                    return t1+5\\n            elif t2 in range(1, 6) and t1 in range(6, 8):\\n                if t1 == 6:\\n                    return t2\\n                else:\\n                    return t2+5\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 405451,
                "title": "can-someone-explain-why-is-this-not-a-solution",
                "content": "rand7 will generate 1..7\\nrand7 // 2 will generate 0..3\\n\\nCombine togetger we will have range from 1..10\\nBut my solution got rejected. Can someone help?\\n\\n```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return rand7() + (rand7() // 2)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return rand7() + (rand7() // 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336747,
                "title": "reframing-the-solution",
                "content": "Here is another way to think about it:\\n\\nYou are using `rand7` to generate each digit of a two-digit base-seven number:\\n* You evaluate `rand7() - 1` to get a random number from 0-6. Let\\'s say this number is 5. This is the first digit.\\n* You evaluate `rand7() - 1` again to get another random number. Let\\'s say this number is 3. This is the second digit.\\n* Multiply the first digit by 7 and then add the second, to get (53)<sub>7</sub> = (38)<sub>10</sub>.\\n\\nYou now have a number chosen uniformly at random from 0-(66)<sub>7</sub> inclusive, which is the same as  0-48. Why is it uniform? Because there is a one-to-one mapping from pairs of digits (x, y) to base-seven numbers (xy)<sub>7</sub>, and each pair of digits is equally likely to occur.\\n\\nTo get a number chosen uniformly at random from 0-39, we just generate numbers by the above procedure and take the first that is less than 40. Now we can floor-divide this number by 4 to get a number from 0-9, and then add one to get a number chosen uniformly at random from 1-10.\\n\\n```python\\ndef rand10():\\n\\twhile True:\\n\\t\\tx = 7*(rand7()-1) + (rand7()-1)\\n\\t\\tif x < 40:\\n\\t\\t\\tbreak\\n\\treturn (x // 4) + 1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef rand10():\\n\\twhile True:\\n\\t\\tx = 7*(rand7()-1) + (rand7()-1)\\n\\t\\tif x < 40:\\n\\t\\t\\tbreak\\n\\treturn (x // 4) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 292367,
                "title": "generate-random-value-in-any-range-o-logn",
                "content": "First we generate 0 or 1 random value (rand2()) and then we can generate a random value in any range using the same function.\\n\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    \\n    // Generate 0 or 1 uniformly\\n    int rand2() {\\n        int x = 7;\\n        while (x == 7) {\\n            x = rand7();\\n        }\\n        return x <= 3;\\n    }\\n    \\n    // Generate any range random variable uniformly using rand2()\\n    int randRange(int start, int end) {\\n        int res = end;\\n        end -= start;\\n\\t\\t\\n        while (res > end) {\\n            res = 0;\\n            for (int i = 0; i <= floor(log2(end)); i++) {\\n                res |= rand2();\\n                res <<= 1;\\n            }\\n            res >>= 1;\\n        }\\n        return start + res;\\n    }\\n    \\n    int rand10() {\\n        return randRange(1, 10);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    \\n    // Generate 0 or 1 uniformly\\n    int rand2() {\\n        int x = 7;\\n        while (x == 7) {\\n            x = rand7();\\n        }\\n        return x <= 3;\\n    }\\n    \\n    // Generate any range random variable uniformly using rand2()\\n    int randRange(int start, int end) {\\n        int res = end;\\n        end -= start;\\n\\t\\t\\n        while (res > end) {\\n            res = 0;\\n            for (int i = 0; i <= floor(log2(end)); i++) {\\n                res |= rand2();\\n                res <<= 1;\\n            }\\n            res >>= 1;\\n        }\\n        return start + res;\\n    }\\n    \\n    int rand10() {\\n        return randRange(1, 10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285076,
                "title": "rejection-sampling-simple-clean-code",
                "content": "```\\nclass Solution {\\n    bool flag = false; \\npublic:\\n    int rand10() {\\n        int result;\\n        \\n        do{\\n            result = rand7();\\n        } while (result > 5);\\n        \\n        if(flag)  {\\n            flag = false;\\n            return result;\\n        }\\n        \\n        else{\\n            flag = true;\\n            return result + 5;\\n        }                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool flag = false; \\npublic:\\n    int rand10() {\\n        int result;\\n        \\n        do{\\n            result = rand7();\\n        } while (result > 5);\\n        \\n        if(flag)  {\\n            flag = false;\\n            return result;\\n        }\\n        \\n        else{\\n            flag = true;\\n            return result + 5;\\n        }                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273777,
                "title": "go-very-easy-2-57-calls",
                "content": "```\\nfunc rand10() int {\\n    base, pro := 7, 7\\n    for base > 5 {\\n      base = rand7() \\n    }\\n    for pro > 6 {\\n        pro = rand7()\\n    }\\n    pro = pro % 2\\n    return pro*5 + base\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rand10() int {\\n    base, pro := 7, 7\\n    for base > 5 {\\n      base = rand7() \\n    }\\n    for pro > 6 {\\n        pro = rand7()\\n    }\\n    pro = pro % 2\\n    return pro*5 + base\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 244824,
                "title": "the-test-cases-don-t-seem-to-test-randomness-is-my-solution-actually-random",
                "content": "```\\nint rand10() { \\n    // first call map 1-3 to 1 and 4-6 to 0\\n    int first = rand7();\\n    int second = rand7();\\n    while(first > 6 || second > 5){\\n        first = rand7();\\n        second = rand7();\\n    }\\n    unsigned multiplier = first < 4 ? 0 : 1;\\n    return second + multiplier*5;\\n}\\n```\\nThe idea is that we get a number 1-5 by using a call to rand7() and rejecting 6 and 7. The we use another call to rand7() to get 1-6, rejecting 7, which we can then group into two groups 1-3 and 4-6. If the second number is in the 4-6 range then we add 5 to our first 1-5 that we got, otherwise we don\\'t.",
                "solutionTags": [],
                "code": "```\\nint rand10() { \\n    // first call map 1-3 to 1 and 4-6 to 0\\n    int first = rand7();\\n    int second = rand7();\\n    while(first > 6 || second > 5){\\n        first = rand7();\\n        second = rand7();\\n    }\\n    unsigned multiplier = first < 4 ? 0 : 1;\\n    return second + multiplier*5;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223622,
                "title": "simple-c-solution-avg-2-6-calls",
                "content": "**Fisrt step:** \\nRun rand7(). If result lies in [1,5], we consider the output corresponds to categories 1-2,3-4,5-6,7-8,9-10, respectively. If output is 6 or 7, then rerun the first step.\\n**Second step:**\\nRun rand7(). If result is odd, we consider the output corresponds to the odd number within the catetory identified as the first step. If result is even, we consider the output corresponds to the even number within the catetory identified as the first step. The only exeception is 7, in that case we rerun the second step.\\n```\\nclass Solution {\\npublic:\\n    int rand10() \\n    {\\n        int m = rand7();\\n        while (m>5)\\n            m = rand7();\\n        int n = rand7();\\n        while (n==7)\\n            n = rand7();\\n        \\n        return (m-1)*2+n%2+1;\\n    }\\n};\\n```\\nThe expected calls in the first step: ```1*5/7+2*(2/7)*5/7+3*(2/7)^2*5/7+...+k*(2/7)^(k-1)*5/7```\\nThe expected calls in the second step: ```1*6/7+2*(1/7)*6/7+3*(1/7)^2*6/7+...+k*(1/7)^(k-1)*6/7```\\nTotal expected calls needed to generate one rand10() is around 2.6",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() \\n    {\\n        int m = rand7();\\n        while (m>5)\\n            m = rand7();\\n        int n = rand7();\\n        while (n==7)\\n            n = rand7();\\n        \\n        return (m-1)*2+n%2+1;\\n    }\\n};\\n```\n```1*5/7+2*(2/7)*5/7+3*(2/7)^2*5/7+...+k*(2/7)^(k-1)*5/7```\n```1*6/7+2*(1/7)*6/7+3*(1/7)^2*6/7+...+k*(1/7)^(k-1)*6/7```",
                "codeTag": "Java"
            },
            {
                "id": 152282,
                "title": "c-2-line",
                "content": "```\\nint rand10() {\\n        auto x = (rand7()-1)*7 + rand7();\\n        return x<=40 ? x%10 +1 : rand10();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        auto x = (rand7()-1)*7 + rand7();\\n        return x<=40 ? x%10 +1 : rand10();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150480,
                "title": "c-average-2-57-rand7-usage",
                "content": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tint rand10() {\\n\\t\\t\\t\\t\\tbool filling = 0;\\n\\t\\t\\t\\t\\tint num = 7;\\n\\t\\t\\t\\t\\twhile(num ==7) num = rand7();\\n\\t\\t\\t\\t\\tfilling = num % 2; // rand2()\\n\\t\\t\\t\\t\\tnum = 10;\\n\\t\\t\\t\\t\\twhile(num>=10) num = (rand7() - 1) * 2 + filling;\\n\\t\\t\\t\\t\\treturn num + 1;\\n\\t\\t\\t}\\n\\t};\\n```\\nHint from [this post](https://leetcode.com/problems/implement-rand10-using-rand7/discuss/150301/Three-line-Java-solution-the-idea-can-be-generalized-to-%22Implement-RandM()-Using-RandN()%22)\\nTo get rand2() from rand7(), the expectation would be 7/6 tries.\\nTo get rand10() from rand14(), the expectation will be 7/5 tries.",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tint rand10() {\\n\\t\\t\\t\\t\\tbool filling = 0;\\n\\t\\t\\t\\t\\tint num = 7;\\n\\t\\t\\t\\t\\twhile(num ==7) num = rand7();\\n\\t\\t\\t\\t\\tfilling = num % 2; // rand2()\\n\\t\\t\\t\\t\\tnum = 10;\\n\\t\\t\\t\\t\\twhile(num>=10) num = (rand7() - 1) * 2 + filling;\\n\\t\\t\\t\\t\\treturn num + 1;\\n\\t\\t\\t}\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150298,
                "title": "python-use-two-rand7-calls-to-generate-rand10",
                "content": "For any `M < N`, a given uniform random integer `randN()` can be used to generate `randM()` by considering the conditional probability. Specifically,\\n\\n`Prob(randN() = i | randN() <= M) = Prob(randN() = i and randN() <= M) / Prob(randN() <= M) = (1 / N) / (M / N) = 1 / M`\\n\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        def rand5():\\n            \"\"\"Generate a uniform random integer in the range 1 to 5.\"\"\"\\n            i = rand7()\\n            while True:\\n                if i < 6:\\n                    return i\\n                i = rand7()\\n                \\n            return 0\\n        \\n        # Use rand7() to generate a uniform random integer in the range\\n        # 1 to 6.\\n        group = rand7()\\n        while True:\\n            if group < 7:\\n                if group % 2 != 0:\\n                    # If it is odd, we generate a uniform random integer\\n                    # {1, 3, 5, 7, 9}.\\n                    return 2 * rand5() - 1\\n                else:\\n                    # If it is even, we generate a uniform random integer\\n                    # {2, 4, 6, 8, 10}.\\n                    return 2 * rand5()\\n            \\n            group = rand7()\\n            \\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        def rand5():\\n            \"\"\"Generate a uniform random integer in the range 1 to 5.\"\"\"\\n            i = rand7()\\n            while True:\\n                if i < 6:\\n                    return i\\n                i = rand7()\\n                \\n            return 0\\n        \\n        # Use rand7() to generate a uniform random integer in the range\\n        # 1 to 6.\\n        group = rand7()\\n        while True:\\n            if group < 7:\\n                if group % 2 != 0:\\n                    # If it is odd, we generate a uniform random integer\\n                    # {1, 3, 5, 7, 9}.\\n                    return 2 * rand5() - 1\\n                else:\\n                    # If it is even, we generate a uniform random integer\\n                    # {2, 4, 6, 8, 10}.\\n                    return 2 * rand5()\\n            \\n            group = rand7()\\n            \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097362,
                "title": "rust-5ms",
                "content": "# Code\\n```rust\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        (0..)\\n            .map(|_| (rand7() - 1) * 7 + (rand7() - 1))\\n            .skip_while(|&i| i >= 40)\\n            .map(|i| i % 10 + 1)\\n            .next()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn rand10() -> i32 {\\n        (0..)\\n            .map(|_| (rand7() - 1) * 7 + (rand7() - 1))\\n            .skip_while(|&i| i >= 40)\\n            .map(|i| i % 10 + 1)\\n            .next()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046148,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined for you.\\n * var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let index = Math.trunc(Math.random() * nums.length);\\n    return nums[index];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined for you.\\n * var rand7 = function() {}\\n * @return {number} a random integer in the range 1 to 7\\n */\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let index = Math.trunc(Math.random() * nums.length);\\n    return nums[index];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042878,
                "title": "simple-easy-to-understand-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int v1 = rand7(),v2 = rand7();\\n        while(v1>5) v1 = rand7();\\n        while(v2==7) v2 = rand7();\\n        return v2<=3?v1:v1+5; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Rejection Sampling",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int v1 = rand7(),v2 = rand7();\\n        while(v1>5) v1 = rand7();\\n        while(v2==7) v2 = rand7();\\n        return v2<=3?v1:v1+5; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020443,
                "title": "formula-based",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while(true){\\n        int row=7*(rand7()-1);\\n        int col=rand7();\\n        int curr=row+col;\\n  if(curr<=40)\\n  return curr%10+1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while(true){\\n        int row=7*(rand7()-1);\\n        int col=rand7();\\n        int curr=row+col;\\n  if(curr<=40)\\n  return curr%10+1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017571,
                "title": "beats-89-43-simple-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n\\n        int comb = (x-1)*7 + y;\\n\\n        if (comb <=40){\\n            return comb%10+1;\\n        }\\n       \\n\\n       return rand10();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n\\n        int comb = (x-1)*7 + y;\\n\\n        if (comb <=40){\\n            return comb%10+1;\\n        }\\n       \\n\\n       return rand10();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017167,
                "title": "what-about-rand7-rand7-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nrand7()+rand7()%4 = ([1, 7]+[1, 7]%4)==> ([1, 7]+[0, 3]) ==> [1, 10]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nrand7()+rand7()%4 = ([1, 7]+[1, 7]%4)==> ([1, 7]+[0, 3]) ==> [1, 10]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code",
                "codeTag": "Unknown"
            },
            {
                "id": 4001713,
                "title": "implement-rand10-using-rand7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=1;i<=10;i++)\\n        {\\n            arr.add(i);\\n        }\\n        int index = (int)(Math.random()*arr.size());\\n        return arr.get(index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=1;i<=10;i++)\\n        {\\n            arr.add(i);\\n        }\\n        int index = (int)(Math.random()*arr.size());\\n        return arr.get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975760,
                "title": "rejecting-sampling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI used rejection sampling to get uniform random variables of [1,5]\\nand [1,2], that way we can represent 10 different numbers (which i stored in the array arr, see the code)\\nprobabilty to get one of [1,2,3,4,5] when rejecting 6 and 7 is 0.2\\nprobability to get even or odd number number in [1,2,3,4,5,6] is 0.5\\n(while rejecting 7)\\nso in total we got 0.2 * 0.5 = 0.1 probability to get all numbers from [1,10]\\n\\nexpectency calculation.\\nlet $$x$$ be random variable. as you know, if x ~ Geo(p) it means that x is the number of tries until first success, in our case probabily for success is $$5/7 $$ hence x ~ Geo(5/7), it is known that for geometry distributed random variables $$E(x) = 1/p = 7/5$$\\n\\nlet y be random variable, same as previously explained, y ~ Geo(6/7)\\nso $$E(y) = 7/6$$\\n\\ntotal $$E(X + Y) = 7/5 + 7/6 = 2.56$$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        arr = [[1,2],[3,4],[5,6],[7,8],[9,10]]\\n        val1 = rand7()\\n        while val1 >= 6:\\n            val1 = rand7()\\n        val2 = rand7()\\n        while val2 >= 7:\\n            val2 = rand7()\\n        return arr[val1 - 1][val2 % 2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        arr = [[1,2],[3,4],[5,6],[7,8],[9,10]]\\n        val1 = rand7()\\n        while val1 >= 6:\\n            val1 = rand7()\\n        val2 = rand7()\\n        while val2 >= 7:\\n            val2 = rand7()\\n        return arr[val1 - 1][val2 % 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973579,
                "title": "best-java-solution-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\n\\n // taken some help;\\n \\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int a = rand7();\\n        int b = rand7();\\n\\n        int val = a+(b-1)*7;\\n\\n        if(val<=40) return (val-1)%10+1;\\n        else return rand10();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\n\\n // taken some help;\\n \\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int a = rand7();\\n        int b = rand7();\\n\\n        int val = a+(b-1)*7;\\n\\n        if(val<=40) return (val-1)%10+1;\\n        else return rand10();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946272,
                "title": "rejection-sampling-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946271,
                "title": "rejection-sampling-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        val = 41\\n        while val > 40:\\n            idx1 = rand7()\\n            idx2 = rand7()\\n            val = (idx1-1)*7+idx2\\n            \\n        \\n        return val % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899919,
                "title": "rejection-sampling-easy-implementataion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x,y,num;\\n        do{\\n            x=rand7();\\n            y=rand7();\\n            num= x+(y-1)*7;\\n        }while(num>40);\\n        return 1+(num-1)%10;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x,y,num;\\n        do{\\n            x=rand7();\\n            y=rand7();\\n            num= x+(y-1)*7;\\n        }while(num>40);\\n        return 1+(num-1)%10;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897671,
                "title": "python-solution-with-probability-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 iid events probility equal to pr(even1)*pr(event2)\\nso if we want generate number with rand10 mean every number from 1-10 draw with uniform probability 1/10\\nwe can think generate this event in 2 steps in sequentail:\\n1. generate event with pr=0.5\\n2. generate anther event with pr=0.2\\nso totally pr=0.5*0.2\\n\\nwhat means for rand10?think of generate number from 1-10,each with pr 1/10:\\n1. we divid 1-10 to 2 group:[1-5] and [6-10], each draw with pr=0.5, how to do?\\n  as rand7 gen 1-7 we can say, if rand7 gen 1-3 we use first group, if gen 5-7 use second one, but equal to 4 draw again until success.\\n\\n2. same ideal for draw a number from the chosen gropup except with pr=0.2\\n  with rand7 gen a number and if in [1-5] we map to one of them, ohterwise repeate.\\n\\nexpection call for rand7:\\nin 1 step need 7/6 call for rand7,and 7/5 for 2step, totally:\\n2.56 calls for rand7\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        r=rand7()\\n        while r==4:r=rand7()\\n        base=0 if r<4 else 5\\n        r=rand7()\\n        while r>5:r=rand7()\\n        return base+r\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        r=rand7()\\n        while r==4:r=rand7()\\n        base=0 if r<4 else 5\\n        r=rand7()\\n        while r>5:r=rand7()\\n        return base+r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894085,
                "title": "python3-solution",
                "content": "# Intuition\\nUse two `rand7()` to get a two-digit 7-base number $X = Y_1 + 7 Y_2$. The number is at most 49. If the number is greater than 40, regenerate another sample. Conditioning on the condition $X \\\\le 40$, $X$ is uniformly distributed in $[1, \\\\cdots, 40]$. So, $\\\\mod(X, 10)$ is uniformly distributed.\\n\\n$$P(X \\\\le 40) = \\\\frac{40}{49}$$ so on average, one needs $49/40$ number of $X$ generations.\\n\\n\\n# Complexity\\n- Time complexity:\\nSuppose `rand7()` costs $r$ numbers of operations. The total cost of `rand10()` is about $2.5 r$.\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        x = (rand7() - 1) * 7 + rand7() - 1\\n        while x >= 40:\\n            x = (rand7() - 1) * 7 + rand7() - 1\\n        return x % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        x = (rand7() - 1) * 7 + rand7() - 1\\n        while x >= 40:\\n            x = (rand7() - 1) * 7 + rand7() - 1\\n        return x % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875465,
                "title": "python-only-use-return-value",
                "content": "\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return randrange(1, 11)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return randrange(1, 11)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861982,
                "title": "javascript-easy-method-beats-100-faster-beginner-s-friendly",
                "content": "# Code\\n```\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let randomIndex = Math.trunc(Math.random() * 10);\\n   return nums[randomIndex];\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar rand10 = function() {\\n    let nums = [1,2,3,4,5,6,7,8,9,10];\\n    let randomIndex = Math.trunc(Math.random() * 10);\\n   return nums[randomIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835506,
                "title": "beat-100-of-implementation-in-any-langage-with-this-simple-trick",
                "content": "# Intuition\\n\\nWe just abuse the fact that there is no mention of independence between the uniform random variables, and this is not tested to validate the generated data.\\n\\n# Complexity\\n\\n$$\\n\\\\mathbb{E}\\\\left[ \\\\mathrm{rand7}_\\\\mathrm{calls} \\\\right] = \\\\frac{1}{n}\\n$$\\n\\nwhere $n$ is the size of the sample to generate\\n\\n# Code python\\n```python\\nclass Solution:\\n    def __init__(self):\\n        # we still call rand7 because if we dont\\n        # the result is not random stricto sensu\\n        self.x = rand7()\\n\\n    def rand10(self):\\n        self.x = (self.x + 1) % 10\\n        return self.x + 1\\n\\n```\\n\\n# Code C\\n```c\\nint rand10() {\\n    static int initialized = 0;\\n    static int state = 0;\\n\\n    if (!initialized) {\\n        initialized = 1;\\n        state = rand7();\\n    }\\n    \\n    state += 1;\\n    state %= 10;\\n    return state + 1;\\n}```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        # we still call rand7 because if we dont\\n        # the result is not random stricto sensu\\n        self.x = rand7()\\n\\n    def rand10(self):\\n        self.x = (self.x + 1) % 10\\n        return self.x + 1\\n\\n```\n```c\\nint rand10() {\\n    static int initialized = 0;\\n    static int state = 0;\\n\\n    if (!initialized) {\\n        initialized = 1;\\n        state = rand7();\\n    }\\n    \\n    state += 1;\\n    state %= 10;\\n    return state + 1;\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3825344,
                "title": "simple-java-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n\\n        int x= rand7();\\n        int y= rand7();\\n\\n        int ans = ((x-1)*7+y) ;\\n\\n        return (ans > 40 ? rand10() : (ans -1)%10 +1 );\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817682,
                "title": "o-1-solution-in-java-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMapping rand7 with rand10.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince rand10 can produce numbers from [1 to 10] and rand7 can produce numbers from [1 to 7] we cannot map rand7 to rand10 directly because it is not possible to map smaller group [1 to 7] with a bigger group [1 to 10]. To achieve a uniform distribution of numbers between 1 and 10 using rand7(), we need to use two instances of rand7() to generate a range of numbers greater than 10. This ensures that all numbers between 1 and 10 have an equal probability of being generated.\\n\\n# Explanation\\n1. Generate two random numbers x and y using rand7().\\n\\n2. Calculate the position in a 2D matrix of size 7x7 using the formula pos = (x - 1) * 7 + y.\\n\\n3. If the generated position pos is greater than 40, we have 9 extra possibilities (41 to 49) that we don\\'t need. These extra possibilities do not have equal probability of being generated, so reject them by making a recursive call to rand10(). This ensures that we only have 40 possibilities (1 to 40) with equal probability.\\n\\n4. To get a number between 1 and 10, take the modulus of (pos - 1) with 10 and add 1. This step ensures that all numbers between 1 and 10 have an equal probability of being generated.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = (x-1)*7+y;\\n        if(pos>40) return rand10();\\n        return (pos-1)%10+1;\\n    }\\n}\\n/**\\n    0  1  2  3  4  5  6\\n    11 12 13 14 15 16 17\\n\\n    7  8  9  0  1  2  3\\n    21 22 23 24 25 26 27\\n\\n    4  5  6  7  8  9  0\\n    31 32 33 34 35 36 37\\n\\n    1  2  3  4  5  6  7\\n    41 42 43 44 45 46 47\\n\\n    8  9  0  1  2  3  4 \\n    51 52 53 54 55 56 57\\n\\n    5  6  7  8  9  0  1\\n    61 62 63 64 65 66 67\\n\\n    2  3  4  5  6  7  8\\n    71 72 73 74 75 76 77\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = (x-1)*7+y;\\n        if(pos>40) return rand10();\\n        return (pos-1)%10+1;\\n    }\\n}\\n/**\\n    0  1  2  3  4  5  6\\n    11 12 13 14 15 16 17\\n\\n    7  8  9  0  1  2  3\\n    21 22 23 24 25 26 27\\n\\n    4  5  6  7  8  9  0\\n    31 32 33 34 35 36 37\\n\\n    1  2  3  4  5  6  7\\n    41 42 43 44 45 46 47\\n\\n    8  9  0  1  2  3  4 \\n    51 52 53 54 55 56 57\\n\\n    5  6  7  8  9  0  1\\n    61 62 63 64 65 66 67\\n\\n    2  3  4  5  6  7  8\\n    71 72 73 74 75 76 77\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814688,
                "title": "easy-python-solution-with-o-1-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        x = rand7()\\n        y = rand7()\\n        pos = (x-1)*7 + y\\n        if pos >= 41:\\n            return self.rand10()\\n        return pos%10 +1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        x = rand7()\\n        y = rand7()\\n        pos = (x-1)*7 + y\\n        if pos >= 41:\\n            return self.rand10()\\n        return pos%10 +1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796798,
                "title": "cpp-7-ms-beats92-22-ruby-167-ms-beats100-0",
                "content": "\\n```cpp []\\n//https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000145893/\\nclass Solution {\\nprivate: \\n\\tint ans;\\npublic:\\n    int rand10() {\\n        do{\\n        \\tans = 7 * (rand7() - 1) + rand7();\\n        }\\n        while (ans > 40);\\n        return ans % 10 + 1;\\n    }\\n};\\n```\\n```ruby []\\n#https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000143249/\\n# The rand7() API is already defined for you.\\n# def rand7()\\n# @return {Integer} a random integer in the range 1 to 7\\n\\ndef rand10()\\n    r = 7 * (rand7() - 1 ) + rand7()\\n\\tuntil r < 41\\n\\t\\tr = 7 * (rand7() - 1 ) + rand7()\\n\\tend\\n\\tr % 10 + 1\\nend\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Ruby"
                ],
                "code": "```cpp []\\n//https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000145893/\\nclass Solution {\\nprivate: \\n\\tint ans;\\npublic:\\n    int rand10() {\\n        do{\\n        \\tans = 7 * (rand7() - 1) + rand7();\\n        }\\n        while (ans > 40);\\n        return ans % 10 + 1;\\n    }\\n};\\n```\n```ruby []\\n#https://leetcode.com/problems/implement-rand10-using-rand7/submissions/1000143249/\\n# The rand7() API is already defined for you.\\n# def rand7()\\n# @return {Integer} a random integer in the range 1 to 7\\n\\ndef rand10()\\n    r = 7 * (rand7() - 1 ) + rand7()\\n\\tuntil r < 41\\n\\t\\tr = 7 * (rand7() - 1 ) + rand7()\\n\\tend\\n\\tr % 10 + 1\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763177,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * def rand7(): Int = {}\\n * @return a random integer in the range 1 to 7\\n */\\nobject Solution extends SolBase {\\n      def rand10(): Int = {\\n        var row, col, idx = 0\\n        do {\\n          row = rand7()\\n          col = rand7()\\n          idx = col + (row - 1) * 7\\n        } while (idx > 40)\\n        1 + (idx - 1) % 10\\n      }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * def rand7(): Int = {}\\n * @return a random integer in the range 1 to 7\\n */\\nobject Solution extends SolBase {\\n      def rand10(): Int = {\\n        var row, col, idx = 0\\n        do {\\n          row = rand7()\\n          col = rand7()\\n          idx = col + (row - 1) * 7\\n        } while (idx > 40)\\n        1 + (idx - 1) % 10\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710270,
                "title": "",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        return sum(rand7() for _ in range(9)) % 10 + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        return sum(rand7() for _ in range(9)) % 10 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642543,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n         double b=(49*(rand7()-1) + 7*(rand7()-1) + (rand7()-1))/343.0;\\n        return int (b*10) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n         double b=(49*(rand7()-1) + 7*(rand7()-1) + (rand7()-1))/343.0;\\n        return int (b*10) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553020,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        \\n        int ans=INT_MAX;\\n\\n        while(ans>=40){\\n            ans = 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10)+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        \\n        int ans=INT_MAX;\\n\\n        while(ans>=40){\\n            ans = 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10)+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548794,
                "title": "cool-solution",
                "content": "# Intuition\\nI was adding `(rand7()+rand7())%7` to the sum and modulo 10 until it worked!\\n\\n# Code\\n```\\nfunc rand10() int {\\n    \\n    return ((rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7)%10+1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rand10() int {\\n    \\n    return ((rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7 + (rand7()+rand7())%7)%10+1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508426,
                "title": "java-solution-with-logic-explained",
                "content": "# Intuition\\nWe are to map the range from 1 to 7 inclusive to a bigger range from 1 to 10 inclusive\\nSo we create a map (2d array) of the size (7x7) and distrubte the element across it, starting from 1 up to 10, after reaching 10 we start again from 1 to 10, we repeat the same process, till there\\'re no enough places to take all of our range (1-10), then we start to fill cells with zeros\\nafter that we pick a number from our distribution using uniformally distributed rand7, because of that our solution will be always unifromally distributed\\n\\n# Code\\n```\\n\\n\\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n    /**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase { \\n    int vals[][] = {\\n        { 1, 2, 3, 4, 5, 6, 7 },\\n        { 8, 9, 10, 1, 2, 3, 4 },\\n        { 5, 6, 7, 8, 9, 10, 1}, \\n        { 2, 3, 4, 5, 6, 7, 8}, \\n        { 9, 10, 1, 2, 3, 4, 5}, \\n        { 6, 7, 8, 9, 10, 0, 0}, \\n        { 0, 0, 0, 0, 0, 0, 0}\\n    };\\n    \\n    public int rand10() {\\n\\n        \\n        int result = 0; \\n        while(result == 0) { \\n            result = vals[rand7()-1][rand7()-1];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506887,
                "title": "go-arr-shuffle",
                "content": "```\\nvar a = [10]int{1,2,3,4,5,6,7,8,9,10}\\nfunc rand10() int {\\n    return a[int(int64(rand7())+time.Now().UnixNano())%10]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar a = [10]int{1,2,3,4,5,6,7,8,9,10}\\nfunc rand10() int {\\n    return a[int(int64(rand7())+time.Now().UnixNano())%10]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499373,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int g=0;\\n    int rand10() {\\n        g++;\\n        if(g%10==0)\\n            return 10;\\n        return g%10;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self):\\n        self.c = {1,2,3,4,5,6,7,8,9,10}\\n\\n    def rand10(self):\\n        x = self.c.pop()\\n        if not self.c:\\n            self.c = {1,2,3,4,5,6,7,8,9,10}\\n        return x\\n```\\n\\n```Java []\\nclass Solution extends SolBase {\\n    int count = 1;\\n    public int rand10() {\\n        count++;\\n        return count%10 +1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int g=0;\\n    int rand10() {\\n        g++;\\n        if(g%10==0)\\n            return 10;\\n        return g%10;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self):\\n        self.c = {1,2,3,4,5,6,7,8,9,10}\\n\\n    def rand10(self):\\n        x = self.c.pop()\\n        if not self.c:\\n            self.c = {1,2,3,4,5,6,7,8,9,10}\\n        return x\\n```\n```Java []\\nclass Solution extends SolBase {\\n    int count = 1;\\n    public int rand10() {\\n        count++;\\n        return count%10 +1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481216,
                "title": "c-5-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = ((x-1)*7) + y;\\n\\n        if(pos >= 41)\\n            return rand10();\\n        \\n        return ((pos%10) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();\\n        int y = rand7();\\n        int pos = ((x-1)*7) + y;\\n\\n        if(pos >= 41)\\n            return rand10();\\n        \\n        return ((pos%10) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469924,
                "title": "easy-java-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x= rand7();\\n        int y= rand7();\\n        int val= (x-1)*7+y;\\n        if(val>40){\\n            return rand10();\\n        }\\n        return val % 10+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x= rand7();\\n        int y= rand7();\\n        int val= (x-1)*7+y;\\n        if(val>40){\\n            return rand10();\\n        }\\n        return val % 10+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468558,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA minimum of two rand7() is needed to get numbers between 1-10;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider a 1 based indexed 7x7 matrix. Develop a relationship between the position and the (x,y) coordinates of the matrix. For eg. 3,5 is at the 19th position, 7,7 will be at the 49th position. \\n\\nFor equal probablity of getting 1-10, some elements need to be discarded. In this case, 41-49 is discadred as it gives numbers between only 1-9.(We need 1-10,hence, unequal probability.)\\n\\nModulo operation to get the desired range of numbers(1-10).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();//x-coordinate\\n        int y = rand7();//y-coordinate\\n\\n        int val = (x-1)*7 + y;// relationsship between (x,y) and the position of the matrix.\\n\\n        if(val>40) return rand10(); // discarded numbers which gives unequal probability. Hence, we call rand10() again.\\n\\n        return val%10+1; // returning numbers ranging 1-10.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x = rand7();//x-coordinate\\n        int y = rand7();//y-coordinate\\n\\n        int val = (x-1)*7 + y;// relationsship between (x,y) and the position of the matrix.\\n\\n        if(val>40) return rand10(); // discarded numbers which gives unequal probability. Hence, we call rand10() again.\\n\\n        return val%10+1; // returning numbers ranging 1-10.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440861,
                "title": "java",
                "content": "split into pairs (num1,num2) we have 49 pairs (num1,num2), for the first 40 group them into groups of 4 and return 1-10 by the group belonging of the random pair, or redraw if the pair isn\\'t belong to any of the gruop.\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while (true){\\n            int random1 = rand7(), random2=rand7();\\n            if (random1==1 && random2<=4) return 1;\\n            if (random1==1) return 2;\\n            if (random1==2 && random2<=1) return 2;\\n            if (random1==2 && random2<=5) return 3;\\n            if (random1==2) return 4;\\n            if (random1==3 && random2<=2)return 4;\\n            if (random1==3 && random2<=6)return 5;\\n            if (random1==3) return 6;\\n            if (random1==4 && random2<=3)return 6;\\n            if (random1==4) return 7;\\n            if (random1==5 && random2<=4)return 8;\\n            if (random1==5 )return 9;\\n            if (random1==6 && random2<=1)return 9;\\n            if (random1==6 && random2<=5)return 10;         \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        while (true){\\n            int random1 = rand7(), random2=rand7();\\n            if (random1==1 && random2<=4) return 1;\\n            if (random1==1) return 2;\\n            if (random1==2 && random2<=1) return 2;\\n            if (random1==2 && random2<=5) return 3;\\n            if (random1==2) return 4;\\n            if (random1==3 && random2<=2)return 4;\\n            if (random1==3 && random2<=6)return 5;\\n            if (random1==3) return 6;\\n            if (random1==4 && random2<=3)return 6;\\n            if (random1==4) return 7;\\n            if (random1==5 && random2<=4)return 8;\\n            if (random1==5 )return 9;\\n            if (random1==6 && random2<=1)return 9;\\n            if (random1==6 && random2<=5)return 10;         \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432918,
                "title": "java-solution-easy",
                "content": "\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n\\n        while(true) {\\n            int row = (rand7() - 1) * 7;\\n            int col = rand7();\\n            int curr = row + col;\\n            if(curr >= 40) {\\n                return 1 + (curr - 1) % 10;\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    \\n    public int rand10() {\\n\\n        while(true) {\\n            int row = (rand7() - 1) * 7;\\n            int col = rand7();\\n            int curr = row + col;\\n            if(curr >= 40) {\\n                return 1 + (curr - 1) % 10;\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403228,
                "title": "python-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* We want to generate a random number between 1 and 10 using the rand7() function, which can only generate numbers between 1 and 7 with equal probability.\\n\\n* To do this, we generate a random number in a larger range, such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n    - When we generate a random number using rand7(), we have seven equally likely outcomes: 1, 2, 3, 4, 5, 6, or 7.\\n    - If we generate two independent random numbers using rand7(), we have 7*7=49 possible outcomes, each of which is equally likely to occur. \\n    - That\\'s because the first number can be any of the seven values, and the second number can also be any of the seven values, resulting in 49 possible combinations.\\n    - Therefore, by generating two independent random numbers using rand7() and using them to create a number in the range [1, 49], we ensure that each number in that range has an equal probability of being generated.\\n\\n* We then reject any numbers outside the range [1, 40], which ensures that we have an equal probability of generating any number between 1 and 10.\\n* The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less than or equal to 49, which means that all numbers between 1 and 10 have an equal probability of being generated if we reject any numbers outside this range.\\n* Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], which gives us a uniform probability distribution for generating random numbers between 1 and 10 using the rand7() function.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the rand10() function is not constant because the number of calls to rand7() is not fixed, and it depends on how many times we need to generate a number between 1 and 40. \\nHowever, the worst-case time complexity is `O(\\u221E)` because there is a possibility that we will never generate a number between 1 and 40, and the loop will run forever.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is `O(1)` because we are not storing any data structures that grow with input size. \\nWe are only using a constant amount of space to store the variables needed to generate the random numbers.\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        We want to generate a random number between 1 and 10 using the rand7() function, \\n        which can only generate numbers between 1 and 7 with equal probability.\\n\\n        To do this, we generate a random number in a larger range, \\n        such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n        We then reject any numbers outside the range [1, 40], \\n        which ensures that we have an equal probability of generating any number between 1 and 10.\\n\\n        The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less \\n        than or equal to 49, \\n\\n        which means that all numbers between 1 and 10 have an equal probability of being generated \\n        if we reject any numbers outside this range.\\n\\n        Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], \\n        which gives us a uniform probability distribution for generating random numbers between 1 and 10 \\n        using the rand7() function.\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice because 7 * 7 = 49. We need 1 to 49 \\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40] because 40 % 10 = 0 and 40 / 10 = 4. We need 1 to 40 in order to get a number in the range [1, 10]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus.\\n        return num % 10 + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        We want to generate a random number between 1 and 10 using the rand7() function, \\n        which can only generate numbers between 1 and 7 with equal probability.\\n\\n        To do this, we generate a random number in a larger range, \\n        such as between 1 and 49, which has an equal probability of generating any number in that range.\\n\\n        We then reject any numbers outside the range [1, 40], \\n        which ensures that we have an equal probability of generating any number between 1 and 10.\\n\\n        The reason we use the range [1, 40] is that it is the largest multiple of 10 that is less \\n        than or equal to 49, \\n\\n        which means that all numbers between 1 and 10 have an equal probability of being generated \\n        if we reject any numbers outside this range.\\n\\n        Finally, we use the modulo operator to map the remaining numbers to the range [1, 10], \\n        which gives us a uniform probability distribution for generating random numbers between 1 and 10 \\n        using the rand7() function.\\n        \"\"\"\\n        while True:\\n            # Generate a number in the range [1, 49] using rand7() twice because 7 * 7 = 49. We need 1 to 49 \\n            num = (rand7() - 1) * 7 + rand7()\\n            \\n            # Reject numbers outside the range [1, 40] because 40 % 10 = 0 and 40 / 10 = 4. We need 1 to 40 in order to get a number in the range [1, 10]\\n            if num <= 40:\\n                break\\n        \\n        # Return a number in the range [1, 10] using modulus.\\n        return num % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382321,
                "title": "python3-made-simple-inefficient-but-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        call = None\\n\\n        while call is None:\\n            temp1 = rand7()\\n            temp2 = rand7()\\n            \\n            if temp1 == 1 and temp2 == 1:\\n                return 1\\n            elif temp1 == 1 and temp2 == 2:\\n                return 2\\n            elif temp1 == 1 and temp2 == 3:\\n                return 3\\n            elif temp1 == 1 and temp2 == 4:\\n                return 4\\n            elif temp1 == 1 and temp2 == 5:\\n                return 5\\n            elif temp1 == 1 and temp2 == 6:\\n                return 6\\n            elif temp1 == 1 and temp2 == 7:\\n                return 7\\n            elif temp1 == 2 and temp2 == 1:\\n                return 8\\n            elif temp1 == 2 and temp2 == 2:\\n                return 9\\n            elif temp1 == 2 and temp2 == 3:\\n                return 10\\n\\n        \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        call = None\\n\\n        while call is None:\\n            temp1 = rand7()\\n            temp2 = rand7()\\n            \\n            if temp1 == 1 and temp2 == 1:\\n                return 1\\n            elif temp1 == 1 and temp2 == 2:\\n                return 2\\n            elif temp1 == 1 and temp2 == 3:\\n                return 3\\n            elif temp1 == 1 and temp2 == 4:\\n                return 4\\n            elif temp1 == 1 and temp2 == 5:\\n                return 5\\n            elif temp1 == 1 and temp2 == 6:\\n                return 6\\n            elif temp1 == 1 and temp2 == 7:\\n                return 7\\n            elif temp1 == 2 and temp2 == 1:\\n                return 8\\n            elif temp1 == 2 and temp2 == 2:\\n                return 9\\n            elif temp1 == 2 and temp2 == 3:\\n                return 10\\n\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308669,
                "title": "python-simple-2-rand7-calls-per-rand10",
                "content": "# Intuition\\nWe\\'ll pick a random value from the matrix:\\n```\\n    1  2  3  4  5  6  7  8  9 10\\n    2  3  4  5  6  7  8  9 10  1\\n    3  4  5  6  7  8  9 10  1  2\\ni-> 4  5  6  7  8  9 10  1  2  3\\n    5  6  7  8  9 10  1  2  3  4\\n    6  7  8  9 10  1  2  3  4  5\\n    7  8  9 10  1  2  3  4  5  6\\n    8  9 10  1  2  3  4  5  6  7\\n          ^\\n          |\\n          j\\n```\\nThe problem is that we can pick both `i` and `j` in the range [0, 6]. \\n\\nOne way to solve is to slide the window of possibilites by shifting the range for `j` by 1 to the right each time a number was picked. Meaning after 1st number the range for `j` will be [1, 7], after 2nd - [2, 8] and so on.\\n\\nThis way on avarage the distribution will be uniform in range [1, 10]\\n\\n# Complexity\\n- Time complexity:\\n$O(1)$\\n\\n- Space complexity:\\n$O(1)$\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    cnt = 0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        i = rand7()\\n        j = (rand7() + self.cnt)%10\\n        self.cnt += 1\\n        return (i + j)%10 + 1\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    1  2  3  4  5  6  7  8  9 10\\n    2  3  4  5  6  7  8  9 10  1\\n    3  4  5  6  7  8  9 10  1  2\\ni-> 4  5  6  7  8  9 10  1  2  3\\n    5  6  7  8  9 10  1  2  3  4\\n    6  7  8  9 10  1  2  3  4  5\\n    7  8  9 10  1  2  3  4  5  6\\n    8  9 10  1  2  3  4  5  6  7\\n          ^\\n          |\\n          j\\n```\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    cnt = 0\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        i = rand7()\\n        j = (rand7() + self.cnt)%10\\n        self.cnt += 1\\n        return (i + j)%10 + 1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295830,
                "title": "easy-java-solution-understand-quickly-nd-easily",
                "content": "******Bold******# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x=rand7();\\n        int y=rand7();\\n        int val=(x-1)*7+y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n        int x=rand7();\\n        int y=rand7();\\n        int val=(x-1)*7+y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284659,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        double t = rand7();\\n        double x = (double) rand()/RAND_MAX ;\\n\\n        t = (t+x)/0.7 ;\\n        int k = t;\\n        if(k > 10)\\n            return k-10;\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        double t = rand7();\\n        double x = (double) rand()/RAND_MAX ;\\n\\n        t = (t+x)/0.7 ;\\n        int k = t;\\n        if(k > 10)\\n            return k-10;\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276806,
                "title": "c-easy-method-100-pure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int ans= INT_MAX;\\n        while(ans >= 40){\\n            ans= 7*(rand7()-1)+(rand7()-1);\\n        }\\n        return (ans%10) +1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216620,
                "title": "slow-but-simple-and-correct",
                "content": "Just do rand7() 10 times, and then take mod 10 of the sum. Slow but correct:\\n```\\n   int rand10() {\\n        int sum = 0;\\n        for (int i=0; i < 10; i++)\\n            sum += rand7();      \\n        return ((sum - 1)% 10) + 1;\\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int rand10() {\\n        int sum = 0;\\n        for (int i=0; i < 10; i++)\\n            sum += rand7();      \\n        return ((sum - 1)% 10) + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189075,
                "title": "7-rand7-1-rand7",
                "content": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            x = 7 * (rand7() - 1) \\n            y = rand7()\\n            if x + y <= 10:\\n                return x+y\\n```",
                "solutionTags": [
                    "Python3",
                    "Rejection Sampling"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while True:\\n            x = 7 * (rand7() - 1) \\n            y = rand7()\\n            if x + y <= 10:\\n                return x+y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173005,
                "title": "sample-solution-using-only-addition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        #Table of a+b, when a < 5 or b > 3\\n        # b 1 2 3 4 5 6 7\\n        #a --------------\\n        #1| 2 3 4 5 6 7 8\\n        #2| 3 4 5 6 7 8 9\\n        #3| 4 5 6 7 8 9 0\\n        #4| 5 6 7 8 9 0 1\\n        #5| x x x 9 0 1 2\\n        #6| x x x 0 1 2 3 \\n        #7| x x x 1 2 3 4\\n        \\n        a = rand7()\\n        b = rand7()\\n\\n        return (a+b)%10+1 if a < 5 or b > 3 else self.rand10()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \\n        #Table of a+b, when a < 5 or b > 3\\n        # b 1 2 3 4 5 6 7\\n        #a --------------\\n        #1| 2 3 4 5 6 7 8\\n        #2| 3 4 5 6 7 8 9\\n        #3| 4 5 6 7 8 9 0\\n        #4| 5 6 7 8 9 0 1\\n        #5| x x x 9 0 1 2\\n        #6| x x x 0 1 2 3 \\n        #7| x x x 1 2 3 4\\n        \\n        a = rand7()\\n        b = rand7()\\n\\n        return (a+b)%10+1 if a < 5 or b > 3 else self.rand10()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163672,
                "title": "c-easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a=rand7(),b=rand7();\\n        while(b>5)  b = rand7();//1,2,3,4,5 for 1/5\\n        while(a>2)  a = rand7();//1,2 for 1/2\\n        return a==1?b:b+5;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int a=rand7(),b=rand7();\\n        while(b>5)  b = rand7();//1,2,3,4,5 for 1/5\\n        while(a>2)  a = rand7();//1,2 for 1/2\\n        return a==1?b:b+5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143087,
                "title": "c-range-mapping",
                "content": "The idea is to fairly map real ranges.\\n\\nEach `rand7()` call will be a pointer to some range.\\n\\nOur ranges of interests are within `[0, 10)`\\nand there are 10 of them: `[0, 1)`, `[1, 2)`, ... `[9, 10)`. Call them **10 ranges**.\\n\\nNow problem is `rand7()` can only evenly cover range `[0, 10)` by dividing it into 7 parts: with ranges `[0, 1.42)`, ... `[8.58, 10)` and none of them match our **10 ranges**. However, once chosen some range we can keep on dividing it into 7 parts until it does fall into one of the **10 ranges**. Once it falls into any of them we return corresponding label.\\n```\\nclass Solution {\\npublic:\\n    // function to return which of 10 ranges our \\n    // real number `x` belongs to\\n    array <int, 2> f(double x) {\\n        return {(int)floor(x), (int)ceil(x)};\\n    }\\n    int rand10() {\\n        double x = 10.0, cur = 0.0;\\n        while (true) {\\n            cur += x * (rand7() / 7.0);\\n            double ll = cur - x / 7.0, rr = cur;\\n            if (f(ll) == f(rr)) // within same range ?\\n                return (int)ceil(rr);\\n            x /= 7.0;\\n            cur -= x;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\nTested expectation for this is close to `~ 2.262`",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to return which of 10 ranges our \\n    // real number `x` belongs to\\n    array <int, 2> f(double x) {\\n        return {(int)floor(x), (int)ceil(x)};\\n    }\\n    int rand10() {\\n        double x = 10.0, cur = 0.0;\\n        while (true) {\\n            cur += x * (rand7() / 7.0);\\n            double ll = cur - x / 7.0, rr = cur;\\n            if (f(ll) == f(rr)) // within same range ?\\n                return (int)ceil(rr);\\n            x /= 7.0;\\n            cur -= x;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136219,
                "title": "4-rand7-call-only",
                "content": "# Intuition\\nUse 2 digits and base 7 gives us 49 choices. We then sum 2 rand7() and module 7 to create a random with range [0-1]. With 50 choices we modulo by 10 to get range [0-9]. Since the question asks for [1-10], we add a single offset.\\n\\n\\n# Code\\n```\\nfunc rand10() int {\\n    return ((rand7()-1)*7+(rand7()-1)+(rand7()+rand7())%7)%10+1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc rand10() int {\\n    return ((rand7()-1)*7+(rand7()-1)+(rand7()+rand7())%7)%10+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3105731,
                "title": "solution-c",
                "content": "\\n# Approach\\ncreate \"range\" of numbers from 1 to 49.\\nif the choosen number is bigger then 10 - continue. else - return it.\\n\\n# Code\\n```\\n\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int r;\\n    do {\\n        r = 7 * (rand7() - 1) + rand7();\\n    } while (r > 10);\\n    return r;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nint rand10() {\\n    int r;\\n    do {\\n        r = 7 * (rand7() - 1) + rand7();\\n    } while (r > 10);\\n    return r;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041044,
                "title": "simple-solution-python3",
                "content": "# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        sm = 0\\n        for _ in range(100):\\n            sm += rand7()\\n        res = sm % 10 + 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        sm = 0\\n        for _ in range(100):\\n            sm += rand7()\\n        res = sm % 10 + 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033626,
                "title": "very-easy-solution-in-o-1-in-c",
                "content": "# Intuition\\n1. For implementing the rand10() using rand7() must have equal probability for each number.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First we have required minimum number of occurance is tow which are x and y.\\n2. Hence there total possibility will 7^2 which is 49.\\n3. Find postion where the probability of rand10() and rand7() will equal.\\n4. postion = (x-1)*7+y;\\n5. If total number of possibilities are not divisible by total number presents in rand10().\\n6. Hence we have to recall the rand10() function in the range (41 to 49).\\n7. Now we have to count total number of possibilities where probably of both api are equal.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int x=0,y=0,val=0;\\n    int rand10() {\\n        x=rand7();\\n        y=rand7();\\n        val=(x-1)*7 + y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Rejection Sampling",
                    "Randomized",
                    "Probability and Statistics"
                ],
                "code": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int x=0,y=0,val=0;\\n    int rand10() {\\n        x=rand7();\\n        y=rand7();\\n        val=(x-1)*7 + y;\\n        if(val>=41){\\n            return rand10();\\n        }\\n        return val%10+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009934,
                "title": "python3-same-as-everyone-else-s-while-loop",
                "content": "# Approach\\nLooks like everyone pretty much did the same thing.\\n\\n# Code\\n```\\nclass Solution:\\n    def rand10(self):\\n        x = 50\\n        while x > 47:\\n            x = rand7() * 7 + rand7()\\n        return (x - 8) // 4 + 1\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rand10(self):\\n        x = 50\\n        while x > 47:\\n            x = rand7() * 7 + rand7()\\n        return (x - 8) // 4 + 1\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970482,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- random first time to get 1-5 to get the bucket since i will split result to [1,2], [3,4] ..., [9,10]\\n- assume I get [5,6] =>\\nrandom one more time to get the first or last number [1,2,3] = left, [4,5,6] = right\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExpected value = 7/5 + 7/6 = 2.333\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        mapping = {\\n            1: [1, 2],\\n            2: [3, 4],\\n            3: [5, 6],\\n            4: [7, 8],\\n            5: [9, 10]\\n        }\\n        while True:\\n            random_val = rand7()\\n            if 1 <= random_val <= 5:\\n                break\\n\\n        possible_vals = mapping[random_val]\\n        while True:\\n            random_val = rand7()\\n            if random_val != 7:\\n                break\\n\\n        index = (random_val-1)//3\\n        return possible_vals[index]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The rand7() API is already defined for you.\\n# def rand7():\\n# @return a random integer in the range 1 to 7\\n\\nclass Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        mapping = {\\n            1: [1, 2],\\n            2: [3, 4],\\n            3: [5, 6],\\n            4: [7, 8],\\n            5: [9, 10]\\n        }\\n        while True:\\n            random_val = rand7()\\n            if 1 <= random_val <= 5:\\n                break\\n\\n        possible_vals = mapping[random_val]\\n        while True:\\n            random_val = rand7()\\n            if random_val != 7:\\n                break\\n\\n        index = (random_val-1)//3\\n        return possible_vals[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929998,
                "title": "java-select-from-list-simple",
                "content": "# Code\\n```\\nclass Solution extends SolBase {\\n\\n    List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\\n\\n    public int rand10() {\\n        int index = (rand7() + rand7()) % 9;\\n        int num = list.remove(index);\\n        list.add(num);\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution extends SolBase {\\n\\n    List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\\n\\n    public int rand10() {\\n        int index = (rand7() + rand7()) % 9;\\n        int num = list.remove(index);\\n        list.add(num);\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859486,
                "title": "c",
                "content": "```\\nint rand10() {\\n        int ans = (rand7() - 1) * 7 + rand7();\\n        return (ans <= 40) ? (ans % 10 + 1) : rand10();    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n        int ans = (rand7() - 1) * 7 + rand7();\\n        return (ans <= 40) ? (ans % 10 + 1) : rand10();    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2789669,
                "title": "python-solution-with-explaination-rejection-sampling-mathematical-explaination",
                "content": "```class Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # use rejection sampling\\n        while True:\\n            row = rand7()\\n            col = rand7()\\n            idx = col + (row - 1) * 7\\n            if idx <= 40:\\n                return (idx - 1) % 10 + 1\\n```\\n\\n\\nThe idea is to use a uniform distribution of (row, col) in a 7x7 grid, which would cover all possible integers from 1 to 49.\\n\\nThen, to map it to 1 to 10, we can just take the remainder of idx / 10.\\n\\nThe probability of having idx <= 40 is 40 / 49 ~ 82.7%.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to a specific value k is 40 / 49 / 10 ~ 8.27%.\\n\\nThat is, the desired probability is 8.27%.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to a specific value k for k = 1, 2, ..., 9 is 8.27%.\\n\\nThus, it is a uniform distribution over 1, 2, ..., 9.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to 10 is 40 / 49 - 9 * 8.27% = 1 - 9 * 8.27% ~ 0.56%.\\n\\nThus, it is not a uniform distribution over 10.\\n\\nThe probability of having idx <= 40 and idx % 10 being equal to 0 is 40 / 49 - 9 * 8.27% = 1 - 9 * 8.27% ~ 0.56%.\\n\\nThus, it is not a uniform distribution over 10.\\n\\nWe can use rejection sampling to get rid of the invalid results.\\n\\nThe probability of having a valid result is 82.7%.\\n\\nThe time complexity is O(1).\\n\\nThe space complexity is O(1).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        # use rejection sampling\\n        while True:\\n            row = rand7()\\n            col = rand7()\\n            idx = col + (row - 1) * 7\\n            if idx <= 40:\\n                return (idx - 1) % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749158,
                "title": "making-a-matrix-easy-solution",
                "content": "# Approach\\nIf you make a matrix of 7x7 the numbers will go from 1-49 but for 7x6 matrix will go upto 42 (close to 40 which is a multiple of 10). So...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: theoritically infinite (when the value in each time becomes either 41 or 42 which calls the rand10() functions infinitely) but otherwise it is O(1);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n            int column = rand7(); // range is 1 - 7\\n            int row = rand7() - 1; // range is 0 - 6.\\n            int value = row * 7 + column; // range is 1 - 42.\\n            if (value <= 40){\\n                return (value - 1) % 10 + 1;\\n            }else {\\n                return rand10(); // ignoring the value 41 & 42, the probablity of getting them is 2/42 which is very less.\\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * The rand7() API is already defined in the parent class SolBase.\\n * public int rand7();\\n * @return a random integer in the range 1 to 7\\n */\\nclass Solution extends SolBase {\\n    public int rand10() {\\n            int column = rand7(); // range is 1 - 7\\n            int row = rand7() - 1; // range is 0 - 6.\\n            int value = row * 7 + column; // range is 1 - 42.\\n            if (value <= 40){\\n                return (value - 1) % 10 + 1;\\n            }else {\\n                return rand10(); // ignoring the value 41 & 42, the probablity of getting them is 2/42 which is very less.\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634597,
                "title": "c-simple-solutions-with-two-approaches",
                "content": "Solution 1: draw two times and reject particular samples\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x;\\n        //first draw: decide if x=1,2,3,4,5 or x=6,7,8,9,10\\n        int firstDraw = rand7();\\n        while (firstDraw==7){\\n            //do again the first draw if firstDraw==7 \\n            firstDraw = rand7();\\n        }\\n        \\n        //if first draw is odd, x=1,2,3,4,5\\n        //if first draw is even, x=6,7,8,9,10\\n        if (firstDraw%2==1){\\n            x = 0;\\n        }else{\\n            x = 5;\\n        }\\n        \\n        //second draw picks a number from {1,2,3,4,5,X,X}\\n        int secondDraw = rand7();\\n        while (secondDraw>=6){\\n            secondDraw = rand7();\\n        }\\n        \\n        x += secondDraw;\\n        return x;\\n    }\\n};\\n```\\n\\nSolution 2: use rand7() for 10 times and sum the numbers up\\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0; i<10; i++){\\n            sum += rand7();\\n        }\\n        return 1 + (sum%10);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int x;\\n        //first draw: decide if x=1,2,3,4,5 or x=6,7,8,9,10\\n        int firstDraw = rand7();\\n        while (firstDraw==7){\\n            //do again the first draw if firstDraw==7 \\n            firstDraw = rand7();\\n        }\\n        \\n        //if first draw is odd, x=1,2,3,4,5\\n        //if first draw is even, x=6,7,8,9,10\\n        if (firstDraw%2==1){\\n            x = 0;\\n        }else{\\n            x = 5;\\n        }\\n        \\n        //second draw picks a number from {1,2,3,4,5,X,X}\\n        int secondDraw = rand7();\\n        while (secondDraw>=6){\\n            secondDraw = rand7();\\n        }\\n        \\n        x += secondDraw;\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rand10() {\\n        int sum = 0;\\n        for (int i=0; i<10; i++){\\n            sum += rand7();\\n        }\\n        return 1 + (sum%10);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569422,
                "title": "python-round-and-7-10-is-the-simplest-solution",
                "content": "class Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return round(rand7()/7*10)",
                "solutionTags": [],
                "code": "class Solution:\\n    def rand10(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return round(rand7()/7*10)",
                "codeTag": "Java"
            },
            {
                "id": 2553734,
                "title": "c-code-1-liners",
                "content": "```\\nint rand10() \\n{\\n    return (rand7()*rand7()*rand7()*rand7()*rand7())%11;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() \\n{\\n    return (rand7()*rand7()*rand7()*rand7()*rand7())%11;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2485364,
                "title": "golden-trick-for-rand-questions-c",
                "content": "```\\nint rand10() {\\n       \\n       //GOLDEN TRICK FOR EVERY RAND() QUESTIONS --> jitne zada rand7 se multiply krayege utne zda chances hoge 1-10 ka random nuMber ki equal probaility hone ke ...  sirf <=3 baar multiply kroge to nahi hoga equal probaibility ke sath random number generate\\n       \\n        return (rand7() * rand7() * rand7()* rand7()* rand7() *rand7()  )%11;\\n    }",
                "solutionTags": [],
                "code": "```\\nint rand10() {\\n       \\n       //GOLDEN TRICK FOR EVERY RAND() QUESTIONS --> jitne zada rand7 se multiply krayege utne zda chances hoge 1-10 ka random nuMber ki equal probaility hone ke ...  sirf <=3 baar multiply kroge to nahi hoga equal probaibility ke sath random number generate\\n       \\n        return (rand7() * rand7() * rand7()* rand7()* rand7() *rand7()  )%11;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2476777,
                "title": "c-o-1-time-space-95-faster",
                "content": "```\\n// The rand7() API is already defined for you.\\n// int rand7();\\n// @return a random integer in the range 1 to 7\\n\\nclass Solution {\\npublic:\\n    int rand10() {\\n        return (rand7() * rand7() * rand7() * rand7()  )%11;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int rand10() {\\n        return (rand7() * rand7() * rand7() * rand7()  )%11;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2471332,
                "title": "range-mapping-rejection-sampling",
                "content": "```python\\n\\'\\'\\'\\nrange mapping\\nrejection sampling\\nO(1), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def rand10(self):\\n        # return a random number within [0, 48]\\n        def helper():\\n            row, col = rand7() - 1, rand7() - 1\\n            return row * 7 + col\\n        \\n        # accept any number within [0, 39]\\n        # reject/regenerate any number within [40, 48]\\n        idx = 40\\n        while idx > 39:\\n            idx = helper()\\n            \\n        return idx % 10 + 1\\n```",
                "solutionTags": [],
                "code": "```python\\n\\'\\'\\'\\nrange mapping\\nrejection sampling\\nO(1), O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def rand10(self):\\n        # return a random number within [0, 48]\\n        def helper():\\n            row, col = rand7() - 1, rand7() - 1\\n            return row * 7 + col\\n        \\n        # accept any number within [0, 39]\\n        # reject/regenerate any number within [40, 48]\\n        idx = 40\\n        while idx > 39:\\n            idx = helper()\\n            \\n        return idx % 10 + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460708,
                "title": "c-solution",
                "content": "```\\nint rand10() {\\n    int res  = 41;\\n    //The highest number res can be is 49. \\n    //The range of 41-49 is not a group of 10 which would make the randomization tilted towards nums 1-9\\n    //Discard any results that are 41 - 49 and reroll\\n    while(res > 40){\\n        res = rand7() + (rand7() - 1) * 7;\\n    }\\n    // % 10 would return a 0 if res - 1 is divisible by 10. Offset by adding 1 to return range to 1 - 10 instead of 0 - 9\\n    return res = 1 + ((res - 1) % 10);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rand10() {\\n    int res  = 41;\\n    //The highest number res can be is 49. \\n    //The range of 41-49 is not a group of 10 which would make the randomization tilted towards nums 1-9\\n    //Discard any results that are 41 - 49 and reroll\\n    while(res > 40){\\n        res = rand7() + (rand7() - 1) * 7;\\n    }\\n    // % 10 would return a 0 if res - 1 is divisible by 10. Offset by adding 1 to return range to 1 - 10 instead of 0 - 9\\n    return res = 1 + ((res - 1) % 10);\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1776652,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1567070,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1570041,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 2051734,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 2020644,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1970373,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1898901,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1837622,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            },
            {
                "id": 1804040,
                "content": [
                    {
                        "username": "user9132S",
                        "content": "I\\'ve seen similar question in interview (intel), January 2023:\\nuse rand6 to create rand8."
                    },
                    {
                        "username": "abhinavkumar045",
                        "content": "An important result used in solving the given problem is -\\n\"(randN - 1)\\\\*N + randN\" is the uniform random variable rand{N^2}.\\n\\nThe following image gives a proof of this result.\\nNOTE - Proof for N=7 has been shown below, which can be easily extended for any N=n.\\n![image](https://assets.leetcode.com/users/images/7a8cc18f-a6a6-4bba-a8e0-7e8c966a9062_1631356458.2566657.jpeg)\\n"
                    },
                    {
                        "username": "msn_user",
                        "content": "`Rand7()` from `Rand5()`:\\nhttps://www.techiedelight.com/generate-numbers-1-7-equal-probability/\\n\\n`Rand12()` from `Rand6()`:\\nhttps://www.techiedelight.com/generate-random-numbers-equal-probability/\\n\\n`Rand3()` from `Rand2()`:\\nhttps://www.techiedelight.com/return-0-1-2-equal-probability-using-specified-function/\\n\\n`Rand2()` from `Rand(1,5)`:\\nhttps://www.techiedelight.com/get-0-1-equal-probability-using-specified-function/"
                    },
                    {
                        "username": "forgedRice",
                        "content": "  can someone explain why this won\\'t work and its not uniformal distribution\\n `while True:`\\n\\n            num = rand7() + rand7() - 1\\n            if num <= 10:\\n                break\\n        return num % 10 + 1"
                    },
                    {
                        "username": "Husoski",
                        "content": "The indentation is wrong in your post.  You have the return statement in the while loop.  If that\\'s in the code, it looks like you\\'ll be getting a `None` result occasionally.\\nMore important, rand7() + rand7() is not uniform.  Roll two dice, for an example.  Each die is uniform (1..6), but do you get a total 2 or 12 as often as you get 6 or 7?"
                    },
                    {
                        "username": "user3502Cr",
                        "content": "Can someone plz tell me how in the frick is this wrong:\n\nvar rand10 = function() {\n    let x = Math.trunc((rand7()+Math.random())/7 * 10 + 1/2 - (1/7*10 - 1) )\n    if(x===11)\n        return rand10()\n    return x\n};\n\nConcept: get any random number between 1 and 8, divide by 7 to get a real number between 1/7 and 8/7 which are 1.428 to 11.428, add 1/2+1/7*10-1 or 0.5 - 0.428 to give us a rando between 1.5 to 11.4999998, truncate to get a number bertween 1 and 11 uniformly, and if you stumble on 11, choose again. I believe its the choose again bit thats causing problems, but if my math is correct the chance of choosing again should still distribute the chance uniformly.\n\nI am getting 9/12, dont tell me its the extra 0.000002 or whatever thats causing a disbalance"
                    },
                    {
                        "username": "Husoski",
                        "content": "[@user3502Cr](/user3502Cr) Last sentence, first paragraph: \"Please do not use a language\\'s built-in random API.\"\\nAs for the other part, maybe I spoke a bit hastily.  What I meant was that the sum of two uniform random variables is not *in general* uniform.  Only one counterexample is needed to prove that, and my example is perfectly valid.\\nIt took a while, but I think I see what you\\'re trying to do.   It looks like you want to convert the output of rand7() to look like 10*Math.random() + 1 and then truncate.  For that, you want to do the `/7*10` *after* adding rand7() + Math.random(); so you need some parentheses.   `let x = (rand7() - 1 + Math.random)*10/7;` Then you can return `1 + Math.min(10, Math.trunc( x))` or something (or stick with your recursive call.)\\nThat should pass the tests, but still violates one of the provisions  of the problem statement."
                    },
                    {
                        "username": "user3502Cr",
                        "content": "[@Husoski](/Husoski) I didnt see how math.random was out of bounds here, but I can see how what Im doing is just reducing it to rand * 10, which I dont see how you can get away without doing. I can try to think of something else.\\n\\nYour second point is invalid though and a bad generalization based on an anecdote. The reason the two dice thing doesnt work is because there are more combos that add up to 7 than those that add up to 2 or 12. You cant extend the same argument here, as the only way to 2.35 is by adding 2 and .35. Its like if the first dice had 1-6 and the second dice had A-F, any combo from 1A to 6F would have uniform probability."
                    },
                    {
                        "username": "Husoski",
                        "content": "First off, using Math.random() is out of bounds.  You\\'re supposed to get the result using rand7() only.\\nSecond, the sum of two uniform random numbers is NOT a uniform random number.  For example, roll two dice and the total of the two rolls is not a uniform value from 2 to 12.\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Conveniently, 7^6 = 117649 is just over a power of 10.  Six calls to the rand7() generator will get you uniform random base 7 number (subtracting 1 each time go get digits in the range 0-6) that has a decimal range of 0 to 117648.  If you reject all such numbers greater than 99999 (about 15% of them), you have a random number with 5 random 0-9 digits.  That\\'s 85% efficiency and theoretically exact uniform distribution (provided that the rand7() generator is perfectly uniform).\\n"
                    },
                    {
                        "username": "nityabhaskar21",
                        "content": "I tried using val=rand7()*7 . And then getting val%10 +1. I am getting values from 1 to 10, but not getting uniform probability."
                    },
                    {
                        "username": "zhiyazw",
                        "content": "I'm a newbie in sampling. \nI come up with a solution which will have 1.0 call to rand7 if it's correct, it passed all tests and was accepted.\nBut it's too naive so that I don't believe it's correct, especially after reading the author's and some top voted solutions.\nHowever I can't prove its incorrectness, could someone prove? \n```\nclass Solution extends SolBase {\n    int rand = 0;\n    public int rand10() {\n        rand += rand7();\n        if (rand > 10) {\n            rand %= 10;\n        }\n        return rand;\n    }\n}\n```"
                    },
                    {
                        "username": "Husoski",
                        "content": "The comment by [@Vladimir Romanov](/blueboar2) is almost right.  Your first result will always be in the [1,7] interval and each subsequent value will be just one of the 7 values at or after the previous value (modulo 10).\n\nOne test that's commonly used with random number generators is to use consecutive random result to generate (x,y) pairs.  Make an int[10][10] array, 'counts' maybe, and then set counts[rand10()][rand10()] += 1.  Repeat that 5,000 times in a loop and then print out the results as a 10x10 table.  The result will be strikingly non-uniform.  (You expect each of the 100 counts to be somewhere around 50, right?)\n\nWrite the program and see for yourself!"
                    },
                    {
                        "username": "blueboar2",
                        "content": "Well, it is obviously not correct as you just return rand7() as rand10(). You will never have any 8/9/10 in your result ."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "What does it mean when they say \"Uniform Random integer\"? Can\\'t we return rand(7) + any value between 1 and 3?"
                    },
                    {
                        "username": "code__HARD",
                        "content": "u can never get values  1 2 3\\n"
                    },
                    {
                        "username": "blueboar2",
                        "content": "If you return rand(7) plus any value from 1 to 3 - then your minimal answer will be 2 (1 from rand(7) and 1 from value). You will never return 1 in your answer and it will be not uniform. Also, you can't get \"any value between 1 and 3\" as question states - not using any random numbers except those from rand(7)."
                    },
                    {
                        "username": "user9132S",
                        "content": "it means the probability to get each number is equal. you can read about it:\\nhttps://en.wikipedia.org/wiki/Discrete_uniform_distribution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Managers with at Least 5 Direct Reports",
        "question_content": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find managers with at least <strong>five direct reports</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | None      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+\n</pre>\n",
        "solutions": [
            {
                "id": 3708167,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n```please upvote to motivate me write more solution",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102697,
                "title": "accepted-and-easy-to-understand-solution",
                "content": "```\\nselect name from employee \\nwhere id in \\n(select managerId from Employee\\ngroup by managerId\\nhaving count(managerId)>=5) \\n```",
                "solutionTags": [],
                "code": "```\\nselect name from employee \\nwhere id in \\n(select managerId from Employee\\ngroup by managerId\\nhaving count(managerId)>=5) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872861,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    managers = employee.groupby(\\n        \\'managerId\\', as_index=False\\n    ).agg(\\n        reporting=(\\'id\\', \\'count\\'),\\n    ).query(\\n        \\'5 <= reporting\\'\\n    )[\\'managerId\\']\\n\\n    return employee[\\n        employee[\\'id\\'].isin(managers)\\n    ][[\\'name\\']]\\n```\\n```SQL []\\nSELECT e1.name\\n  FROM Employee e1\\n      JOIN Employee e2\\n          ON e1.id = e2.managerId\\n GROUP BY e1.id\\nHAVING count(e2.managerId) >= 5;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    managers = employee.groupby(\\n        \\'managerId\\', as_index=False\\n    ).agg(\\n        reporting=(\\'id\\', \\'count\\'),\\n    ).query(\\n        \\'5 <= reporting\\'\\n    )[\\'managerId\\']\\n\\n    return employee[\\n        employee[\\'id\\'].isin(managers)\\n    ][[\\'name\\']]\\n```\n```SQL []\\nSELECT e1.name\\n  FROM Employee e1\\n      JOIN Employee e2\\n          ON e1.id = e2.managerId\\n GROUP BY e1.id\\nHAVING count(e2.managerId) >= 5;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3782990,
                "title": "sub-query-solution-with-explanation",
                "content": "\\n\\n# Intuition\\nThe problem asks us to find the names of managers who have at least five direct reports. We need to identify the managers based on their role and count the number of employees who report to them.\\n\\n# Approach\\nTo solve the problem, your approach can be explained as follows:\\n\\n1. First, we group the employees based on the managers they report to. This helps us identify the managers and their direct reports.\\n1. Then, we filter the groups and keep only those where the count of employees reporting to the manager is at least five. This ensures we select only the managers who have at least five direct reports.\\n1. Finally, we retrieve the names of the employees who are identified as qualifying managers based on the filtered results.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of your solution depends on the number of rows in the Employee table. The subquery groups the employees, and the outer query performs the filtering and retrieval. The time complexity can be expressed as $$O(n)$$, where n is the number of employees in the table.\\n\\n- Space complexity:\\nThe space complexity of your solution depends on the size of the result set. In this case, it will be the number of managers who have at least five direct reports. The space complexity can be considered as $$O(k)$$, where k is the number of managers meeting the criteria.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT name \\nFROM Employee \\nWHERE id IN (\\n    SELECT managerId \\n    FROM Employee \\n    GROUP BY managerId \\n    HAVING COUNT(managerId) >= 5\\n)\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT name \\nFROM Employee \\nWHERE id IN (\\n    SELECT managerId \\n    FROM Employee \\n    GROUP BY managerId \\n    HAVING COUNT(managerId) >= 5\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857371,
                "title": "100-easy-fast-clean-solution",
                "content": "IF  THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT E1.name FROM Employee E1 INNER JOIN  ( SELECT managerId FROM \\n\\nEmployee GROUP BY managerId HAVING COUNT(managerId) >= 5)  E2 ON \\n\\nE1.id = E2.managerId \\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/c0ed808a-b1b1-4627-93da-0fdb98fec094_1691054593.6652298.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT E1.name FROM Employee E1 INNER JOIN  ( SELECT managerId FROM \\n\\nEmployee GROUP BY managerId HAVING COUNT(managerId) >= 5)  E2 ON \\n\\nE1.id = E2.managerId \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725916,
                "title": "mysql-simple-and-clean-beats-99-12",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to find the managers who have at least five direct reports, i.e., employees who report to them. One way to think about this problem is to use a **join** operation on the Employee table with itself, where we match the managerId column of one table with the id column of another table. This way, we can find all the pairs of managers and their direct reports. Then, we can use a **GROUP BY** clause to group the results by manager name and use a **HAVING** clause to filter out the managers who have less than five direct reports.\\n\\n# Approach\\n1. Join the Employee table with itself on the condition that `e1.id = e2.managerId`. This will give us all pairs of managers and their direct reports.\\n2. Group the results by manager name using a `GROUP BY` clause.\\n3. Use a `HAVING` clause to filter out the managers who have less than five direct reports.\\n4. Select the manager name column to get the final result.\\n\\nHere is the SQL code that implements this approach:\\n\\n```sql\\nSELECT e1.name\\nFROM Employee e1\\nJOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.name\\nHAVING COUNT(e2.id) >= 5;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to find the managers who have at least five direct reports, i.e., employees who report to them. One way to think about this problem is to use a **join** operation on the Employee table with itself, where we match the managerId column of one table with the id column of another table. This way, we can find all the pairs of managers and their direct reports. Then, we can use a **GROUP BY** clause to group the results by manager name and use a **HAVING** clause to filter out the managers who have less than five direct reports.\\n\\n# Approach\\n1. Join the Employee table with itself on the condition that `e1.id = e2.managerId`. This will give us all pairs of managers and their direct reports.\\n2. Group the results by manager name using a `GROUP BY` clause.\\n3. Use a `HAVING` clause to filter out the managers who have less than five direct reports.\\n4. Select the manager name column to get the final result.\\n\\nHere is the SQL code that implements this approach:\\n\\n```sql\\nSELECT e1.name\\nFROM Employee e1\\nJOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.name\\nHAVING COUNT(e2.id) >= 5;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2075668,
                "title": "mysql-beats-90-cross-join",
                "content": "```\\nSELECT      E2.name\\nFROM        Employee E1, Employee E2\\nWHERE       E1.managerId  = E2.id  \\nGROUP BY    E1.managerId\\nHAVING      COUNT(E1.managerId) >= 5 \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT      E2.name\\nFROM        Employee E1, Employee E2\\nWHERE       E1.managerId  = E2.id  \\nGROUP BY    E1.managerId\\nHAVING      COUNT(E1.managerId) >= 5 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596265,
                "title": "self-join",
                "content": "```\\nselect distinct m.name as name\\nfrom employee e join employee m\\non m.id = e.managerid\\ngroup by m.id\\nhaving count(*) >= 5\\n```\\n\\nThe key is to view the employee table as two tables, one for employee, one for manager. manager table donates the primary key to the employee table.",
                "solutionTags": [],
                "code": "```\\nselect distinct m.name as name\\nfrom employee e join employee m\\non m.id = e.managerid\\ngroup by m.id\\nhaving count(*) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3970307,
                "title": "pandas-very-intutive-approach-commented-code",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    # Group the employees by managerId and count the number of direct reports\\n    manager_report_count = employee.groupby(\\'managerId\\').size().reset_index(name=\\'directReports\\')\\n    \\n    # Filter managers with at least five direct reports\\n    result = manager_report_count[manager_report_count[\\'directReports\\'] >= 5]\\n    \\n    # Merge with the Employee table to get the names of these managers\\n    result = result.merge(employee[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n    \\n    # Select only the \\'name\\' column and drop the \\'id\\' and \\'directReports\\' columns\\n    result = result[[\\'name\\']]\\n    \\n    return result\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    # Group the employees by managerId and count the number of direct reports\\n    manager_report_count = employee.groupby(\\'managerId\\').size().reset_index(name=\\'directReports\\')\\n    \\n    # Filter managers with at least five direct reports\\n    result = manager_report_count[manager_report_count[\\'directReports\\'] >= 5]\\n    \\n    # Merge with the Employee table to get the names of these managers\\n    result = result.merge(employee[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n    \\n    # Select only the \\'name\\' column and drop the \\'id\\' and \\'directReports\\' columns\\n    result = result[[\\'name\\']]\\n    \\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3697000,
                "title": "nested-query-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select managerId from Employee \\n                group by managerId\\n                having count(managerId) >= 5);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select managerId from Employee \\n                group by managerId\\n                having count(managerId) >= 5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558540,
                "title": "simple-implementation-with-join-group-by-having",
                "content": "\\n\\n# Code\\n``` MS_SQL []\\nSELECT      e1.name \\nFROM        Employee e1\\nJOIN        Employee e2\\nON          e1.id = e2.managerId\\nGROUP BY    e1.id, e1.name\\nHAVING      COUNT(e1.id) >= 5;\\n```\\n\\n**The basic hint to identify the main approach behind the problem is to check the number of tables for this one.** Again, that is not the only thing to check but it helps in many cases.\\n\\n1. The objective is to return the name that acts as manager for at least 5 employees.\\n2. `Self join the table` and you can now `reference the id and managerId fields`.\\n3. Since you have to determine the relation between id and managerId, you will have to `JOIN ON e1.id = e2.managerId`.\\n4. To filter the rows with count >= 5, merge the column values by using `GROUP BY`.\\n5. Apply the condition using `HAVING COUNT(e1.id) >= 5`.\\n\\n\\n# Commands\\n\\n### JOIN \\nIt is a way to combine data from two or more tables based on a common column. \\n## GROUP BY\\nIt is used to group rows that have the same values into summary rows and perform aggregate functions on the grouped data. \\n## HAVING\\nIt is used to filter groups returned by the GROUP BY clause. \\n<hr>\\n\\n# Let me know if you have any other interesting approach.",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` MS_SQL []\\nSELECT      e1.name \\nFROM        Employee e1\\nJOIN        Employee e2\\nON          e1.id = e2.managerId\\nGROUP BY    e1.id, e1.name\\nHAVING      COUNT(e1.id) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587413,
                "title": "super-easy-solution-self-inner-join-postgres-mysql-oracle-beats-38-in-average",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo resolve this issue, you need to divide the task into several logic parts. You will need to perform self-inner-join to get the names which belong to manager group. To do this we should compare `managerId` with `id`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Firstly we execute the following equery and find out the names list where each person is a manager. We can do this by self inner join ON id = managerId. Please do not forget that you should use alias for each table.\\n\\n```\\nSELECT e1.name\\nFROM Employee e1\\nINNER JOIN Employee e2\\nON e1.id = e2.managerId;\\n```\\n2. Now you can easily notice - there is a name column so all we have to do now is just GROUP they by the COUNT aggregate function. \\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT e1.name\\nFROM Employee e1\\nINNER JOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.name\\nHAVING COUNT(e1.name) >= 5;\\n\\n```\\n\\n3. It is worth noting we ought to add here HAVING keyword for filtering out the necessary results.\\n\\n\\nThank you!\\n",
                "solutionTags": [
                    "MySQL",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nSELECT e1.name\\nFROM Employee e1\\nINNER JOIN Employee e2\\nON e1.id = e2.managerId;\\n```\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT e1.name\\nFROM Employee e1\\nINNER JOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.name\\nHAVING COUNT(e1.name) >= 5;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3390789,
                "title": "mysql-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee where id in (select managerId from Employee group by managerId having count(*)>=5);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee where id in (select managerId from Employee group by managerId having count(*)>=5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827488,
                "title": "mysql-self-join-faster-than-90",
                "content": "```\\nSELECT e2.Name\\nFROM Employee e1 JOIN Employee e2\\nON e1.managerId = e2.Id\\nGROUP BY e1.managerId\\nHAVING COUNT(e1.managerId)>=5\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT e2.Name\\nFROM Employee e1 JOIN Employee e2\\nON e1.managerId = e2.Id\\nGROUP BY e1.managerId\\nHAVING COUNT(e1.managerId)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3529215,
                "title": "mysql-solution-for-managers-with-at-least-5-direct-reports-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given query selects the names of employees who are managers and have at least 5 employees reporting to them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inner subquery retrieves the ManagerId from the \"Employee\" table.\\n2. It groups the ManagerId values to identify unique managers using the group by clause.\\n3. The having count(*) >= 5 condition filters the groups to include only those managers who have at least 5 employees reporting to them.\\n4. The outer query selects the names (Name) of employees from the \"Employee\" table where the Id is in the set of ManagerIds obtained from the inner subquery.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the \"Employee\" table and the efficiency of indexing on the Id and ManagerId columns. The inner subquery involves a group-by operation, which can have a time complexity of O(N log N), where N is the number of rows in the table. The outer query\\'s time complexity depends on the number of ManagerIds retrieved from the inner subquery and the efficiency of joining and filtering. Overall, the time complexity is typically linear or sublinear, but it can be influenced by the indexing and join performance.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query is determined by the memory required to process the subquery and store the result set. The subquery may require additional memory to store intermediate results, such as the grouped ManagerIds. The size of the result set depends on the number of employees who meet the condition (managers with at least 5 employees reporting to them). The space complexity is proportional to the size of the result set. If the result set is large, it may require additional memory resources to store and return the data. However, if the result set is small compared to the total table size, the impact on space complexity is minimal.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect Name from Employee where Id in\\n(\\n    Select ManagerId from Employee \\n    group by ManagerId having count(*) >= 5\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Name from Employee where Id in\\n(\\n    Select ManagerId from Employee \\n    group by ManagerId having count(*) >= 5\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1253011,
                "title": "the-null-value-format-drives-me-crazy",
                "content": "This is my query\\n\\n```\\nselect b.Name\\nfrom Employee a left join\\nEmployee b\\non a.ManagerId = b.Id\\ngroup by b.Name\\nhaving count(*) >=5\\n```\\n\\nBut it was deemed wrong answer b/c the format of the null...\\n\\n```\\nOutput:\\n{\"headers\": [\"Name\"], \"values\": [[null]]}\\nExpected:\\n{\"headers\": [\"Name\"], \"values\": []}\\n\\n```\\n\\nThen I changed into \\n```\\nselect ifnull(c.name,\\'\\') as Name\\nfrom\\n(select b.Name\\nfrom Employee a left join\\nEmployee b\\non a.ManagerId = b.Id\\ngroup by b.Name\\nhaving count(*) >=5\\n ) c\\n```\\n\\nIt was still deemed wrong answer...\\n\\n```\\nOutput:\\n{\"headers\": [\"Name\"], \"values\": [[\"\"]]}\\nExpected:\\n{\"headers\": [\"Name\"], \"values\": []}\\n```\\n\\nHelp!!\\n",
                "solutionTags": [],
                "code": "```\\nselect b.Name\\nfrom Employee a left join\\nEmployee b\\non a.ManagerId = b.Id\\ngroup by b.Name\\nhaving count(*) >=5\\n```\n```\\nOutput:\\n{\"headers\": [\"Name\"], \"values\": [[null]]}\\nExpected:\\n{\"headers\": [\"Name\"], \"values\": []}\\n\\n```\n```\\nselect ifnull(c.name,\\'\\') as Name\\nfrom\\n(select b.Name\\nfrom Employee a left join\\nEmployee b\\non a.ManagerId = b.Id\\ngroup by b.Name\\nhaving count(*) >=5\\n ) c\\n```\n```\\nOutput:\\n{\"headers\": [\"Name\"], \"values\": [[\"\"]]}\\nExpected:\\n{\"headers\": [\"Name\"], \"values\": []}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 765221,
                "title": "ms-sql-beats-100",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect e.name\\nfrom employee m left join employee e\\non m.managerid = e.id\\ngroup by e.name\\nhaving count(e.name) > 4\\n;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect e.name\\nfrom employee m left join employee e\\non m.managerid = e.id\\ngroup by e.name\\nhaving count(e.name) > 4\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914243,
                "title": "intuitive-approach",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    ans = pd.merge(employee, employee[\"managerId\"].value_counts(), how=\"left\", left_on=\"id\", right_on=\"managerId\")\\n    filt = (ans[\"count\"] >= 5)\\n    return ans[filt][[\"name\"]]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    ans = pd.merge(employee, employee[\"managerId\"].value_counts(), how=\"left\", left_on=\"id\", right_on=\"managerId\")\\n    filt = (ans[\"count\"] >= 5)\\n    return ans[filt][[\"name\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3526349,
                "title": "easy-solution-with-inner-querie-mssql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have the following steps for finding managers with at least five direct reports:\\n  - Getting the manager who has at least five direct reports (using inner queries to equal the managerId to the employeeId)\\n  - Apply the where condition to inner querie.\\n  - Select the employee\\'s name.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using where condition.\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT e.name FROM Employee e\\nWHERE (SELECT COUNT(managerId) FROM Employee WHERE managerId = e.id) >= 5\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT e.name FROM Employee e\\nWHERE (SELECT COUNT(managerId) FROM Employee WHERE managerId = e.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101103,
                "title": "easy-to-understand-using-group-by-and-having-clause",
                "content": "\\n# Approach\\n<-- Use a subquery to identify the managerId values that have at least five direct reports. This is done by grouping the employees by their managerId and using the HAVING clause to filter for counts greater than or equal to 5.\\n\\n<--Then use the IN clause to select the name of employees whose id matches the managerId values found in the subquery, effectively finding the names of managers with at least five direct reports.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name \\nfrom employee \\nwhere id in\\n(select managerId \\nfrom Employee\\nGroup by managerId\\nHaving count(managerId)>=5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name \\nfrom employee \\nwhere id in\\n(select managerId \\nfrom Employee\\nGroup by managerId\\nHaving count(managerId)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564339,
                "title": "simple-solution",
                "content": "```sql\\n SELECT name\\n FROM Employee\\n WHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n SELECT name\\n FROM Employee\\n WHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916740,
                "title": "simple-self-explanatory",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name \\nFROM Employee\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId)>4\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name \\nFROM Employee\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId)>4\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902991,
                "title": "many-ways-to-solve-this-problem",
                "content": "# MySQL\\n\\n### Using Sub Query:\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee e\\nWHERE 5 <= (\\n    SELECT COUNT(*) \\n    FROM Employee e2 \\n    WHERE e2.managerId IS NOT NULL \\n    AND e2.managerId=e.id\\n    )\\n```\\n\\n### Using Join:\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee e1\\nJOIN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n    ) e2\\nON e1.id = e2.managerId\\n```\\n\\n### IN Clause with Subquery:\\n\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n    )\\n```\\n<hr>\\n\\n# Pandas:\\n\\n### Difference between using count() and size():\\n\\nWhen We use `groupby().count().reset_index()` our output looks like this:\\n| managerId | id | name | department |\\n| --------- | -- | ---- | ---------- |\\n| 101       | 5  | 5    | 5          |\\n\\nBut if we use `groupby().size().reset_index(name=\\'count\\')` our output looks like this:\\n| managerId | count |\\n| --------- | ----- |\\n| 101       | 5     |\\n\\nSo, using `count()` would keep all the columns and therefore take more memory than `size()`. `size()` will reduce unnecessary columns.\\n\\n### Usign INNER JOIN:\\n\\n``` Python3 []\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n  df = employee.groupby(\\'managerId\\')\\n                .size()\\n                .reset_index(name=\\'count\\')\\n  df =  df[df[\\'count\\'] >= 5]\\n  managers = pd.merge(\\n                    df, \\n                    employee, \\n                    left_on=\\'managerId\\', \\n                    right_on=\\'id\\', \\n                    how=\\'inner\\'\\n                    )\\n  return managers[[\\'name\\']]\\n```\\n### Using IN Clause:\\n\\n``` Python3 []\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n  df = employee.groupby(\\'managerId\\')\\n                .size()\\n                .reset_index(name=\\'count\\')\\n  df =  df[df[\\'count\\'] >= 5]\\n  return employee[employee[\\'id\\'].isin(df[\\'managerId\\'])][[\\'name\\']]\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee e\\nWHERE 5 <= (\\n    SELECT COUNT(*) \\n    FROM Employee e2 \\n    WHERE e2.managerId IS NOT NULL \\n    AND e2.managerId=e.id\\n    )\\n```\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee e1\\nJOIN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n    ) e2\\nON e1.id = e2.managerId\\n```\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(managerId) >= 5\\n    )\\n```\n``` Python3 []\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n  df = employee.groupby(\\'managerId\\')\\n                .size()\\n                .reset_index(name=\\'count\\')\\n  df =  df[df[\\'count\\'] >= 5]\\n  managers = pd.merge(\\n                    df, \\n                    employee, \\n                    left_on=\\'managerId\\', \\n                    right_on=\\'id\\', \\n                    how=\\'inner\\'\\n                    )\\n  return managers[[\\'name\\']]\\n```\n``` Python3 []\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n  df = employee.groupby(\\'managerId\\')\\n                .size()\\n                .reset_index(name=\\'count\\')\\n  df =  df[df[\\'count\\'] >= 5]\\n  return employee[employee[\\'id\\'].isin(df[\\'managerId\\'])][[\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3860724,
                "title": "pandas-clean-and-simple-solution",
                "content": "```\\nimport pandas as pd\\n\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    required_managers = (\\n        employee\\n        .groupby(\\'managerId\\', as_index=False)\\n        .agg(reporting=(\\'id\\', \\'count\\'))\\n        .query(\\'reporting >= 5\\')\\n    )[\\'managerId\\']\\n\\n    return employee[employee[\\'id\\'].isin(required_managers)][[\\'name\\']]\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    required_managers = (\\n        employee\\n        .groupby(\\'managerId\\', as_index=False)\\n        .agg(reporting=(\\'id\\', \\'count\\'))\\n        .query(\\'reporting >= 5\\')\\n    )[\\'managerId\\']\\n\\n    return employee[employee[\\'id\\'].isin(required_managers)][[\\'name\\']]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3800548,
                "title": "simple-using-having",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name\\nfrom employee\\nwhere id in ( SELECT managerId\\nFROM employee\\nGROUP BY managerId\\nHAVING count(name) >= 5 );\\n```\\n\\n![1qivbn.jpg](https://assets.leetcode.com/users/images/a169dbd7-b34d-4a99-8359-a8a813239d9a_1689869293.2703924.jpeg)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name\\nfrom employee\\nwhere id in ( SELECT managerId\\nFROM employee\\nGROUP BY managerId\\nHAVING count(name) >= 5 );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634292,
                "title": "simple-self-join",
                "content": "\\n```\\nselect b.name from Employee b\\njoin (select managerId from Employee group by managerID having count(*) >= 5) a \\non b.id=a.managerID\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect b.name from Employee b\\njoin (select managerId from Employee group by managerID having count(*) >= 5) a \\non b.id=a.managerID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591398,
                "title": "easy-solution-mysql-pandas-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For this query, we need to perform SELF INNER JOIN on the Employee table such that the id(Employee id) of one alias is the same as the managerID of another alias.\\n- We then group the output by managerID with a condition that managerID has a count >= 5 which means that a managers receives atleast 5 direct reports.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we select the name of the employee from alias E1.\\n2. In the FROM statement, we perform an **INNER JOIN with aliases E1 and E2 of the Employee table such that E1.id = E2.managerID.**\\n3. The **GROUP BY clause** is used to group the managers **HAVING** number of managerID >=5 using **COUNT()** function.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT E1.name \\nFROM Employee as E1 INNER JOIN Employee as E2\\nON E1.id = E2.managerID\\nGROUP BY E2.managerID\\nHAVING COUNT(E2.managerID)>=\\'5\\';\\n```\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    output = employee.groupby([\\'managerId\\'])[\\'id\\'].agg([\\'count\\']).reset_index()\\n    output = output.loc[output[\\'count\\']>=5,[\\'managerId\\']]\\n    output = employee.loc[employee[\\'id\\'].isin(output[\\'managerId\\']),[\\'name\\']]\\n\\n    return output\\n```\\n### Please upvote if you find my solution helpful.",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT E1.name \\nFROM Employee as E1 INNER JOIN Employee as E2\\nON E1.id = E2.managerID\\nGROUP BY E2.managerID\\nHAVING COUNT(E2.managerID)>=\\'5\\';\\n```\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    output = employee.groupby([\\'managerId\\'])[\\'id\\'].agg([\\'count\\']).reset_index()\\n    output = output.loc[output[\\'count\\']>=5,[\\'managerId\\']]\\n    output = employee.loc[employee[\\'id\\'].isin(output[\\'managerId\\']),[\\'name\\']]\\n\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3562418,
                "title": "sql-subquery-where-group-by-count-easy-solution",
                "content": "# Intuition\\nI used a subquery to find the id of one employee and the managerId of another employee\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/7714675c-5111-4c9a-aca2-1c6dee6b9bcb_1685030198.6421015.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\nname\\nfrom Employee \\nwhere id in (select managerId from Employee group by managerId having count(managerId) >= 5)\\n\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\nname\\nfrom Employee \\nwhere id in (select managerId from Employee group by managerId having count(managerId) >= 5)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556580,
                "title": "sql-code",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee where id in(select managerId from Employee group by managerId HAVING 5<=count(managerId));\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee where id in(select managerId from Employee group by managerId HAVING 5<=count(managerId));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075789,
                "title": "solving-using-windowing",
                "content": "```\\nWITH t AS (SELECT DISTINCT ManagerID, COUNT(*) OVER (PARTITION BY ManagerID) AS num FROM Employee )\\nSELECT e.Name FROM t LEFT JOIN Employee AS e ON t.ManagerID = e.Id WHERE t.num >= 5  and e.Name IS NOT NULL\\n```",
                "solutionTags": [],
                "code": "```\\nWITH t AS (SELECT DISTINCT ManagerID, COUNT(*) OVER (PARTITION BY ManagerID) AS num FROM Employee )\\nSELECT e.Name FROM t LEFT JOIN Employee AS e ON t.ManagerID = e.Id WHERE t.num >= 5  and e.Name IS NOT NULL\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031177,
                "title": "mysql-solution-570-managers-with-at-least-5-direct-reports",
                "content": "```Intuition []\\n    1. The problem asks to find the name(s) of manager(s) who recieves five or more direct reports. \\n    2. So, In order to find the manager\\'s names We need to identify all the ids of employees who are reporting to a specific manager.\\n    3. Then count the number of employees who report to the specific manager.\\n    4. After calculating the total number of Id (i.e employee\\'s id) for each managerId, we\\'ll compare whether the number of employee\\'s id is greater or equal to 5 for each managerId or not.\\n    5. If condition is satisfied then finally we\\'ll return the name of managers associated with that managerIds.\\n```\\n```Approach_1 []\\n    1. Establish a self join on table using INNER JOIN clause on table employee with two different alias name e1 and e2 in FROM clause.\\n        i.e => \\'FROM Employee e1 INNER JOIN Employee e2\\'\\n    2. Specify the matching column from each table on ON clause with INNER JOIN.\\n        i.e => \\'ON e1.id = e2.managerId\\'\\n    3. Then group the employee\\'s Id based on the managerId to whom the reports directly.\\n        i.e => \\'GROUP BY e2.managerID`\\n    4. Then Pass the condition for required number of employee\\'s Id for each managerId within HAVING clause using count() aggregate function.\\n        i.e => \\'HAVING count(e2.id) >= 5\\'\\n    5. Now finally we are set to retrieve the name of manager who have at least 5 direct reports using SELECT clause.\\n        i.e => \\'SELECT e1.name\\'\\n```\\n```Approach_2 []\\n    1. Specify a table two times with two different alias name e1 and e2 separated with comma (,) in FROM clause.\\n        i.e => \\'FROM Employee e1, Employee e2\\'\\n    2. Specify the matching column condition for two tables within WHERE clause.\\n        i.e => \\'WHERE e1.id = e2.managerId\\'\\n    3. Then group the employee\\'s Id based on the managerId to whom the reports directly.\\n        i.e => \\'GROUP BY e2.managerID`\\n    4. Then Pass the condition for required number of employee\\'s Id for each managerId within HAVING clause using count() aggregate function.\\n        i.e => \\'HAVING count(e2.id) >= 5\\'\\n    5. Now finally we are set to retrieve the name of manager who have at least 5 direct reports using SELECT clause.\\n        i.e => \\'SELECT e1.name\\'\\n```\\n```Complexity []\\n1. Time complexity: Beats 99.4% users.\\n2. Space complexity: Beats 100% users.\\n```\\n---\\n- **CODE:**\\n```MySQL(INNER_JOIN) []\\nSELECT e1.name \\nFROM Employee e1 INNER JOIN Employee e2 ON e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING count(e2.id) >= 5;\\n```\\n```MySQL(WHERE_Clause) [sfdcsda]\\nSELECT e1.name \\nFROM Employee e1, Employee e2 \\nWHERE e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING count(e2.id) >= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```Intuition []\\n    1. The problem asks to find the name(s) of manager(s) who recieves five or more direct reports. \\n    2. So, In order to find the manager\\'s names We need to identify all the ids of employees who are reporting to a specific manager.\\n    3. Then count the number of employees who report to the specific manager.\\n    4. After calculating the total number of Id (i.e employee\\'s id) for each managerId, we\\'ll compare whether the number of employee\\'s id is greater or equal to 5 for each managerId or not.\\n    5. If condition is satisfied then finally we\\'ll return the name of managers associated with that managerIds.\\n```\n```Approach_1 []\\n    1. Establish a self join on table using INNER JOIN clause on table employee with two different alias name e1 and e2 in FROM clause.\\n        i.e => \\'FROM Employee e1 INNER JOIN Employee e2\\'\\n    2. Specify the matching column from each table on ON clause with INNER JOIN.\\n        i.e => \\'ON e1.id = e2.managerId\\'\\n    3. Then group the employee\\'s Id based on the managerId to whom the reports directly.\\n        i.e => \\'GROUP BY e2.managerID`\\n    4. Then Pass the condition for required number of employee\\'s Id for each managerId within HAVING clause using count() aggregate function.\\n        i.e => \\'HAVING count(e2.id) >= 5\\'\\n    5. Now finally we are set to retrieve the name of manager who have at least 5 direct reports using SELECT clause.\\n        i.e => \\'SELECT e1.name\\'\\n```\n```Approach_2 []\\n    1. Specify a table two times with two different alias name e1 and e2 separated with comma (,) in FROM clause.\\n        i.e => \\'FROM Employee e1, Employee e2\\'\\n    2. Specify the matching column condition for two tables within WHERE clause.\\n        i.e => \\'WHERE e1.id = e2.managerId\\'\\n    3. Then group the employee\\'s Id based on the managerId to whom the reports directly.\\n        i.e => \\'GROUP BY e2.managerID`\\n    4. Then Pass the condition for required number of employee\\'s Id for each managerId within HAVING clause using count() aggregate function.\\n        i.e => \\'HAVING count(e2.id) >= 5\\'\\n    5. Now finally we are set to retrieve the name of manager who have at least 5 direct reports using SELECT clause.\\n        i.e => \\'SELECT e1.name\\'\\n```\n```Complexity []\\n1. Time complexity: Beats 99.4% users.\\n2. Space complexity: Beats 100% users.\\n```\n```MySQL(INNER_JOIN) []\\nSELECT e1.name \\nFROM Employee e1 INNER JOIN Employee e2 ON e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING count(e2.id) >= 5;\\n```\n```MySQL(WHERE_Clause) [sfdcsda]\\nSELECT e1.name \\nFROM Employee e1, Employee e2 \\nWHERE e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING count(e2.id) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976884,
                "title": "pandas-step-by-step-solution-for-beginners",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    \\n    manager_report_count = employee.groupby(\\'managerId\\').size().reset_index(name=\\'directReports\\')\\n    \\n    result = manager_report_count[manager_report_count[\\'directReports\\'] >= 5]\\n    \\n    result = result.merge(employee[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n    \\n    result = result[[\\'name\\']]\\n    \\n    return result\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    \\n    manager_report_count = employee.groupby(\\'managerId\\').size().reset_index(name=\\'directReports\\')\\n    \\n    result = manager_report_count[manager_report_count[\\'directReports\\'] >= 5]\\n    \\n    result = result.merge(employee[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n    \\n    result = result[[\\'name\\']]\\n    \\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3955545,
                "title": "easy-solution-sql-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem involves selecting employees who are managers and have more than four subordinates. The query likely uses a self-join to connect employees with their managers and then counts the number of subordinates each manager has.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The outer query selects the name from a subquery aliased as c.\\n2. The subquery aliased as c performs a left join on the Employee table using a self-join. It retrieves the name and id of each employee along with a count of how many times their name appears in the joined result, which essentially represents the number of subordinates they have.\\n3. The GROUP BY clause groups the result by the name and id of the manager (employee), which is essential for counting the number of subordinates for each manager.\\n4. The WHERE clause filters the results from the subquery to only include those rows where the count of subordinates (countname) is greater than 4\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.name from (select a.name, count(a.name) countname\\nfrom Employee as a left join Employee as b\\non a.id=b.managerid\\ngroup by a.name,a.id) as c where c.countname>4;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.name from (select a.name, count(a.name) countname\\nfrom Employee as a left join Employee as b\\non a.id=b.managerid\\ngroup by a.name,a.id) as c where c.countname>4;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929681,
                "title": "easy-and-self-explanatory",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name FROM Employee WHERE id IN (SELECT DISTINCT managerId FROM Employee \\nGROUP BY managerId \\nHAVING managerId IS NOT NULL and COUNT(managerId)>=5);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name FROM Employee WHERE id IN (SELECT DISTINCT managerId FROM Employee \\nGROUP BY managerId \\nHAVING managerId IS NOT NULL and COUNT(managerId)>=5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906545,
                "title": "pandas-groupby-filtering",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) groupby manager_id & count\\n2) filter id by count at least five => int array\\n3) filter employee by contains id with (2)int array using `isin` function\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    df = employee.groupby(\"managerId\", as_index = False).agg(\"count\")\\n    return employee[employee[\"id\"].isin(df[df[\"id\"] >= 5][\"managerId\"].values)][[\"name\"]]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    df = employee.groupby(\"managerId\", as_index = False).agg(\"count\")\\n    return employee[employee[\"id\"].isin(df[df[\"id\"] >= 5][\"managerId\"].values)][[\"name\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3864953,
                "title": "clear-explanation-joins-clean-solution",
                "content": "select a.name from Employee a inner join\\n(select b.managerId from Employee b group by b.managerId \\nhaving count (b.managerId)>=5) b on a.id=b.managerId;\\n\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/e4efe56b-33fc-4175-af06-e49773d8c768_1691198201.7516055.jpeg)\\n",
                "solutionTags": [],
                "code": "select a.name from Employee a inner join\\n(select b.managerId from Employee b group by b.managerId \\nhaving count (b.managerId)>=5) b on a.id=b.managerId;\\n\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/e4efe56b-33fc-4175-af06-e49773d8c768_1691198201.7516055.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3827504,
                "title": "simple-solution-with-in-keyword",
                "content": "select name from employee where id in(select managerId from employee  group by managerId \\nhaving(count(managerId)>=5))",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select name from employee where id in(select managerId from employee  group by managerId \\nhaving(count(managerId)>=5))",
                "codeTag": "Unknown"
            },
            {
                "id": 2334361,
                "title": "my-sql-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect E.name\\nfrom Employee E \\nleft join Employee E2 on E.id = E2.managerId \\ngroup by E.id \\nhaving count(E.id) >= 5\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect E.name\\nfrom Employee E \\nleft join Employee E2 on E.id = E2.managerId \\ngroup by E.id \\nhaving count(E.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2272182,
                "title": "2-mysql-solutions-with-a-cte-and-a-subquery-respectively",
                "content": "Subquery Solution:\\n```\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(1) >= 5)\\n```\\n\\nCTE Solution:\\n```\\nWITH managers AS (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(1) >= 5)\\nSELECT e.name\\nFROM Employee AS e\\nINNER JOIN managers AS m\\n    ON m.managerId = e.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(1) >= 5)\\n```\n```\\nWITH managers AS (\\n    SELECT managerId\\n    FROM Employee\\n    GROUP BY managerId\\n    HAVING COUNT(1) >= 5)\\nSELECT e.name\\nFROM Employee AS e\\nINNER JOIN managers AS m\\n    ON m.managerId = e.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124418,
                "title": "mysql-faster-than-99-73",
                "content": "```\\nselect name from Employee\\n\\twhere id in (select managerid from Employee\\n\\tgroup by managerid\\n\\thaving count(id)>=5)\\n```",
                "solutionTags": [],
                "code": "```\\nselect name from Employee\\n\\twhere id in (select managerid from Employee\\n\\tgroup by managerid\\n\\thaving count(id)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814060,
                "title": "simple-sql-with-group-by-having",
                "content": "SELECT e1.name\\nFROM Employee e1\\nLEFT JOIN Employee e2\\n   ON e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING COUNT(e2.managerId) >= 5",
                "solutionTags": [],
                "code": "SELECT e1.name\\nFROM Employee e1\\nLEFT JOIN Employee e2\\n   ON e1.id = e2.managerId\\nGROUP BY e2.managerId\\nHAVING COUNT(e2.managerId) >= 5",
                "codeTag": "Unknown"
            },
            {
                "id": 112327,
                "title": "my-solution-91-62-fast",
                "content": "SELECT Name\\nFROM EMPLOYEE \\nWHERE Id in (\\n             SELECT ManagerID\\n             FROM EMPLOYEE\\n             WHERE ManagerID IS NOT NULL\\n             GROUP BY ManagerId\\n             HAVING COUNT(ManagerID) >= 5\\n            );",
                "solutionTags": [],
                "code": "SELECT Name\\nFROM EMPLOYEE \\nWHERE Id in (\\n             SELECT ManagerID\\n             FROM EMPLOYEE\\n             WHERE ManagerID IS NOT NULL\\n             GROUP BY ManagerId\\n             HAVING COUNT(ManagerID) >= 5\\n            );",
                "codeTag": "Unknown"
            },
            {
                "id": 102696,
                "title": "ac-solution-without-sub-query-self-join",
                "content": "```\\nselect p2.name from employee p1 join employee p2 on p1.managerid = p2.id group by p1.managerid having count(*) >= 5\\n```",
                "solutionTags": [],
                "code": "```\\nselect p2.name from employee p1 join employee p2 on p1.managerid = p2.id group by p1.managerid having count(*) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067423,
                "title": "mssql-simple-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJoin the table itself with other select to filter count values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT  name FROM Employee e \\nJOIN (SELECT managerId, COUNT(managerId) AS mcount FROM Employee\\nGROUP BY managerId HAVING COUNT(managerId)>4 ) d ON e.id = d.managerID\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT  name FROM Employee e \\nJOIN (SELECT managerId, COUNT(managerId) AS mcount FROM Employee\\nGROUP BY managerId HAVING COUNT(managerId)>4 ) d ON e.id = d.managerID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971012,
                "title": "begginer-friendly-simplest-no-complication",
                "content": "\\n\\n# Code\\n```\\n# SELECT name FROM Emplyoe\\nSELECT name FROM Employee where\\nid in\\n(\\n  SELECT managerId\\n  FROM Employee \\n  GROUP BY managerId \\n  having count(id)>=5\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# SELECT name FROM Emplyoe\\nSELECT name FROM Employee where\\nid in\\n(\\n  SELECT managerId\\n  FROM Employee \\n  GROUP BY managerId \\n  having count(id)>=5\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853227,
                "title": "pandas-simple-pandas-solution-96-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 240 ms, faster than 96.43% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n# Memory Usage: 61.6 MB, less than 92.86% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n\\n![image](https://assets.leetcode.com/users/images/1d63ef2c-64b9-47db-bc1c-8d1ba2465214_1690982374.3431852.png)\\n\\n\\timport pandas as pd\\n\\n\\tdef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\tmanagers = employee.groupby([\\'managerId\\'])[\\'id\\'].agg([\\'count\\']).reset_index()\\n\\n\\t\\tmanagers = managers[managers[\\'count\\'] >= 5]\\n\\n\\t\\tresult = employee[(employee[\\'id\\'].isin(managers[\\'managerId\\']))][[\\'name\\']]\\n\\n\\t\\treturn result\\n# Runtime: 548 ms, faster than 7.14% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n# Memory Usage: 58.9 MB, less than 100.00% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n\\n\\timport pandas as pd\\n\\n\\tdef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\tmanager_id = list(employee[\\'managerId\\'].dropna())\\n\\n\\t\\tdata = []\\n\\n\\t\\tfor index in employee.index:\\n\\n\\t\\t\\temployee_data = employee.iloc[index]\\n\\n\\t\\t\\tif manager_id.count(int(employee_data[\\'id\\'])) >= 5 :\\n\\n\\t\\t\\t\\tdata.append(employee_data[\\'name\\'])\\n\\n\\t\\tresult = pd.DataFrame(data , columns = [\\'name\\'])\\n\\n\\t\\treturn result\\n\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 240 ms, faster than 96.43% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n# Memory Usage: 61.6 MB, less than 92.86% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n\\n![image](https://assets.leetcode.com/users/images/1d63ef2c-64b9-47db-bc1c-8d1ba2465214_1690982374.3431852.png)\\n\\n\\timport pandas as pd\\n\\n\\tdef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\tmanagers = employee.groupby([\\'managerId\\'])[\\'id\\'].agg([\\'count\\']).reset_index()\\n\\n\\t\\tmanagers = managers[managers[\\'count\\'] >= 5]\\n\\n\\t\\tresult = employee[(employee[\\'id\\'].isin(managers[\\'managerId\\']))][[\\'name\\']]\\n\\n\\t\\treturn result\\n# Runtime: 548 ms, faster than 7.14% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n# Memory Usage: 58.9 MB, less than 100.00% of Pandas online submissions for Managers with at Least 5 Direct Reports.\\n\\n\\timport pandas as pd\\n\\n\\tdef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\tmanager_id = list(employee[\\'managerId\\'].dropna())\\n\\n\\t\\tdata = []\\n\\n\\t\\tfor index in employee.index:\\n\\n\\t\\t\\temployee_data = employee.iloc[index]\\n\\n\\t\\t\\tif manager_id.count(int(employee_data[\\'id\\'])) >= 5 :\\n\\n\\t\\t\\t\\tdata.append(employee_data[\\'name\\'])\\n\\n\\t\\tresult = pd.DataFrame(data , columns = [\\'name\\'])\\n\\n\\t\\treturn result\\n\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3802346,
                "title": "esay-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580994,
                "title": "same-query-for-all-3-db-inner-join",
                "content": "\\n\\n```\\nselect e1.name from Employee e1 inner join (select managerId from employee group by managerId having count(managerId)>=5) e2 on e1.id=e2.managerId;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect e1.name from Employee e1 inner join (select managerId from employee group by managerId having count(managerId)>=5) e2 on e1.id=e2.managerId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430525,
                "title": "mysql-solution-using-cte-join",
                "content": "WITH managerid_cte(managerId) AS \\n(SELECT managerId FROM Employee GROUP BY managerId  HAVING COUNT(managerId)>=5)\\nSELECT name from Employee e JOIN\\nmanagerid_cte m ON e.id=m.managerId;",
                "solutionTags": [],
                "code": "WITH managerid_cte(managerId) AS \\n(SELECT managerId FROM Employee GROUP BY managerId  HAVING COUNT(managerId)>=5)\\nSELECT name from Employee e JOIN\\nmanagerid_cte m ON e.id=m.managerId;",
                "codeTag": "Unknown"
            },
            {
                "id": 2318615,
                "title": "subquery-having-count-easy-solution",
                "content": "\\nselect name\\nfrom Employee \\nwhere id in (\\nselect managerId\\nfrom Employee\\ngroup by managerId\\nhaving count(managerId) >=5);",
                "solutionTags": [],
                "code": "\\nselect name\\nfrom Employee \\nwhere id in (\\nselect managerId\\nfrom Employee\\ngroup by managerId\\nhaving count(managerId) >=5);",
                "codeTag": "Unknown"
            },
            {
                "id": 2276275,
                "title": "mysql-using-subquery-sol-explained",
                "content": "* Find the manger id who is having >=5 Employee \\n* Use the previous query in subquery to find the name of manager where id=manager_id\\n```\\nSelect name from employee\\nwhere id in (Select managerId from employee  group by 1 having count(*)>=5 )\\n```",
                "solutionTags": [],
                "code": "```\\nSelect name from employee\\nwhere id in (Select managerId from employee  group by 1 having count(*)>=5 )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2132817,
                "title": "mysql-solution-with-explanation",
                "content": "```\\n# Write your MySQL query statement below\\n# objective : report manager with at least five direct reports\\n# approach :\\n# 1. find manager ids with group by managerId having count(distict name)>=5\\n# 2. select name where manager id in #1 list\\n\\nSELECT name\\nFROM Employee\\nWHERE 1=1\\nAND id in (\\nSELECT managerID\\nFROM Employee\\nGROUP BY managerID\\nHAVING count(distinct name)>=5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# objective : report manager with at least five direct reports\\n# approach :\\n# 1. find manager ids with group by managerId having count(distict name)>=5\\n# 2. select name where manager id in #1 list\\n\\nSELECT name\\nFROM Employee\\nWHERE 1=1\\nAND id in (\\nSELECT managerID\\nFROM Employee\\nGROUP BY managerID\\nHAVING count(distinct name)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948499,
                "title": "mysql-easy-having-clause",
                "content": "```\\nselect t2.name\\nfrom employee t1 \\nJOIN employee t2\\non t1.managerid = t2.id\\ngroup by t2.id\\nhaving count(t2.id) >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t2.name\\nfrom employee t1 \\nJOIN employee t2\\non t1.managerid = t2.id\\ngroup by t2.id\\nhaving count(t2.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829351,
                "title": "mysql-solution-without-join",
                "content": "```\\nselect name\\nfrom Employee\\nWhere id in (\\n    select distinct managerId\\n    from Employee\\n    Group By managerId\\n    Having (count(distinct id) >=5)\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name\\nfrom Employee\\nWhere id in (\\n    select distinct managerId\\n    from Employee\\n    Group By managerId\\n    Having (count(distinct id) >=5)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647349,
                "title": "self-join-group-by-beats-98-of-the-solution",
                "content": "```\\nSELECT\\n    E2.name\\nFROM\\n    Employee E1\\nJOIN\\n    Employee E2\\nON\\n    E1.managerId = E2.id\\nGROUP BY\\n    E1.managerId\\nHAVING\\n    COUNT(E1.id) >= 5\\n;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    E2.name\\nFROM\\n    Employee E1\\nJOIN\\n    Employee E2\\nON\\n    E1.managerId = E2.id\\nGROUP BY\\n    E1.managerId\\nHAVING\\n    COUNT(E1.id) >= 5\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1630764,
                "title": "mysql-solution-using-self-join",
                "content": "```\\nSELECT mng.NAME\\nFROM   employee mng\\n       LEFT JOIN employee emp\\n              ON( mng.id = emp.managerid )\\nGROUP  BY mng.NAME\\nHAVING Count(DISTINCT emp.id) >= 5 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT mng.NAME\\nFROM   employee mng\\n       LEFT JOIN employee emp\\n              ON( mng.id = emp.managerid )\\nGROUP  BY mng.NAME\\nHAVING Count(DISTINCT emp.id) >= 5 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466894,
                "title": "neat-solution-without-joining",
                "content": "SELECT Name\\nFROM Employee\\nWHERE Id IN (SELECT ManagerId\\n            FROM Employee\\n            GROUP BY ManagerID\\n            HAVING COUNT(Name) >= 5)",
                "solutionTags": [],
                "code": "SELECT Name\\nFROM Employee\\nWHERE Id IN (SELECT ManagerId\\n            FROM Employee\\n            GROUP BY ManagerID\\n            HAVING COUNT(Name) >= 5)",
                "codeTag": "Unknown"
            },
            {
                "id": 1360662,
                "title": "simple-and-straight-forward-mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect e2.name from employee e1 \\njoin employee e2 on e1.managerID = e2.ID\\ngroup by e2.ID\\nhaving count(e2.ID)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e2.name from employee e1 \\njoin employee e2 on e1.managerID = e2.ID\\ngroup by e2.ID\\nhaving count(e2.ID)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286597,
                "title": "mysql-faster-than-94-64",
                "content": "```\\nSELECT Name\\nFROM Employee\\nWHERE Id IN (SELECT ManagerId FROM Employee GROUP BY 1 HAVING COUNT(*)>=5)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Name\\nFROM Employee\\nWHERE Id IN (SELECT ManagerId FROM Employee GROUP BY 1 HAVING COUNT(*)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234179,
                "title": "mysql-solution",
                "content": "```\\nwith x as #delete \\'null\\' value in ManagerId\\n    (select  ManagerId from Employee \\n     where  ManagerId  != \\'null\\'),\\n     x1 as #get manager name\\n     (select distinct Id, Name\\n     from Employee \\n     where Id in (select ManagerId from x) )\\n     \\n\\nselect x1.Name\\nfrom x1 \\nleft join x \\non x1.Id = x.ManagerId\\ngroup by x.ManagerId \\nhaving count(x.ManagerId) >=5\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith x as #delete \\'null\\' value in ManagerId\\n    (select  ManagerId from Employee \\n     where  ManagerId  != \\'null\\'),\\n     x1 as #get manager name\\n     (select distinct Id, Name\\n     from Employee \\n     where Id in (select ManagerId from x) )\\n     \\n\\nselect x1.Name\\nfrom x1 \\nleft join x \\non x1.Id = x.ManagerId\\ngroup by x.ManagerId \\nhaving count(x.ManagerId) >=5\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083896,
                "title": "mysql-94-37-groupby-having-cte",
                "content": "```\\nwith\\nManangerList \\nas\\n(\\n    select \\n        ManagerId\\n    from Employee \\n    group by ManagerId  \\n    having count(Id) >= 5\\n)\\nselect \\nName \\t  \\nfrom Employee emp\\njoin ManangerList mlst\\non emp.id = mlst.ManagerId\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith\\nManangerList \\nas\\n(\\n    select \\n        ManagerId\\n    from Employee \\n    group by ManagerId  \\n    having count(Id) >= 5\\n)\\nselect \\nName \\t  \\nfrom Employee emp\\njoin ManangerList mlst\\non emp.id = mlst.ManagerId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033417,
                "title": "simple-query-using-having-and-group-by",
                "content": "select name from employee where id in (select managerid from Employee group by Managerid having count(id) >= 5);",
                "solutionTags": [],
                "code": "select name from employee where id in (select managerid from Employee group by Managerid having count(id) >= 5);",
                "codeTag": "Unknown"
            },
            {
                "id": 923788,
                "title": "95-72-fastersolution-using-left-join",
                "content": "```\\nselect \\n\\te.name \\nfrom employee e \\n\\tleft join employee a on \\n\\te.id = a.managerid \\n\\tgroup by a.managerid\\n\\thaving count(a.managerid) >=5",
                "solutionTags": [],
                "code": "```\\nselect \\n\\te.name \\nfrom employee e \\n\\tleft join employee a on \\n\\te.id = a.managerid \\n\\tgroup by a.managerid\\n\\thaving count(a.managerid) >=5",
                "codeTag": "Unknown"
            },
            {
                "id": 833888,
                "title": "mysql-4-lines-solution-beat-98-61",
                "content": "```\\nselect b.name from\\nemployee a join employee b on a.managerid=b.id\\ngroup by 1\\nhaving count(*)>=5\\n```",
                "solutionTags": [],
                "code": "```\\nselect b.name from\\nemployee a join employee b on a.managerid=b.id\\ngroup by 1\\nhaving count(*)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102700,
                "title": "simplest-solution-without-unnecessary-nesting",
                "content": "```\\nSELECT e1.Name \\nFROM Employee AS e1 INNER JOIN Employee AS e2 \\nON e1.Id = e2.ManagerId \\nGROUP BY e1.Name \\nHAVING Count(e1.Name) >= 5\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT e1.Name \\nFROM Employee AS e1 INNER JOIN Employee AS e2 \\nON e1.Id = e2.ManagerId \\nGROUP BY e1.Name \\nHAVING Count(e1.Name) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106093,
                "title": "solve-without-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHad to solve this without joins\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused basic cte\\n\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nwith t1 as (SELECT managerId\\nFROM Employee\\nWHERE managerId IS NOT NULL\\nGROUP BY managerId\\nHAVING COUNT(managerId) >= 5)\\n\\nselect e.name\\nfrom Employee e\\nwhere e.id in (select * from t1)\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith t1 as (SELECT managerId\\nFROM Employee\\nWHERE managerId IS NOT NULL\\nGROUP BY managerId\\nHAVING COUNT(managerId) >= 5)\\n\\nselect e.name\\nfrom Employee e\\nwhere e.id in (select * from t1)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4105362,
                "title": "join-agg-using-count-having-by",
                "content": "# Approach\\njoin + agg using count & having by\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect b.name as name from employee a join employee b on a.managerid = b.id group by b.id having count(*) >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect b.name as name from employee a join employee b on a.managerid = b.id group by b.id having count(*) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104652,
                "title": "570-managers-with-at-least-5-direct-reports-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Inner join \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect    e1.name from \\nEmployee e1 \\nInner join Employee e2 on e2.managerId = e1.id\\ngroup by e2.managerId\\n having count(e2.id) >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect    e1.name from \\nEmployee e1 \\nInner join Employee e2 on e2.managerId = e1.id\\ngroup by e2.managerId\\n having count(e2.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102865,
                "title": "very-simple-mysql-solution",
                "content": "# Code\\n```\\nSELECT name \\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY 1 HAVING COUNT(managerId)>4)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name \\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY 1 HAVING COUNT(managerId)>4)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102677,
                "title": "mysql-solution-with-explanation-of-each-line",
                "content": "# Solution\\n```\\n# Write your MySQL query statement below\\nSELECT e2.name                  # only the manager\\'s name\\nFROM Employee e1                # Outer iteration of Employee\\nINNER JOIN Employee e2          # Inner iteration of employee\\nON e1.managerId = e2.id         # Joining to find the manager name of each employee\\nGROUP BY e1.managerId           # Grouping to count the number of employees under a single manager\\nHAVING COUNT(e1.managerId) >= 5 # Number of employees under a manager must be >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e2.name                  # only the manager\\'s name\\nFROM Employee e1                # Outer iteration of Employee\\nINNER JOIN Employee e2          # Inner iteration of employee\\nON e1.managerId = e2.id         # Joining to find the manager name of each employee\\nGROUP BY e1.managerId           # Grouping to count the number of employees under a single manager\\nHAVING COUNT(e1.managerId) >= 5 # Number of employees under a manager must be >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102066,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  E.name\\nFROM Employee E INNER JOIN Employee Em ON E.id=Em.managerId\\nGROUP BY E.id,E.name\\nHAVING COUNT(Em.managerId)>=5;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  E.name\\nFROM Employee E INNER JOIN Employee Em ON E.id=Em.managerId\\nGROUP BY E.id,E.name\\nHAVING COUNT(Em.managerId)>=5;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101492,
                "title": "group-by-having-in",
                "content": "# Code\\n```\\nSELECT name\\nFROM Employee e\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee e \\n    GROUP BY managerId \\n    HAVING COUNT(*) >=5\\n) \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name\\nFROM Employee e\\nWHERE id IN (\\n    SELECT managerId\\n    FROM Employee e \\n    GROUP BY managerId \\n    HAVING COUNT(*) >=5\\n) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099364,
                "title": "570-managers-with-at-least-5-direct-reports-by-innerjoin-and-groupby",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n    e2.name\\nfrom \\n    Employee e1\\ninner join\\n    Employee e2\\non\\n    e1.managerId=e2.id\\ngroup by \\n    e1.managerId\\nhaving \\n    count(*)>=5;\\n    \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n    e2.name\\nfrom \\n    Employee e1\\ninner join\\n    Employee e2\\non\\n    e1.managerId=e2.id\\ngroup by \\n    e1.managerId\\nhaving \\n    count(*)>=5;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098407,
                "title": "from-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name \\nfrom (select \\n    managerId,\\n    count(*) as subordinates\\nfrom employee\\ngroup by managerId  \\nhaving subordinates>= 5) as m \\ninner join employee e\\non e.id=m.managerId\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name \\nfrom (select \\n    managerId,\\n    count(*) as subordinates\\nfrom employee\\ngroup by managerId  \\nhaving subordinates>= 5) as m \\ninner join employee e\\non e.id=m.managerId\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097774,
                "title": "very-easy-solution-using-cross-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->very simple approach cross join the table on id and manager id to get the cartesian product and then filter by using count \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.name from employee a\\ncross join employee b\\non a.id=b.managerId\\ngroup by b.managerId\\nhaving count(*)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.name from employee a\\ncross join employee b\\non a.id=b.managerId\\ngroup by b.managerId\\nhaving count(*)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097413,
                "title": "super-easy-mysql-solution",
                "content": "\\nselect name from Employee e join (select managerId, count(managerId) \\'cntmgr\\' from Employee group by managerId) c on e.id = c.managerId and c.cntmgr >=5\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\nselect name from Employee e join (select managerId, count(managerId) \\'cntmgr\\' from Employee group by managerId) c on e.id = c.managerId and c.cntmgr >=5\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4096779,
                "title": "effecient-solution",
                "content": "\\n\\n# Code\\n```\\n\\nselect o.name from employee o inner join employee s on o.id=s.managerid group by o.name, s.managerid having count(*)>=5 \\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\nselect o.name from employee o inner join employee s on o.id=s.managerid group by o.name, s.managerid having count(*)>=5 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095848,
                "title": "managers-with-at-least-5-direct-reports-mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e1.name From Employee e1 inner join Employee e2 on e1.id = e2.managerId group by e1.id having count(e2.managerId) >= 5;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e1.name From Employee e1 inner join Employee e2 on e1.id = e2.managerId group by e1.id having count(e2.managerId) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095352,
                "title": "using-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from employee\\nwhere id in ( select managerId from employee group by managerId having count(managerId)>=5);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from employee\\nwhere id in ( select managerId from employee group by managerId having count(managerId)>=5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094541,
                "title": "simple-mysql-solution",
                "content": "\\n```\\n# Write your MySQL query statement below\\nSELECT a.name\\nFROM Employee a\\nWHERE (SELECT COUNT(managerId) FROM Employee WHERE managerId=a.id) > 4\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.name\\nFROM Employee a\\nWHERE (SELECT COUNT(managerId) FROM Employee WHERE managerId=a.id) > 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093076,
                "title": "beats-95-runtime-simple-solution",
                "content": "# Main idea: we count the number of rows grouping by managersId, then join the resulting table on the original Employee table on the condition Employee.id = q.managerId\\n\\n# Code\\n```\\nselect\\nname \\nfrom \\n(select \\nmanagerId\\nfrom \\n(select \\nmanagerId, \\ncount(managerId) as reports\\nfrom \\nEmployee\\ngroup by managerId) as w\\nwhere reports > 4) as q\\njoin \\nEmployee \\non Employee.id = q.managerId\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\nname \\nfrom \\n(select \\nmanagerId\\nfrom \\n(select \\nmanagerId, \\ncount(managerId) as reports\\nfrom \\nEmployee\\ngroup by managerId) as w\\nwhere reports > 4) as q\\njoin \\nEmployee \\non Employee.id = q.managerId\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092531,
                "title": "two-simple-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n# select name from Employee\\n# where id in (select managerId from Employee\\n# group by managerId\\n# having count(id) >= 5)\\n\\nwith cte As\\n(\\nselect managerId from Employee\\ngroup by managerId\\nhaving count(id) >= 5\\n\\n)\\n\\nselect e.name from Employee e\\njoin cte on cte.managerId = e.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# select name from Employee\\n# where id in (select managerId from Employee\\n# group by managerId\\n# having count(id) >= 5)\\n\\nwith cte As\\n(\\nselect managerId from Employee\\ngroup by managerId\\nhaving count(id) >= 5\\n\\n)\\n\\nselect e.name from Employee e\\njoin cte on cte.managerId = e.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092124,
                "title": "using-joins-and-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith subquery\\n\\nSELECT name \\nFROM Employee \\nWHERE id IN (\\n    SELECT managerId \\n    FROM Employee \\n    GROUP BY managerId \\n    HAVING COUNT(managerId) >= 5\\n)\\n\\n\\nwith joins\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith subquery\\n\\nSELECT name \\nFROM Employee \\nWHERE id IN (\\n    SELECT managerId \\n    FROM Employee \\n    GROUP BY managerId \\n    HAVING COUNT(managerId) >= 5\\n)\\n\\n\\nwith joins\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089628,
                "title": "pandas-solution-in-3-steps",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n    # Group employees by manager and count the number of records in each group\\n    grouped = employee.groupby(\\'managerId\\').count().reset_index()\\n    \\n    # Filter for manager IDs where the count of employees is greater than or equal to 5\\n    grouped = grouped.loc[grouped[\\'id\\'] >= 5, \\'managerId\\']\\n    p\\n    # Select the names of employees whose manager IDs match the filtered manager IDs\\n    df = employee.loc[employee[\\'id\\'].isin(grouped), [\\'name\\']]\\n    \\n    return df\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n    grouped = employee.groupby(\\'managerId\\').count().reset_index()    \\n    grouped = grouped.loc[grouped[\\'id\\'] >= 5, \\'managerId\\']    \\n    df = employee.loc[employee[\\'id\\'].isin(grouped), [\\'name\\']]\\n    return df\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n\\n    grouped = employee.groupby(\\'managerId\\').count().reset_index()    \\n    grouped = grouped.loc[grouped[\\'id\\'] >= 5, \\'managerId\\']    \\n    df = employee.loc[employee[\\'id\\'].isin(grouped), [\\'name\\']]\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4086132,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.name from Employee a inner join\\n(select b.managerId from Employee b group by b.managerId\\nhaving count(b.managerId)>=5) b on a.id=b.managerId;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.name from Employee a inner join\\n(select b.managerId from Employee b group by b.managerId\\nhaving count(b.managerId)>=5) b on a.id=b.managerId;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083214,
                "title": "simple-solution-beats-98-95-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n select name from employee\\n where id in (select managerId from employee\\n             group by managerId\\n             having count(managerId)>=5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n select name from employee\\n where id in (select managerId from employee\\n             group by managerId\\n             having count(managerId)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082995,
                "title": "east-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e1.name\\nFROM Employee e1 \\nJOIN Employee e2\\nON e1.id=e2.managerId\\nGROUP BY e2.managerId\\nHAVING COUNT(e1.id)>=5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e1.name\\nFROM Employee e1 \\nJOIN Employee e2\\nON e1.id=e2.managerId\\nGROUP BY e2.managerId\\nHAVING COUNT(e1.id)>=5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081845,
                "title": "easy-approach",
                "content": "# SQL\\n\\nwith table1 as(\\nselect name , managerid,count(managerid) over(partition by managerid) as cnt\\nfrom employee)\\nselect name from employee where id in (select distinct managerid from table1 where cnt >= 5 )\\n\\n# Pandas\\n\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    ans = employee.groupby(\\'managerId\\').agg({\\'managerId\\':lambda x : len(x)})\\n\\n    ans.columns = [\\'cnt\\']\\n\\n    ans.reset_index(inplace = True)\\n\\n    out = pd.DataFrame(columns = [\\'name\\'])\\n\\n    idi = ans[\\'managerId\\'].unique()\\n    w = 0\\n\\n    for i in idi :\\n        if len(employee[employee[\\'id\\'] == i]) > 0 and len(employee[employee[\\'managerId\\'] == i]) >= 5:\\n            out.loc[w,\\'name\\'] = employee[employee[\\'id\\'] == i][\\'name\\'].values[0]\\n\\n        else:\\n            pass\\n\\n        w += 1\\n\\n    return out",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "# SQL\\n\\nwith table1 as(\\nselect name , managerid,count(managerid) over(partition by managerid) as cnt\\nfrom employee)\\nselect name from employee where id in (select distinct managerid from table1 where cnt >= 5 )\\n\\n# Pandas\\n\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    ans = employee.groupby(\\'managerId\\').agg({\\'managerId\\':lambda x : len(x)})\\n\\n    ans.columns = [\\'cnt\\']\\n\\n    ans.reset_index(inplace = True)\\n\\n    out = pd.DataFrame(columns = [\\'name\\'])\\n\\n    idi = ans[\\'managerId\\'].unique()\\n    w = 0\\n\\n    for i in idi :\\n        if len(employee[employee[\\'id\\'] == i]) > 0 and len(employee[employee[\\'managerId\\'] == i]) >= 5:\\n            out.loc[w,\\'name\\'] = employee[employee[\\'id\\'] == i][\\'name\\'].values[0]\\n\\n        else:\\n            pass\\n\\n        w += 1\\n\\n    return out",
                "codeTag": "Python3"
            },
            {
                "id": 4081688,
                "title": "simple-self-join-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e1.name FROM Employee e1, Employee e2 WHERE e1.id = e2.managerId GROUP BY e2.managerId HAVING COUNT(e2.managerId)>4;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e1.name FROM Employee e1, Employee e2 WHERE e1.id = e2.managerId GROUP BY e2.managerId HAVING COUNT(e2.managerId)>4;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081134,
                "title": "solved-with-subquery-with-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT e.name\\nFROM Employee e\\nJOIN (\\n  SELECT managerid, COUNT(*)\\n  FROM Employee\\n  WHERE managerid is not null\\n  GROUP BY managerid\\n  HAVING COUNT(*) > 4\\n) sub ON e.id = sub.managerid;\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT e.name\\nFROM Employee e\\nJOIN (\\n  SELECT managerid, COUNT(*)\\n  FROM Employee\\n  WHERE managerid is not null\\n  GROUP BY managerid\\n  HAVING COUNT(*) > 4\\n) sub ON e.id = sub.managerid;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079603,
                "title": "cheesiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect a.name from employee a, employee b where a.id = b.managerid group by b.managerid having count(b.id)>=5\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database",
                    "Quickselect"
                ],
                "code": "```\\nselect a.name from employee a, employee b where a.id = b.managerid group by b.managerid having count(b.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079490,
                "title": "simple-code",
                "content": "\\n\\n# Approach\\nFirst we have to join both the tables then group by managerid and then having clause\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e2.name \\nfrom Employee as e1\\nJoin Employee as e2 on e1.managerId= e2.id\\ngroup by e1.managerId\\nhaving Count(e1.managerId)>=5\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e2.name \\nfrom Employee as e1\\nJoin Employee as e2 on e1.managerId= e2.id\\ngroup by e1.managerId\\nhaving Count(e1.managerId)>=5\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078867,
                "title": "sql-subquery",
                "content": "```\\nSELECT name\\nFROM Employee\\nWHERE id IN (\\n        SELECT managerId\\n        FROM Employee\\n        GROUP BY managerId\\n        HAVING count(managerId) >= 5\\n    )\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT name\\nFROM Employee\\nWHERE id IN (\\n        SELECT managerId\\n        FROM Employee\\n        GROUP BY managerId\\n        HAVING count(managerId) >= 5\\n    )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078332,
                "title": "simple-solution-having-99-96",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect e.name\\nfrom employee as e\\nwhere e.id in (select eManager.managerId\\n               from Employee as eManager\\n               where eManager.managerId is not null\\n               group by eManager.managerId\\n               having count(*) >= 5)\\n```\\n**Please Upvote**\\uD83D\\uDD25\\uD83D\\uDE09\\n*Thanks for visiting my solution*.",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect e.name\\nfrom employee as e\\nwhere e.id in (select eManager.managerId\\n               from Employee as eManager\\n               where eManager.managerId is not null\\n               group by eManager.managerId\\n               having count(*) >= 5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078169,
                "title": "the-same-column-managerid-id",
                "content": "\\n```\\n\\nselect e1.name from Employee e1 inner join Employee e2 on e1.id=e2.managerId where e1.id=e2.managerId group by e1.id having(count(e2.managerId))>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect e1.name from Employee e1 inner join Employee e2 on e1.id=e2.managerId where e1.id=e2.managerId group by e1.id having(count(e2.managerId))>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077055,
                "title": "easy-to-understand-solution",
                "content": "We start by joining the table with self so that we have a table which will contain the id\\'s mapped with the manager id\\'s. This will repeat the id\\'s the number of times same manager id apprears on the \\'managerId\\' column.\\nThen the rest is simple, we just group the results based on the id..\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e1.name\\nfrom employee e1 join employee e2\\non e1.id = e2.managerId\\ngroup by e1.id\\nhaving count(e1.id) >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e1.name\\nfrom employee e1 join employee e2\\non e1.id = e2.managerId\\ngroup by e1.id\\nhaving count(e1.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076525,
                "title": "simple-self-join-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT m.name as \\'name\\'\\nFROM Employee e JOIN Employee m\\nON e.managerId = m.id\\nGROUP BY m.id\\nHAVING COUNT(distinct e.id) >=5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT m.name as \\'name\\'\\nFROM Employee e JOIN Employee m\\nON e.managerId = m.id\\nGROUP BY m.id\\nHAVING COUNT(distinct e.id) >=5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074394,
                "title": "pandas-groupby-size-merge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    count_report = employee.groupby(\\'managerId\\').size().reset_index(name =\\'report\\')\\n\\n    result = employee.merge(count_report[count_report[\\'report\\']>=5], left_on = \\'id\\', right_on = \\'managerId\\')\\n\\n    return result[[\\'name\\']]    \\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    count_report = employee.groupby(\\'managerId\\').size().reset_index(name =\\'report\\')\\n\\n    result = employee.merge(count_report[count_report[\\'report\\']>=5], left_on = \\'id\\', right_on = \\'managerId\\')\\n\\n    return result[[\\'name\\']]    \\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4072189,
                "title": "mssql-two-solutions",
                "content": "With subquery:\\n```\\nSELECT\\nname\\nFROM Employee e\\nWHERE\\n(\\n    SELECT \\n    COUNT(*) \\n    FROM Employee \\n    WHERE managerId = e.id\\n) >= 5\\n```\\n\\n\\nWithout subquery:\\n```\\nSELECT m.name\\nFROM Employee e\\nJOIN Employee m ON e.managerId = m.id\\ngroup by e.managerId, m.name\\nHAVING COUNT(e.id) >= 5\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\nname\\nFROM Employee e\\nWHERE\\n(\\n    SELECT \\n    COUNT(*) \\n    FROM Employee \\n    WHERE managerId = e.id\\n) >= 5\\n```\n```\\nSELECT m.name\\nFROM Employee e\\nJOIN Employee m ON e.managerId = m.id\\ngroup by e.managerId, m.name\\nHAVING COUNT(e.id) >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070014,
                "title": "simple-soln-using-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the Manager Id which is repeating more than or equal to 5 times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a query to get the manager id\\'s whcih are repeating according to the condition. use it as an input to the base query of getting the name.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from employee where id in (select managerId from employee group by managerId having count(managerId)>=5)  ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from employee where id in (select managerId from employee group by managerId having count(managerId)>=5)  ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069282,
                "title": "ms-sql-server-solution-subquery",
                "content": "SELECT [name] from Employee AS e3 join (SELECT e1.id FROM Employee e1\\nJOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.id \\nHAVING COUNT(e1.id) >= 5) as e4 on e3.id = e4.id\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "SELECT [name] from Employee AS e3 join (SELECT e1.id FROM Employee e1\\nJOIN Employee e2\\nON e1.id = e2.managerId\\nGROUP BY e1.id \\nHAVING COUNT(e1.id) >= 5) as e4 on e3.id = e4.id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4067858,
                "title": "simple-and-easy-solution",
                "content": "# Intuition\\n<!-- After seeing question i thought that first i will count total number of same id in managaer table and after this i will do inner join of count table with given table\\nand the solution which i have provided is very easy solution \\n# **please like it and upvote it -->**\\n\\n\\n\\n# Code\\n```\\nwith temp as(\\nselect  managerid as id,count(managerid) as counting from employee \\ngroup by managerid\\n)\\nselect e.name from employee e inner join temp t on e.id=t.id where t.counting>=5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith temp as(\\nselect  managerid as id,count(managerid) as counting from employee \\ngroup by managerid\\n)\\nselect e.name from employee e inner join temp t on e.id=t.id where t.counting>=5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066622,
                "title": "simple-sub-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name\\nfrom employee e\\nwhere id in (\\n    select managerId\\n    from employee\\n    group by managerId\\n    having count(managerId)>=5  \\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name\\nfrom employee e\\nwhere id in (\\n    select managerId\\n    from employee\\n    group by managerId\\n    having count(managerId)>=5  \\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065917,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e2.name from employee e1\\nJOIN  employee e2\\non e1.managerId=e2.id\\ngroup by e1.managerId\\nhaving COUNT(e1.id)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e2.name from employee e1\\nJOIN  employee e2\\non e1.managerId=e2.id\\ngroup by e1.managerId\\nhaving COUNT(e1.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065777,
                "title": "managers-with-at-least-5-direct-reports-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple flow\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT NAME\\nFROM EMPLOYEE\\nWHERE ID IN(\\n    SELECT MANAGERID\\n    FROM EMPLOYEE E\\n    GROUP BY MANAGERID\\n    HAVING COUNT(MANAGERID)>=5\\n)\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6d05754a-a811-4102-9c16-187399eb3674_1695148546.665277.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT NAME\\nFROM EMPLOYEE\\nWHERE ID IN(\\n    SELECT MANAGERID\\n    FROM EMPLOYEE E\\n    GROUP BY MANAGERID\\n    HAVING COUNT(MANAGERID)>=5\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064782,
                "title": "simple-solution-using-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(M + K), where M is the number of distinct manager IDs, and K is the number of rows in the result DataFrame.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    # deducting size of emplyees under manager.\\n    count_manager = employee.groupby(\\'managerId\\').size().reset_index(name = \\'employee_count\\')\\n    # Filtering manager by condition.\\n    count = count_manager[count_manager[\\'employee_count\\'] >= 5]\\n    # Getting name using the managerID.\\n    return employee[[\\'name\\']][employee[\\'id\\'].isin(count[\\'managerId\\'])]\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    # deducting size of emplyees under manager.\\n    count_manager = employee.groupby(\\'managerId\\').size().reset_index(name = \\'employee_count\\')\\n    # Filtering manager by condition.\\n    count = count_manager[count_manager[\\'employee_count\\'] >= 5]\\n    # Getting name using the managerID.\\n    return employee[[\\'name\\']][employee[\\'id\\'].isin(count[\\'managerId\\'])]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4062607,
                "title": "easy-uproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e1.name from employee e1 left join employee e2 on e1.id=e2.managerId  group by e2.managerId having count(e2.managerId)>4\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e1.name from employee e1 left join employee e2 on e1.id=e2.managerId  group by e2.managerId having count(e2.managerId)>4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062427,
                "title": "subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select manager_id from \\n(select count(managerId) as count, managerId as manager_id from Employee group by managerId ) as CountTable\\nwhere count>=5) ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select manager_id from \\n(select count(managerId) as count, managerId as manager_id from Employee group by managerId ) as CountTable\\nwhere count>=5) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062206,
                "title": "very-easy-solution-mysql",
                "content": "# Description\\nBasically, you have to make a subquery where it\\'s gonna return a single row with all the managerIds that have 5 or more occurances in the original table (using GROUP BY and COUNT(*)). Then you have to extract the name of the people that have the \\'id\\' in that row. Simple as that\\n\\n# Code\\n```\\nSELECT name FROM employee \\nWHERE id IN \\n(SELECT managerId FROM employee\\nGROUP BY managerId HAVING COUNT(*) >= 5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT name FROM employee \\nWHERE id IN \\n(SELECT managerId FROM employee\\nGROUP BY managerId HAVING COUNT(*) >= 5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061681,
                "title": "75-simple-solution-using-inner-join",
                "content": "# Explanation\\nThis code is very straightforward, it takes the name from the first manager table where the same table is joined twice using INNER JOIN, then we group by the manager id and only select those who have a number of id\\'s that\\'s greater than or equal to 5. **Make sure to like if you found this helpful**.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT m.name\\nFROM Employee AS e INNER JOIN Employee AS m ON e.managerId = m.id\\nGROUP BY e.managerId\\nHAVING COUNT(e.id) >= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT m.name\\nFROM Employee AS e INNER JOIN Employee AS m ON e.managerId = m.id\\nGROUP BY e.managerId\\nHAVING COUNT(e.id) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060202,
                "title": "solution-using-a-subquery",
                "content": "# Explanation\\nInstead of connecting the __Employee__ table to itself, you can create a nested query to get the __managerID__ according to the condition and compare the id with the result\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId\\n            FROM Employee\\n            GROUP BY managerId\\n            HAVING COUNT(managerId) > 4)\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId\\n            FROM Employee\\n            GROUP BY managerId\\n            HAVING COUNT(managerId) > 4)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059688,
                "title": "easy-solution-using-subquery",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee where id in (select managerId from Employee group by managerId having count(managerId)>=5);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee where id in (select managerId from Employee group by managerId having count(managerId)>=5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059424,
                "title": "simple-solution-by-pd",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(empl: pd.DataFrame) -> pd.DataFrame:\\n  df = empl.groupby(\\'managerId\\').size().reset_index(name=\\'dR\\')\\n  df = df[df[\\'dR\\'] >= 5]\\n  df = df.merge(empl[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n  return df[[\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(empl: pd.DataFrame) -> pd.DataFrame:\\n  df = empl.groupby(\\'managerId\\').size().reset_index(name=\\'dR\\')\\n  df = df[df[\\'dR\\'] >= 5]\\n  df = df.merge(empl[[\\'id\\', \\'name\\']], left_on=\\'managerId\\', right_on=\\'id\\', how=\\'inner\\')\\n  return df[[\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4058433,
                "title": "day-4-q2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e2.name\\nFROM Employee e1 JOIN Employee e2\\nON e1.managerId = e2.id\\nGROUP BY e1.managerId\\nHAVING COUNT(e2.id)>=5\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e2.name\\nFROM Employee e1 JOIN Employee e2\\nON e1.managerId = e2.id\\nGROUP BY e1.managerId\\nHAVING COUNT(e2.id)>=5\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058320,
                "title": "simple-approach-with-cte",
                "content": "\\n# Approach\\nSimply put, group manager ids and count them . Retrive them if they are more than 5.\\nthen retrive name for that manager id.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect managerId\\nfrom employee e\\ngroup by managerId\\nhaving count(id)>=5)\\n\\nselect name \\nfrom cte c join employee e\\nwhere e.id=c.managerId;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as(\\nselect managerId\\nfrom employee e\\ngroup by managerId\\nhaving count(id)>=5)\\n\\nselect name \\nfrom cte c join employee e\\nwhere e.id=c.managerId;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057633,
                "title": "a-really-simple-solution-not-even-sure-if-it-s-correct-even-tho-it-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to \"group by managerID\" so at least we can figure out the id that we need to get. And then I realized that I have to actually get the name of the manager that appeared at least 5 times in the managerID column. So I decided to use a subquery to figure out the id that is the managerID that meets the requirements. \\n\\nAnd then I just have to find the name whose id appeared in my subquery results. \\n\\nOne thing tho, I blindly assumed that there will only be 1 manager who has at least 5 direct reports. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM (SELECT managerID, COUNT(managerID) as counts\\n      FROM Employee e\\n      GROUP BY managerID\\n      HAVING counts >= 5) as A,\\n      Employee\\nWHERE Employee.id = A.managerID\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM (SELECT managerID, COUNT(managerID) as counts\\n      FROM Employee e\\n      GROUP BY managerID\\n      HAVING counts >= 5) as A,\\n      Employee\\nWHERE Employee.id = A.managerID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057630,
                "title": "a-easy-to-understand-solution-sql",
                "content": "# Approach\\n\\nNeed to find out which employee reports to which manager.\\n\\n1. Join the table with itself, to align the employee and their manager\\n2. After join, each row would be having id, representing the employee, and managerId (Here, this represents the number of employee that need to report to id)\\n3. Get the Count\\n4. Select with where condition\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT name\\nFROM\\n    (SELECT e1.id, e1.name, COUNT(e2.managerId) as directReports\\n    FROM Employee e1\\n    INNER JOIN Employee e2\\n    ON e1.id = e2.managerId\\n    GROUP BY e1.id) as r\\nWHERE r.directReports >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT name\\nFROM\\n    (SELECT e1.id, e1.name, COUNT(e2.managerId) as directReports\\n    FROM Employee e1\\n    INNER JOIN Employee e2\\n    ON e1.id = e2.managerId\\n    GROUP BY e1.id) as r\\nWHERE r.directReports >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056728,
                "title": "three-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# select name \\n# from employee\\n# where id IN \\n# (Select managerId\\n# from employee\\n# group by managerId\\n# having count(id)>=5)\\nselect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId\\nhaving count(e.id)>=5\\n\\n# Select m.name\\n# from employee as e\\n# inner join employee as m\\n# on e.managerId=m.id\\n# group by e.managerId \\n# having count(e.id)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# select name \\n# from employee\\n# where id IN \\n# (Select managerId\\n# from employee\\n# group by managerId\\n# having count(id)>=5)\\nselect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId\\nhaving count(e.id)>=5\\n\\n# Select m.name\\n# from employee as e\\n# inner join employee as m\\n# on e.managerId=m.id\\n# group by e.managerId \\n# having count(e.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055390,
                "title": "simple-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name\\nfrom Employee\\nwhere id in(select managerId\\nfrom Employee\\ngroup by managerId\\nhaving Count(id)>=5);\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name\\nfrom Employee\\nwhere id in(select managerId\\nfrom Employee\\ngroup by managerId\\nhaving Count(id)>=5);\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055155,
                "title": "using-subquery-and-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust need to count which employee id is at attributed to atleast 5 managerIds\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nthe best approach would be to first get a subquery of counting number of managed employees by managerId (SELECT managerId, count(managerId), group by managerId)\\n\\nthen joining it to the original table, and filtering by the condition (where number_of_reports >= 5\\n)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2 mins\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n4 lines\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nwith dr as (select e.managerId, count(e.managerId) as number_of_reports from Employee e group by e.managerId)\\n\\nselect e.name from Employee e\\nLEFT JOIN dr on e.id = dr.managerId\\nwhere dr.number_of_reports >= 5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nwith dr as (select e.managerId, count(e.managerId) as number_of_reports from Employee e group by e.managerId)\\n\\nselect e.name from Employee e\\nLEFT JOIN dr on e.id = dr.managerId\\nwhere dr.number_of_reports >= 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054802,
                "title": "sql-570-basic-using-groupby-having-ak",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name from Employee where id IN (\\nSELECT managerId FROM  Employee\\nGROUP BY managerId\\nHAVING COUNT(managerId)>=5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name from Employee where id IN (\\nSELECT managerId FROM  Employee\\nGROUP BY managerId\\nHAVING COUNT(managerId)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054499,
                "title": "3-approaches-to-solve-the-problem",
                "content": "A 3 way solution to the problem\\n\\n# Code\\n```\\n#cte:-\\nwith manager as (select e1.id as nid,count(*) as ncount from Employee e1 inner join Employee e2 where e2.managerId = e1.id group by e1.id) select name from Employee right join manager on id = nid where ncount>=5\\n\\n#self-join and then condition\\nselect e1.name as name from Employee e1 inner join Employee e2 where e2.managerId = e1.id group by e1.id having count(e1.id)>=5\\n\\n#condition while selecting from table and them self join\\nselect e1.name from Employee e1 inner join (select managerID from Employee group by managerID having count(*)>=5) e2 on e1.id = e2.managerID\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#cte:-\\nwith manager as (select e1.id as nid,count(*) as ncount from Employee e1 inner join Employee e2 where e2.managerId = e1.id group by e1.id) select name from Employee right join manager on id = nid where ncount>=5\\n\\n#self-join and then condition\\nselect e1.name as name from Employee e1 inner join Employee e2 where e2.managerId = e1.id group by e1.id having count(e1.id)>=5\\n\\n#condition while selecting from table and them self join\\nselect e1.name from Employee e1 inner join (select managerID from Employee group by managerID having count(*)>=5) e2 on e1.id = e2.managerID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054426,
                "title": "sql-with-approach-explained-well",
                "content": "\\n# Approach\\n**1. You have an Employee table with columns like id, name, and managerId.**\\n\\n**2. The query uses a self-join on the Employee table to create two aliases for the same table: \"e\" for employees and \"m\" for managers.**\\n\\n**3. The ON clause specifies that the join should be based on the managerId of employees matching the id of managers. This establishes a hierarchical relationship between employees and their managers.**\\n\\n**4. The GROUP BY clause groups the results by the managerId, effectively grouping employees under their respective managers.**\\n\\n**5. The HAVING clause filters the grouped results to only include those groups (managers) that have at least 5 employees (as determined by the COUNT(e.id)).**\\n\\n**5. Finally, the SELECT statement selects the names of managers (\"m.name\") who meet the criteria.**\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect m.name from Employee e\\ninner join Employee m\\non e.managerId=m.id\\ngroup by e.managerId\\nhaving count(e.id)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect m.name from Employee e\\ninner join Employee m\\non e.managerId=m.id\\ngroup by e.managerId\\nhaving count(e.id)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053374,
                "title": "subquery-solution-super-fast",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith M as\\n(select managerid\\nfrom employee\\ngroup by managerid\\nhaving count(id)>=5)\\nselect e.name from m\\ninner join employee e\\non e.id = m.managerid\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith M as\\n(select managerid\\nfrom employee\\ngroup by managerid\\nhaving count(id)>=5)\\nselect e.name from m\\ninner join employee e\\non e.id = m.managerid\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052224,
                "title": "beats-99-91-inner-join-group-by",
                "content": "\\n# Code\\n/* Write your PL/SQL query statement below */\\nselect e.name from\\n(\\nselect managerId , count(managerId)\\nfrom Employee\\ngroup by managerId\\nhaving count(managerId) >= 5\\n) x\\ninner join employee e\\non x.managerId = e.id\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\n# Code\\n/* Write your PL/SQL query statement below */\\nselect e.name from\\n(\\nselect managerId , count(managerId)\\nfrom Employee\\ngroup by managerId\\nhaving count(managerId) >= 5\\n) x\\ninner join employee e\\non x.managerId = e.id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4051875,
                "title": "sri-vinuta",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nSELECT e1.name\\nFROM Employee e1\\nJOIN Employee e2 ON e2.managerId = e1.id\\nGROUP BY e1.id\\nHAVING COUNT(e2.managerId = e1.id)>= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nSELECT e1.name\\nFROM Employee e1\\nJOIN Employee e2 ON e2.managerId = e1.id\\nGROUP BY e1.id\\nHAVING COUNT(e2.managerId = e1.id)>= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051706,
                "title": "mysql-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from employee as ep \\nwhere (select count(managerid) from employee where managerid = ep.id )>=5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from employee as ep \\nwhere (select count(managerid) from employee where managerid = ep.id )>=5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048855,
                "title": "super-easy-solution-using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e1.name \\nfrom employee e1\\njoin employee e2\\non e1.id=e2.managerId \\ngroup by e2.managerId\\nhaving count(e2.managerId)>=5\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e1.name \\nfrom employee e1\\njoin employee e2\\non e1.id=e2.managerId \\ngroup by e2.managerId\\nhaving count(e2.managerId)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048764,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nselect name from Employee where id in (select managerId from Employee group\\nby managerId having count(managerId)>=5);\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name from Employee where id in (select managerId from Employee group\\nby managerId having count(managerId)>=5);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048405,
                "title": "mysql-using-simple-subquery-beats-99",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee \\nWHERE id IN (\\n  SELECT managerId\\n  FROM Employee \\n  GROUP BY managerId\\n  HAVING COUNT(*) >= 5\\n)\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT name\\nFROM Employee \\nWHERE id IN (\\n  SELECT managerId\\n  FROM Employee \\n  GROUP BY managerId\\n  HAVING COUNT(*) >= 5\\n)\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045905,
                "title": "easy-solution-beats-89-46-of-users-with-oracle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nselect name from employee where id in\\n(\\nselect managerid from employee group by managerid having count(*) >=5\\n);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nselect name from employee where id in\\n(\\nselect managerid from employee group by managerid having count(*) >=5\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045834,
                "title": "sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect name from Employee where ID in(\\n  select managerId from employee group by managerId having count(managerId) >=5\\n);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name from Employee where ID in(\\n  select managerId from employee group by managerId having count(managerId) >=5\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045472,
                "title": "pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Find managers using groupby and aggregation\\n2) Filter managers with >= 5 reports\\n3) Find employees, whoes id is in the filteres managers table\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    managers = employee.groupby(\\'managerId\\'\\n        ).agg(\\n            reports = (\\'id\\', \\'count\\')\\n        ).reset_index()\\n    return employee[\\n            employee.id.isin(\\n                managers.managerId[managers.reports >= 5]\\n                )\\n            ][[\\'name\\']]\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    managers = employee.groupby(\\'managerId\\'\\n        ).agg(\\n            reports = (\\'id\\', \\'count\\')\\n        ).reset_index()\\n    return employee[\\n            employee.id.isin(\\n                managers.managerId[managers.reports >= 5]\\n                )\\n            ][[\\'name\\']]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4044823,
                "title": "easy-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044779,
                "title": "no-correlated-sub-query",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect a.name from Employee a cross join Employee b where a.id = b.managerId \\ngroup by a.id having count(a.id) >=5  \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.name from Employee a cross join Employee b where a.id = b.managerId \\ngroup by a.id having count(a.id) >=5  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044314,
                "title": "easy-to-understand-solution-525ms-beats-93-62-of-users-0-00mb-beats-100-00-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEasy approach \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n525ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0.00MB\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect e.name from (select s.managerId, count(s.id) as managed from Employee s group by s.managerId) as t left join Employee e on e.id = t.managerId where t.managed >= 5 and name is not null\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect e.name from (select s.managerId, count(s.id) as managed from Employee s group by s.managerId) as t left join Employee e on e.id = t.managerId where t.managed >= 5 and name is not null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043807,
                "title": "easy-approach-for-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select managerId from Employee group by managerId having count(*)>=5)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect name from Employee\\nwhere id in (select managerId from Employee group by managerId having count(*)>=5)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043175,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nwith t1 as (\\n  select managerId from Employee\\n  where managerId is not null\\n  group by managerId\\n  having count(*) >= 5\\n)\\nselect name from Employee e\\ninner join t1 \\non t1.managerId = e.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith t1 as (\\n  select managerId from Employee\\n  where managerId is not null\\n  group by managerId\\n  having count(*) >= 5\\n)\\nselect name from Employee e\\ninner join t1 \\non t1.managerId = e.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043130,
                "title": "easy-sql-query",
                "content": "# Intuition\\n To solve this problem, we want to identify managers who have at least five direct reports among employees in the Employee table.\\n\\n# Approach\\n We approach this by using a SQL query with a correlated subquery. In the subquery, we count the number of employees managed by each employee (represented by e1) by matching their id with the managerId of other employees (represented by e2). We then filter for employees (e1) who have at least five direct reports (i.e., where the count is greater than or equal to 5). This gives us the names of managers with the specified criteria.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this SQL query depends on the size of the Employee table. It involves a correlated subquery that scans the Employee table for each employee (e1), resulting in a complexity of O(n^2), where n is the number of rows in the table.\\n\\n- Space complexity:\\nThe space complexity is primarily determined by the database\\'s internal handling of the query and result set. It does not significantly depend on the input size and can be considered constant or O(1). \\n\\n\\n# Code\\n```\\nselect name\\nfrom Employee e1\\nwhere (\\n  select count(*)\\n  from Employee e2\\n  where e1.id = e2.managerId\\n) >= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect name\\nfrom Employee e1\\nwhere (\\n  select count(*)\\n  from Employee e2\\n  where e1.id = e2.managerId\\n) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042022,
                "title": "sql-server-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect a.name from Employee a\\ninner join Employee b\\non a.id = b.managerId\\ngroup by a.id, a.name\\nhaving count(a.name)>=5\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect a.name from Employee a\\ninner join Employee b\\non a.id = b.managerId\\ngroup by a.id, a.name\\nhaving count(a.name)>=5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040765,
                "title": "1-using-subqueries-2-using-join",
                "content": "# Write your MySQL query statement below\\n\\n# using subqueries\\n\\n# select name from employee where id in (select managerId from employee where managerID is not null group by managerID having count(managerId)>=5);\\n\\n#  using Join\\n\\nselect  name from employee join (select managerId from employee where managerID is not null group by managerID having count(managerId)>=5) temp on employee.id=temp.managerId;\\n",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\n\\n# using subqueries\\n\\n# select name from employee where id in (select managerId from employee where managerID is not null group by managerID having count(managerId)>=5);\\n\\n#  using Join\\n\\nselect  name from employee join (select managerId from employee where managerID is not null group by managerID having count(managerId)>=5) temp on employee.id=temp.managerId;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4038296,
                "title": "use-group-by-and-having",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect name from Employee where id in (select managerId from Employee\\ngroup by managerId having count(1)>=5);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect name from Employee where id in (select managerId from Employee\\ngroup by managerId having count(1)>=5);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035578,
                "title": "beats-78-of-ms-sql-server",
                "content": "# Intuition\\n<!-- Make sure to take some time to review the input and output samples. Employee IDs can also be Manager IDs. So, this means we will need to create another table to do an implicit join somewhere. -->\\n\\n# Approach\\n<!-- Step 1: create a table that returns managerIDs and a count of employeeIDs. Step 2: create new query where we Select name corresponding to managerIDs titled as an employee ID, which requires us to join our temp table with the original employees table. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below \\n-Find managers with at least 5 direct reports.\\n-ID=employee ID\\n-NAME=manager\\n-department=departmentname\\n-managerID=ID of manager\\nEmployees can be managers\\nSELECT ID where count is greater thatn 5\\n-If managerID is null, then the employee does not have a manager\\nemployees can also be managers\\nNeeds\\n-find managerID and count of ID\\n*/\\n\\nWITH directreportcount AS (\\nSELECT\\nmanagerid,\\nCOUNT(id) AS directreports\\nFROM employee\\nGROUP BY managerid\\n)\\n\\nSELECT\\nemployee.name\\nFROM directreportcount INNER JOIN employee\\nON directreportcount.managerid=employee.id\\nWHERE directreports >=5;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below \\n-Find managers with at least 5 direct reports.\\n-ID=employee ID\\n-NAME=manager\\n-department=departmentname\\n-managerID=ID of manager\\nEmployees can be managers\\nSELECT ID where count is greater thatn 5\\n-If managerID is null, then the employee does not have a manager\\nemployees can also be managers\\nNeeds\\n-find managerID and count of ID\\n*/\\n\\nWITH directreportcount AS (\\nSELECT\\nmanagerid,\\nCOUNT(id) AS directreports\\nFROM employee\\nGROUP BY managerid\\n)\\n\\nSELECT\\nemployee.name\\nFROM directreportcount INNER JOIN employee\\nON directreportcount.managerid=employee.id\\nWHERE directreports >=5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035103,
                "title": "managers-with-at-least-5-direct-reports",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e.name\\nFROM Employee as e\\nJOIN Employee as e1\\nWHERE e.id = e1.managerId\\nGROUP BY e1.managerId\\nHAVING count(e1.id) >= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e.name\\nFROM Employee as e\\nJOIN Employee as e1\\nWHERE e.id = e1.managerId\\nGROUP BY e1.managerId\\nHAVING count(e1.id) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035071,
                "title": "easy-pandas-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    df_m = employee[employee[\\'managerId\\']!=None].groupby([\\'managerId\\'],as_index=False)[\\'id\\'].count()\\n    ms = set(df_m[df_m[\\'id\\']>=5][\\'managerId\\'])\\n    df_5 = employee[employee[\\'id\\'].isin(ms)][[\\'name\\']]\\n    return df_5\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    df_m = employee[employee[\\'managerId\\']!=None].groupby([\\'managerId\\'],as_index=False)[\\'id\\'].count()\\n    ms = set(df_m[df_m[\\'id\\']>=5][\\'managerId\\'])\\n    df_5 = employee[employee[\\'id\\'].isin(ms)][[\\'name\\']]\\n    return df_5\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034586,
                "title": "mysql-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    e2.name\\nFROM Employee e1\\nINNER JOIN Employee e2 ON e1.managerId = e2.id\\nGROUP BY e1.managerId\\nHAVING COUNT(e1.managerId) >= 5\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    e2.name\\nFROM Employee e1\\nINNER JOIN Employee e2 ON e1.managerId = e2.id\\nGROUP BY e1.managerId\\nHAVING COUNT(e1.managerId) >= 5\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034070,
                "title": "managers-with-at-least-5-direct-reports",
                "content": "## Code\\n```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect m.name\\nfrom employee as e\\ninner join employee as m\\non e.managerId=m.id\\ngroup by e.managerId \\nhaving count(e.id)>=5\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031784,
                "title": "570-managers-with-at-least-5-direct-reports",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e1.name\\nFROM Employee e1\\nLEFT JOIN Employee e2 ON e1.id = e2.managerId\\nGROUP BY e1.id, e1.name\\nHAVING COUNT(e2.id) >= 5;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e1.name\\nFROM Employee e1\\nLEFT JOIN Employee e2 ON e1.id = e2.managerId\\nGROUP BY e1.id, e1.name\\nHAVING COUNT(e2.id) >= 5;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031153,
                "title": "simple-solution-using-having-count",
                "content": "# Complexity\\n- Time complexity: 2 minutes\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(id)>=5 );\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT name\\nFROM Employee\\nWHERE id IN (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT(id)>=5 );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030699,
                "title": "pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Identify employees without a manager: Find the employees with a null value in the \"managerId\" column and assume that they are their own managers by filling the null values with their own id values.\\n- Count the number of direct reports for each manager: Group the employees based on their \"managerId\" and count the occurrences of each manager in the \"managerId\" column.\\n- Filter managers with at least five direct reports: Select only the managers who have at least five direct reports based on the count of occurrences.\\n- Retrieve the names of the selected managers: Merge the selected manager\\'s ids with the \"id\" and \"name\" columns of the employee table to retrieve their names.\\n- Return the result: Return the result table containing the names of the managers with at least five direct reports.\\n# Complexity\\n#### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ is the number of rows in the `employee` DataFrame. \\n#### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ due to the need to store the DataFrame and any additional data structures, where $$n$$ is the number of rows in the `employee` DataFrame.\\n# Runtime & Memory\\n![Screenshot 2023-09-11 at 14.01.51.png](https://assets.leetcode.com/users/images/c204799a-69f7-47d1-8819-99003814249a_1694427005.560878.png)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    employee[\"managerId\"] = employee[\"managerId\"].fillna(employee[\"id\"])\\n\\n    counts = employee[\"managerId\"].value_counts()\\n    result = (\\n        counts[counts >= 5]\\n        .reset_index()\\n        .merge(employee[[\"id\", \"name\"]], left_on=\"managerId\", right_on=\"id\")[[\"name\"]]\\n    )\\n\\n    return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef find_managers(employee: pd.DataFrame) -> pd.DataFrame:\\n    employee[\"managerId\"] = employee[\"managerId\"].fillna(employee[\"id\"])\\n\\n    counts = employee[\"managerId\"].value_counts()\\n    result = (\\n        counts[counts >= 5]\\n        .reset_index()\\n        .merge(employee[[\"id\", \"name\"]], left_on=\"managerId\", right_on=\"id\")[[\"name\"]]\\n    )\\n\\n    return result\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1968092,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1890352,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1575898,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1990018,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1995133,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1919490,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1639987,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 2000239,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1903180,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 2016317,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1968092,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1890352,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1575898,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1990018,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1995133,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1919490,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1639987,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 2000239,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1903180,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 2016317,
                "content": [
                    {
                        "username": "amankumarsingh123",
                        "content": "i am unable to understand the question, can anyone please help me in this"
                    },
                    {
                        "username": "Hackytech",
                        "content": "[@Olek-dev](/Olek-dev) Thanks for clearing."
                    },
                    {
                        "username": "Olek-dev",
                        "content": "Find who is a manager for at least 5 employees (has at least 5 subordinates). So you need to find the name of a person whose ID appears at least 5 times in the managerId column"
                    },
                    {
                        "username": "nikhit5",
                        "content": "Easiest with the right logic\nI never understood combining the table twice...\n\n `select name from Employee \nwhere id in (select managerID from employee \ngroup by managerId having count(*)>=5);`"
                    },
                    {
                        "username": "YinanDoggo",
                        "content": "[@user5714z](/user5714z) Thanks for the explaination. I tried both join and this method and I did see the difference in solving time but can\\'t explain why"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "[@user5714z](/user5714z) Is this true in general or just for this question?"
                    },
                    {
                        "username": "shubham_kaspale",
                        "content": "you are great "
                    },
                    {
                        "username": "user5714z",
                        "content": "Because joins are faster compare to subqueries so its better to use joins over subqueries for optimized query performance"
                    },
                    {
                        "username": "chaitanyaedara",
                        "content": "# Write your MySQL query statement below\\nselect m.name\\nfrom employee e\\njoin employee m\\nwhere e.managerid=m.id\\ngroup by e.managerid\\nhaving count(*) >=5"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "select name from employee where id=101;"
                    },
                    {
                        "username": "srjefers",
                        "content": "worst, it only works for the testCase, not for other cases"
                    },
                    {
                        "username": "vpabla7",
                        "content": "MADLAD"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "select name from employee\\nhaving count(managerid) >=5"
                    },
                    {
                        "username": "ravindrayadav78795",
                        "content": "it failed on 3rd tc"
                    },
                    {
                        "username": "LiniWei",
                        "content": "select distinct e1.name\\nfrom Employee as e1\\nleft join Employee as e2\\non e1.id=e2.managerID\\nhaving count(e1.name)>=5"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select name from employee where id in\\n(select managerId from employee group by managerId \\nhaving (count(distinct id)>=5))"
                    },
                    {
                        "username": "larsx2",
                        "content": "FYI You can have more than one manager with the same name."
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "Yeah the last testcase has John 2 times which was really getting me , ur hint helped me , thanks \\n:)"
                    },
                    {
                        "username": "lex8390",
                        "content": "While CTE is viable to solve this problem, the most straightforward way is to use a subquery. Remember to account for null values in the subquery and watch the order of your where, group by and having clauses.  "
                    },
                    {
                        "username": "zwan7415",
                        "content": ".......Did I do something wrong? \\nSELECT e.name   --, count(e.name) as num\\nFROM Employee e LEFT JOIN Employee n on e.id = n.managerId\\nGROUP BY e.name  \\nHAVING count(e.name)>=5"
                    },
                    {
                        "username": "jargolastik",
                        "content": "You can group by Manager ID instead of the name because this will produce an error if there are two different managers with the same name."
                    }
                ]
            },
            {
                "id": 1977673,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2073122,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2073097,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2072408,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2072044,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2058736,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2057734,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2057395,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2050205,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2042118,
                "content": [
                    {
                        "username": "Olek-dev",
                        "content": "Why is this code Accepted but gives an Error on submission?? - Output -null- but expected an empty table :(  I don't understand how to drop that null (name is not null doesn't work)            \n                                                                                                       \nWITH cte AS (SELECT managerId FROM Employee GROUP BY managerId HAVING COUNT (managerId >= 5))\nSELECT e.name FROM employee e\nRIGHT JOIN cte\nON cte.managerId = e.id"
                    },
                    {
                        "username": "Olek-dev",
                        "content": "[@lex8390](/lex8390) thank you!! "
                    },
                    {
                        "username": "lex8390",
                        "content": "since you are doing a right join you need IS NOT NULL in your manager name column (see below). The issue in testcase 8/9 is that managerId contains a null value which does not belong to any manager name hence returning another null value. I guess the idea is to teach us to handle errors in databases. \n\nAlso, watch your parenthesis on your HAVING clause \n\nWITH cte (managerId) AS \n  (SELECT managerId\n   FROM Employee\n   GROUP BY managerId\n   HAVING COUNT (managerId) >= 5\n  )\n\nSELECT e.name\nFROM employee e\n  RIGHT JOIN cte c\n    ON c.managerId = e.id\nWHERE e.name IS NOT NULL\n"
                    },
                    {
                        "username": "Rupali410",
                        "content": "select name from\\n(\\nselect m.id,m.name\\nfrom employee e join employee m \\non nvl(e.managerid,0) = nvl(m.id,0)\\ngroup by m.id,m.name\\nhaving count(1) >=5\\n)"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "/* Write your PL/SQL query statement below */\\nwith cte as(\\nselect m.name from employee e join employee m\\non e.managerid=m.id\\ngroup by m.name\\nhaving count(1)>= 5\\n) select nvl(name,\\'\\') as name from cte ;\\n\\nNot able to satisfy this test case. out of 8/9 works well!!\\n\\n| id  | name  | department | managerId |\\n| --- | ----- | ---------- | --------- |\\n| 101 | John  | A          | null      |\\n| 102 | Dan   | A          | 101       |\\n| 103 | James | A          | 101       |\\n| 104 | Amy   | A          | 101       |\\n| 105 | Anne  | A          | 101       |\\n| 106 | Ron   | B          | 101       |\\n| 111 | John  | A          | null      |\\n| 112 | Dan   | A          | 111       |\\n| 113 | James | A          | 111       |\\n| 114 | Amy   | A          | 111       |\\n| 115 | Anne  | A          | 111       |\\n| 116 | Ron   | B          | 111       |\\n\\n| NAME |\\n| ---- |\\n| John |\\n\\n| name |\\n| ---- |\\n| John |\\n| John |\\n"
                    },
                    {
                        "username": "user2817dC",
                        "content": "This should say \"subordinates\" instead of \"direct supports\"."
                    },
                    {
                        "username": "wheatsnackbread",
                        "content": "T-SQL Simple using Subqueries:\\n\\n/* Write your T-SQL query statement below */\\nSELECT Employee.name AS \"Name\" FROM (SELECT managerId, COUNT(managerId) AS directReports FROM Employee GROUP BY managerId HAVING COUNT(managerId) >= 5) sub INNER JOIN Employee ON sub.managerId = Employee.id;"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\\n\\nselect name from employee a\\nwhere exists (select managerID from employee b\\n                where a.id=b.managerID\\n                group by managerId\\n                having count(*) >=5);"
                    },
                    {
                        "username": "Krushna_Dattatraya_Vyas",
                        "content": "select name from Employee\\nwhere managerID is not null\\ngroup by managerId\\nhaving count(ManagerId)>=5;\\n\\nWhat did I do wrong here?"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "Easy solution \\n\\nselect A.name from(\\nselect e1.name,e2.managerId as  managerId\\nfrom employee e1,\\nemployee e2\\nwhere e1.id=e2.managerId  \\n)A group by A.managerId having count(managerId)>=5;\\n\\n"
                    },
                    {
                        "username": "__Ace__",
                        "content": "we can use subquery to see if the id in ( managerId from Employee group by managerId ) is having count greater than or equal to 5;"
                    },
                    {
                        "username": "user4507PE",
                        "content": "SELECT \\nXYZ.NAME FROM\\n(SELECT \\nE1.ID,\\nE1.NAME,\\nCOUNT(*)\\nFROM EMPLOYEE E1\\nINNER JOIN EMPLOYEE E2\\nON E1.ID=E2.MANAGERID\\nGROUP BY E1.ID,E1.NAME HAVING COUNT(*) >=5\\n)XYZ\\n;"
                    }
                ]
            },
            {
                "id": 2032117,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 2028796,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 2022270,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 2019016,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 2005386,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1996770,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1992054,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1992006,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1990019,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1986608,
                "content": [
                    {
                        "username": "shrut_23",
                        "content": "Easy if you got the logic right.\\n\\n `select A.name from Employee as A where A.id in  ( select managerId as id from Employee GROUP BY managerId HAVING count(managerId) >= 5\\n  );`"
                    },
                    {
                        "username": "Nithin_126",
                        "content": "\\'select name from (select name , count(managerId) >=5 from Employee) as subquery\\' seems to run fine when testcases aren\\'t empty. "
                    },
                    {
                        "username": "kartikbangard1",
                        "content": "Can someone explain the question?"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "Find someone with at least 5 subordinates"
                    },
                    {
                        "username": "Lomelo404",
                        "content": "Does anyone else has a problem with submiting the answer in Oracle. When I hit submit it changes the expected answer to 2 names instead of 1("
                    },
                    {
                        "username": "srivanimaguluri",
                        "content": "SELECT\\nname\\nFROM\\nEmployee\\nwhere id in (select managerId from Employee group by managerId having count(managerId)>=5)"
                    },
                    {
                        "username": "SwatiM14",
                        "content": "select name from employee where id in (select e2.managerid from employee e1, employee e2 where e1.id = e2.managerid group by e2.managerid having count(e2.managerid)= 5)"
                    },
                    {
                        "username": "user1440f",
                        "content": "SELECT name FROM Employee WHERE id IN (\\n  SELECT managerId FROM Employee GROUP BY managerId having COUNT(name) >= 5\\n);\\n\\nwithout join"
                    },
                    {
                        "username": "chirangee_verma",
                        "content": "in the form of nested query \\nselect name from employee where id in (\\n  select managerid from employee  group by managerid having count(managerid)>=5 \\n  );"
                    },
                    {
                        "username": "Sathya_Bala",
                        "content": "SELECT E1.name\\nFROM Employee E1\\nLEFT JOIN Employee E2 ON E1.id = E2.managerId\\nGROUP BY E1.name\\nHAVING COUNT(E2.id) >= 5;"
                    },
                    {
                        "username": "meow_power",
                        "content": "I can\\'t understand why we just can\\'t use <b>group by</b> (having count>=5) and we <b> won\\'t have to do some complex join</b>?"
                    }
                ]
            },
            {
                "id": 1977370,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1971001,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1969501,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1969449,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1958300,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1936258,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1921967,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1921208,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1919260,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            },
            {
                "id": 1883872,
                "content": [
                    {
                        "username": "mudhapakamanohar",
                        "content": "select name from Employee where id in (select managerId from (select managerId,count(managerId) from Employee  group by managerId having count(managerId)>=5) as a);"
                    },
                    {
                        "username": "ramanjeetparihar",
                        "content": "with cte as (select managerid, count(managerid) as countx from employee\\nwhere id != managerid or managerid is not null\\ngroup by managerid\\nhaving countx >= 5)\\n\\nselect name from employee e, cte\\nwhere e.id = cte.managerid"
                    },
                    {
                        "username": "eriksohnberg",
                        "content": "\\nselect name \\nfrom employee \\nwhere id in ( SELECT managerId\\n              FROM employee\\n              GROUP BY managerId\\n              HAVING count(name) >= 5 );"
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "Can anyone explain me why we use WHERE instead of AND after join ?  "
                    },
                    {
                        "username": "haziqfathi31",
                        "content": "*ON"
                    },
                    {
                        "username": "AaronCreor",
                        "content": "select e.name\\n from Employee e\\n where e.id in\\n (select emp.id from employee emp where (select count(*) from employee where employee.managerId = emp.id)>=5)"
                    },
                    {
                        "username": "Msey",
                        "content": "is 'self join' faster than 'in' with subquery?"
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "self join is faster than subquery"
                    },
                    {
                        "username": "District_12",
                        "content": "I want one more medium in my collection but it\\'s not a medium."
                    },
                    {
                        "username": "nitishgupta8777",
                        "content": "select distinct e2.name as name\\nfrom Employee e1\\ninner join Employee e2\\non e1.managerId=e2.id"
                    },
                    {
                        "username": "Tinkoo",
                        "content": "select mng.name from employee emp join employee mng on emp.managerid = mng.id group by mng.id having count(emp.id)>=5;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.name\\nFROM Employee as a, Employee as b\\nWHERE b.managerid = a.id\\ngroup by b.managerid\\nhaving count(*) >= 5"
                    }
                ]
            }
        ]
    },
    {
        "title": "Second Minimum Node In a Binary Tree",
        "question_content": "<p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node&#39;s value is the smaller value among its two sub-nodes. More formally, the property&nbsp;<code>root.val = min(root.left.val, root.right.val)</code>&nbsp;always holds.</p>\n\n<p>Given such a binary tree, you need to output the <b>second minimum</b> value in the set made of all the nodes&#39; value in the whole tree.</p>\n\n<p>If no such second minimum value exists, output -1 instead.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"width: 431px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,5,null,null,5,7]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The smallest value is 2, the second smallest value is 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"width: 321px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,2]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The smallest value is 2, but there isn&#39;t any second smallest value.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 25]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>root.val == min(root.left.val, root.right.val)</code>&nbsp;for each internal node of the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 107158,
                "title": "java-divide-and-conquer-solution",
                "content": "for left and right sub-node, if their value is the same with the parent node value, need to using recursion to find the next candidate, otherwise use their node value as the candidate.\\n```  \\npublic int findSecondMinimumValue(TreeNode root) {\\n    if (root == null) {\\n        return -1;\\n    }\\n    if (root.left == null && root.right == null) {\\n        return -1;\\n    }\\n    \\n    int left = root.left.val;\\n    int right = root.right.val;\\n    \\n    // if value same as root value, need to find the next candidate\\n    if (root.left.val == root.val) {\\n        left = findSecondMinimumValue(root.left);\\n    }\\n    if (root.right.val == root.val) {\\n        right = findSecondMinimumValue(root.right);\\n    }\\n    \\n    if (left != -1 && right != -1) {\\n        return Math.min(left, right);\\n    } else if (left != -1) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```  \\npublic int findSecondMinimumValue(TreeNode root) {\\n    if (root == null) {\\n        return -1;\\n    }\\n    if (root.left == null && root.right == null) {\\n        return -1;\\n    }\\n    \\n    int left = root.left.val;\\n    int right = root.right.val;\\n    \\n    // if value same as root value, need to find the next candidate\\n    if (root.left.val == root.val) {\\n        left = findSecondMinimumValue(root.left);\\n    }\\n    if (root.right.val == root.val) {\\n        right = findSecondMinimumValue(root.right);\\n    }\\n    \\n    if (left != -1 && right != -1) {\\n        return Math.min(left, right);\\n    } else if (left != -1) {\\n        return left;\\n    } else {\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107233,
                "title": "java-4-lines",
                "content": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        if(root.left == null) return -1;\\n        \\n        int l = root.left.val == root.val ? findSecondMinimumValue(root.left) : root.left.val;\\n        int r = root.right.val == root.val ? findSecondMinimumValue(root.right) : root.right.val;\\n        \\n        return l == -1 || r == -1 ? Math.max(l, r) : Math.min(l, r);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        if(root.left == null) return -1;\\n        \\n        int l = root.left.val == root.val ? findSecondMinimumValue(root.left) : root.left.val;\\n        int r = root.right.val == root.val ? findSecondMinimumValue(root.right) : root.right.val;\\n        \\n        return l == -1 || r == -1 ? Math.max(l, r) : Math.min(l, r);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107165,
                "title": "python-extremely-easy-to-understand-beats-91",
                "content": "Based on the special property of the tree, we can guarantee that the root node is the smallest node in the tree. We just have to recursively traverse the tree and find a node that is bigger than the root node but smaller than any existing node we have come across.\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your technical interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        res = [float(\\'inf\\')]\\n        def traverse(node):\\n            if not node:\\n                return\\n            if root.val < node.val < res[0]:\\n                res[0] = node.val\\n            traverse(node.left)\\n            traverse(node.right)\\n        traverse(root)\\n        return -1 if res[0] == float(\\'inf\\') else res[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        res = [float(\\'inf\\')]\\n        def traverse(node):\\n            if not node:\\n                return\\n            if root.val < node.val < res[0]:\\n                res[0] = node.val\\n            traverse(node.left)\\n            traverse(node.right)\\n        traverse(root)\\n        return -1 if res[0] == float(\\'inf\\') else res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107159,
                "title": "c-dfs-recursion",
                "content": "This question is very similar to searching for minimum value in the Binary Tree. \\nThe only requirement is that this value must be different from the root value, k. \\n```\\nIf the root value of a subtree == k, \\n         keep searching its children.\\nelse, \\n         return the root value because it is the minimum of current subtree.\\n```\\n```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root) return -1;\\n        int ans = minval(root, root->val);\\n        return ans;\\n    }\\nprivate:\\n    int minval(TreeNode* p, int first) {\\n        if (p == nullptr) return -1;\\n        if (p->val != first) return p->val;\\n        int left = minval(p->left, first), right = minval(p->right, first);\\n        // if all nodes of a subtree = root->val, \\n        // there is no second minimum value, return -1\\n        if (left == -1) return right;\\n        if (right == -1) return left;\\n        return min(left, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nIf the root value of a subtree == k, \\n         keep searching its children.\\nelse, \\n         return the root value because it is the minimum of current subtree.\\n```\n```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root) return -1;\\n        int ans = minval(root, root->val);\\n        return ans;\\n    }\\nprivate:\\n    int minval(TreeNode* p, int first) {\\n        if (p == nullptr) return -1;\\n        if (p->val != first) return p->val;\\n        int left = minval(p->left, first), right = minval(p->right, first);\\n        // if all nodes of a subtree = root->val, \\n        // there is no second minimum value, return -1\\n        if (left == -1) return right;\\n        if (right == -1) return left;\\n        return min(left, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430909,
                "title": "java-bfs-solution",
                "content": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n\\tif(root==null || root.right==null || root.left==null) return -1;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tInteger secondMin = null;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr.right!=null) q.offer(curr.right);\\n\\t\\tif(curr.left!=null) q.offer(curr.left);\\n\\t\\tif(curr.val!=root.val) {\\n\\t\\t\\tif(secondMin==null) secondMin = curr.val;\\n\\t\\t\\telse secondMin = Math.min(secondMin, curr.val);\\n\\t\\t}\\n\\t}\\n\\treturn secondMin==null? -1 : secondMin;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n\\tif(root==null || root.right==null || root.left==null) return -1;\\n\\tQueue<TreeNode> q = new LinkedList<>();\\n\\tq.offer(root);\\n\\tInteger secondMin = null;\\n\\twhile(!q.isEmpty()) {\\n\\t\\tTreeNode curr = q.poll();\\n\\t\\tif(curr.right!=null) q.offer(curr.right);\\n\\t\\tif(curr.left!=null) q.offer(curr.left);\\n\\t\\tif(curr.val!=root.val) {\\n\\t\\t\\tif(secondMin==null) secondMin = curr.val;\\n\\t\\t\\telse secondMin = Math.min(secondMin, curr.val);\\n\\t\\t}\\n\\t}\\n\\treturn secondMin==null? -1 : secondMin;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107228,
                "title": "python-straightforward-with-explanation",
                "content": "Say the value of the root is `min1`.  If some node's value is larger, it might be the answer, but every descendant node will be at least as big, so we don't need to check them.\\n\\n```python\\ndef findSecondMinimumValue(self, root):\\n    self.ans = float('inf')\\n    min1 = root.val\\n\\n    def dfs(node):\\n        if node:\\n            if min1 < node.val < self.ans:\\n                self.ans = node.val\\n            elif node.val == min1:\\n                dfs(node.left)\\n                dfs(node.right)\\n\\n    dfs(root)\\n    return self.ans if self.ans < float('inf') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\ndef findSecondMinimumValue(self, root):\\n    self.ans = float('inf')\\n    min1 = root.val\\n\\n    def dfs(node):\\n        if node:\\n            if min1 < node.val < self.ans:\\n                self.ans = node.val\\n            elif node.val == min1:\\n                dfs(node.left)\\n                dfs(node.right)\\n\\n    dfs(root)\\n    return self.ans if self.ans < float('inf') else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1426155,
                "title": "c-hashset-inorder-traversal-dfs-100-faster-0ms",
                "content": "**Please Upvote if you liked it**\\n \\n     class Solution {\\n     public:\\n     void dfs(TreeNode* root,set<int> &s){                                            \\n       if(root==NULL)\\n            return;\\n        dfs(root->left,s);\\n        s.insert(root->val);\\n        dfs(root->right,s);\\n        }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        dfs(root,s);\\n        if(s.size()==1)\\n            return -1;\\n        auto it=s.begin();\\n        it++;\\n        return *it;\\n         }\\n\\t\\t };",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n     public:\\n     void dfs(TreeNode* root,set<int> &s){                                            \\n       if(root==NULL)\\n            return;\\n        dfs(root->left,s);\\n        s.insert(root->val);\\n        dfs(root->right,s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 578849,
                "title": "python-99-16ms-explnation-bfs",
                "content": "1. get all the values \\n2. if there\\'s 1 unique value, return -1\\n3. else return 2nd smallest\\n\\ncheers\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        nums = []\\n        nodes = [root]\\n        while nodes:\\n            t = nodes.pop()\\n            nums.append(t.val)\\n            if t.left:\\n                nodes.append(t.left)\\n            if t.right:\\n                nodes.append(t.right)\\n        \\n        if len(set(nums)) == 1:\\n            return -1\\n        \\n        return sorted(set(nums))[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        nums = []\\n        nodes = [root]\\n        while nodes:\\n            t = nodes.pop()\\n            nums.append(t.val)\\n            if t.left:\\n                nodes.append(t.left)\\n            if t.right:\\n                nodes.append(t.right)\\n        \\n        if len(set(nums)) == 1:\\n            return -1\\n        \\n        return sorted(set(nums))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236496,
                "title": "faster-than-100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    set<int>S;\\n    void secMin(TreeNode *root){\\n        if(root==NULL) return;\\n        S.insert(root->val);\\n        secMin(root->left);\\n        secMin(root->right);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        secMin(root);\\n        if(S.size()>=2){\\n            int x = *next(S.begin(), 1);\\n            return x;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    set<int>S;\\n    void secMin(TreeNode *root){\\n        if(root==NULL) return;\\n        S.insert(root->val);\\n        secMin(root->left);\\n        secMin(root->right);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        secMin(root);\\n        if(S.size()>=2){\\n            int x = *next(S.begin(), 1);\\n            return x;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274796,
                "title": "simple-java-solution-dfs-boolean",
                "content": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    int secondMin = Integer.MAX_VALUE;\\n    boolean found = false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.val < min) {\\n            min = root.val;\\n        }\\n        \\n        if(root.val > min && root.val<=secondMin) {\\n            found = true;\\n            secondMin = root.val;\\n        }\\n        \\n        findSecondMinimumValue(root.left);\\n        findSecondMinimumValue(root.right);\\n        \\n        return !found ? -1 : secondMin ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min = Integer.MAX_VALUE;\\n    int secondMin = Integer.MAX_VALUE;\\n    boolean found = false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        if(root.val < min) {\\n            min = root.val;\\n        }\\n        \\n        if(root.val > min && root.val<=secondMin) {\\n            found = true;\\n            secondMin = root.val;\\n        }\\n        \\n        findSecondMinimumValue(root.left);\\n        findSecondMinimumValue(root.right);\\n        \\n        return !found ? -1 : secondMin ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112520,
                "title": "simple-java-solution-with-a-single-recursive-function-3ms",
                "content": "```\\nclass Solution\\n{\\n    public int findSecondMinimumValue(TreeNode root)\\n    {\\n        if(root.left == null)   return -1;\\n        \\n        int left  = (root.left.val  == root.val) ? findSecondMinimumValue(root.left)  : root.left.val;\\n        int right = (root.right.val == root.val) ? findSecondMinimumValue(root.right) : root.right.val;\\n\\n        if(left  == -1)         return right;\\n        if(right == -1)         return left;\\n\\n        return Math.min(left, right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int findSecondMinimumValue(TreeNode root)\\n    {\\n        if(root.left == null)   return -1;\\n        \\n        int left  = (root.left.val  == root.val) ? findSecondMinimumValue(root.left)  : root.left.val;\\n        int right = (root.right.val == root.val) ? findSecondMinimumValue(root.right) : root.right.val;\\n\\n        if(left  == -1)         return right;\\n        if(right == -1)         return left;\\n\\n        return Math.min(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840434,
                "title": "easy-to-understand-and-constant-memory",
                "content": "We have to find the second minimum value \\nour root will be smallest value, now second minimum value will one of it\\'s child or sibling.\\n```\\nclass Solution {\\npublic:\\n    long long int ans = LLONG_MAX;\\n    void findMin(TreeNode* root, int curr) {\\n        if (!root) return;\\n        \\n\\t\\t//if ans is greater than current value and not equal to minimum element then update the answer\\n        if (root->val != curr && (ans > root->val)) {\\n            ans = root->val;\\n        }\\n\\t\\t//return because after current node value of  every child will be greater or same value that we updated in answer\\n\\t\\t if (ans <= root->val) return;\\n        \\n        findMin(root->left, curr);\\n        findMin(root->right, curr);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        findMin(root, root->val);\\n        if (ans == LLONG_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int ans = LLONG_MAX;\\n    void findMin(TreeNode* root, int curr) {\\n        if (!root) return;\\n        \\n\\t\\t//if ans is greater than current value and not equal to minimum element then update the answer\\n        if (root->val != curr && (ans > root->val)) {\\n            ans = root->val;\\n        }\\n\\t\\t//return because after current node value of  every child will be greater or same value that we updated in answer\\n\\t\\t if (ans <= root->val) return;\\n        \\n        findMin(root->left, curr);\\n        findMin(root->right, curr);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        findMin(root, root->val);\\n        if (ans == LLONG_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262518,
                "title": "c-beats-100-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        int smallval = root -> val;\\n        return (findSecondMinimumValue(root , smallval) == INT_MAX) ? -1 : findSecondMinimumValue(root, smallval);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root, int smallval)\\n    {\\n\\n        if(root->val != smallval)\\n        {\\n            return root->val;\\n        }\\n        int x = (root->left)? findSecondMinimumValue(root->left, smallval): INT_MAX;\\n        int y = (root->right)? findSecondMinimumValue(root->right, smallval): INT_MAX;\\n        return min(x, y);\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        int smallval = root -> val;\\n        return (findSecondMinimumValue(root , smallval) == INT_MAX) ? -1 : findSecondMinimumValue(root, smallval);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root, int smallval)\\n    {\\n\\n        if(root->val != smallval)\\n        {\\n            return root->val;\\n        }\\n        int x = (root->left)? findSecondMinimumValue(root->left, smallval): INT_MAX;\\n        int y = (root->right)? findSecondMinimumValue(root->right, smallval): INT_MAX;\\n        return min(x, y);\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107164,
                "title": "very-simple-java-solution",
                "content": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n            if (root == null) {\\n                return -1;\\n            }\\n            Set<Integer> set = new TreeSet<>();\\n            dfs(root, set);\\n            Iterator<Integer> iterator = set.iterator();\\n            int count = 0;\\n            while (iterator.hasNext()) {\\n                count++;\\n                int result = iterator.next();\\n                if (count == 2) {\\n                    return result;\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        private void dfs(TreeNode root, Set<Integer> set) {\\n            if (root == null) {\\n                return;\\n            }\\n            set.add(root.val);\\n            dfs(root.left, set);\\n            dfs(root.right, set);\\n            return;\\n        }\\n```\\n\\nAlso viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/src/main/java/com/fishercoder/solutions/_671.java) on Github.",
                "solutionTags": [],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n            if (root == null) {\\n                return -1;\\n            }\\n            Set<Integer> set = new TreeSet<>();\\n            dfs(root, set);\\n            Iterator<Integer> iterator = set.iterator();\\n            int count = 0;\\n            while (iterator.hasNext()) {\\n                count++;\\n                int result = iterator.next();\\n                if (count == 2) {\\n                    return result;\\n                }\\n            }\\n            return -1;\\n        }\\n\\n        private void dfs(TreeNode root, Set<Integer> set) {\\n            if (root == null) {\\n                return;\\n            }\\n            set.add(root.val);\\n            dfs(root.left, set);\\n            dfs(root.right, set);\\n            return;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391310,
                "title": "without-set-dfs-c-o-n",
                "content": "###### Definition of the tree: `root.val = min(root.left.val, root.right.val)`\\n###### Observation: \\n1. The primary root is the smallest one (or one of the ...);\\n1. If a child is larger than the parent, then the child might be the second-smallest one, and the whole sub-tree starting from this child can be skipped.\\n\\n###### It\\'s easy to use `set` and solve this problem. What if interviewer disagrees to use `set` ? (Scroll down to see the solution)\\n### Explained below inside the code for better Understanding.\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: $$O(n)$$ `Traversal`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$ `height of tree`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDE09Really took a lot of time to come up with this, Pls {UPVOTE}\\uD83D\\uDE09\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    /*Take 2 variables: firstMin & secondMin*/\\n    long long secondMin=LONG_MAX,firstMin;\\n\\n    void findSecMin(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n\\n        /*  1)Second min is always greater than first min.\\n            2) So find a value in a tree which is greater than firstMin.\\n            3) If we find a value smaller than or equal to secondMin,\\n            we then update our secondMin.*/\\n        if(root->val > firstMin){\\n            if(root->val <= secondMin)\\n                secondMin = root->val;\\n        }\\n\\n        find(root->left);\\n        find(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        //Set root\\'s value as first min.\\n        firstMin = root->val;\\n\\n        //Function call\\n        findSecMin(root);\\n\\n        //In case secondMin was not found\\n        if(secondMin == LONG_MAX)\\n            return -1;\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return secondMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    /*Take 2 variables: firstMin & secondMin*/\\n    long long secondMin=LONG_MAX,firstMin;\\n\\n    void findSecMin(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n\\n        /*  1)Second min is always greater than first min.\\n            2) So find a value in a tree which is greater than firstMin.\\n            3) If we find a value smaller than or equal to secondMin,\\n            we then update our secondMin.*/\\n        if(root->val > firstMin){\\n            if(root->val <= secondMin)\\n                secondMin = root->val;\\n        }\\n\\n        find(root->left);\\n        find(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        //Set root\\'s value as first min.\\n        firstMin = root->val;\\n\\n        //Function call\\n        findSecMin(root);\\n\\n        //In case secondMin was not found\\n        if(secondMin == LONG_MAX)\\n            return -1;\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return secondMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503759,
                "title": "java-hashset-solution-easy-100",
                "content": "# Approach\\nThe given code is a Java implementation of a solution to find the second minimum value in a binary tree. Let\\'s break down the approach step by step:\\n\\n1. The `findSecondMinimumValue` method takes a `TreeNode` object called `root` as input and returns an integer.\\n\\n2. Inside the method, a `HashSet` called `hs` is created to store unique values encountered during the tree traversal.\\n\\n3. The `find` method is called to perform an in-order traversal of the binary tree. It takes the `root` node and the `hs` set as parameters.\\n\\n4. The `find` method is a recursive function that performs an in-order traversal of the binary tree. It visits the left subtree first, then adds the value of the current node to the `hs` set, and finally visits the right subtree.\\n\\n5. After the traversal is complete, the `hs` set will contain all unique values from the binary tree.\\n\\n6. An integer variable `k` is initialized to 0, and an integer array `ans` of size `hs.size()` is created to store the values from the `hs` set.\\n\\n7. A for-each loop iterates over the elements of the `hs` set and assigns them to the `ans` array.\\n\\n8. The `ans` array is sorted in ascending order using the `Arrays.sort` method.\\n\\n9. If the length of the `ans` array is 1, it means there is only one unique value in the binary tree. In this case, -1 is returned as there is no second minimum value.\\n\\n10. Otherwise, the second element (index 1) of the sorted `ans` array is returned as the second minimum value.\\n\\nIn summary, the code performs an in-order traversal of a binary tree, collects all unique values in a `HashSet`, and then finds the second minimum value from the collected values.\\n\\n# Complexity\\n- **Time complexity**:\\nThe time complexity of the code is O(n + m log m), where n is the number of nodes in the tree and m is the number of unique values in the tree.\\n\\n- **Space complexity**:\\nThe space complexity of the code is O(n + m) in the average case and O(n) in the worst case, where n is the number of nodes in the tree and m is the number of unique values.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }\\n        Arrays.sort(ans);\\n        if(ans.length==1)return -1;   \\n         return ans[1];\\n    }\\n    static void find(TreeNode root,Set<Integer>hs){\\n        if(root==null)return;\\n        find(root.left,hs);\\n        hs.add(root.val);\\n        find(root.right,hs);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }\\n        Arrays.sort(ans);\\n        if(ans.length==1)return -1;   \\n         return ans[1];\\n    }\\n    static void find(TreeNode root,Set<Integer>hs){\\n        if(root==null)return;\\n        find(root.left,hs);\\n        hs.add(root.val);\\n        find(root.right,hs);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169825,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return -1\\n        elif not root.left and not root.right:\\n            return -1\\n        elif root.left.val != root.right.val:\\n            if root.left.val < root.right.val:\\n                tmp = self.findSecondMinimumValue(root.left)\\n                if tmp != -1:\\n                    return min(tmp, root.right.val)\\n                else:\\n                    return root.right.val\\n            else:\\n                tmp = self.findSecondMinimumValue(root.right)\\n                if tmp != -1:\\n                    return min(tmp, root.left.val)\\n                else:\\n                    return root.left.val\\n        else:\\n            l = self.findSecondMinimumValue(root.left)\\n            r = self.findSecondMinimumValue(root.right)\\n            if l == -1 and r == -1:\\n                return -1\\n            elif l == -1:\\n                return r\\n            elif r == -1:\\n                return l\\n            else:\\n                return min(l,r)\\n```\\nBFS:\\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        trav = root\\n        minimum, sminimum = root.val, float(\\'inf\\')\\n        queue = collections.deque([root])\\n        while queue:\\n            u = queue.popleft()\\n            if u.val < sminimum and u.val != minimum:\\n                sminimum = u.val\\n            if u.left:\\n                queue.append(u.left)\\n                queue.append(u.right)\\n        if sminimum == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return sminimum\\n```\\nDFS:\\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            elif root.val != self.minimum and root.val < self.sminimum:\\n                self.sminimum = root.val\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        self.minimum = root.val\\n        self.sminimum = float(\\'inf\\')\\n        dfs(root)\\n        return self.sminimum if self.sminimum != float(\"inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        if not root:\\n            return -1\\n        elif not root.left and not root.right:\\n            return -1\\n        elif root.left.val != root.right.val:\\n            if root.left.val < root.right.val:\\n                tmp = self.findSecondMinimumValue(root.left)\\n                if tmp != -1:\\n                    return min(tmp, root.right.val)\\n                else:\\n                    return root.right.val\\n            else:\\n                tmp = self.findSecondMinimumValue(root.right)\\n                if tmp != -1:\\n                    return min(tmp, root.left.val)\\n                else:\\n                    return root.left.val\\n        else:\\n            l = self.findSecondMinimumValue(root.left)\\n            r = self.findSecondMinimumValue(root.right)\\n            if l == -1 and r == -1:\\n                return -1\\n            elif l == -1:\\n                return r\\n            elif r == -1:\\n                return l\\n            else:\\n                return min(l,r)\\n```\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        trav = root\\n        minimum, sminimum = root.val, float(\\'inf\\')\\n        queue = collections.deque([root])\\n        while queue:\\n            u = queue.popleft()\\n            if u.val < sminimum and u.val != minimum:\\n                sminimum = u.val\\n            if u.left:\\n                queue.append(u.left)\\n                queue.append(u.right)\\n        if sminimum == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return sminimum\\n```\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            elif root.val != self.minimum and root.val < self.sminimum:\\n                self.sminimum = root.val\\n            dfs(root.left)\\n            dfs(root.right)\\n            \\n        self.minimum = root.val\\n        self.sminimum = float(\\'inf\\')\\n        dfs(root)\\n        return self.sminimum if self.sminimum != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107163,
                "title": "bfs-acc-solution-java-and-c-code",
                "content": "Java:\\n```\\npublic int findSecondMinimumValue(TreeNode root) \\n{\\n    int rootVal = root.val;\\n    int secondSmall =Integer.MAX_VALUE;\\n    boolean diffFound = false;\\n    Queue<TreeNode> Q= new LinkedList<TreeNode>();\\n    Q.add(root);\\n\\n    while(!Q.isEmpty())\\n    {\\n        TreeNode curr=Q.poll();\\n        if(curr.val!=rootVal && curr.val < secondSmall)\\n        {\\n            secondSmall=curr.val;\\n            diffFound=true;\\n        }\\n        if(curr.left!=null)\\n        {\\n            Q.add(curr.left);\\n            Q.add(curr.right);\\n        }\\n    }\\n\\n    return (secondSmall == Integer.MAX_VALUE && !diffFound) ? -1 : secondSmall;\\n} \\n```\\n\\nC#:\\n```\\n    public int FindSecondMinimumValue(TreeNode root)\\n    {\\n        int rootVal = root.val;\\n        int secondSmall = int.MaxValue;\\n        bool diffFound = false;\\n        Queue<TreeNode> Q = new Queue<TreeNode>();\\n        Q.Enqueue(root);\\n\\n        while (Q.Any()) //while Q is not empty\\n        {\\n            TreeNode curr = Q.Dequeue();\\n            if (curr.val != rootVal && curr.val <= secondSmall)\\n            {\\n                secondSmall = curr.val;\\n                diffFound = true;\\n            }\\n            if (curr.left != null)\\n            {\\n                Q.Enqueue(curr.left);\\n                Q.Enqueue(curr.right);\\n            }\\n        }\\n        return (secondSmall == int.MaxValue && !diffFound) ? -1 : secondSmall;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) \\n{\\n    int rootVal = root.val;\\n    int secondSmall =Integer.MAX_VALUE;\\n    boolean diffFound = false;\\n    Queue<TreeNode> Q= new LinkedList<TreeNode>();\\n    Q.add(root);\\n\\n    while(!Q.isEmpty())\\n    {\\n        TreeNode curr=Q.poll();\\n        if(curr.val!=rootVal && curr.val < secondSmall)\\n        {\\n            secondSmall=curr.val;\\n            diffFound=true;\\n        }\\n        if(curr.left!=null)\\n        {\\n            Q.add(curr.left);\\n            Q.add(curr.right);\\n        }\\n    }\\n\\n    return (secondSmall == Integer.MAX_VALUE && !diffFound) ? -1 : secondSmall;\\n} \\n```\n```\\n    public int FindSecondMinimumValue(TreeNode root)\\n    {\\n        int rootVal = root.val;\\n        int secondSmall = int.MaxValue;\\n        bool diffFound = false;\\n        Queue<TreeNode> Q = new Queue<TreeNode>();\\n        Q.Enqueue(root);\\n\\n        while (Q.Any()) //while Q is not empty\\n        {\\n            TreeNode curr = Q.Dequeue();\\n            if (curr.val != rootVal && curr.val <= secondSmall)\\n            {\\n                secondSmall = curr.val;\\n                diffFound = true;\\n            }\\n            if (curr.left != null)\\n            {\\n                Q.Enqueue(curr.left);\\n                Q.Enqueue(curr.right);\\n            }\\n        }\\n        return (secondSmall == int.MaxValue && !diffFound) ? -1 : secondSmall;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472204,
                "title": "c-0ms-solution-faster-than-100",
                "content": "```\\n\\nclass Solution {\\n    set <int> s;\\n    \\n    void Solve(TreeNode * root)\\n    {\\n        if(!root)\\n            return ;\\n        Solve(root->left);\\n        s.insert(root->val);\\n        Solve(root->right);\\n        \\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        Solve(root);\\n        \\n          if(s.size()==1)\\n           return -1 ;\\n          s.erase(s.begin());\\n        \\n          return *s.begin();\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/51d65873-0248-474d-bc13-f1dfa40d53e4_1661326419.1908376.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    set <int> s;\\n    \\n    void Solve(TreeNode * root)\\n    {\\n        if(!root)\\n            return ;\\n        Solve(root->left);\\n        s.insert(root->val);\\n        Solve(root->right);\\n        \\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        Solve(root);\\n        \\n          if(s.size()==1)\\n           return -1 ;\\n          s.erase(s.begin());\\n        \\n          return *s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012529,
                "title": "python-recursion-and-preorder-easy-solution-with-explanation-7ms-beats-100",
                "content": "**Explanation**\\n1. traverse through tree in preorder\\n2. smallest is root, result is currently largest (will continuously update)\\n3. for each traverse see if the value is NOT the smallest (>smallest) but smaller than the current second-smallest (res)\\n4. return res if it has been updated (not infinity anymore)\\n\\n![image](https://assets.leetcode.com/users/images/d649c2f4-c01e-4505-ac9e-657c197cba65_1651813564.6766617.png)\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n   \\n        self.smallest = root.val\\n        self.res = float(\"inf\")\\n        self.preorder(root)\\n        \\n        \\n        if self.res < float(\"inf\"):\\n            return self.res\\n        else:\\n            return -1   \\n        \\n    def preorder(self, node):\\n        if node:\\n            if self.smallest < node.val < self.res:\\n                self.res = node.val\\n                \\n            self.preorder(node.left)\\n            self.preorder(node.right)\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n   \\n        self.smallest = root.val\\n        self.res = float(\"inf\")\\n        self.preorder(root)\\n        \\n        \\n        if self.res < float(\"inf\"):\\n            return self.res\\n        else:\\n            return -1   \\n        \\n    def preorder(self, node):\\n        if node:\\n            if self.smallest < node.val < self.res:\\n                self.res = node.val\\n                \\n            self.preorder(node.left)\\n            self.preorder(node.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826629,
                "title": "both-runtime-0-ms-faster-than-100-00-c",
                "content": "\\n      //1. [using vector]\\n\\t  \\n      class Solution {\\n      public:\\n          vector<int> vec;\\n          int findSecondMinimumValue(TreeNode* root) {\\n              if(root==nullptr) return 0;\\n              vec.push_back(root->val);\\n              findSecondMinimumValue(root->left);\\n              findSecondMinimumValue(root->right);\\n        \\n              sort(vec.begin(),vec.end());\\n              vec.erase(unique(vec.begin(),vec.end()),vec.end());\\n              return vec.size()>1?vec[1]:-1;\\n          }\\n      };\\n\\n     // 2. [using set]\\n\\n\\t  class Solution {\\n      public:\\n          set<int> set;\\n          int findSecondMinimumValue(TreeNode* root) {\\n              dfs(root);\\n              int count=0;\\n              for(auto it:set){\\n                  if(count==1)\\n                      return it;\\n                  count++;\\n              }\\n              return -1;\\n          }\\n          void dfs(TreeNode* root){\\n              if(root){\\n              dfs(root->left);\\n              set.insert(root->val);\\n              dfs(root->right);\\n              }\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n      public:\\n          vector<int> vec;\\n          int findSecondMinimumValue(TreeNode* root) {\\n              if(root==nullptr) return 0;\\n              vec.push_back(root->val);\\n              findSecondMinimumValue(root->left);\\n              findSecondMinimumValue(root->right);\\n        \\n              sort(vec.begin(),vec.end());\\n              vec.erase(unique(vec.begin(),vec.end()),vec.end());\\n              return vec.size()>1?vec[1]:-1;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 502359,
                "title": "javascript-dfs-solution",
                "content": "```javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar findSecondMinimumValue = function(root) {\\n  if (!root) return -1;\\n  const min1 = root.val;\\n  let min2 = Infinity;\\n  const stack = [root];\\n  while (stack.length) {\\n    const node = stack.pop();\\n    if (min1 < node.val && node.val < min2) min2 = node.val;\\n    if (node.left) stack.push(node.left);\\n    if (node.right) stack.push(node.right);\\n  }\\n  return min2 === Infinity ? -1 : min2;\\n};\\n```\\n\\n* 35/35 cases passed (44 ms)\\n* Your runtime beats 97.99 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (33.9 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar findSecondMinimumValue = function(root) {\\n  if (!root) return -1;\\n  const min1 = root.val;\\n  let min2 = Infinity;\\n  const stack = [root];\\n  while (stack.length) {\\n    const node = stack.pop();\\n    if (min1 < node.val && node.val < min2) min2 = node.val;\\n    if (node.left) stack.push(node.left);\\n    if (node.right) stack.push(node.right);\\n  }\\n  return min2 === Infinity ? -1 : min2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653819,
                "title": "simplest-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        a = []\\n\\n        def dfs(root):\\n            if not root:\\n                return\\n            dfs(root.left)\\n            a.append(root.val)\\n            dfs(root.right)\\n\\n        dfs(root)\\n\\n        return (sorted(set(a)))[1] if len(set(a)) >= 2 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        a = []\\n\\n        def dfs(root):\\n            if not root:\\n                return\\n            dfs(root.left)\\n            a.append(root.val)\\n            dfs(root.right)\\n\\n        dfs(root)\\n\\n        return (sorted(set(a)))[1] if len(set(a)) >= 2 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772205,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\n public:\\n void dfs(TreeNode* root,set<int> &s){                                            \\n   if(root==NULL)\\n        return;\\n    dfs(root->left,s);\\n    s.insert(root->val);\\n    dfs(root->right,s);\\n    }\\n\\nint findSecondMinimumValue(TreeNode* root) {\\n    set<int> s;\\n    dfs(root,s);\\n    if(s.size()==1)\\n        return -1;\\n    auto it=s.begin();\\n    it++;\\n    return *it;\\n     }\\n\\t };\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n public:\\n void dfs(TreeNode* root,set<int> &s){                                            \\n   if(root==NULL)\\n        return;\\n    dfs(root->left,s);\\n    s.insert(root->val);\\n    dfs(root->right,s);\\n    }\\n\\nint findSecondMinimumValue(TreeNode* root) {\\n    set<int> s;\\n    dfs(root,s);\\n    if(s.size()==1)\\n        return -1;\\n    auto it=s.begin();\\n    it++;\\n    return *it;\\n     }\\n\\t };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671188,
                "title": "runtime-0ms-faster-than-100-00-simple-solution-begineer-friendly",
                "content": "```\\n\\tpublic int findSecondMinimumValue(TreeNode root) {   \\n       if(root == null) return -1;\\n       if(root.left == null && root.right == null) return -1;\\n    \\n       int left = root.left.val;\\n       int right = root.right.val;\\n        \\n       if(root.left.val == root.val) {\\n           left = findSecondMinimumValue(root.left);\\n       }\\n       \\n       if(root.right.val == root.val) {\\n           right = findSecondMinimumValue(root.right);\\n       }\\n        \\n       if(left != -1 && right != -1) {\\n           return Math.min(left, right);\\n       } else if(left != -1) {\\n           return left;\\n       } else {\\n           return right;\\n       }\\n    }",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic int findSecondMinimumValue(TreeNode root) {   \\n       if(root == null) return -1;\\n       if(root.left == null && root.right == null) return -1;\\n    \\n       int left = root.left.val;\\n       int right = root.right.val;\\n        \\n       if(root.left.val == root.val) {\\n           left = findSecondMinimumValue(root.left);\\n       }\\n       \\n       if(root.right.val == root.val) {\\n           right = findSecondMinimumValue(root.right);\\n       }\\n        \\n       if(left != -1 && right != -1) {\\n           return Math.min(left, right);\\n       } else if(left != -1) {\\n           return left;\\n       } else {\\n           return right;\\n       }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1971562,
                "title": "python-easy-solution-explained",
                "content": "```\\n\\'\\'\\'\\nAlgorithm:\\n----------------------------------------------------------------------------\\n1. Perform PREORDER TRAVERSAL and add value of nodes in a SET.\\n2. Sort the SET. \\n3. Return the second element of the set if the size of the SET is more than \\n   one.\\n4. Else return -1 since no second minimum element is not found. \\n----------------------------------------------------------------------------\\n\\'\\'\\'\\n\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def preorder(root, dic):\\n            if root:\\n                if root.val not in dic:\\n                    dic.append(root.val)\\n                preorder(root.left, dic)\\n                preorder(root.right, dic)\\n        dic = []\\n        preorder(root, dic)\\n        dic.sort()\\n        return dic[1] if len(dic) > 1 else -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n\\'\\'\\'\\nAlgorithm:\\n----------------------------------------------------------------------------\\n1. Perform PREORDER TRAVERSAL and add value of nodes in a SET.\\n2. Sort the SET. \\n3. Return the second element of the set if the size of the SET is more than \\n   one.\\n4. Else return -1 since no second minimum element is not found. \\n----------------------------------------------------------------------------\\n\\'\\'\\'\\n\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def preorder(root, dic):\\n            if root:\\n                if root.val not in dic:\\n                    dic.append(root.val)\\n                preorder(root.left, dic)\\n                preorder(root.right, dic)\\n        dic = []\\n        preorder(root, dic)\\n        dic.sort()\\n        return dic[1] if len(dic) > 1 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674123,
                "title": "python-bfs-faster-than-96",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        queue = deque([root])\\n        ans = float(\\'inf\\')\\n\\n        while queue:\\n            node = queue.popleft()\\n            if node.left and node.right:\\n                larger = max(node.left.val, node.right.val)\\n\\n                if larger > node.val:\\n                    ans = min(ans, larger)\\n\\n                queue.append(node.left)\\n                queue.append(node.right)\\n\\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nIdea: find the smallest value larger than root.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        queue = deque([root])\\n        ans = float(\\'inf\\')\\n\\n        while queue:\\n            node = queue.popleft()\\n            if node.left and node.right:\\n                larger = max(node.left.val, node.right.val)\\n\\n                if larger > node.val:\\n                    ans = min(ans, larger)\\n\\n                queue.append(node.left)\\n                queue.append(node.right)\\n\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211650,
                "title": "java-runtime-faster-than-100-bfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int min = Integer.MAX_VALUE;\\n        int secondMin = Integer.MAX_VALUE;\\n        boolean isChecked = false;\\n        while(!queue.isEmpty()){\\n            int queueSize = queue.size();\\n            for(int i=0; i<queueSize; i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.val<=min){\\n                    min=curr.val;\\n                }else if(curr.val<=secondMin){\\n                    secondMin= curr.val;\\n                    isChecked=true;\\n                }\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n            }\\n        }\\n        return secondMin==Integer.MAX_VALUE && !isChecked?-1:secondMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int min = Integer.MAX_VALUE;\\n        int secondMin = Integer.MAX_VALUE;\\n        boolean isChecked = false;\\n        while(!queue.isEmpty()){\\n            int queueSize = queue.size();\\n            for(int i=0; i<queueSize; i++){\\n                TreeNode curr = queue.poll();\\n                if(curr.val<=min){\\n                    min=curr.val;\\n                }else if(curr.val<=secondMin){\\n                    secondMin= curr.val;\\n                    isChecked=true;\\n                }\\n                if(curr.left!=null) queue.add(curr.left);\\n                if(curr.right!=null) queue.add(curr.right);\\n            }\\n        }\\n        return secondMin==Integer.MAX_VALUE && !isChecked?-1:secondMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691231,
                "title": "java-bfs-iterative-100-faster-easy-to-understand",
                "content": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root); int min=root.val; boolean flag=true;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode curr=q.poll();\\n                if(min<curr.val && flag){ // For the first time, find the greater value than root node\\n                    min=Math.max(curr.val, min);\\n                    flag=false;\\n                }\\n                if(curr.val!=root.val){ // find smaller element(IF EXIST) than current minimum and it should NOT be equal to root value\\n                    min=Math.min(curr.val, min);\\n                }\\n                if(curr.left!=null){q.add(curr.left);}\\n                if(curr.right!=null){q.add(curr.right);}\\n            }\\n        }\\n        return (min==root.val) ? -1 : min;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root); int min=root.val; boolean flag=true;\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode curr=q.poll();\\n                if(min<curr.val && flag){ // For the first time, find the greater value than root node\\n                    min=Math.max(curr.val, min);\\n                    flag=false;\\n                }\\n                if(curr.val!=root.val){ // find smaller element(IF EXIST) than current minimum and it should NOT be equal to root value\\n                    min=Math.min(curr.val, min);\\n                }\\n                if(curr.left!=null){q.add(curr.left);}\\n                if(curr.right!=null){q.add(curr.right);}\\n            }\\n        }\\n        return (min==root.val) ? -1 : min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 240694,
                "title": "recursive-javascript-dfs-solution-with-comments",
                "content": "Got this problem during linkedin phone interview and failed disastrously. Anyways... . Here\\'s a relatively elegant solution I came up with after studying the problem:\\n\\n```\\nfunction findSecondMinimumValue(root) {\\n    const minVal = getMinLargerThanX(root);\\n    return minVal == null ? -1 : minVal;\\n}\\n\\nfunction getMinLargerThanX(node, x = node.val /* initialize x to value of root node which contains the first minimum val */) {\\n    /* \\n    If current node value is larger then x, it\\'s a candidate of being lowest number larger than X and it\\'s descendants are going to be equal\\n    or larger anyways, so let\\'s stop here and return the candidate value (min val higher than X in subtree).\\n    */\\n  if (node.val > x) {\\n    return node.val;\\n  }\\n\\n  /*\\n  If current node has `left` (property of tree is to have two or zero sub-nodes, which means if it has `left` it also has `right`.)\\n  we determine the min value larger than x in each subtree (left and right subtree).\\n  */\\n  if (node.left) {\\n    // determine min value larger than x in each subtree.\\n    const leftMin = getMinLargerThanX(node.left, x);\\n    const rightMin = getMinLargerThanX(node.right, x);\\n\\n    if (leftMin && rightMin) {\\n        // If each subtree has a valid leftMin and rightMin (which are both larger than x), return the lesser one.\\n      return Math.min(leftMin, rightMin);\\n    } else {\\n       // If only one subtree has a value larger than x, return the min from the subtree which contains that value.\\n       // If none of the subtrees has a value larger than x, this expression will evaluate to `null`.\\n      return leftMin || rightMin;\\n    }\\n  }\\n\\n  // if node\\'s value wasn\\'t higher than x and it didn\\'t have children either, simply return `null` to indicate no value higher than x was found in this subtree.  \\n  return null;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findSecondMinimumValue(root) {\\n    const minVal = getMinLargerThanX(root);\\n    return minVal == null ? -1 : minVal;\\n}\\n\\nfunction getMinLargerThanX(node, x = node.val /* initialize x to value of root node which contains the first minimum val */) {\\n    /* \\n    If current node value is larger then x, it\\'s a candidate of being lowest number larger than X and it\\'s descendants are going to be equal\\n    or larger anyways, so let\\'s stop here and return the candidate value (min val higher than X in subtree).\\n    */\\n  if (node.val > x) {\\n    return node.val;\\n  }\\n\\n  /*\\n  If current node has `left` (property of tree is to have two or zero sub-nodes, which means if it has `left` it also has `right`.)\\n  we determine the min value larger than x in each subtree (left and right subtree).\\n  */\\n  if (node.left) {\\n    // determine min value larger than x in each subtree.\\n    const leftMin = getMinLargerThanX(node.left, x);\\n    const rightMin = getMinLargerThanX(node.right, x);\\n\\n    if (leftMin && rightMin) {\\n        // If each subtree has a valid leftMin and rightMin (which are both larger than x), return the lesser one.\\n      return Math.min(leftMin, rightMin);\\n    } else {\\n       // If only one subtree has a value larger than x, return the min from the subtree which contains that value.\\n       // If none of the subtrees has a value larger than x, this expression will evaluate to `null`.\\n      return leftMin || rightMin;\\n    }\\n  }\\n\\n  // if node\\'s value wasn\\'t higher than x and it didn\\'t have children either, simply return `null` to indicate no value higher than x was found in this subtree.  \\n  return null;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107203,
                "title": "easy-like-finding-second-minimum-element-in-an-array",
                "content": "**public int findSecondMinimumValue(TreeNode root) {\\n        int min=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.remove();\\n            if(min>temp.val){\\n                min2=min;\\n                min=temp.val;\\n            } else if(temp.val!=min && min2>temp.val){\\n                min2 = temp.val;\\n            }\\n            if(temp.left!=null){\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null){\\n                q.add(temp.right);\\n            }\\n        }\\n        if(min2==Integer.MAX_VALUE){\\n            min2=-1;\\n        }\\n        return min2;\\n    }**\\n\\nUse queue to traverse through tree and find the second minimum element as you would do in an array. This way is bfs as you move level wise.",
                "solutionTags": [],
                "code": "**public int findSecondMinimumValue(TreeNode root) {\\n        int min=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            TreeNode temp = q.remove();\\n            if(min>temp.val){\\n                min2=min;\\n                min=temp.val;\\n            } else if(temp.val!=min && min2>temp.val){\\n                min2 = temp.val;\\n            }\\n            if(temp.left!=null){\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null){\\n                q.add(temp.right);\\n            }\\n        }\\n        if(min2==Integer.MAX_VALUE){\\n            min2=-1;\\n        }\\n        return min2;\\n    }**\\n\\nUse queue to traverse through tree and find the second minimum element as you would do in an array. This way is bfs as you move level wise.",
                "codeTag": "Unknown"
            },
            {
                "id": 2555350,
                "title": "java-simple-solution-beats-100",
                "content": "Solution 2 is faster than solution 1. These two are the solutions that came to my mind.\\n# Solution 1\\n\\n```\\nclass Solution {\\n    Set<Integer> set;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        set = new TreeSet<>();\\n        inorder(root);\\n        int idx = 0;\\n        for(int i : set){\\n            if(idx == 1)return i;\\n            idx++;\\n        }\\n        return -1;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null)return;\\n        set.add(root.val);\\n        inorder(root.left);\\n        inorder(root.right);\\n    }\\n}\\n```\\n# Solution 2\\n```\\nclass Solution {\\n    int min1 = Integer.MAX_VALUE;\\n    long min2 = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inorder(root);\\n        inorder1(root);\\n        return min2 == Long.MAX_VALUE ? -1 : (int)min2;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null)return;\\n        inorder(root.left);\\n        min1 = Math.min(min1,root.val);\\n        inorder(root.right);\\n    }\\n    public void inorder1(TreeNode root){\\n        if(root == null)return;\\n        inorder1(root.left);\\n        min2 = root.val > min1 && min2 >= root.val ? root.val : min2;\\n        inorder1(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer> set;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        set = new TreeSet<>();\\n        inorder(root);\\n        int idx = 0;\\n        for(int i : set){\\n            if(idx == 1)return i;\\n            idx++;\\n        }\\n        return -1;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null)return;\\n        set.add(root.val);\\n        inorder(root.left);\\n        inorder(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int min1 = Integer.MAX_VALUE;\\n    long min2 = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inorder(root);\\n        inorder1(root);\\n        return min2 == Long.MAX_VALUE ? -1 : (int)min2;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null)return;\\n        inorder(root.left);\\n        min1 = Math.min(min1,root.val);\\n        inorder(root.right);\\n    }\\n    public void inorder1(TreeNode root){\\n        if(root == null)return;\\n        inorder1(root.left);\\n        min2 = root.val > min1 && min2 >= root.val ? root.val : min2;\\n        inorder1(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313983,
                "title": "c-efficient-recursive-solution-with-explanation",
                "content": "Observation: we will get the lowest node of the tree as the current node as all the children node are either same or greater so we can return as soon as we get a node other than the root node, as root node is the minimum node.\\n\\nUpvote if you understood the solution or feel free to ask in the comments\\n\\n```\\nclass Solution {\\npublic:\\n    long solve(TreeNode* r, int mini){\\n\\t//value are in the range [1,INT_MAX] so we need to keep record with LONG_MAX\\n        if(r == nullptr){\\n            return LONG_MAX;\\n        }\\n\\t\\t\\t//if current node is not equal to the root node then this is the possible 2nd largest\\n        if(r -> val != mini){\\n            return r -> val;\\n        }\\n\\t\\t//if this node is same as root then we need to get minimum from left and right of the node\\n        return min(solve(r -> left, mini),solve(r -> right,mini));\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        long ans = solve(root , root -> val);\\n        if(ans == LONG_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long solve(TreeNode* r, int mini){\\n\\t//value are in the range [1,INT_MAX] so we need to keep record with LONG_MAX\\n        if(r == nullptr){\\n            return LONG_MAX;\\n        }\\n\\t\\t\\t//if current node is not equal to the root node then this is the possible 2nd largest\\n        if(r -> val != mini){\\n            return r -> val;\\n        }\\n\\t\\t//if this node is same as root then we need to get minimum from left and right of the node\\n        return min(solve(r -> left, mini),solve(r -> right,mini));\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        long ans = solve(root , root -> val);\\n        if(ans == LONG_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959378,
                "title": "faster-than-100-easiest-java-solution",
                "content": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n         HashSet<Integer> list=new HashSet<>();\\n          che(root,list);\\n           List<Integer> list2 = new ArrayList<>(list);\\n        Collections.sort(list2);\\n\\n          if(list.size()<2){return -1;}\\n        return list2.get(1);\\n    }\\n    static void che(TreeNode root,HashSet list){\\n        if(root==null){return;}\\n        che(root.left,list);\\n        list.add(root.val);\\n        che(root.right,list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n         HashSet<Integer> list=new HashSet<>();\\n          che(root,list);\\n           List<Integer> list2 = new ArrayList<>(list);\\n        Collections.sort(list2);\\n\\n          if(list.size()<2){return -1;}\\n        return list2.get(1);\\n    }\\n    static void che(TreeNode root,HashSet list){\\n        if(root==null){return;}\\n        che(root.left,list);\\n        list.add(root.val);\\n        che(root.right,list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881858,
                "title": "second-minimum-node-in-a-binary-tree-solution-java",
                "content": "class Solution {\\n  public int findSecondMinimumValue(TreeNode root) {\\n    if (root == null)\\n      return -1;\\n    return findSecondMinimumValue(root, root.val);\\n  }\\n\\n  private int findSecondMinimumValue(TreeNode root, int min) {\\n    if (root == null)\\n      return -1;\\n    if (root.val > min)\\n      return root.val;\\n\\n    final int leftMin = findSecondMinimumValue(root.left, min);\\n    final int rightMin = findSecondMinimumValue(root.right, min);\\n\\n    if (leftMin == -1 || rightMin == -1)\\n      return Math.max(leftMin, rightMin);\\n    return Math.min(leftMin, rightMin);\\n  }\\n}\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public int findSecondMinimumValue(TreeNode root) {\\n    if (root == null)\\n      return -1;\\n    return findSecondMinimumValue(root, root.val);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 1767716,
                "title": "c-faster-than-100",
                "content": "```\\nvoid traverse(TreeNode* root,set<int>&s){\\n        if(root == NULL){\\n            return;\\n        }\\n        s.insert(root->val);\\n        traverse(root->left,s);\\n        traverse(root->right,s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        set<int>s;\\n        traverse(root,s);\\n\\t\\t\\n        // check if there are atleast 2 unique nodes\\n        if(s.size() < 2){ \\n            return -1;\\n        }\\n        \\n\\t\\tauto it = s.begin();     // points to 1st smallest element\\n        it++;                    // points to 2nd smallest element\\n        return *it;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid traverse(TreeNode* root,set<int>&s){\\n        if(root == NULL){\\n            return;\\n        }\\n        s.insert(root->val);\\n        traverse(root->left,s);\\n        traverse(root->right,s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        set<int>s;\\n        traverse(root,s);\\n\\t\\t\\n        // check if there are atleast 2 unique nodes\\n        if(s.size() < 2){ \\n            return -1;\\n        }\\n        \\n\\t\\tauto it = s.begin();     // points to 1st smallest element\\n        it++;                    // points to 2nd smallest element\\n        return *it;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634558,
                "title": "c-easy-solution-in-o-n-time-and-o-1-auxiliary-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void util(TreeNode* root,int &mina,int &minb,bool &f){\\n        if(root==0)\\n            return;\\n        if(root->val==INT_MAX){\\n            if(minb==INT_MAX)\\n             minb=root->val;\\n            f=1;\\n        }\\n        if(root->val<mina){\\n            mina=root->val;\\n        }\\n        else if(root->val>mina && root->val<minb){\\n            minb=root->val;\\n        }\\n        util(root->left,mina,minb,f);\\n        util(root->right,mina,minb,f);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int mina=INT_MAX;\\n        int minb=INT_MAX;\\n        bool f=0;\\n        util(root,mina,minb,f);\\n        if(mina==minb)\\n            return -1;\\n        if(f){\\n            if(minb==INT_MAX)\\n                return minb;\\n        }\\n        if(minb==INT_MAX) return -1;\\n        return minb;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void util(TreeNode* root,int &mina,int &minb,bool &f){\\n        if(root==0)\\n            return;\\n        if(root->val==INT_MAX){\\n            if(minb==INT_MAX)\\n             minb=root->val;\\n            f=1;\\n        }\\n        if(root->val<mina){\\n            mina=root->val;\\n        }\\n        else if(root->val>mina && root->val<minb){\\n            minb=root->val;\\n        }\\n        util(root->left,mina,minb,f);\\n        util(root->right,mina,minb,f);\\n        \\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int mina=INT_MAX;\\n        int minb=INT_MAX;\\n        bool f=0;\\n        util(root,mina,minb,f);\\n        if(mina==minb)\\n            return -1;\\n        if(f){\\n            if(minb==INT_MAX)\\n                return minb;\\n        }\\n        if(minb==INT_MAX) return -1;\\n        return minb;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541808,
                "title": "c-code-using-inorder-and-vector",
                "content": "vector<int> v1;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return ;\\n        inorder(root->left);\\n        v1.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        inorder(root);\\n        sort(v1.begin(),v1.end());\\n        //for find unique element in vector\\n        vector<int>::iterator ip;\\n        ip = unique(v1.begin(),v1.end());\\n        v1.resize(distance(v1.begin(),ip));\\n        int n = v1.size();\\n        if(n<2)\\n            return -1;  \\n        int temp = v1[1];\\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "vector<int> v1;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return ;\\n        inorder(root->left);\\n        v1.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        inorder(root);\\n        sort(v1.begin(),v1.end());\\n        //for find unique element in vector\\n        vector<int>::iterator ip;\\n        ip = unique(v1.begin(),v1.end());\\n        v1.resize(distance(v1.begin(),ip));\\n        int n = v1.size();\\n        if(n<2)\\n            return -1;  \\n        int temp = v1[1];\\n        return temp;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1391813,
                "title": "0ms-100-c-solution",
                "content": "```\\n    set<int>s;\\n    void check(TreeNode* root1){\\n            s.insert(root1->val);\\n        if(root1->left)\\n        check(root1->left);\\n        if(root1->right)\\n        check(root1->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        check(root);\\n        if(s.size()<2)\\n            return -1;\\n        s.erase(s.begin());\\n        auto it = s.begin();\\n      return *it;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    set<int>s;\\n    void check(TreeNode* root1){\\n            s.insert(root1->val);\\n        if(root1->left)\\n        check(root1->left);\\n        if(root1->right)\\n        check(root1->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        check(root);\\n        if(s.size()<2)\\n            return -1;\\n        s.erase(s.begin());\\n        auto it = s.begin();\\n      return *it;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1018491,
                "title": "sorted-set-inorder-beats-90-python-optimal-sol",
                "content": "Simple naive solution:\\n\\nTime: `O(NlgN)`\\nSpace `O(N)`\\n\\n```py\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        def inorder(n):\\n            if n:\\n                inorder(n.left)\\n                output.add(n.val)\\n                inorder(n.right)\\n        output = set()\\n        inorder(root)\\n        if len(output) == 1:\\n            return -1\\n        return sorted(output)[1]\\n```\\n\\nOptimal solution using special BT property:\\nTime: `O(N)`\\nSpace `O(1)`\\n```py\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        def inorder(n):\\n            if n:\\n                if smallest < n.val < self.second:\\n                    self.second = n.val\\n                elif smallest == n.val: # bcuz of the property of this special bt \\n                    inorder(n.left)\\n                    inorder(n.right)\\n        smallest = root.val\\n        self.second = float(\\'inf\\')\\n        inorder(root)\\n        return self.second if self.second != float(\\'inf\\') else -1\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```py\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        def inorder(n):\\n            if n:\\n                inorder(n.left)\\n                output.add(n.val)\\n                inorder(n.right)\\n        output = set()\\n        inorder(root)\\n        if len(output) == 1:\\n            return -1\\n        return sorted(output)[1]\\n```\n```py\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        def inorder(n):\\n            if n:\\n                if smallest < n.val < self.second:\\n                    self.second = n.val\\n                elif smallest == n.val: # bcuz of the property of this special bt \\n                    inorder(n.left)\\n                    inorder(n.right)\\n        smallest = root.val\\n        self.second = float(\\'inf\\')\\n        inorder(root)\\n        return self.second if self.second != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843335,
                "title": "0ms-solution-beats-100-runtime",
                "content": "**Please upvote if useful!**\\n```\\n priority_queue<int,vector<int>,greater<int>> pq;//min heap****\\n    void build(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        pq.push(root->val);\\n        build(root->left);\\n        build(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL)\\n            return -1;\\n        build(root);\\n        int ans=pq.top();\\n        pq.pop();\\n        while(!pq.empty())\\n        {\\n            int temp=pq.top();\\n            if(temp!=ans)\\n                return temp;\\n            else\\n                pq.pop();\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n priority_queue<int,vector<int>,greater<int>> pq;//min heap****\\n    void build(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        pq.push(root->val);\\n        build(root->left);\\n        build(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL)\\n            return -1;\\n        build(root);\\n        int ans=pq.top();\\n        pq.pop();\\n        while(!pq.empty())\\n        {\\n            int temp=pq.top();\\n            if(temp!=ans)\\n                return temp;\\n            else\\n                pq.pop();\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 712751,
                "title": "dfs-solution-using-python-3-faster-than-92",
                "content": "```\\ndef findSecondMinimumValue(self, root: TreeNode) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\tmin_val, second_min_val = root.val, float(inf)\\n\\n\\tstack = [root.left, root.right]\\n\\n\\twhile stack:\\n\\t\\tnode = stack.pop()\\n\\t\\tif node:\\n\\t\\t\\tif node.val>min_val:\\n\\t\\t\\t\\tif node.val<second_min_val:\\n\\t\\t\\t\\t\\tsecond_min_val = node.val\\n\\t\\t\\t\\t#all the nodes below will either be equal to second_min_val or greater than that\\n\\t\\t\\t\\t#so no need to check those\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif node.val<=min_val:\\n\\t\\t\\t\\tif node.val<min_val:\\n\\t\\t\\t\\t\\tsecond_min_val, min_val = min_val, node.val\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\t\\tstack.append(node.right)\\n\\treturn second_min_val if second_min_val<float(inf) else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef findSecondMinimumValue(self, root: TreeNode) -> int:\\n\\tif not root:\\n\\t\\treturn 0\\n\\tmin_val, second_min_val = root.val, float(inf)\\n\\n\\tstack = [root.left, root.right]\\n\\n\\twhile stack:\\n\\t\\tnode = stack.pop()\\n\\t\\tif node:\\n\\t\\t\\tif node.val>min_val:\\n\\t\\t\\t\\tif node.val<second_min_val:\\n\\t\\t\\t\\t\\tsecond_min_val = node.val\\n\\t\\t\\t\\t#all the nodes below will either be equal to second_min_val or greater than that\\n\\t\\t\\t\\t#so no need to check those\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\telif node.val<=min_val:\\n\\t\\t\\t\\tif node.val<min_val:\\n\\t\\t\\t\\t\\tsecond_min_val, min_val = min_val, node.val\\n\\t\\t\\t\\tstack.append(node.left)\\n\\t\\t\\t\\tstack.append(node.right)\\n\\treturn second_min_val if second_min_val<float(inf) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 348980,
                "title": "java-0-ms-pre-order-explained",
                "content": "Note that the second minimum value > minimum value, i.e. that the two mins must be distinct\\n> **T/S:** O(n)/O(n), where n = numer of nodes in the tree\\n```\\npublic int findSecondMinimumValue(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn -1;\\n\\tvar secondMin = new int[]{-1};\\n\\tpreorder(root, new int[]{root.val}, secondMin);\\n\\treturn secondMin[0];\\n}\\n\\nprivate void preorder(TreeNode root, int[] min, int[] secondMin) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\t// This is the first initialization of second min value of the tree. Do this if:\\n\\t// 1. the second min hasn\\'t been initialized yet and this node\\'s value != the minimum value in the tree, or\\n\\t// 2. this node\\'s val is smaller than the current second min val\\n\\tif (root.val != min[0] && secondMin[0] == -1 || \\n\\t\\tmin[0] < root.val && root.val < secondMin[0]) {\\n\\t\\t\\n\\t\\tsecondMin[0] = root.val;\\n\\t} else if (root.val == min[0]) {\\n\\t\\t// we need to traverse in this case because node might have a greater child or sub-child which could replace\\n\\t\\t// second minimum\\n\\t\\tpreorder(root.left, min, secondMin);\\n\\t\\tpreorder(root.right, min, secondMin);\\n\\t}\\n\\t// if node.val > second minimum, we don\\'t need to traverse further because this node and all the nodes in its\\n\\t// subtree will be greater than or equal to second minimum, so we can\\'t find anything less than second minimum\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn -1;\\n\\tvar secondMin = new int[]{-1};\\n\\tpreorder(root, new int[]{root.val}, secondMin);\\n\\treturn secondMin[0];\\n}\\n\\nprivate void preorder(TreeNode root, int[] min, int[] secondMin) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\t// This is the first initialization of second min value of the tree. Do this if:\\n\\t// 1. the second min hasn\\'t been initialized yet and this node\\'s value != the minimum value in the tree, or\\n\\t// 2. this node\\'s val is smaller than the current second min val\\n\\tif (root.val != min[0] && secondMin[0] == -1 || \\n\\t\\tmin[0] < root.val && root.val < secondMin[0]) {\\n\\t\\t\\n\\t\\tsecondMin[0] = root.val;\\n\\t} else if (root.val == min[0]) {\\n\\t\\t// we need to traverse in this case because node might have a greater child or sub-child which could replace\\n\\t\\t// second minimum\\n\\t\\tpreorder(root.left, min, secondMin);\\n\\t\\tpreorder(root.right, min, secondMin);\\n\\t}\\n\\t// if node.val > second minimum, we don\\'t need to traverse further because this node and all the nodes in its\\n\\t// subtree will be greater than or equal to second minimum, so we can\\'t find anything less than second minimum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107168,
                "title": "c-short-accepted-0ms-recursive-o-n-worst-case",
                "content": "```\\nclass Solution {\\npublic:\\n    int SecondMin(TreeNode const * root, int min_val) {\\n        if (!root) return INT_MAX;\\n        if (root->val != min_val) return root->val;\\n        return min(SecondMin(root->left, min_val), SecondMin(root->right, min_val));\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root) return -1;\\n        int sec_min = SecondMin(root, root->val);\\n        return sec_min == INT_MAX ? -1 : sec_min;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int SecondMin(TreeNode const * root, int min_val) {\\n        if (!root) return INT_MAX;\\n        if (root->val != min_val) return root->val;\\n        return min(SecondMin(root->left, min_val), SecondMin(root->right, min_val));\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root) return -1;\\n        int sec_min = SecondMin(root, root->val);\\n        return sec_min == INT_MAX ? -1 : sec_min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003921,
                "title": "simple-python-solution",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def inorderTraversal(node):\\n            if not node:\\n                return\\n            inorderTraversal(node.left)\\n            unique_values.add(node.val)\\n            inorderTraversal(node.right)\\n        unique_values = set()\\n        inorderTraversal(root)\\n        sorted_values = sorted(unique_values)\\n        if len(sorted_values) < 2:\\n            return -1\\n        return sorted_values[1]    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def inorderTraversal(node):\\n            if not node:\\n                return\\n            inorderTraversal(node.left)\\n            unique_values.add(node.val)\\n            inorderTraversal(node.right)\\n        unique_values = set()\\n        inorderTraversal(root)\\n        sorted_values = sorted(unique_values)\\n        if len(sorted_values) < 2:\\n            return -1\\n        return sorted_values[1]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416572,
                "title": "c-solution-100-time-78-98-space-inorder-traversal-set",
                "content": "# Complexity\\n- Time complexity: O(n.log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root);\\n\\n    void inorderTraversal(TreeNode *node, set<int>& s);\\n};\\n/**********************************************************/\\nint Solution::findSecondMinimumValue(TreeNode* root) {\\n    set<int> s;\\n    set<int>::iterator it;\\n    if (root != nullptr) {\\n        inorderTraversal(root, s);\\n    }\\n    if (s.size() >= 2) {\\n        it = s.begin();\\n        ++it;\\n        return *it;\\n    }\\n    return -1;\\n}\\n/**********************************************************/\\nvoid Solution::inorderTraversal(TreeNode *node, set<int>& s) {\\n    if (node->left != nullptr) {\\n        inorderTraversal(node->left, s);\\n    }\\n    s.insert(node->val);\\n    if (node->right != nullptr) {\\n        inorderTraversal(node->right, s);\\n    }\\n    return;\\n}\\n/**********************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root);\\n\\n    void inorderTraversal(TreeNode *node, set<int>& s);\\n};\\n/**********************************************************/\\nint Solution::findSecondMinimumValue(TreeNode* root) {\\n    set<int> s;\\n    set<int>::iterator it;\\n    if (root != nullptr) {\\n        inorderTraversal(root, s);\\n    }\\n    if (s.size() >= 2) {\\n        it = s.begin();\\n        ++it;\\n        return *it;\\n    }\\n    return -1;\\n}\\n/**********************************************************/\\nvoid Solution::inorderTraversal(TreeNode *node, set<int>& s) {\\n    if (node->left != nullptr) {\\n        inorderTraversal(node->left, s);\\n    }\\n    s.insert(node->val);\\n    if (node->right != nullptr) {\\n        inorderTraversal(node->right, s);\\n    }\\n    return;\\n}\\n/**********************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349422,
                "title": "python3-dfs-dfs-recursive-bfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n                                                            #DFS\\n        a = []\\n        if not root: return -1\\n        stack = [(root, root.val)]\\n        while stack:\\n            node, val = stack.pop()\\n            if node.val not in a:\\n                a.append(node.val)\\n            if node.left: stack.append((node.left, node.left.val))\\n            if node.right: stack.append((node.right, node.right.val))\\n        a.sort()\\n        return a[1] if len(a) >= 2 else -1\\n\\n        self.ans = float(\\'inf\\')\\n        min1 = root.val\\n                                                            #Recursive DFS\\n        def dfs(node):\\n            if node:\\n                if min1 < node.val < self.ans:\\n                    self.ans = node.val\\n                elif node.val == min1:\\n                    dfs(node.left)\\n                    dfs(node.right)\\n\\n        dfs(root)\\n        return self.ans if self.ans < float(\\'inf\\') else -1\\n                                                            #BFS\\n        a = []\\n        if not root: return -1\\n        dq = collections.deque([(root, root.val)])\\n        while dq:\\n            node, val = dq.popleft()\\n            if node.val not in a:\\n                a.append(node.val)\\n            if node.left: dq.append((node.left, node.left.val))\\n            if node.right: dq.append((node.right, node.right.val))\\n        a.sort()\\n        return a[1] if len(a) >= 2 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n                                                            #DFS\\n        a = []\\n        if not root: return -1\\n        stack = [(root, root.val)]\\n        while stack:\\n            node, val = stack.pop()\\n            if node.val not in a:\\n                a.append(node.val)\\n            if node.left: stack.append((node.left, node.left.val))\\n            if node.right: stack.append((node.right, node.right.val))\\n        a.sort()\\n        return a[1] if len(a) >= 2 else -1\\n\\n        self.ans = float(\\'inf\\')\\n        min1 = root.val\\n                                                            #Recursive DFS\\n        def dfs(node):\\n            if node:\\n                if min1 < node.val < self.ans:\\n                    self.ans = node.val\\n                elif node.val == min1:\\n                    dfs(node.left)\\n                    dfs(node.right)\\n\\n        dfs(root)\\n        return self.ans if self.ans < float(\\'inf\\') else -1\\n                                                            #BFS\\n        a = []\\n        if not root: return -1\\n        dq = collections.deque([(root, root.val)])\\n        while dq:\\n            node, val = dq.popleft()\\n            if node.val not in a:\\n                a.append(node.val)\\n            if node.left: dq.append((node.left, node.left.val))\\n            if node.right: dq.append((node.right, node.right.val))\\n        a.sort()\\n        return a[1] if len(a) >= 2 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317117,
                "title": "671-space-95-86-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the minimum value and second minimum value to be the root value.\\n\\n2. Define a recursive helper function to explore the tree, taking a node as input.\\n\\n3. Within the helper function, use the nonlocal keyword to access the minimum and second minimum values from the outer function scope.\\n\\n4. Check if the node value is less than the current minimum value. If it is, update the second minimum value to be the previous minimum value, and update the minimum value to be the node value.\\n\\n5. If the node value is not less than the current minimum value but is less than the current second minimum value, update the second minimum value to be the node value.\\n\\n6. Recursively call the helper function on the left and right subtrees of the current node if they exist.\\n\\n7. Call the helper function on the root node to start exploring the tree.\\n\\n8. Check if the second minimum value was updated during the exploration. If it was, return the second minimum value. Otherwise, return -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        # initialize minimum and second minimum values to be the root value\\n        min_val = root.val\\n        second_min_val = float(\\'inf\\')\\n        \\n        # recursive helper function to explore the tree\\n        def dfs(node: TreeNode) -> None:\\n            nonlocal min_val, second_min_val\\n            \\n            # check if node value is less than current minimum value\\n            if node.val < min_val:\\n                second_min_val = min_val\\n                min_val = node.val\\n            # check if node value is not less than minimum value but less than second minimum value\\n            elif node.val != min_val and node.val < second_min_val:\\n                second_min_val = node.val\\n                \\n            # explore left and right subtrees if they exist\\n            if node.left:\\n                dfs(node.left)\\n            if node.right:\\n                dfs(node.right)\\n        \\n        # explore the tree starting from the root\\n        dfs(root)\\n        \\n        # check if second minimum value was updated and return it, otherwise return -1\\n        return second_min_val if second_min_val != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        # initialize minimum and second minimum values to be the root value\\n        min_val = root.val\\n        second_min_val = float(\\'inf\\')\\n        \\n        # recursive helper function to explore the tree\\n        def dfs(node: TreeNode) -> None:\\n            nonlocal min_val, second_min_val\\n            \\n            # check if node value is less than current minimum value\\n            if node.val < min_val:\\n                second_min_val = min_val\\n                min_val = node.val\\n            # check if node value is not less than minimum value but less than second minimum value\\n            elif node.val != min_val and node.val < second_min_val:\\n                second_min_val = node.val\\n                \\n            # explore left and right subtrees if they exist\\n            if node.left:\\n                dfs(node.left)\\n            if node.right:\\n                dfs(node.right)\\n        \\n        # explore the tree starting from the root\\n        dfs(root)\\n        \\n        # check if second minimum value was updated and return it, otherwise return -1\\n        return second_min_val if second_min_val != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859222,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\n    set <int> s;\\n    \\n    void Solve(TreeNode * root)\\n    {\\n        if(!root)\\n            return ;\\n        Solve(root->left);\\n        s.insert(root->val);\\n        Solve(root->right);\\n        \\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        Solve(root);\\n        \\n          if(s.size()==1)\\n           return -1 ;\\n          s.erase(s.begin());\\n        \\n          return *s.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\n    set <int> s;\\n    \\n    void Solve(TreeNode * root)\\n    {\\n        if(!root)\\n            return ;\\n        Solve(root->left);\\n        s.insert(root->val);\\n        Solve(root->right);\\n        \\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        Solve(root);\\n        \\n          if(s.size()==1)\\n           return -1 ;\\n          s.erase(s.begin());\\n        \\n          return *s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831548,
                "title": "java-dfs",
                "content": "If you like it pls upvote\\n```\\n\\n        int min;\\n        long res = Long.MAX_VALUE;\\n\\n        public void dfs(TreeNode root) {\\n            if (root != null) {\\n\\n                if (min < root.val && root.val < res) {\\n                    res = root.val;\\n                } else if (min == root.val){\\n                    dfs(root.left);\\n                    dfs(root.right);\\n                }\\n\\n            }\\n        }\\n\\n        public int findSecondMinimumValue(TreeNode root) {\\n            if (root == null) return -1;\\n            min = root.val;\\n            dfs(root);\\n            return res < Long.MAX_VALUE ? (int) res : -1;\\n        }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n        int min;\\n        long res = Long.MAX_VALUE;\\n\\n        public void dfs(TreeNode root) {\\n            if (root != null) {\\n\\n                if (min < root.val && root.val < res) {\\n                    res = root.val;\\n                } else if (min == root.val){\\n                    dfs(root.left);\\n                    dfs(root.right);\\n                }\\n\\n            }\\n        }\\n\\n        public int findSecondMinimumValue(TreeNode root) {\\n            if (root == null) return -1;\\n            min = root.val;\\n            dfs(root);\\n            return res < Long.MAX_VALUE ? (int) res : -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749159,
                "title": "runtime-0ms-faster-than-100-00-memory-usage-40-7-mb-dfs",
                "content": "```\\n    public int firstMinValue = Integer.MAX_VALUE;\\n    public int secondMinValue = Integer.MAX_VALUE;\\n    public boolean wasSetSecondMin = false;\\n\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if (root == null) return -1;\\n\\n        dfs(root);\\n\\n        return wasSetSecondMin ? secondMinValue : -1;\\n    }\\n\\n    public void dfs(TreeNode root) {\\n        if (root == null) return;\\n\\n        if (root.val < firstMinValue) {\\n            firstMinValue = root.val;\\n        } else if (root.val > firstMinValue && root.val <= secondMinValue) {\\n            secondMinValue = root.val;\\n            wasSetSecondMin = true;\\n        }\\n\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public int firstMinValue = Integer.MAX_VALUE;\\n    public int secondMinValue = Integer.MAX_VALUE;\\n    public boolean wasSetSecondMin = false;\\n\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if (root == null) return -1;\\n\\n        dfs(root);\\n\\n        return wasSetSecondMin ? secondMinValue : -1;\\n    }\\n\\n    public void dfs(TreeNode root) {\\n        if (root == null) return;\\n\\n        if (root.val < firstMinValue) {\\n            firstMinValue = root.val;\\n        } else if (root.val > firstMinValue && root.val <= secondMinValue) {\\n            secondMinValue = root.val;\\n            wasSetSecondMin = true;\\n        }\\n\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582113,
                "title": "100-faster-using-inorder-traversal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode *root,vector<int>&v){\\n        if(root==0)\\n            return;\\n        dfs(root->left,v);\\n        v.push_back(root->val);\\n        dfs(root->right,v);\\n        sort(v.begin(),v.end());\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>v;\\n        dfs(root,v);\\n        map<int,int>mp;\\n        vector<int>v1;\\n        for(int i=0;i<v.size();i++){\\n            mp[v[i]]++;\\n        }\\n        for(auto it:mp){\\n            v1.push_back(it.first);\\n        }\\n        if(v1.size()>1)\\n        return v1[1];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode *root,vector<int>&v){\\n        if(root==0)\\n            return;\\n        dfs(root->left,v);\\n        v.push_back(root->val);\\n        dfs(root->right,v);\\n        sort(v.begin(),v.end());\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>v;\\n        dfs(root,v);\\n        map<int,int>mp;\\n        vector<int>v1;\\n        for(int i=0;i<v.size();i++){\\n            mp[v[i]]++;\\n        }\\n        for(auto it:mp){\\n            v1.push_back(it.first);\\n        }\\n        if(v1.size()>1)\\n        return v1[1];\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331184,
                "title": "c-inorder-dfs-faster-than-100-simple-approach",
                "content": "![image](https://assets.leetcode.com/users/images/40bf6f1c-0862-4e9c-9328-a592755a4292_1658743253.3787162.png)\\n\\n\\n\\n```\\nlong long a = pow(2, 31), b = pow(2, 31);\\n    \\nvoid findMin(TreeNode* root) {\\n\\tif(!root) return;\\n    findSecondMinimumValue(root->left);\\n    if (root->val < a) {\\n\\t\\tb = a;\\n\\t\\ta = root->val;\\n\\t}\\n    if (root->val < b && root->val > a) b = root->val;\\n    findSecondMinimumValue(root->right);\\n}\\n    \\nint findSecondMinimumValue(TreeNode* root) {\\n\\tfindMin(root);\\n    return b == pow(2, 31) ? -1 : b;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nlong long a = pow(2, 31), b = pow(2, 31);\\n    \\nvoid findMin(TreeNode* root) {\\n\\tif(!root) return;\\n    findSecondMinimumValue(root->left);\\n    if (root->val < a) {\\n\\t\\tb = a;\\n\\t\\ta = root->val;\\n\\t}\\n    if (root->val < b && root->val > a) b = root->val;\\n    findSecondMinimumValue(root->right);\\n}\\n    \\nint findSecondMinimumValue(TreeNode* root) {\\n\\tfindMin(root);\\n    return b == pow(2, 31) ? -1 : b;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293488,
                "title": "74-tc-and-65-sc-easy-python-solution",
                "content": "```\\ndef findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n\\tleaf = set()\\n\\tdef dfs(node):\\n\\t\\tif not(node.left):\\n\\t\\t\\tleaf.add(node.val)\\n\\t\\t\\treturn\\n\\t\\tdfs(node.left)\\n\\t\\tdfs(node.right)\\n\\tdfs(root)\\n\\treturn -1 if(len(leaf) < 2) else sorted(list(leaf))[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\ndef findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n\\tleaf = set()\\n\\tdef dfs(node):\\n\\t\\tif not(node.left):\\n\\t\\t\\tleaf.add(node.val)\\n\\t\\t\\treturn\\n\\t\\tdfs(node.left)\\n\\t\\tdfs(node.right)\\n\\tdfs(root)\\n\\treturn -1 if(len(leaf) < 2) else sorted(list(leaf))[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086672,
                "title": "python-bfs-simple-with-explanation",
                "content": "BFS solution optimized using a queue and not using a set. Explanation provided\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        # bfs\\n        # maintain two variables min1 = root.val and min2 = math.inf\\n        # any node value can be in 5 situations\\n        # when we see a node, its val can be \\n        # node.val < min1 : not possible as root.val is minimum in the subtree\\n        # node.val == min1 : search this subtree\\n        # min1<node.val < min2: update min2, but don\\'t search this subtree as this node val will be the smallest in this subtree\\n        # node.val == min2: don\\'t search this subtree, as min2 will be smallest in its subtree\\n        # node.val > min2: don\\'t search this subtree\\n\\n        q = deque()\\n        q.append(root)\\n        min1 = root.val\\n        min2 = float(\\'inf\\')\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                if min1<node.val<min2:\\n                    min2 = node.val\\n                elif node.val == min1:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n        return min2 if min2 < float(\\'inf\\') else -1\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        # bfs\\n        # maintain two variables min1 = root.val and min2 = math.inf\\n        # any node value can be in 5 situations\\n        # when we see a node, its val can be \\n        # node.val < min1 : not possible as root.val is minimum in the subtree\\n        # node.val == min1 : search this subtree\\n        # min1<node.val < min2: update min2, but don\\'t search this subtree as this node val will be the smallest in this subtree\\n        # node.val == min2: don\\'t search this subtree, as min2 will be smallest in its subtree\\n        # node.val > min2: don\\'t search this subtree\\n\\n        q = deque()\\n        q.append(root)\\n        min1 = root.val\\n        min2 = float(\\'inf\\')\\n        while q:\\n            node = q.popleft()\\n            if node:\\n                if min1<node.val<min2:\\n                    min2 = node.val\\n                elif node.val == min1:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n        return min2 if min2 < float(\\'inf\\') else -1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960481,
                "title": "faster-than-100-easy-inorder-solution-c-solution",
                "content": "```\\nvoid inorder(TreeNode* root,set<int>&s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,s);\\n        s.insert(root->val);\\n        inorder(root->right,s);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n         set<int>s;\\n        inorder(root,s);\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(s.size()==1)\\n        {\\n            return -1;\\n        }\\n        auto x=s.begin();\\n        x++;\\n        return *x;\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nvoid inorder(TreeNode* root,set<int>&s)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        inorder(root->left,s);\\n        s.insert(root->val);\\n        inorder(root->right,s);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n         set<int>s;\\n        inorder(root,s);\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(s.size()==1)\\n        {\\n            return -1;\\n        }\\n        auto x=s.begin();\\n        x++;\\n        return *x;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1834027,
                "title": "c-easiest-to-understand-and-can-use-for-most-questions",
                "content": "This approach can be use for a lot of problems like mode (use map for this), find 2, 3, 4th biggest/smallest problem etc.\\n\\nPlease give me an upvote so I can make my mom proud!\\n\\n```\\n    void helper(TreeNode* root, std::set<int>& s)\\n    {\\n        if (!root)\\n            return;\\n        \\n        s.insert(root->val);\\n        helper(root->left, s);\\n        helper(root->right, s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        std::set<int> s;\\n        \\n        helper(root, s);\\n        int count = 0;\\n        for(const auto& itr : s)\\n        {\\n            if (count == 1)\\n                return itr;\\n            ++count;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void helper(TreeNode* root, std::set<int>& s)\\n    {\\n        if (!root)\\n            return;\\n        \\n        s.insert(root->val);\\n        helper(root->left, s);\\n        helper(root->right, s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        std::set<int> s;\\n        \\n        helper(root, s);\\n        int count = 0;\\n        for(const auto& itr : s)\\n        {\\n            if (count == 1)\\n                return itr;\\n            ++count;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503077,
                "title": "c-without-stl-easy-to-understand",
                "content": "```\\nclass Solution {\\n     int first = INT_MAX, second = INT_MAX, flag = -1;\\npublic:\\n    void solve(TreeNode* root){\\n        if(!root){\\n            return;\\n        }\\n        if(root->val < first){\\n            second = first; first = root->val;\\n        }\\n        if(root->val > first && root->val <= second){\\n            second = root->val;\\n            flag = 1;\\n        }\\n        if(root->val > first && root->val > second){\\n            return;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        solve(root);\\n        return flag == -1 ? -1 : second;\\n    }\\n};\\n```\\n**If you understand this logic then upvote the answer.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     int first = INT_MAX, second = INT_MAX, flag = -1;\\npublic:\\n    void solve(TreeNode* root){\\n        if(!root){\\n            return;\\n        }\\n        if(root->val < first){\\n            second = first; first = root->val;\\n        }\\n        if(root->val > first && root->val <= second){\\n            second = root->val;\\n            flag = 1;\\n        }\\n        if(root->val > first && root->val > second){\\n            return;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        solve(root);\\n        return flag == -1 ? -1 : second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238986,
                "title": "java-100-00-arraylist-hashset",
                "content": "\\n\\t\\tclass Solution \\n      {\\n\\t\\tHashSet<Integer> hs = new  HashSet<Integer>();\\n\\t\\tpublic int findSecondMinimumValue(TreeNode root) \\n\\t\\t{\\n\\t\\t\\tpre(root);\\n\\t\\t\\tArrayList<Integer> al = new ArrayList<Integer>(hs);\\n\\t\\t\\tCollections.sort(al);\\n\\t\\t\\tif(al.size()==1)\\n            return -1;\\n\\t\\t\\treturn al.get(1);\\n\\t\\t}\\n\\t\\tpublic void pre(TreeNode root)\\n\\t\\t{\\n\\t\\t\\tif(root==null)\\n            return ;\\n\\t\\t\\tpre(root.left);\\n\\t\\t\\ths.add(root.val);\\n\\t\\t\\tpre(root.right);\\n\\t\\t}\\n\\t}\\n\\t\\n\\t![image](https://assets.leetcode.com/users/images/cc6a9df6-3946-44ed-84c2-e8e5403751f7_1642135489.2038393.png)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution \\n      {\\n\\t\\tHashSet<Integer> hs = new  HashSet<Integer>();\\n\\t\\tpublic int findSecondMinimumValue(TreeNode root) \\n\\t\\t{\\n\\t\\t\\tpre(root);\\n\\t\\t\\tArrayList<Integer> al = new ArrayList<Integer>(hs);\\n\\t\\t\\tCollections.sort(al);\\n\\t\\t\\tif(al.size()==1)\\n            return -1;\\n\\t\\t\\treturn al.get(1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1222650,
                "title": "easy-java-beats-100-solutions",
                "content": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null) return -1;\\n        if(root.right == null && root.left == null) return -1;\\n        int left = root.left.val;\\n        int right = root.right.val;\\n        if(root.val == left) {\\n            left = findSecondMinimumValue( root.left);\\n        }\\n        if(root.val == right){\\n            right = findSecondMinimumValue(root.right);\\n        }\\n        if(right != -1 && left != -1) return Math.min(right, left);\\n        else if(right == -1) return left;\\n        else return right;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null) return -1;\\n        if(root.right == null && root.left == null) return -1;\\n        int left = root.left.val;\\n        int right = root.right.val;\\n        if(root.val == left) {\\n            left = findSecondMinimumValue( root.left);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170700,
                "title": "c-very-easy-solution-using-set-0ms-100-faster",
                "content": "### C++\\nWe use a set to store the unique values of the tree by inorder traversal. Since all values in a set are automatically sorted in ascending order, we return the second value in the set. If size of set is less than 2 i.e 0 or 1, return -1.\\n```\\nclass Solution {\\npublic:\\n    \\n    set<int> s;\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        inorder(root);\\n        \\n        if(s.size()<2)\\n            return -1;\\n        \\n        int n=*next(s.begin(),1);\\n        \\n        return n;\\n        \\n    }\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)return;\\n        inorder(root->left);\\n        s.insert(root->val);\\n        inorder(root->right);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    set<int> s;\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        \\n        inorder(root);\\n        \\n        if(s.size()<2)\\n            return -1;\\n        \\n        int n=*next(s.begin(),1);\\n        \\n        return n;\\n        \\n    }\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)return;\\n        inorder(root->left);\\n        s.insert(root->val);\\n        inorder(root->right);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126053,
                "title": "java-dfs-solution",
                "content": "This question actually needs very clear thinking, very easy to get lost and over complicate it. Personal opinion: it is an excellent data structure and dfs exercise but not a fair interview question if expected to complete within 10 minutes, unless for an algorithm competition.\\n```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if (root.left == null || root.right == null) {\\n            return -1;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n        \\n        if (left == root.val) {\\n            left = findSecondMinimumValue(root.left);\\n        } \\n        \\n        if (right == root.val) {\\n            right = findSecondMinimumValue(root.right);\\n        }\\n        \\n        if (left > root.val && right > root.val) {\\n            return Math.min(left, right);\\n        }\\n        return left == -1 ? right : left;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if (root.left == null || root.right == null) {\\n            return -1;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n        \\n        if (left == root.val) {\\n            left = findSecondMinimumValue(root.left);\\n        } \\n        \\n        if (right == root.val) {\\n            right = findSecondMinimumValue(root.right);\\n        }\\n        \\n        if (left > root.val && right > root.val) {\\n            return Math.min(left, right);\\n        }\\n        return left == -1 ? right : left;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096010,
                "title": "java-0-ms-beating-100-not-the-best-way-to-code-this-i-agree",
                "content": "```\\nclass Solution {\\n    int second=-1;\\n    int top;\\n    public int findSecondMinimumValue(TreeNode root){\\n        top = root.val;\\n        secMin(root);\\n        return second;\\n    }\\n    \\n    public void secMin(TreeNode root){\\n        if(root == null) return;\\n        if(root.left!=null && (top!=root.left.val || top!=root.right.val)){\\n            if(root.right.val==top){\\n                if(second!=-1) second= Math.min(root.left.val,second);\\n                else second= root.left.val;\\n            }\\n            else if(root.left.val==top){\\n                 if(second!=-1) second= Math.min(root.right.val,second);\\n                 else second= root.right.val;\\n            }\\n            else{\\n                second = Math.min(root.left.val,Math.min(root.right.val,second));\\n            }\\n        }\\n        secMin(root.left);\\n        secMin(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int second=-1;\\n    int top;\\n    public int findSecondMinimumValue(TreeNode root){\\n        top = root.val;\\n        secMin(root);\\n        return second;\\n    }\\n    \\n    public void secMin(TreeNode root){\\n        if(root == null) return;\\n        if(root.left!=null && (top!=root.left.val || top!=root.right.val)){\\n            if(root.right.val==top){\\n                if(second!=-1) second= Math.min(root.left.val,second);\\n                else second= root.left.val;\\n            }\\n            else if(root.left.val==top){\\n                 if(second!=-1) second= Math.min(root.right.val,second);\\n                 else second= root.right.val;\\n            }\\n            else{\\n                second = Math.min(root.left.val,Math.min(root.right.val,second));\\n            }\\n        }\\n        secMin(root.left);\\n        secMin(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022244,
                "title": "c-recursive-faster-than-100",
                "content": "```\\nint findSecondMinimumValue(TreeNode* root) {\\n    \\n        if (root->left == nullptr) return -1;\\n            \\n        int min_left = root->val == root->left->val ? \\n            findSecondMinimumValue (root->left) :\\n            root->left->val; \\n        \\n        int min_right = root->val == root->right->val ?\\n            findSecondMinimumValue (root->right) :\\n            root->right->val;\\n        \\n        if (min_left == -1) return min_right;\\n        if (min_right == -1) return min_left;\\n        return std::min (min_left, min_right);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findSecondMinimumValue(TreeNode* root) {\\n    \\n        if (root->left == nullptr) return -1;\\n            \\n        int min_left = root->val == root->left->val ? \\n            findSecondMinimumValue (root->left) :\\n            root->left->val; \\n        \\n        int min_right = root->val == root->right->val ?\\n            findSecondMinimumValue (root->right) :\\n            root->right->val;\\n        \\n        if (min_left == -1) return min_right;\\n        if (min_right == -1) return min_left;\\n        return std::min (min_left, min_right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995221,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        \\n        unsigned a=UINT_MAX, b=UINT_MAX;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            if(q.front()->left)  q.push(q.front()->left);\\n            if(q.front()->right) q.push(q.front()->right);\\n            \\n            if(q.front()->val<a) {\\n                if(a<b) b=a;\\n                a=q.front()->val;\\n            }\\n            else if(q.front()->val!=a and q.front()->val<b)\\n                b=q.front()->val;\\n            \\n            q.pop();\\n        }\\n        \\n        return b!=UINT_MAX?b:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        \\n        unsigned a=UINT_MAX, b=UINT_MAX;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()) {\\n            if(q.front()->left)  q.push(q.front()->left);\\n            if(q.front()->right) q.push(q.front()->right);\\n            \\n            if(q.front()->val<a) {\\n                if(a<b) b=a;\\n                a=q.front()->val;\\n            }\\n            else if(q.front()->val!=a and q.front()->val<b)\\n                b=q.front()->val;\\n            \\n            q.pop();\\n        }\\n        \\n        return b!=UINT_MAX?b:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821393,
                "title": "100-c-easy-to-understand-using-set-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    set<int> st;\\n    void call_inorder(TreeNode *root){\\n        if(root==NULL){\\n            return;\\n        }\\n        call_inorder(root->left);\\n        st.insert(root->val);\\n        call_inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        call_inorder(root);\\n        if(st.size()<2){\\n            return -1;\\n        }\\n        auto it=st.begin();\\n        it++;\\n        return *it;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> st;\\n    void call_inorder(TreeNode *root){\\n        if(root==NULL){\\n            return;\\n        }\\n        call_inorder(root->left);\\n        st.insert(root->val);\\n        call_inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        call_inorder(root);\\n        if(st.size()<2){\\n            return -1;\\n        }\\n        auto it=st.begin();\\n        it++;\\n        return *it;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817502,
                "title": "c-dfs-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL || root->left==NULL)\\n            return -1;\\n        int first=root->val;\\n        int l=helper(root->left,first);\\n        int r=helper(root->right,first);\\n        if(l!=-1 && r!=-1)\\n            return min(l,r);\\n        return max(l,r);\\n    }\\n    \\n    int helper(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n            return -1;\\n        if(root->val==x)\\n        {\\n            int y=helper(root->left,x);\\n            int z=helper(root->right,x);\\n            \\n            if(y!=-1 && z!=-1)\\n                return min(y,z);\\n            else\\n                return max(y,z);\\n        }\\n        else\\n        {\\n            return (root->val);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL || root->left==NULL)\\n            return -1;\\n        int first=root->val;\\n        int l=helper(root->left,first);\\n        int r=helper(root->right,first);\\n        if(l!=-1 && r!=-1)\\n            return min(l,r);\\n        return max(l,r);\\n    }\\n    \\n    int helper(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n            return -1;\\n        if(root->val==x)\\n        {\\n            int y=helper(root->left,x);\\n            int z=helper(root->right,x);\\n            \\n            if(y!=-1 && z!=-1)\\n                return min(y,z);\\n            else\\n                return max(y,z);\\n        }\\n        else\\n        {\\n            return (root->val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605797,
                "title": "javascript-dfs-solution",
                "content": "```js\\nvar findSecondMinimumValue = function(node, minVal = node.val) {\\n    if (!node) return -1;\\n    if (node.val !== minVal) return node.val;\\n    \\n    const leftVal = findSecondMinimumValue(node.left, minVal);\\n    const rightVal = findSecondMinimumValue(node.right, minVal);        \\n    \\n    if (leftVal === -1 && rightVal === -1) return -1;\\n    if (leftVal === -1 || rightVal === -1) return Math.max(leftVal, rightVal);\\n\\n    return Math.min(leftVal, rightVal);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```js\\nvar findSecondMinimumValue = function(node, minVal = node.val) {\\n    if (!node) return -1;\\n    if (node.val !== minVal) return node.val;\\n    \\n    const leftVal = findSecondMinimumValue(node.left, minVal);\\n    const rightVal = findSecondMinimumValue(node.right, minVal);        \\n    \\n    if (leftVal === -1 && rightVal === -1) return -1;\\n    if (leftVal === -1 || rightVal === -1) return Math.max(leftVal, rightVal);\\n\\n    return Math.min(leftVal, rightVal);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525370,
                "title": "my-c-solution-using-minheap-pq-100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> minheap;\\n    int findSecondMinimumValue(TreeNode* root) {\\n        preorder(root);\\n        int curr = minheap.top();\\n        minheap.pop();\\n        while(!minheap.empty()){\\n            if(curr == minheap.top()){\\n                minheap.pop();\\n            }\\n            else\\n                return minheap.top();\\n        }\\n        return -1;\\n        \\n    }\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        minheap.push(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> minheap;\\n    int findSecondMinimumValue(TreeNode* root) {\\n        preorder(root);\\n        int curr = minheap.top();\\n        minheap.pop();\\n        while(!minheap.empty()){\\n            if(curr == minheap.top()){\\n                minheap.pop();\\n            }\\n            else\\n                return minheap.top();\\n        }\\n        return -1;\\n        \\n    }\\n    void preorder(TreeNode* root){\\n        if(!root) return;\\n        minheap.push(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455080,
                "title": "python3-simple-solution-using-set-function",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        values = []\\n        def getValues(root):\\n            if not root:\\n                return\\n            values.append(root.val)\\n            if root.left:\\n                getValues(root.left)\\n            if root.right:\\n                getValues(root.right)\\n        getValues(root)\\n        values = sorted(set(values))\\n        if len(values) > 1:\\n            return values[1]\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def findSecondMinimumValue(self, root: TreeNode) -> int:\\n        values = []\\n        def getValues(root):\\n            if not root:\\n                return\\n            values.append(root.val)\\n            if root.left:\\n                getValues(root.left)\\n            if root.right:\\n                getValues(root.right)\\n        getValues(root)\\n        values = sorted(set(values))\\n        if len(values) > 1:\\n            return values[1]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454986,
                "title": "javascript-recursive",
                "content": "```\\nvar findSecondMinimumValue = function(root) {\\n  \\n    const values = new Set()\\n\\n    function getValue (node) {\\n        if (!node) return\\n        if (node) values.add(node.val) \\n        if (node.left) getValue(node.left)\\n        if (node.right) getValue(node.right)\\n    }\\n    \\n    getValue(root)\\n    \\n    return values.size > 1 ? [...values].sort()[1] : -1\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findSecondMinimumValue = function(root) {\\n  \\n    const values = new Set()\\n\\n    function getValue (node) {\\n        if (!node) return\\n        if (node) values.add(node.val) \\n        if (node.left) getValue(node.left)\\n        if (node.right) getValue(node.right)\\n    }\\n    \\n    getValue(root)\\n    \\n    return values.size > 1 ? [...values].sort()[1] : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405721,
                "title": "beats-100-python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef findSecondMinimumValue(self, root: TreeNode) -> int:\\n\\t\\t\\tdef inorderTraversal(root):\\n\\t\\t\\t\\tif not root:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\tr = set(inorderTraversal(root))\\n\\t\\t\\tif len(r)>=2:\\n\\t\\t\\t\\treturn sorted(list(r))[1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findSecondMinimumValue(self, root: TreeNode) -> int:\\n\\t\\t\\tdef inorderTraversal(root):\\n\\t\\t\\t\\tif not root:\\n\\t\\t\\t\\t\\treturn []\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\\n\\t\\t\\tr = set(inorderTraversal(root))\\n\\t\\t\\tif len(r)>=2:\\n\\t\\t\\t\\treturn sorted(list(r))[1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 107175,
                "title": "6-lines-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int res = INT_MAX;\\n        DFS(root, root->val, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n    \\n    void DFS(TreeNode* root, int val, int& res){\\n        if(!root) return;\\n        if(root->val != val) res = min(res, root->val);\\n        if(root->val == val) DFS(root->left, val, res), DFS(root->right, val, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int res = INT_MAX;\\n        DFS(root, root->val, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n    \\n    void DFS(TreeNode* root, int val, int& res){\\n        if(!root) return;\\n        if(root->val != val) res = min(res, root->val);\\n        if(root->val == val) DFS(root->left, val, res), DFS(root->right, val, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107212,
                "title": "python-bfs-early-pruning",
                "content": "We can use a standard bfs to find the second minimum value, but given the fact that the root value is the smaller of both its children, we can prune this early because we do not need to further than a node that has greater value of the root value.\\n\\n    def findSecondMinimumValue(self, root):\\n        if not root or not root.left: return -1\\n        s = [root]\\n        smallest = float('inf')\\n        while s:\\n            temp = []\\n            for i in s:\\n                if i.val > root.val:\\n                    smallest = min(smallest, i.val)\\n                elif i.left:\\n                    temp.append(i.left)\\n                    temp.append(i.right) \\n            s = temp\\n        return -1 if smallest == float('inf') else smallest",
                "solutionTags": [],
                "code": "We can use a standard bfs to find the second minimum value, but given the fact that the root value is the smaller of both its children, we can prune this early because we do not need to further than a node that has greater value of the root value.\\n\\n    def findSecondMinimumValue(self, root):\\n        if not root or not root.left: return -1\\n        s = [root]\\n        smallest = float('inf')\\n        while s:\\n            temp = []\\n            for i in s:\\n                if i.val > root.val:\\n                    smallest = min(smallest, i.val)\\n                elif i.left:\\n                    temp.append(i.left)\\n                    temp.append(i.right) \\n            s = temp\\n        return -1 if smallest == float('inf') else smallest",
                "codeTag": "Python3"
            },
            {
                "id": 107235,
                "title": "c-dfs-solution",
                "content": "```\\n    public int FindSecondMinimumValue(TreeNode root) {\\n        int[] liaValue = new int[] { root.val, -1};\\n        helper( root, liaValue );\\n        return liaValue[1];\\n    }\\n    \\n    private void helper( TreeNode root, int[] piaValue ) {\\n        if ( root != null && ( piaValue[1] == -1 || root.val < piaValue[1]))  {\\n           if ( root.val != piaValue[0] ) \\n               piaValue[1] = root.val;\\n            \\n            helper( root.left, piaValue );\\n            helper( root.right, piaValue );\\n    \\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FindSecondMinimumValue(TreeNode root) {\\n        int[] liaValue = new int[] { root.val, -1};\\n        helper( root, liaValue );\\n        return liaValue[1];\\n    }\\n    \\n    private void helper( TreeNode root, int[] piaValue ) {\\n        if ( root != null && ( piaValue[1] == -1 || root.val < piaValue[1]))  {\\n           if ( root.val != piaValue[0] ) \\n               piaValue[1] = root.val;\\n            \\n            helper( root.left, piaValue );\\n            helper( root.right, piaValue );\\n    \\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 107189,
                "title": "java-dfs-no-set",
                "content": "Hi, Everyone:\\nI just want to share my solution here:\\n```\\nclass Solution {\\n    private Integer m1=null;\\n    private Integer m2=null;\\n    \\n    private void helper(TreeNode root){\\n        if(root==null)\\n            return;\\n        if( (m2==null && root.val>m1.intValue()) || (m2!=null && root.val>m1.intValue() && root.val<m2) )\\n            m2 = root.val;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        \\n        m1 = root.val;\\n        helper(root);\\n        if(m2==null)\\n            return -1;\\n        return m2.intValue();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Integer m1=null;\\n    private Integer m2=null;\\n    \\n    private void helper(TreeNode root){\\n        if(root==null)\\n            return;\\n        if( (m2==null && root.val>m1.intValue()) || (m2!=null && root.val>m1.intValue() && root.val<m2) )\\n            m2 = root.val;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        \\n        m1 = root.val;\\n        helper(root);\\n        if(m2==null)\\n            return -1;\\n        return m2.intValue();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 107249,
                "title": "c-2-lines",
                "content": "Note the trick with unsigned int to handle -1 as the large positive number. BTW, when counting lines, I only include lines with logic; so I do not count things like method signatures and closing brackets.\\n```\\nunsigned int minValue(TreeNode* r, int v) {\\n    return r->val != v ? r->val : r->left == nullptr ? -1 : min(minValue(r->left, v), minValue(r->right, v));\\n}\\nint findSecondMinimumValue(TreeNode* root) {\\n    return minValue(root, root->val);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nunsigned int minValue(TreeNode* r, int v) {\\n    return r->val != v ? r->val : r->left == nullptr ? -1 : min(minValue(r->left, v), minValue(r->right, v));\\n}\\nint findSecondMinimumValue(TreeNode* root) {\\n    return minValue(root, root->val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973200,
                "title": "easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n    Stack Space\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, int& minVal, long long& secondMin) {\\n        if (root == nullptr)\\n            return;\\n\\n        if (root->val < minVal) {\\n            secondMin = minVal;\\n            minVal = root->val;\\n        } else if (root->val > minVal && root->val < secondMin) {\\n            secondMin = root->val;\\n        }\\n\\n        helper(root->left, minVal, secondMin);\\n        helper(root->right, minVal, secondMin);\\n    }\\n\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (root == nullptr)\\n            return -1;\\n\\n        int minVal = root->val;\\n        long long secondMin = LLONG_MAX;\\n\\n        helper(root, minVal, secondMin);\\n\\n        if (secondMin == LLONG_MAX)\\n            return -1;\\n\\n        return secondMin;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, int& minVal, long long& secondMin) {\\n        if (root == nullptr)\\n            return;\\n\\n        if (root->val < minVal) {\\n            secondMin = minVal;\\n            minVal = root->val;\\n        } else if (root->val > minVal && root->val < secondMin) {\\n            secondMin = root->val;\\n        }\\n\\n        helper(root->left, minVal, secondMin);\\n        helper(root->right, minVal, secondMin);\\n    }\\n\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (root == nullptr)\\n            return -1;\\n\\n        int minVal = root->val;\\n        long long secondMin = LLONG_MAX;\\n\\n        helper(root, minVal, secondMin);\\n\\n        if (secondMin == LLONG_MAX)\\n            return -1;\\n\\n        return secondMin;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943623,
                "title": "iterative-linear-o-n-approach-beats-100-runtime-full-explanation",
                "content": "# Performance\\n![image.png](https://assets.leetcode.com/users/images/77429860-3dcd-4dcd-9168-e85eb1faf70e_1692678792.7249014.png)\\n\\n\\n# Approach\\n1. Initialize a variable `min_` with a large value (`2**32`) and a stack with the `root` node.\\n2. Start a loop that continues until the `stack` is empty.\\n3. Inside the loop, `pop` a node from the `stack`.\\n4. Compare the value of the current node with the value of the `root` node.\\n    - If they are different, update `min_` with the smaller of the current `node\\'s value` and `min_`.\\n5. If the current node has a `left` child, push the `left` child onto the `stack`.\\n6. If the current node has a `right` child, push the `right` child onto the `stack`.\\n7. After processing all nodes, return `-1` if `min_` was not updated, otherwise return the value of `min_`.\\n\\n# Complexity\\n- ### Time Complexity: $O(N)$\\nThe time complexity of the code is determined by the traversal of all nodes in the binary tree. In the worst case, the code visits every node exactly once. Therefore, the time complexity is $O(N)$, where `N` is the number of nodes in the binary tree.\\n\\n- ### Space Complexity: $O(N)$\\nThe space complexity of the code is determined by the space required to store the `stack` for the depth-first traversal. In the worst case, the `stack` can hold all nodes in a branch of the binary tree, which corresponds to the height of the tree.\\n\\nIn a balanced binary tree, the height is approximately $log\\u2082(N)$, where` N` is the number of nodes. In the worst case, when the tree is completely unbalanced (essentially a linked list), the height becomes `N`.\\n\\n*Therefore, the space complexity can vary:*\\n\\n`Balanced Binary Tree`: $O(log N)$\\n`Unbalanced Binary Tree`: $O(N)$\\n\\nThe `min_` variable, regardless of the value it holds, takes constant space as it\\'s a single integer variable.\\n\\nIn conclusion, the code has a time complexity of $O(N)$ and a space complexity that depends on the height of the binary tree, varying between $O(log N)$ for balanced trees and $O(N)$ for completely unbalanced trees.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        min_ = 2**32\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node.val != root.val:\\n                min_ = min(min_,node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return -1 if min_ == 2**32 else min_\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findSecondMinimumValue(self, root):\\n        min_ = 2**32\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node.val != root.val:\\n                min_ = min(min_,node.val)\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return -1 if min_ == 2**32 else min_\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706831,
                "title": "second-minimum-node-in-a-binary-tree-easy-java-sol",
                "content": "# Complexity\\n- Time complexity:O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashSet<Integer> set;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        set = new HashSet<>();\\n        inorder(root);\\n\\n        List<Integer> list = new ArrayList<>(set);\\n\\n        return helper(list);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        set.add(root.val);\\n        inorder(root.right);\\n    }\\n    public int helper(List<Integer> list){\\n        // collection.sort(list, collections.reverseOrder());\\n        if(list.size() == 0){\\n            return -1;\\n        }\\n        if(list.size() == 1){\\n            return -1;\\n        }\\n        Collections.sort(list);\\n        return list.get(1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree",
                    "Hash Function"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashSet<Integer> set;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        set = new HashSet<>();\\n        inorder(root);\\n\\n        List<Integer> list = new ArrayList<>(set);\\n\\n        return helper(list);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        set.add(root.val);\\n        inorder(root.right);\\n    }\\n    public int helper(List<Integer> list){\\n        // collection.sort(list, collections.reverseOrder());\\n        if(list.size() == 0){\\n            return -1;\\n        }\\n        if(list.size() == 1){\\n            return -1;\\n        }\\n        Collections.sort(list);\\n        return list.get(1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660694,
                "title": "shortest-and-easiest-implementation-using-dfs-c-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans = LONG_MAX;\\n    void dfs(TreeNode* node, int x){\\n        if(!node) return;\\n        if(node->val != x && node->val < ans) ans = node->val;\\n        dfs(node->left,x);\\n        dfs(node->right,x);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        dfs(root,root->val);\\n        return ans != LONG_MAX ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long ans = LONG_MAX;\\n    void dfs(TreeNode* node, int x){\\n        if(!node) return;\\n        if(node->val != x && node->val < ans) ans = node->val;\\n        dfs(node->left,x);\\n        dfs(node->right,x);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        dfs(root,root->val);\\n        return ans != LONG_MAX ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617348,
                "title": "easy-solution-using-recursion-and-sort",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    \\n        void solve(TreeNode* root,vector<int>&res){\\n            if(root==NULL){\\n                return;\\n            }\\n            else{\\n                res.push_back(root->val);\\n                solve(root->left,res);\\n                solve(root->right,res);\\n            }\\n        }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>hu;\\n        solve(root,hu);\\n        map<int,int>jk;\\n        vector<int>po;\\n        for (int i=0;i<hu.size();++i){\\n            jk[hu[i]]++;\\n        }\\n        for(auto i:jk){\\n            cout<<i.first<<endl;\\n            po.push_back(i.first);\\n        }\\n        int ui=po.size();\\n        if(ui>1)\\n        {\\n        sort(po.begin(),po.end());\\n        return po[1];\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    \\n        void solve(TreeNode* root,vector<int>&res){\\n            if(root==NULL){\\n                return;\\n            }\\n            else{\\n                res.push_back(root->val);\\n                solve(root->left,res);\\n                solve(root->right,res);\\n            }\\n        }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>hu;\\n        solve(root,hu);\\n        map<int,int>jk;\\n        vector<int>po;\\n        for (int i=0;i<hu.size();++i){\\n            jk[hu[i]]++;\\n        }\\n        for(auto i:jk){\\n            cout<<i.first<<endl;\\n            po.push_back(i.first);\\n        }\\n        int ui=po.size();\\n        if(ui>1)\\n        {\\n        sort(po.begin(),po.end());\\n        return po[1];\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3586470,
                "title": "easiest-approach-using-array-and-inorder-beats-100-beginner-friendly-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void push(TreeNode* root, vector<int> & v){\\n        if(!root){\\n            return;\\n        }\\n        push(root->left,v);\\n        v.push_back(root->val);\\n        push(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> ans;\\n        push(root,ans);\\n        sort(ans.begin(),ans.end());\\n        int mini = ans[0];\\n        int n = ans.size();\\n        if(ans[0]==ans[n-1]){\\n            return -1;\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            if(mini<ans[i]){\\n                mini = ans[i];\\n                break;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void push(TreeNode* root, vector<int> & v){\\n        if(!root){\\n            return;\\n        }\\n        push(root->left,v);\\n        v.push_back(root->val);\\n        push(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> ans;\\n        push(root,ans);\\n        sort(ans.begin(),ans.end());\\n        int mini = ans[0];\\n        int n = ans.size();\\n        if(ans[0]==ans[n-1]){\\n            return -1;\\n        }\\n        for(int i = 0 ; i<n ; i++){\\n            if(mini<ans[i]){\\n                mini = ans[i];\\n                break;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461074,
                "title": "0-ms-java-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n      class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        Collections.sort(list);\\n        if (list.size() < 2) {\\n            return -1;\\n        }\\n        return list.get(1);\\n    }\\n\\n    private void inorder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left, list);\\n        if (!list.contains(root.val)) {\\n            list.add(root.val);\\n        }\\n        inorder(root.right, list);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n      class Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        Collections.sort(list);\\n        if (list.size() < 2) {\\n            return -1;\\n        }\\n        return list.get(1);\\n    }\\n\\n    private void inorder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left, list);\\n        if (!list.contains(root.val)) {\\n            list.add(root.val);\\n        }\\n        inorder(root.right, list);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299616,
                "title": "very-easy-0ms-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        TreeSet<Integer>a=new TreeSet();\\n    public void collect(TreeNode root){\\n        if(root==null)return;\\n        a.add(root.val);\\n        collect(root.right);\\n        collect(root.left);\\n    }\\n    public int findSecondMinimumValue(TreeNode root) {\\n        collect(root);\\n        if(a.size()<=1){\\n            return -1;\\n        }\\n        int first=a.pollFirst();\\n        int second=a.pollFirst();\\n        return second;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        TreeSet<Integer>a=new TreeSet();\\n    public void collect(TreeNode root){\\n        if(root==null)return;\\n        a.add(root.val);\\n        collect(root.right);\\n        collect(root.left);\\n    }\\n    public int findSecondMinimumValue(TreeNode root) {\\n        collect(root);\\n        if(a.size()<=1){\\n            return -1;\\n        }\\n        int first=a.pollFirst();\\n        int second=a.pollFirst();\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254095,
                "title": "easy-understand-solution-runtime-0ms-faster-than-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like my solution please upvote\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int min=-1;\\n    int secondMin=Integer.MAX_VALUE;\\n    boolean flag=false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null)return secondMin;\\n        min =root.val;\\n        help(root);\\n        if(!flag){return -1;}\\n        return secondMin;\\n    }\\n    public void help(TreeNode root){\\n        if(root == null)return;\\n        if(min< root.val && root.val<= secondMin){\\n            secondMin = root.val;\\n            flag = true;\\n        }\\n        help(root.left);\\n        help(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int min=-1;\\n    int secondMin=Integer.MAX_VALUE;\\n    boolean flag=false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null)return secondMin;\\n        min =root.val;\\n        help(root);\\n        if(!flag){return -1;}\\n        return secondMin;\\n    }\\n    public void help(TreeNode root){\\n        if(root == null)return;\\n        if(min< root.val && root.val<= secondMin){\\n            secondMin = root.val;\\n            flag = true;\\n        }\\n        help(root.left);\\n        help(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222460,
                "title": "c-using-recursion-basic-logic",
                "content": "```\\nclass Solution {\\n    long int smallest=2147483648,secondsmall=2147483648;\\n    void inorder(TreeNode*node){\\n        if(node==NULL) return;\\n        if(node->val<smallest) smallest=node->val;\\n        if(node->val>smallest && node->val<secondsmall){\\n            secondsmall=node->val;\\n        }\\n        if(node->left)  inorder(node->left);\\n        if(node->right) inorder(node->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root){\\n        inorder(root);\\n        if(secondsmall==2147483648) return -1;\\n        return secondsmall;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long int smallest=2147483648,secondsmall=2147483648;\\n    void inorder(TreeNode*node){\\n        if(node==NULL) return;\\n        if(node->val<smallest) smallest=node->val;\\n        if(node->val>smallest && node->val<secondsmall){\\n            secondsmall=node->val;\\n        }\\n        if(node->left)  inorder(node->left);\\n        if(node->right) inorder(node->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root){\\n        inorder(root);\\n        if(secondsmall==2147483648) return -1;\\n        return secondsmall;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222136,
                "title": "four-liner-recursive-traversal-0-ms-beats-100",
                "content": "# Code\\n\\n```swift\\nfunc findSecondMinimumValue(_ root: TreeNode?) -> Int {\\n    let nums = numSet(root).sorted()\\n    return nums.count > 1 ? nums[1] : -1\\n}\\n\\nprivate func numSet(_ root: TreeNode?) -> Set<Int> {\\n    guard let root = root else { return [] }\\n    return Set([root.val]).union(numSet(root.left)).union(numSet(root.right))\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nfunc findSecondMinimumValue(_ root: TreeNode?) -> Int {\\n    let nums = numSet(root).sorted()\\n    return nums.count > 1 ? nums[1] : -1\\n}\\n\\nprivate func numSet(_ root: TreeNode?) -> Set<Int> {\\n    guard let root = root else { return [] }\\n    return Set([root.val]).union(numSet(root.left)).union(numSet(root.right))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109106,
                "title": "c-recursion-esay-esay-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    set<int>s;\\n    void result(TreeNode* root){\\n        if(root==0){\\n            return;\\n        }\\n        s.insert(root->val);\\n        result(root->left);\\n        result(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==0) return -1;\\n        result(root);\\n        set<int>::iterator itr=s.begin();\\n        itr++;\\n        if(s.size()>1) return *itr;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    set<int>s;\\n    void result(TreeNode* root){\\n        if(root==0){\\n            return;\\n        }\\n        s.insert(root->val);\\n        result(root->left);\\n        result(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==0) return -1;\\n        result(root);\\n        set<int>::iterator itr=s.begin();\\n        itr++;\\n        if(s.size()>1) return *itr;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888680,
                "title": "simple-python-solution-upto-98-faster",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def trav(root, final):\\n            if not root:\\n                return None\\n            if root.val not in final:\\n                final.append(root.val)\\n\\n            if root.left:\\n                trav(root.left,final)\\n            \\n            if root.right:\\n                trav(root.right,final)\\n            \\n            return final\\n\\n        final = trav(root,[])\\n        final = sorted(final)\\n        #print(final)\\n        if len(final)>=2:\\n            return final[1]\\n        else:\\n            return -1\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def trav(root, final):\\n            if not root:\\n                return None\\n            if root.val not in final:\\n                final.append(root.val)\\n\\n            if root.left:\\n                trav(root.left,final)\\n            \\n            if root.right:\\n                trav(root.right,final)\\n            \\n            return final\\n\\n        final = trav(root,[])\\n        final = sorted(final)\\n        #print(final)\\n        if len(final)>=2:\\n            return final[1]\\n        else:\\n            return -1\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861196,
                "title": "second-minimum-node-in-a-binary-tree-0-ms-beats-100",
                "content": "# Intuition\\nwe have given two critical point:\\n1. root of all tree will be smalllest no by observing given tree we can find out.\\n2. now we just need to find a node greter then root and less than all element.\\n\\n# Approach\\nTo get second Smallest you need to store root value as first smallest and travarse all trough the tree to find second smalllest.\\n\\n#there is edge case where node value is equal to INT_MAX so we also need a flag for whether we find such node which is greater than root value and  less than other\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO( 1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     \\n     void helper(TreeNode* root,int fs,int &ans,int &f){\\n           if(root==NULL)\\n             return ;\\n            \\n            helper(root->left,fs,ans,f);\\n            helper(root->right,fs,ans,f);\\n\\n            if(root->val >fs && root->val<=ans){\\n                 f=1;\\n                ans=root->val;\\n            }\\n     }\\n\\n    int findSecondMinimumValue(TreeNode* root) {  \\n        int ans=INT_MAX;   \\n        int f=0;\\n        helper(root,root->val,ans,f);\\n        \\n        if(f==0)\\n         return -1;\\n\\n    return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     \\n     void helper(TreeNode* root,int fs,int &ans,int &f){\\n           if(root==NULL)\\n             return ;\\n            \\n            helper(root->left,fs,ans,f);\\n            helper(root->right,fs,ans,f);\\n\\n            if(root->val >fs && root->val<=ans){\\n                 f=1;\\n                ans=root->val;\\n            }\\n     }\\n\\n    int findSecondMinimumValue(TreeNode* root) {  \\n        int ans=INT_MAX;   \\n        int f=0;\\n        helper(root,root->val,ans,f);\\n        \\n        if(f==0)\\n         return -1;\\n\\n    return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847943,
                "title": "c-runtime-0ms-100-faster-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<int>nums;\\n        while(!q.empty()){\\n            TreeNode *curr=q.front();\\n            nums.push_back(curr->val);\\n            if(curr->left!=NULL){\\n                q.push(curr->left);\\n            }\\n            if(curr->right!=NULL){\\n                q.push(curr->right);\\n            }\\n            q.pop();\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int>::iterator i;\\n        i=unique(nums.begin(),nums.end());\\n        nums.resize(distance(nums.begin(),i));\\n        if(nums.size()==1){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        vector<int>nums;\\n        while(!q.empty()){\\n            TreeNode *curr=q.front();\\n            nums.push_back(curr->val);\\n            if(curr->left!=NULL){\\n                q.push(curr->left);\\n            }\\n            if(curr->right!=NULL){\\n                q.push(curr->right);\\n            }\\n            q.pop();\\n        }\\n        sort(nums.begin(),nums.end());\\n        vector<int>::iterator i;\\n        i=unique(nums.begin(),nums.end());\\n        nums.resize(distance(nums.begin(),i));\\n        if(nums.size()==1){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811094,
                "title": "100-faster-c-for-beginners",
                "content": "class Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans)\\n{\\nif(!root) return;\\n\\n    ans.push_back(root->val);\\n    inorder(root->left,ans);\\n    inorder(root->right,ans);\\n    \\n}\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root) return -1;\\n        vector<int> ans;\\n        inorder(root,ans);\\n        \\n        sort(ans.begin(),ans.end());\\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\\n        if(ans.size()==1) return -1;\\n        else return ans[1];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int> &ans)\\n{\\nif(!root) return;\\n\\n    ans.push_back(root->val);\\n    inorder(root->left,ans);\\n    inorder(root->right,ans);\\n    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 2791725,
                "title": "easiest-solution-c-plus-plus-recursion-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n// please upvote if it is helpful.\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,set<int> &st){\\n        if(!root) return;\\n        st.insert(root->val);\\n        solve(root->left,st);\\n        solve(root->right,st);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> st;\\n        solve(root,st);\\n        vector<int> vec;\\n        for(auto i:st) vec.push_back(i);\\n        sort(vec.begin(),vec.end());\\n        return vec.size()>1?vec[1]:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n// please upvote if it is helpful.\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,set<int> &st){\\n        if(!root) return;\\n        st.insert(root->val);\\n        solve(root->left,st);\\n        solve(root->right,st);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> st;\\n        solve(root,st);\\n        vector<int> vec;\\n        for(auto i:st) vec.push_back(i);\\n        sort(vec.begin(),vec.end());\\n        return vec.size()>1?vec[1]:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776798,
                "title": "0ms-100-faster-solution-simple-tree-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ \\n    Because of Recursive Call Stack \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int min = Integer.MAX_VALUE;\\n\\n    static boolean flag = false;\\n\\n    static void findMin( TreeNode root ){\\n\\n        if( root == null ) return;\\n\\n        if( root.left != null && root.left.val != root.val ){\\n            min = Math.min(min , root.left.val);\\n            flag = true;\\n        }\\n\\n        if(  root.right != null && root.right.val != root.val ){\\n            min = Math.min( min , root.right.val );\\n            flag = true;\\n        }\\n\\n        findMin( root.left );\\n\\n        findMin( root.right );\\n\\n    }\\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n\\n        min = Integer.MAX_VALUE;\\n\\n        flag = false;\\n\\n        findMin( root );\\n\\n        if( min == Integer.MAX_VALUE && !flag ){\\n            return -1;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int min = Integer.MAX_VALUE;\\n\\n    static boolean flag = false;\\n\\n    static void findMin( TreeNode root ){\\n\\n        if( root == null ) return;\\n\\n        if( root.left != null && root.left.val != root.val ){\\n            min = Math.min(min , root.left.val);\\n            flag = true;\\n        }\\n\\n        if(  root.right != null && root.right.val != root.val ){\\n            min = Math.min( min , root.right.val );\\n            flag = true;\\n        }\\n\\n        findMin( root.left );\\n\\n        findMin( root.right );\\n\\n    }\\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n\\n        min = Integer.MAX_VALUE;\\n\\n        flag = false;\\n\\n        findMin( root );\\n\\n        if( min == Integer.MAX_VALUE && !flag ){\\n            return -1;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722522,
                "title": "used-set",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void ino(TreeNode* r, set<int> &s)\\n    {\\n        if(!r)\\n            return;\\n        ino(r->left,s);\\n        s.insert(r->val);\\n        ino(r->right,s);\\n    }\\n    int findSecondMinimumValue(TreeNode* r) {\\n        set<int> s;\\n        ino(r,s);\\n        \\n        if(s.size()<=1)\\n            return -1;\\n        int j = 0;\\n        for(auto i: s)\\n        {\\n            if(j==1)\\n                return i;\\n            j++;\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void ino(TreeNode* r, set<int> &s)\\n    {\\n        if(!r)\\n            return;\\n        ino(r->left,s);\\n        s.insert(r->val);\\n        ino(r->right,s);\\n    }\\n    int findSecondMinimumValue(TreeNode* r) {\\n        set<int> s;\\n        ino(r,s);\\n        \\n        if(s.size()<=1)\\n            return -1;\\n        int j = 0;\\n        for(auto i: s)\\n        {\\n            if(j==1)\\n                return i;\\n            j++;\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695952,
                "title": "you-just-need-to-realize-one-truth",
                "content": "Think about the definition of the tree: `root.val = min(root.left.val, root.right.val)` twenty times then you will finally notice the fact that:\\n* The primary root is the smallest one (or one of the ...);\\n* **If a child is bigger than the parent, then the child might be the second-smallest one, and the whole sub-tree starting from this child can be skipped.**\\n\\nTherefore, you only need to do an old-school O(n) traversal to examine the nodes one by one, however, the fact mentioned above in bold can save you a lot of time unless your have very bad luck --- the worse case is O(n).\\n\\n*(The following code was reported 0ms and beating 100%. But I guess the test data is not big enough.)*\\n\\n```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        uint32_t res = UINT_MAX;\\n\\t\\t\\n        while(!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\t\\t\\t\\n            if (p->val > root->val) {\\n                res = std::min(res, (uint32_t) p->val);\\n\\t\\t\\t\\t// no more q.push here, say goodbye to the whole sub-tree\\n            } else { // p->val == root->val\\n                if (p->left) q.push(p->left);\\n                if (p->right) q.push(p->right);                \\n            }\\n        }\\n\\t\\t\\n        return res == UINT_MAX ? -1 : (int) res;\\n    }\\n};\\n```\\n\\nI thought about it for ~10 mins in my sofa and during this time, I wanted to give up many times, but finally I got it. However, I am pretty sure that if I were not in my sofa, if I were staring at an interviewer\\'s face, I would collapse and never find the answer.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        uint32_t res = UINT_MAX;\\n\\t\\t\\n        while(!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n\\t\\t\\t\\n            if (p->val > root->val) {\\n                res = std::min(res, (uint32_t) p->val);\\n\\t\\t\\t\\t// no more q.push here, say goodbye to the whole sub-tree\\n            } else { // p->val == root->val\\n                if (p->left) q.push(p->left);\\n                if (p->right) q.push(p->right);                \\n            }\\n        }\\n\\t\\t\\n        return res == UINT_MAX ? -1 : (int) res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2582110,
                "title": "c-100-fastest-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int smallest, second;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root)\\n        return;\\n        \\n        if(root->val>smallest and (root->val<second or second==-1))\\n        second=root->val;\\n        \\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        smallest=root->val;\\n        second=-1;\\n        solve(root);\\n        \\n        return second;\\n    }\\n};\\n```\\nUpvote if it helps !\\nT.C O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int smallest, second;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root)\\n        return;\\n        \\n        if(root->val>smallest and (root->val<second or second==-1))\\n        second=root->val;\\n        \\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        smallest=root->val;\\n        second=-1;\\n        solve(root);\\n        \\n        return second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577364,
                "title": "simple-python",
                "content": "```\\ndef findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n\\tarr = sorted(set(self.treeToList(root)))\\n\\tif len(arr) < 2:\\n\\t\\treturn -1\\n\\telse:\\n\\t\\treturn arr[1]\\n\\ndef treeToList(self, root):\\n\\tif root is None:\\n\\t\\treturn []\\n\\treturn self.treeToList(root.left) + [root.val] + self.treeToList(root.right)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n\\tarr = sorted(set(self.treeToList(root)))\\n\\tif len(arr) < 2:\\n\\t\\treturn -1\\n\\telse:\\n\\t\\treturn arr[1]\\n\\ndef treeToList(self, root):\\n\\tif root is None:\\n\\t\\treturn []\\n\\treturn self.treeToList(root.left) + [root.val] + self.treeToList(root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2550134,
                "title": "java-very-easy-solution-100-faster-easy-to-read",
                "content": "```\\nclass Solution { \\n     long min = Long.MAX_VALUE;\\n     long secmin = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n         smallest(root);\\n         secondmin(root);\\n         return secmin == Long.MAX_VALUE ? -1 : (int)secmin;\\n    }\\n    \\n    public void smallest(TreeNode node){\\n        if(node == null) return;\\n        \\n        smallest(node.left);\\n        min = min > node.val ? node.val : min;\\n        smallest(node.right);\\n    }\\n    \\n    public void secondmin(TreeNode node){\\n        if(node == null) return;\\n        \\n        secondmin(node.left);\\n         if(node.val > min && secmin > node.val){\\n             secmin = node.val;\\n         }\\n        secondmin(node.right);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n     long min = Long.MAX_VALUE;\\n     long secmin = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n         smallest(root);\\n         secondmin(root);\\n         return secmin == Long.MAX_VALUE ? -1 : (int)secmin;\\n    }\\n    \\n    public void smallest(TreeNode node){\\n        if(node == null) return;\\n        \\n        smallest(node.left);\\n        min = min > node.val ? node.val : min;\\n        smallest(node.right);\\n    }\\n    \\n    public void secondmin(TreeNode node){\\n        if(node == null) return;\\n        \\n        secondmin(node.left);\\n         if(node.val > min && secmin > node.val){\\n             secmin = node.val;\\n         }\\n        secondmin(node.right);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542495,
                "title": "recurssion-travel-and-change-statergy",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    long firstMin = Long.MAX_VALUE;\\n    long secondMin = Long.MAX_VALUE;\\n  \\n    public int findSecondMinimumValue(TreeNode root) {\\n        utilfindSecondMinimumValue(root);\\n        if (secondMin == Long.MAX_VALUE) return -1;\\n        int ans = (int)secondMin;\\n        return ans;\\n    }\\n    public void utilfindSecondMinimumValue(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.val < firstMin) {\\n            secondMin = firstMin;\\n            firstMin = root.val;\\n        } else if (root.val != firstMin && root.val < secondMin) {\\n            secondMin = root.val;\\n        }\\n        utilfindSecondMinimumValue(root.left);\\n        utilfindSecondMinimumValue(root.right);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    long firstMin = Long.MAX_VALUE;\\n    long secondMin = Long.MAX_VALUE;\\n  \\n    public int findSecondMinimumValue(TreeNode root) {\\n        utilfindSecondMinimumValue(root);\\n        if (secondMin == Long.MAX_VALUE) return -1;\\n        int ans = (int)secondMin;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2535228,
                "title": "fast-python-dfs-solution-98",
                "content": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        vals = set()\\n        def dfs(root):\\n            if root is None: return\\n            vals.add(root.val)\\n            dfs(root.left)\\n            dfs(root.right)\\n        dfs(root)\\n        min_val, res = min(vals), float(\"inf\")\\n        for val in vals:\\n            if min_val < val < res:\\n                res = val\\n        return res if res != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        vals = set()\\n        def dfs(root):\\n            if root is None: return\\n            vals.add(root.val)\\n            dfs(root.left)\\n            dfs(root.right)\\n        dfs(root)\\n        min_val, res = min(vals), float(\"inf\")\\n        for val in vals:\\n            if min_val < val < res:\\n                res = val\\n        return res if res != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513898,
                "title": "c-solution-100-faster-0-ms-time-taken",
                "content": "### **Approach :**\\n**Function Name :** ```inorder( TreeNode* root, set<int> &s) ```\\n**Return type :** ```void```\\n\\n- Passing **set** as a refrence to the **inorder traversal** and store all node values into the **set**.\\n- Erase the ```1st smallest``` value from the set. ```s.erase(s.begin())``` .\\n- Then check the size of the set if size ```<1``` then ```return -1``` else ```return *s.begin()``` . \\n- **Note :** ```s.begin()``` returns the **pointer** but we need **value stored** at that pointer so we ```return *s.begin()``` .\\n\\n**If you like and understood the solution then don\\'t forget to upvote solution .**\\n\\n### **Solution :**\\n\\n```C++\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,set<int> &s){\\n        if(root==NULL) return;\\n        inorder(root->left,s);\\n        s.insert(root->val);\\n        inorder(root->right,s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        inorder(root,s);\\n        s.erase(s.begin());\\n        return (s.size()<1)? -1:*s.begin();\\n    }\\n};\\n```\\n\\n**If you like and understood the solution then don\\'t forget to upvote solution .**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```inorder( TreeNode* root, set<int> &s) ```\n```void```\n```1st smallest```\n```s.erase(s.begin())```\n```<1```\n```return -1```\n```return *s.begin()```\n```s.begin()```\n```return *s.begin()```\n```C++\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,set<int> &s){\\n        if(root==NULL) return;\\n        inorder(root->left,s);\\n        s.insert(root->val);\\n        inorder(root->right,s);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        inorder(root,s);\\n        s.erase(s.begin());\\n        return (s.size()<1)? -1:*s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483035,
                "title": "c-0-ms-100-faster-simple-understanding-simple-recursion",
                "content": "Here it is given that we have to find the second minimum node, in order to do so we will just check the another node greater than current node value since current node value will the minimum value. \\nif we encounter the same value as root node we will skip it.\\n\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Second Minimum Node In a Binary Tree.\\nMemory Usage: 7.1 MB, less than 71.41% of C++ online submissions for Second Minimum Node In a Binary Tree.\\n\\n\\nHere is the code, \\n\\n///\\n\\nclass Solution {\\npublic:\\n\\n\\n    long long int ans = LLONG_MAX;\\n    void findMin(TreeNode* root, int data)\\n    {\\n        if(!root)\\n            return;\\n        if(root->val >= ans)  // if the value is same or greater then ans , just skip \\n            return;\\n        if(root->val != data && (ans > root->val))  // if the value is low then ans, update \\n            ans = root->val;\\n        \\n        findMin(root->left,data);\\n        findMin(root->right,data);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        findMin(root,root->val);\\n        if(ans == LLONG_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n\\n// UPVOTE if it helps.\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    long long int ans = LLONG_MAX;\\n    void findMin(TreeNode* root, int data)\\n    {\\n        if(!root)\\n            return;\\n        if(root->val >= ans)  // if the value is same or greater then ans , just skip \\n            return;\\n        if(root->val != data && (ans > root->val))  // if the value is low then ans, update \\n            ans = root->val;\\n        \\n        findMin(root->left,data);\\n        findMin(root->right,data);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475394,
                "title": "c-100-fast-solution-easy-level-order-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstSmallest(TreeNode* root){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int smallest = root->val;\\n        while(!q.empty()){\\n            TreeNode * temp = q.front();\\n            q.pop();\\n            if(temp->left){\\n                smallest = min (smallest, temp->left->val);\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                smallest = min (smallest, temp->right->val);\\n                q.push(temp->right);\\n            }\\n        }\\n        return smallest;\\n    }\\n    \\n    int secondSmallest(TreeNode* root, int smallest){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int secondSmallest = INT_MAX;\\n        bool found = false;\\n        while(!q.empty()){\\n            TreeNode * temp = q.front();\\n            q.pop();\\n            if(temp->left){\\n                if(temp->left->val>smallest and temp->left->val <= secondSmallest) secondSmallest = temp->left->val, found = true;;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                if(temp->right->val > smallest and temp->right->val <= secondSmallest) secondSmallest = temp->right->val, found = true;;\\n                q.push(temp->right);\\n            }\\n        }\\n        if(!found) return -1;\\n        return secondSmallest;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        int smallest = firstSmallest(root);\\n        return secondSmallest(root, smallest);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstSmallest(TreeNode* root){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int smallest = root->val;\\n        while(!q.empty()){\\n            TreeNode * temp = q.front();\\n            q.pop();\\n            if(temp->left){\\n                smallest = min (smallest, temp->left->val);\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                smallest = min (smallest, temp->right->val);\\n                q.push(temp->right);\\n            }\\n        }\\n        return smallest;\\n    }\\n    \\n    int secondSmallest(TreeNode* root, int smallest){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int secondSmallest = INT_MAX;\\n        bool found = false;\\n        while(!q.empty()){\\n            TreeNode * temp = q.front();\\n            q.pop();\\n            if(temp->left){\\n                if(temp->left->val>smallest and temp->left->val <= secondSmallest) secondSmallest = temp->left->val, found = true;;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                if(temp->right->val > smallest and temp->right->val <= secondSmallest) secondSmallest = temp->right->val, found = true;;\\n                q.push(temp->right);\\n            }\\n        }\\n        if(!found) return -1;\\n        return secondSmallest;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        int smallest = firstSmallest(root);\\n        return secondSmallest(root, smallest);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463457,
                "title": "python-solution-simple-easy-and-faster",
                "content": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        self.res=[]\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left):\\n                dsf(root.left)\\n            if(root.val not in self.res):\\n                self.res.append(root.val)\\n            if(root.right):\\n                dsf(root.right)\\n        dsf(root)\\n        \\n        self.res.sort()\\n        return self.res[1] if(len(self.res)>1) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        self.res=[]\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left):\\n                dsf(root.left)\\n            if(root.val not in self.res):\\n                self.res.append(root.val)\\n            if(root.right):\\n                dsf(root.right)\\n        dsf(root)\\n        \\n        self.res.sort()\\n        return self.res[1] if(len(self.res)>1) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416607,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    \\n    void solve(TreeNode *root,set<int>&stt){\\n        if(!root)return ;\\n        \\n        solve(root->left,stt);\\n        stt.insert(root->val);\\n        solve(root->right,stt);\\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int>stt;\\n        solve(root,stt);\\n        if(stt.size()<2)return -1;\\n        int i=1;\\n        for(auto it:stt){\\n            if(i==2)return it;\\n            i++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void solve(TreeNode *root,set<int>&stt){\\n        if(!root)return ;\\n        \\n        solve(root->left,stt);\\n        stt.insert(root->val);\\n        solve(root->right,stt);\\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int>stt;\\n        solve(root,stt);\\n        if(stt.size()<2)return -1;\\n        int i=1;\\n        for(auto it:stt){\\n            if(i==2)return it;\\n            i++;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391823,
                "title": "c-faster-than-100-easy-solution",
                "content": "void solve(TreeNode * root, unordered_set<int> & s){\\n        if(root==NULL)\\n            return;\\n        s.insert(root->val);\\n        solve(root->left,s);\\n        solve(root->right,s);\\n        return;\\n    }    \\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> v;\\n        unordered_set<int> s;\\n        solve(root,s);\\n        for(auto i=s.begin(); i!=s.end(); i++)\\n            v.push_back(*i);\\n        if(v.size()==0||v.size()==1)\\n            return -1;\\n        sort(v.begin(),v.end());\\n        return v[1];\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "void solve(TreeNode * root, unordered_set<int> & s){\\n        if(root==NULL)\\n            return;\\n        s.insert(root->val);\\n        solve(root->left,s);\\n        solve(root->right,s);\\n        return;\\n    }    \\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> v;\\n        unordered_set<int> s;\\n        solve(root,s);\\n        for(auto i=s.begin(); i!=s.end(); i++)\\n            v.push_back(*i);\\n        if(v.size()==0||v.size()==1)\\n            return -1;\\n        sort(v.begin(),v.end());\\n        return v[1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2300777,
                "title": "fastest-recursive-no-extra-space",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, m):\\n            if not node: return float(\\'inf\\')\\n            if node.val > m: return node.val\\n            return min(dfs(node.left, m), dfs(node.right, m))\\n        ans = dfs(root, root.val)\\n        return -1 if ans == float(\\'inf\\') else ans\\n```\\n```\\n                       2\\n\\n          2                        5\\n\\n    2           3            5           6\\n\\n 2    3      3     6      5     7     6      8\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, m):\\n            if not node: return float(\\'inf\\')\\n            if node.val > m: return node.val\\n            return min(dfs(node.left, m), dfs(node.right, m))\\n        ans = dfs(root, root.val)\\n        return -1 if ans == float(\\'inf\\') else ans\\n```\n```\\n                       2\\n\\n          2                        5\\n\\n    2           3            5           6\\n\\n 2    3      3     6      5     7     6      8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289950,
                "title": "c-map-0ms-recursion",
                "content": "```\\nclass Solution {\\n    map<int, int> mp;\\n    \\n    void helper(TreeNode* node)\\n    {\\n        if(!node)\\n            return;\\n        \\n        mp[node->val]++;\\n        \\n        helper(node->left);\\n        helper(node->right);\\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        helper(root);\\n        if(mp.size()==1)\\n            return -1;\\n        mp.erase(mp.begin());\\n        auto a=mp.begin();\\n        return a->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    map<int, int> mp;\\n    \\n    void helper(TreeNode* node)\\n    {\\n        if(!node)\\n            return;\\n        \\n        mp[node->val]++;\\n        \\n        helper(node->left);\\n        helper(node->right);\\n    }\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        helper(root);\\n        if(mp.size()==1)\\n            return -1;\\n        mp.erase(mp.begin());\\n        auto a=mp.begin();\\n        return a->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285643,
                "title": "morris-traversal-fastest-solution-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public:\\n        int findSecondMinimumValue(TreeNode* root) {\\n            TreeNode* current = root;\\n            long long m1 = LLONG_MAX, m2 = LLONG_MAX;\\n            while (current) {\\n                if (current->left) {\\n                    TreeNode* predecessor = current->left;\\n                    while (predecessor->right && predecessor->right != current) predecessor = predecessor->right;\\n                    if (predecessor->right) {\\n                        predecessor->right = NULL;\\n                        if (current->val < m1) {\\n                            m2 = m1;\\n                            m1 = current->val;\\n                        } else if (current->val != m1 && current->val < m2) {\\n                            m2 = current->val;\\n                        }\\n                        current = current->right;\\n                    } else {\\n                        predecessor->right = current;\\n                        current = current->left;\\n                    }\\n                } else {\\n                    if (current->val < m1) {\\n                        m2 = m1;\\n                        m1 = current->val;\\n                    } else if (current->val != m1 && current->val < m2) {\\n                        m2 = current->val;\\n                    }\\n                    current = current->right;\\n                }\\n            }\\n            return m2 == LLONG_MAX ? -1 : m2;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        int findSecondMinimumValue(TreeNode* root) {\\n            TreeNode* current = root;\\n            long long m1 = LLONG_MAX, m2 = LLONG_MAX;\\n            while (current) {\\n                if (current->left) {\\n                    TreeNode* predecessor = current->left;\\n                    while (predecessor->right && predecessor->right != current) predecessor = predecessor->right;\\n                    if (predecessor->right) {\\n                        predecessor->right = NULL;\\n                        if (current->val < m1) {\\n                            m2 = m1;\\n                            m1 = current->val;\\n                        } else if (current->val != m1 && current->val < m2) {\\n                            m2 = current->val;\\n                        }\\n                        current = current->right;\\n                    } else {\\n                        predecessor->right = current;\\n                        current = current->left;\\n                    }\\n                } else {\\n                    if (current->val < m1) {\\n                        m2 = m1;\\n                        m1 = current->val;\\n                    } else if (current->val != m1 && current->val < m2) {\\n                        m2 = current->val;\\n                    }\\n                    current = current->right;\\n                }\\n            }\\n            return m2 == LLONG_MAX ? -1 : m2;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278223,
                "title": "faster-than-100-you-can-t-find-more-easier-solution",
                "content": "UPVOTE IF LIKED\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        int min=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]!=min)\\n            {\\n                return v[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Sorting",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void inorder(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return ;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        int min=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]!=min)\\n            {\\n                return v[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246690,
                "title": "100ms-fastest-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long min1=LONG_MAX;\\n    long min2=LONG_MAX;\\n    int MinimumValue(TreeNode* root) \\n    {\\n        if(root!=NULL)\\n        {  \\n            MinimumValue(root->left);\\n\\n            if(root->val<min1)\\n            {\\n                min2=min1;\\n                min1=root->val;\\n            }\\n            if(root->val>min1 && root->val<min2)\\n            {min2=root->val;\\n            }\\n            \\n            MinimumValue(root->right);\\n        }\\n        return min2;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) \\n    {\\n        long ans=MinimumValue(root);\\n        if(ans==LONG_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long min1=LONG_MAX;\\n    long min2=LONG_MAX;\\n    int MinimumValue(TreeNode* root) \\n    {\\n        if(root!=NULL)\\n        {  \\n            MinimumValue(root->left);\\n\\n            if(root->val<min1)\\n            {\\n                min2=min1;\\n                min1=root->val;\\n            }\\n            if(root->val>min1 && root->val<min2)\\n            {min2=root->val;\\n            }\\n            \\n            MinimumValue(root->right);\\n        }\\n        return min2;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) \\n    {\\n        long ans=MinimumValue(root);\\n        if(ans==LONG_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208814,
                "title": "simplest-solution-best-for-beginners-set-c-0ms-faster-than-100",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    set<int>s;\\n    void solve(TreeNode *root1){\\n        s.insert(root1->val);\\n        if(root1->left){\\n            solve(root1->left);\\n        }\\n        if(root1->right){\\n            solve(root1->right);\\n        }\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n       if(!root) return -1;\\n        solve(root);\\n        if(s.size()<2)\\n            return -1;\\n        s.erase(s.begin());\\n        auto it = s.begin();\\n      return *it;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    set<int>s;\\n    void solve(TreeNode *root1){\\n        s.insert(root1->val);\\n        if(root1->left){\\n            solve(root1->left);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2205176,
                "title": "easy-c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, set<int>&s){\\n        if(root){\\n            inOrder(root->left,s);\\n            s.insert(root->val);\\n            inOrder(root->right,s);\\n            \\n        }\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        inOrder(root,s);\\n        if(s.size()<2) return -1;\\n        set<int>::iterator st=next(s.begin(),1);\\n        return *st;\\n    }\\n};\\n\\'\\'\\'\\nupvote if u find it useful",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inOrder(TreeNode* root, set<int>&s){\\n        if(root){\\n            inOrder(root->left,s);\\n            s.insert(root->val);\\n            inOrder(root->right,s);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2199824,
                "title": "python-straightforward-interactive-bfs-solution",
                "content": "We are just looking for all adjacent nodes with the values different from the root value. Second min is guranteed to be among them. To find such frontier edge BFS is the first to come into mind. DFS can be used with exactly the same result.\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        queue = deque([root])\\n        min_val = math.inf\\n        root_val = root.val\\n        while queue:\\n            curr = queue.popleft()\\n            if curr:                \\n                if curr.val == root_val:                    \\n                    queue.append(curr.left)                    \\n                    queue.append(curr.right)\\n                else:\\n                    min_val = min(min_val, curr.val) \\n                    \\n        return min_val if min_val != math.inf else -1\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        \\n        queue = deque([root])\\n        min_val = math.inf\\n        root_val = root.val\\n        while queue:\\n            curr = queue.popleft()\\n            if curr:                \\n                if curr.val == root_val:                    \\n                    queue.append(curr.left)                    \\n                    queue.append(curr.right)\\n                else:\\n                    min_val = min(min_val, curr.val) \\n                    \\n        return min_val if min_val != math.inf else -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183677,
                "title": "cpp-100-faster-without-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* t = q.front();\\n            s.insert(t->val);\\n            q.pop();\\n            if(t->left!=NULL){q.push(t->left);}\\n            if(t->right!=NULL){q.push(t->right);}\\n        }\\n        int ans = -1,cnt=0;\\n        for(auto &it:s)\\n        {\\n            if(cnt==1)\\n            {\\n                ans = it;\\n                break;\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\npls do upvote :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        set<int> s;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* t = q.front();\\n            s.insert(t->val);\\n            q.pop();\\n            if(t->left!=NULL){q.push(t->left);}\\n            if(t->right!=NULL){q.push(t->right);}\\n        }\\n        int ans = -1,cnt=0;\\n        for(auto &it:s)\\n        {\\n            if(cnt==1)\\n            {\\n                ans = it;\\n                break;\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155787,
                "title": "c-easy-solution-easy-to-understand-recursion",
                "content": "class Solution {\\npublic: \\n\\n\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL){\\n            return -1;\\n            \\n        }\\n        if(root->left==NULL && root->right==NULL){\\n            return -1;\\n        }\\n        int left=root->left->val;\\n        int right=root->right->val;\\n        if(root->left->val==root->val){\\n        left=findSecondMinimumValue(root->left);\\n        }\\n        if(root->right->val==root->val){ \\n        right=findSecondMinimumValue(root->right);\\n        }\\n        if(left!=-1 && right!=-1){\\n            return min(left,right);    \\n        }\\n        else if(left!=-1){\\n            return left;\\n         }\\n        else{\\n            return right;     \\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic: \\n\\n\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL){\\n            return -1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2118074,
                "title": "easiest-java-solution-with-detailed-comments-recursion-is-crazy",
                "content": "class Solution {\\n    int min = Integer.MAX_VALUE;\\n    int sec_min = Integer.MAX_VALUE;\\n    boolean check = false;    \\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null){\\n            return -1;\\n        }\\n        \\n        //we\\'ll first assign the minimum value int the global variable min and then this will not be changed once assigned since \\n        // we are given in the ques that root is the smallest value \\n        \\n        if(root.val<min){         \\n            min = root.val;\\n        }\\n        \\n        //if there is a value which is greater than or min but less than sec minimum value we\\'ll assign it here to the variable \\n        //and will make the check true which means we have found the sec minimum value for current level and then will traverse till end \\n        \\n        if(root.val>min && root.val<=sec_min){\\n            check = true;\\n            sec_min = root.val;\\n        }\\n        \\n        findSecondMinimumValue(root.left);\\n        findSecondMinimumValue(root.right);\\n        \\n        return check == false ? -1 : sec_min; // it means second minimum value doesn\\'t exist in the given tree and we return -1 as ans.\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int min = Integer.MAX_VALUE;\\n    int sec_min = Integer.MAX_VALUE;\\n    boolean check = false;    \\n    \\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2113011,
                "title": "cpp",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   vector<int>v;\\n    vector<int> inorder(TreeNode* a)\\n    {\\n      \\n        if(a==NULL)return v;\\n        inorder(a->left);\\n        v.push_back(a->val);\\n        inorder(a->right);\\n        return v;\\n    }\\n    int findSecondMinimumValue(TreeNode* root) \\n    {\\n       \\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        int res=0;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(v[i]!=v[i+1])\\n            {\\n                res=i+1;\\n                break;\\n            }\\n        }\\n        if(res==0)return -1;\\n        return v[res];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   vector<int>v;\\n    vector<int> inorder(TreeNode* a)\\n    {\\n      \\n        if(a==NULL)return v;\\n        inorder(a->left);\\n        v.push_back(a->val);\\n        inorder(a->right);\\n        return v;\\n    }\\n    int findSecondMinimumValue(TreeNode* root) \\n    {\\n       \\n        inorder(root);\\n        sort(v.begin(),v.end());\\n        int res=0;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(v[i]!=v[i+1])\\n            {\\n                res=i+1;\\n                break;\\n            }\\n        }\\n        if(res==0)return -1;\\n        return v[res];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112798,
                "title": "python-bfs-quickselect-o-n-no-recursion",
                "content": "steps:\\n1. Use BFS to collect all values in the tree starting from root.\\n2. Use QuickSelect to quickly find the k-th smallest (or largest) element in an *un*sorted list. In this case we are quick selecting for 2nd smallest, which is k = 1.\\n\\nTime:\\nO(n) to collect all values with BFS, O(n) quick select. T(n) = T(n/2) + O(n)\\n\\n```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return -1\\n        \\n        vals = set()\\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if not curr:\\n                continue\\n            vals.add(curr.val)\\n            queue.append(curr.left)\\n            queue.append(curr.right)\\n            \\n        vals = list(vals)\\n        if len(vals) < 2:\\n            return -1\\n        return self.quickselect(vals, 0, len(vals) - 1, 1)\\n    \\n    \\n    def quickselect(self, arr, start, end, k):\\n        if start >= end:\\n            return arr[k]\\n        \\n        left = start\\n        right = end\\n        pivot = arr[(left + right) // 2]\\n        while left <= right:\\n            while left <= right and arr[left] < pivot:\\n                left += 1\\n            while left <= right and arr[right] > pivot:\\n                right -= 1\\n            if left <= right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n        if k <= right:\\n            return self.quickselect(arr, start, right, k)\\n        if k >= left:\\n            return self.quickselect(arr, left, end, k)\\n        return arr[k]\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e7cf88b4-7468-43ac-b897-e1ef1aa88c69_1679267943.366933.png)\\n\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        if not root:\\n            return -1\\n        \\n        vals = set()\\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if not curr:\\n                continue\\n            vals.add(curr.val)\\n            queue.append(curr.left)\\n            queue.append(curr.right)\\n            \\n        vals = list(vals)\\n        if len(vals) < 2:\\n            return -1\\n        return self.quickselect(vals, 0, len(vals) - 1, 1)\\n    \\n    \\n    def quickselect(self, arr, start, end, k):\\n        if start >= end:\\n            return arr[k]\\n        \\n        left = start\\n        right = end\\n        pivot = arr[(left + right) // 2]\\n        while left <= right:\\n            while left <= right and arr[left] < pivot:\\n                left += 1\\n            while left <= right and arr[right] > pivot:\\n                right -= 1\\n            if left <= right:\\n                arr[left], arr[right] = arr[right], arr[left]\\n                left += 1\\n                right -= 1\\n        if k <= right:\\n            return self.quickselect(arr, start, right, k)\\n        if k >= left:\\n            return self.quickselect(arr, left, end, k)\\n        return arr[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083329,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return ;\\n        solve(root->left);\\n        m[root->val]++;\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        solve(root);\\n        if(m.size()<2)\\n            return -1;\\n        int c=0,ans;\\n        for(auto x:m)\\n        {\\n            ans=x.first;\\n            c++;\\n            if(c==2) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    void solve(TreeNode* root)\\n    {\\n        if(!root) return ;\\n        solve(root->left);\\n        m[root->val]++;\\n        solve(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        solve(root);\\n        if(m.size()<2)\\n            return -1;\\n        int c=0,ans;\\n        for(auto x:m)\\n        {\\n            ans=x.first;\\n            c++;\\n            if(c==2) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060374,
                "title": "c-easy-solution-recursion",
                "content": "```\\nclass Solution {\\n    void inorder(TreeNode* root,int rval,long long int &nextmin){\\n        if(root == NULL) return;\\n        if(root->val < nextmin && rval < root->val){\\n            nextmin = root->val;\\n            return;\\n        }\\n        inorder(root->left,rval,nextmin);\\n        inorder(root->right,rval,nextmin);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        long long int nextmin= 1e15;\\n        inorder(root,root->val,nextmin);\\n        if(nextmin == 1e15){\\n            return -1;\\n        }\\n        return nextmin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void inorder(TreeNode* root,int rval,long long int &nextmin){\\n        if(root == NULL) return;\\n        if(root->val < nextmin && rval < root->val){\\n            nextmin = root->val;\\n            return;\\n        }\\n        inorder(root->left,rval,nextmin);\\n        inorder(root->right,rval,nextmin);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        long long int nextmin= 1e15;\\n        inorder(root,root->val,nextmin);\\n        if(nextmin == 1e15){\\n            return -1;\\n        }\\n        return nextmin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039040,
                "title": "easy-peasy-java-leasy-just-normal-array",
                "content": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        long[] res = new long[2];\\n        res[0]=Integer.MAX_VALUE+1l;\\n        res[1]=Integer.MAX_VALUE+1l;\\n        getAns(root,res);\\n        if(res[1]==Integer.MAX_VALUE+1l)\\n            return -1;\\n        return (int)res[1];\\n    }\\n    private void getAns(TreeNode root,long[] res){\\n        if(root==null)\\n            return;\\n        if(res[0]>root.val){//finding new minimum\\n            res[1]=res[0];//Updating old minimum to second minimum\\n            res[0]=root.val;//new minimum\\n        }\\n        if(root.val>res[0] && root.val<res[1])//checking for values greater than 1st min but                                               //less than second minimum\\n            res[1]=root.val;\\n        getAns(root.left,res);\\n        getAns(root.right,res);\\n        return;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findSecondMinimumValue(TreeNode root) {\\n        long[] res = new long[2];\\n        res[0]=Integer.MAX_VALUE+1l;\\n        res[1]=Integer.MAX_VALUE+1l;\\n        getAns(root,res);\\n        if(res[1]==Integer.MAX_VALUE+1l)\\n            return -1;\\n        return (int)res[1];\\n    }\\n    private void getAns(TreeNode root,long[] res){\\n        if(root==null)\\n            return;\\n        if(res[0]>root.val){//finding new minimum\\n            res[1]=res[0];//Updating old minimum to second minimum\\n            res[0]=root.val;//new minimum\\n        }\\n        if(root.val>res[0] && root.val<res[1])//checking for values greater than 1st min but                                               //less than second minimum\\n            res[1]=root.val;\\n        getAns(root.left,res);\\n        getAns(root.right,res);\\n        return;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003516,
                "title": "java-0ms-100-faster-inorder-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inOrder(root);\\n        if(pq.size() <=1) return -1;\\n        else{\\n            pq.poll();\\n            return pq.poll();\\n        }\\n    }\\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        \\n        inOrder(root.left);\\n        if(!pq.contains(root.val)) pq.add(root.val);\\n        inOrder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inOrder(root);\\n        if(pq.size() <=1) return -1;\\n        else{\\n            pq.poll();\\n            return pq.poll();\\n        }\\n    }\\n    public void inOrder(TreeNode root){\\n        if(root == null) return;\\n        \\n        inOrder(root.left);\\n        if(!pq.contains(root.val)) pq.add(root.val);\\n        inOrder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990297,
                "title": "c-0-ms-beats-100-6-9-mb-beats-95-25",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Second Minimum Node In a Binary Tree.\\nMemory Usage: 6.9 MB, less than 95.25% of C++ online submissions for Second Minimum Node In a Binary Tree.\\n\\n```\\nclass Solution {\\npublic:\\n    int min, second_smallest = -1;\\n    \\n    inline void update_second_smallest(int new_val) {\\n        //assert(new_val >= min);\\n        if (new_val != min && (second_smallest == -1 || new_val < second_smallest))\\n            second_smallest = new_val;\\n        return ;\\n    }\\n    \\n    void recursive(TreeNode * root) {\\n        while (true) {\\n            update_second_smallest(root->val);\\n            if (!root->left)\\n                return ;\\n            if (root->left->val > root->right->val)\\n                swap(root->left, root->right);\\n            //assert(root->left->val == root->val);\\n            //Since root->right->val >= 0, the if () will not be called when second_smallest == -1\\n            int right_val = root->right->val;\\n            if (min < right_val && right_val < second_smallest)\\n                second_smallest = right_val;\\n            else\\n                recursive(root->right);\\n            root = root->left;\\n        }\\n        return ; //Unreachable\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        min = root->val; //root->val is the minimum of the entire tree\\n        recursive(root);\\n        return second_smallest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int min, second_smallest = -1;\\n    \\n    inline void update_second_smallest(int new_val) {\\n        //assert(new_val >= min);\\n        if (new_val != min && (second_smallest == -1 || new_val < second_smallest))\\n            second_smallest = new_val;\\n        return ;\\n    }\\n    \\n    void recursive(TreeNode * root) {\\n        while (true) {\\n            update_second_smallest(root->val);\\n            if (!root->left)\\n                return ;\\n            if (root->left->val > root->right->val)\\n                swap(root->left, root->right);\\n            //assert(root->left->val == root->val);\\n            //Since root->right->val >= 0, the if () will not be called when second_smallest == -1\\n            int right_val = root->right->val;\\n            if (min < right_val && right_val < second_smallest)\\n                second_smallest = right_val;\\n            else\\n                recursive(root->right);\\n            root = root->left;\\n        }\\n        return ; //Unreachable\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        min = root->val; //root->val is the minimum of the entire tree\\n        recursive(root);\\n        return second_smallest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985776,
                "title": "c-recursion-based-0-ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n//     another logic could be to do inorder traversal and make a set and return the 2nd value in it using next if set element count >=2;(eliminating call for duplicates).\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root->left)return -1;\\n        // no leaf nodes\\n        int v1,v2;\\n        if(root->val==max(root->left->val,root->right->val)){ //case1-left=right =root\\n            v1=findSecondMinimumValue(root->left);\\n            v2=findSecondMinimumValue(root->right);\\n            if(v1!=-1&&v2!=-1)return min(v1,v2);\\n            else return max(v1,v2); //case when both left and right do not possess any min \\n            \\n        }\\n        else if(root->val==root->left->val){  //case2--as root= left <right \\n            v1=root->right->val;\\n            v2=findSecondMinimumValue(root->left);\\n            if(v2!=-1)return min(v1,v2);\\n            return v1;\\n        }\\n        else if(root->val==root->right->val){  // case3--\\n            // root=min,root= right ..> left>root==right\\n            v1=root->left->val;\\n            v2=findSecondMinimumValue(root->right);\\n             if(v2!=-1)return min(v1,v2);\\n             return v1;\\n        }\\n        else{ // 4th case root < left<right or root< right<left \\n            return min(root->left->val,root->right->val);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     another logic could be to do inorder traversal and make a set and return the 2nd value in it using next if set element count >=2;(eliminating call for duplicates).\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root->left)return -1;\\n        // no leaf nodes\\n        int v1,v2;\\n        if(root->val==max(root->left->val,root->right->val)){ //case1-left=right =root\\n            v1=findSecondMinimumValue(root->left);\\n            v2=findSecondMinimumValue(root->right);\\n            if(v1!=-1&&v2!=-1)return min(v1,v2);\\n            else return max(v1,v2); //case when both left and right do not possess any min \\n            \\n        }\\n        else if(root->val==root->left->val){  //case2--as root= left <right \\n            v1=root->right->val;\\n            v2=findSecondMinimumValue(root->left);\\n            if(v2!=-1)return min(v1,v2);\\n            return v1;\\n        }\\n        else if(root->val==root->right->val){  // case3--\\n            // root=min,root= right ..> left>root==right\\n            v1=root->left->val;\\n            v2=findSecondMinimumValue(root->right);\\n             if(v2!=-1)return min(v1,v2);\\n             return v1;\\n        }\\n        else{ // 4th case root < left<right or root< right<left \\n            return min(root->left->val,root->right->val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962177,
                "title": "faster-than-100-easy-inorder-traversal-c-solution",
                "content": "***Do upvote if you like the solution***\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int>&v){\\n        if(!root)\\n            return;\\n        in(root->left,v);\\n        v.push_back(root->val);\\n        in(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        int m=-1;\\n        sort(begin(v),end(v));\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n            m=v[i];\\n                break;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void in(TreeNode* root, vector<int>&v){\\n        if(!root)\\n            return;\\n        in(root->left,v);\\n        v.push_back(root->val);\\n        in(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>v;\\n        in(root,v);\\n        int m=-1;\\n        sort(begin(v),end(v));\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]!=v[i-1]){\\n            m=v[i];\\n                break;\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960444,
                "title": "c-100-fast-recursion-without-helper-function-o-n-space",
                "content": "1. There are many easy ways to do this problem\\n2. using recursion\\n\\t     - use helper recursion function store values in vector and find     second min.\\n         - without helper function 4 cases to handle shown with if else in code easy and understable. In each step return either -1 or minmum of recursive call value and child value not equal to node value.\\n         \\n```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root->left==NULL)return -1;\\n        \\n        int v1,v2;\\n        if( (root->val==root->left->val)&&(root->val==root->right->val)){ //case1\\n            v1=findSecondMinimumValue(root->left);\\n            v2=findSecondMinimumValue(root->right);\\n            if(v1!=-1&&v2!=-1)return min(v1,v2);\\n            if(v1!=-1)return v1;\\n            else if(v2!=-1)return v2;\\n            else return-1;\\n            \\n        }\\n        else if(root->val==root->left->val){  //case2\\n            v1=root->right->val;\\n            v2=findSecondMinimumValue(root->left);\\n            if(v2!=-1)return min(v1,v2);\\n            return v1;\\n        }\\n        else if(root->val==root->right->val){  // case3\\n            v1=root->left->val;\\n            v2=findSecondMinimumValue(root->right);\\n             if(v2!=-1)return min(v1,v2);\\n             return v1;\\n        }\\n        else{ // 4th case\\n            return min(root->left->val,root->right->val);\\n        }\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root->left==NULL)return -1;\\n        \\n        int v1,v2;\\n        if( (root->val==root->left->val)&&(root->val==root->right->val)){ //case1\\n            v1=findSecondMinimumValue(root->left);\\n            v2=findSecondMinimumValue(root->right);\\n            if(v1!=-1&&v2!=-1)return min(v1,v2);\\n            if(v1!=-1)return v1;\\n            else if(v2!=-1)return v2;\\n            else return-1;\\n            \\n        }\\n        else if(root->val==root->left->val){  //case2\\n            v1=root->right->val;\\n            v2=findSecondMinimumValue(root->left);\\n            if(v2!=-1)return min(v1,v2);\\n            return v1;\\n        }\\n        else if(root->val==root->right->val){  // case3\\n            v1=root->left->val;\\n            v2=findSecondMinimumValue(root->right);\\n             if(v2!=-1)return min(v1,v2);\\n             return v1;\\n        }\\n        else{ // 4th case\\n            return min(root->left->val,root->right->val);\\n        }\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959296,
                "title": "c-100",
                "content": "```c++\\nclass Solution {\\npublic:\\n    set<int> bag;\\n    \\n    void kthSmall(TreeNode* root, int k) {\\n        if ( root == nullptr ) { return; }\\n        kthSmall(root->left, k);\\n        \\n        if ( bag.count(root->val) == 0 ) { \\n            bag.insert(root->val);\\n            if ( size(bag) == k ) { return; }\\n        }\\n        \\n        kthSmall(root->right, k);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        kthSmall(root, 2);\\n        if ( size(bag) < 2 ) { return -1; }\\n        return vector<int>(bag.begin(), bag.end()).at(1);\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    set<int> bag;\\n    \\n    void kthSmall(TreeNode* root, int k) {\\n        if ( root == nullptr ) { return; }\\n        kthSmall(root->left, k);\\n        \\n        if ( bag.count(root->val) == 0 ) { \\n            bag.insert(root->val);\\n            if ( size(bag) == k ) { return; }\\n        }\\n        \\n        kthSmall(root->right, k);\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        kthSmall(root, 2);\\n        if ( size(bag) < 2 ) { return -1; }\\n        return vector<int>(bag.begin(), bag.end()).at(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959097,
                "title": "c-solution-inorder-traversal-simple-and-easy-to-understand",
                "content": "```\\n\\npublic class Solution {\\n    public void InorderTraversal(TreeNode root,ref List<int> result)\\n\\t\\t{\\n\\t\\t\\tif (root == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\n\\t\\t\\tInorderTraversal(root.left,ref result);\\n\\t\\t\\tresult.Add(root.val);\\n\\t\\t\\tInorderTraversal(root.right,ref result);\\n\\t\\t\\t\\n\\t\\t}\\n    public int FindSecondMinimumValue(TreeNode root) {\\n        \\n        List<int> result = new List<int>();\\n\\t\\t\\tInorderTraversal(root, ref result); // inorder tree traversal and put data to list\\n\\t\\t\\tresult = result.OrderBy(r => r).ToList(); // after extraction of data order in ascending\\n\\n\\t\\t\\tint min = result[0]; // after ordering in asc the first item at index 0 is smallest.\\n\\t\\t\\tforeach(int item in result)  // loop and check any item greater than min\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (item > min)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn item;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\npublic class Solution {\\n    public void InorderTraversal(TreeNode root,ref List<int> result)\\n\\t\\t{\\n\\t\\t\\tif (root == null)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t\\n\\t\\t\\tInorderTraversal(root.left,ref result);\\n\\t\\t\\tresult.Add(root.val);\\n\\t\\t\\tInorderTraversal(root.right,ref result);\\n\\t\\t\\t\\n\\t\\t}\\n    public int FindSecondMinimumValue(TreeNode root) {\\n        \\n        List<int> result = new List<int>();\\n\\t\\t\\tInorderTraversal(root, ref result); // inorder tree traversal and put data to list\\n\\t\\t\\tresult = result.OrderBy(r => r).ToList(); // after extraction of data order in ascending\\n\\n\\t\\t\\tint min = result[0]; // after ordering in asc the first item at index 0 is smallest.\\n\\t\\t\\tforeach(int item in result)  // loop and check any item greater than min\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (item > min)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn item;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951880,
                "title": "c-easy-solution-95-5",
                "content": "```\\n//Declare the set as a Global variable ...\\uD83D\\uDE42\\n\\tset<int> s;\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        findSecondMinimumValue(root->left);\\n        s.insert(root->val);\\n        \\n        findSecondMinimumValue(root->right);\\n        \\n        if(s.size()>=2){\\n            int x = *next(s.begin(), 1);\\n            return x;\\n        }\\n        \\n        return  -1;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n//Declare the set as a Global variable ...\\uD83D\\uDE42\\n\\tset<int> s;\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(!root){\\n            return 0;\\n        }\\n        findSecondMinimumValue(root->left);\\n        s.insert(root->val);\\n        \\n        findSecondMinimumValue(root->right);\\n        \\n        if(s.size()>=2){\\n            int x = *next(s.begin(), 1);\\n            return x;\\n        }\\n        \\n        return  -1;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1951436,
                "title": "second-minimum-node-in-a-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int v=-1;\\n  \\n    void fun(TreeNode *root,int ans){\\n        if(root==NULL)\\n            return;\\n        fun(root->left,ans);\\n        if((root->val>ans and v==-1) || (root->val<v and root->val>ans)){\\n            v=root->val;\\n        }\\n        fun(root->right,ans);\\n    }\\nint findSecondMinimumValue(TreeNode* root) {\\n    int ans=root->val;\\n    fun(root,ans);\\n    return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int v=-1;\\n  \\n    void fun(TreeNode *root,int ans){\\n        if(root==NULL)\\n            return;\\n        fun(root->left,ans);\\n        if((root->val>ans and v==-1) || (root->val<v and root->val>ans)){\\n            v=root->val;\\n        }\\n        fun(root->right,ans);\\n    }\\nint findSecondMinimumValue(TreeNode* root) {\\n    int ans=root->val;\\n    fun(root,ans);\\n    return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921187,
                "title": "inorder-traversal-java-treeset",
                "content": "```\\nclass Solution {\\n    Set<Integer> set = new TreeSet<>();\\n    public int findSecondMinimumValue(TreeNode root) {\\n        dfs(root);\\n        Iterator<Integer> itr = set.iterator();\\n        int i=1;\\n        while(itr.hasNext() && i<2){\\n            int val = itr.next();\\n            System.out.println(val);\\n            i++;\\n        }\\n        \\n        \\n        return (itr.hasNext()) ? itr.next() : -1;\\n    }\\n    \\n    public TreeNode dfs(TreeNode root) {\\n        if(root == null)\\n            return null;\\n        \\n        dfs(root.left);\\n        set.add(root.val);\\n        dfs(root.right);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    Set<Integer> set = new TreeSet<>();\\n    public int findSecondMinimumValue(TreeNode root) {\\n        dfs(root);\\n        Iterator<Integer> itr = set.iterator();\\n        int i=1;\\n        while(itr.hasNext() && i<2){\\n            int val = itr.next();\\n            System.out.println(val);\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1886097,
                "title": "java-fast-solution-by-al",
                "content": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        int min_val = -1;\\n        while(!stack.empty()) {\\n            TreeNode node = stack.pop();\\n            if(node.val > root.val && (min_val == -1 || node.val < min_val)) {\\n                min_val = node.val;\\n            }\\n            if(node.left != null) {\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return min_val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Stack;\\n\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        int min_val = -1;\\n        while(!stack.empty()) {\\n            TreeNode node = stack.pop();\\n            if(node.val > root.val && (min_val == -1 || node.val < min_val)) {\\n                min_val = node.val;\\n            }\\n            if(node.left != null) {\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return min_val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861233,
                "title": "simple-java-bfs-iterative-solution-beats-100-with-explanation",
                "content": "**Intuition and approach** :- Here, the main point to note is that the minimum value in the whole tree is the ```root```. So, we can maintain a ```mindiff``` variable to find the minimum difference between the ```root.val``` and ```cur.val```. In other words, we are actually finding the minimum node in the whole tree, excluding the root, which is nothing but the second minimum node of the tree. Thus, we check for every ```cur.val``` in the BFS traversal and in the end, we check whether the value of ```mindiff``` has changed or not, and return ```secmin```.\\n\\n\\n\\n**Code**:-\\n```\\n public int findSecondMinimumValue(TreeNode root)\\n    {\\n        int mindiff= Integer.MAX_VALUE;\\n        int secmin=Integer.MAX_VALUE;\\n        Queue<TreeNode> queue=new ArrayDeque<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty())\\n        {\\n            for (int i = 0; i < queue.size(); i++)\\n            {\\n                TreeNode cur=queue.poll();\\n                if (cur.val-root.val!=0 && cur.val-root.val<mindiff)\\n                {\\n                    secmin= cur.val;\\n                    mindiff=cur.val-root.val;\\n                }\\n                if (cur.left!=null)\\n                    queue.offer(cur.left);\\n                if (cur.right!=null)\\n                    queue.offer(cur.right);\\n            }\\n        }\\n        if (mindiff==Integer.MAX_VALUE)\\n            return -1;\\n        else\\n            return secmin;\\n    }\\n```\\n\\n**Time Complexity**:- O(n), where n is number of nodes\\n**Space Complexity**:- O(width of tree)\\n\\n\\n\\n\\n***Upvote if you understood the solution!!!!!***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```root```\n```mindiff```\n```root.val```\n```cur.val```\n```cur.val```\n```mindiff```\n```secmin```\n```\\n public int findSecondMinimumValue(TreeNode root)\\n    {\\n        int mindiff= Integer.MAX_VALUE;\\n        int secmin=Integer.MAX_VALUE;\\n        Queue<TreeNode> queue=new ArrayDeque<>();\\n        queue.offer(root);\\n        while (!queue.isEmpty())\\n        {\\n            for (int i = 0; i < queue.size(); i++)\\n            {\\n                TreeNode cur=queue.poll();\\n                if (cur.val-root.val!=0 && cur.val-root.val<mindiff)\\n                {\\n                    secmin= cur.val;\\n                    mindiff=cur.val-root.val;\\n                }\\n                if (cur.left!=null)\\n                    queue.offer(cur.left);\\n                if (cur.right!=null)\\n                    queue.offer(cur.right);\\n            }\\n        }\\n        if (mindiff==Integer.MAX_VALUE)\\n            return -1;\\n        else\\n            return secmin;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860107,
                "title": "java-0ms-easy-to-understand-solution-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Long firstMin = Long.MAX_VALUE;\\n    Long secondMin = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inorder(root);\\n        return secondMin!=Long.MAX_VALUE?secondMin.intValue():-1;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return ;\\n        }\\n        inorder(root.left);\\n        if(root.val<firstMin){\\n            secondMin = Long.valueOf(firstMin);\\n            firstMin =  Long.valueOf(root.val);\\n        }\\n        else if(root.val<=secondMin && root.val!=firstMin){\\n            secondMin = Long.valueOf(root.val);\\n        }\\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Long firstMin = Long.MAX_VALUE;\\n    Long secondMin = Long.MAX_VALUE;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        inorder(root);\\n        return secondMin!=Long.MAX_VALUE?secondMin.intValue():-1;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null){\\n            return ;\\n        }\\n        inorder(root.left);\\n        if(root.val<firstMin){\\n            secondMin = Long.valueOf(firstMin);\\n            firstMin =  Long.valueOf(root.val);\\n        }\\n        else if(root.val<=secondMin && root.val!=firstMin){\\n            secondMin = Long.valueOf(root.val);\\n        }\\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828377,
                "title": "c-100-faster-simple-solution",
                "content": "**100% faster solution using recursion**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int sMin = INT_MAX;\\n    int flag = 0;\\npublic:\\n    void findMin(TreeNode* root, int min)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->val == min)\\n        {\\n            findMin(root->left, min);\\n            findMin(root->right, min);\\n        }\\n        else if(root->val > min && root->val <= sMin)\\n        {\\n            sMin=root->val;\\n            flag=1;\\n            return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        int min = root->val;\\n        \\n        findMin(root, min);\\n        \\n        if(flag==1)\\n            return sMin;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    int sMin = INT_MAX;\\n    int flag = 0;\\npublic:\\n    void findMin(TreeNode* root, int min)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->val == min)\\n        {\\n            findMin(root->left, min);\\n            findMin(root->right, min);\\n        }\\n        else if(root->val > min && root->val <= sMin)\\n        {\\n            sMin=root->val;\\n            flag=1;\\n            return;\\n        }\\n        \\n        return;\\n    }\\n    \\n    int findSecondMinimumValue(TreeNode* root) {\\n        int min = root->val;\\n        \\n        findMin(root, min);\\n        \\n        if(flag==1)\\n            return sMin;\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791230,
                "title": "easiest-solution-ever-100-faster-fcuk-off",
                "content": "just put in vector sort and return the second highest value\\n\\n```\\n\\n```class Solution {\\npublic:\\n    void push(TreeNode* root,vector<int>&v)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        v.push_back(root->val);\\n        push(root->left,v);\\n        push(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int>x;\\n        push(root,x);\\n        sort(x.begin(),x.end());\\n        int ans=x[0];\\n        int p=x[0];\\n        for(int i=1;i<x.size();i++)\\n        {\\n            if(x[i]>ans)\\n            {\\n                ans=x[i];\\n                break;\\n            }\\n        }\\n        if(ans==p)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758579,
                "title": "c-solution",
                "content": "here to find second minimum i used preorder traversal and simply returned the second node in thee sequence using a set(which will remove duplicate elements)\\nin the code it is set int s and not set s!!\\n**Please do consider upvoting my solution**\\n\\n\\n/**\\n\\nclass Solution {\\n    void preorder(TreeNode*root,set<int>&s)\\n    {\\n        if(root==NULL)return;\\n        preorder(root->left,s);\\n        s.insert(root->val);\\n        preorder(root->right,s);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n           sets  <int> s;\\n        preorder(root,s);\\n        if(s.size()==1) return -1;\\n        auto it=s.begin();\\n        it++;\\n        return *it;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void preorder(TreeNode*root,set<int>&s)\\n    {\\n        if(root==NULL)return;\\n        preorder(root->left,s);\\n        s.insert(root->val);\\n        preorder(root->right,s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1755030,
                "title": "java-sollution",
                "content": "```\\nclass Solution {\\n    HashSet<Integer>hs = new HashSet<>();\\n    public int findSecondMinimumValue(TreeNode root){\\n        if(root==null)return -1;\\n        getvalue(root);\\n        List<Integer>list = new ArrayList<>(hs);\\n        Collections.sort(list);\\n        if(list.size()==1)return -1;\\n        return list.get(1);\\n    }\\n    public void getvalue(TreeNode root){\\n        if(root==null)return;\\n        hs.add(root.val);\\n        getvalue(root.left);\\n        getvalue(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashSet<Integer>hs = new HashSet<>();\\n    public int findSecondMinimumValue(TreeNode root){\\n        if(root==null)return -1;\\n        getvalue(root);\\n        List<Integer>list = new ArrayList<>(hs);\\n        Collections.sort(list);\\n        if(list.size()==1)return -1;\\n        return list.get(1);\\n    }\\n    public void getvalue(TreeNode root){\\n        if(root==null)return;\\n        hs.add(root.val);\\n        getvalue(root.left);\\n        getvalue(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732502,
                "title": "0ms-100-faster-plain-dfs",
                "content": "```\\nclass Solution {\\n    int ssv = -1;\\n    int ssv2 = -1;\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root)\\n            return -1;\\n        pOrder(root);\\n        return ssv2;\\n    }\\n    \\n    void pOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        ssv = ssv == -1 ? root->val : min(root->val, ssv);\\n        if (root->val > ssv) {\\n            ssv2 = ssv2 == -1 ? root->val : min(root->val, ssv2);\\n        }\\n        pOrder(root->left);\\n        pOrder(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ssv = -1;\\n    int ssv2 = -1;\\n    \\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if (!root)\\n            return -1;\\n        pOrder(root);\\n        return ssv2;\\n    }\\n    \\n    void pOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        ssv = ssv == -1 ? root->val : min(root->val, ssv);\\n        if (root->val > ssv) {\\n            ssv2 = ssv2 == -1 ? root->val : min(root->val, ssv2);\\n        }\\n        pOrder(root->left);\\n        pOrder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723551,
                "title": "easy-python-solution",
                "content": "class Solution:\\n\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def helper(root,l):\\n            if not root:\\n                return\\n            \\n            l.append(root.val)\\n            helper(root.left,l)\\n            helper(root.right,l)\\n        \\n        l = []\\n        helper(root,l)\\n        \\n        s = sorted(list(set(l)))\\n        if len(s)>1:\\n            return s[1]\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        def helper(root,l):\\n            if not root:\\n                return\\n            \\n            l.append(root.val)\\n            helper(root.left,l)\\n            helper(root.right,l)\\n        \\n        l = []\\n        helper(root,l)\\n        \\n        s = sorted(list(set(l)))\\n        if len(s)>1:\\n            return s[1]\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1689095,
                "title": "rust-solution",
                "content": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn find_second_minimum_value(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let (mut min_1, mut min_2) = (None, None);\\n        let mut stack = vec![root];\\n        while let Some(node) = stack.pop() {\\n            if let Some(node) = node {\\n                let node = node.borrow();\\n                let val = Some(node.val);\\n                if min_1.is_none() {\\n                    min_1 = val;\\n                } else if min_1 > val {\\n                    min_2 = min_1;\\n                    min_1 = val;\\n                } else if val > min_1 && (min_2.is_none() || min_2 > val) {\\n                    min_2 = val;\\n                }\\n                stack.push(node.left.clone());\\n                stack.push(node.right.clone());\\n            }\\n        }\\n        min_2.unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn find_second_minimum_value(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let (mut min_1, mut min_2) = (None, None);\\n        let mut stack = vec![root];\\n        while let Some(node) = stack.pop() {\\n            if let Some(node) = node {\\n                let node = node.borrow();\\n                let val = Some(node.val);\\n                if min_1.is_none() {\\n                    min_1 = val;\\n                } else if min_1 > val {\\n                    min_2 = min_1;\\n                    min_1 = val;\\n                } else if val > min_1 && (min_2.is_none() || min_2 > val) {\\n                    min_2 = val;\\n                }\\n                stack.push(node.left.clone());\\n                stack.push(node.right.clone());\\n            }\\n        }\\n        min_2.unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661569,
                "title": "easy-c-100-faster-using-vector-and-dfs",
                "content": "\\'\\'\\'\\nclass Solution {\\nprivate:\\n    vector<int>v1;\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        v1.push_back(root->val);\\n        findSecondMinimumValue(root->left);\\n        findSecondMinimumValue(root->right);\\n        sort(v1.begin(),v1.end());\\n        for(int i=1;i<v1.size();i++)\\n        {\\n            if(v1[i]==v1[i-1])\\n                continue;\\n            else\\n                return v1[i];\\n        }\\n        return -1;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<int>v1;\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        v1.push_back(root->val);\\n        findSecondMinimumValue(root->left);\\n        findSecondMinimumValue(root->right);\\n        sort(v1.begin(),v1.end());\\n        for(int i=1;i<v1.size();i++)\\n        {\\n            if(v1[i]==v1[i-1])\\n                continue;\\n            else\\n                return v1[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1650929,
                "title": "c-easy-solution-run-time-0-ms-memory-distribution-7-1-mb",
                "content": "* /**\\n*  * Definition for a binary tree node.\\n*  * struct TreeNode {\\n*  *     int val;\\n*  *     TreeNode *left;\\n*  *     TreeNode *right;\\n*  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n*  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n*  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n*  * };\\n*  */\\n* class Solution {\\n* public:\\n*     vector<int> mp;\\n*     int findSecondMinimumValue(TreeNode* root) {\\n*         generate(root);\\n*         sort(mp.begin(),mp.end());\\n*         int i, second;\\n*     second=mp[0];\\n*     for (i = 1; i < mp.size() ; i ++)\\n*     {\\n*        \\n*         if(mp[i]==second)\\n*         {\\n*             continue;\\n*         }\\n*         \\n*         else{\\n*             return mp[i];\\n*             break;\\n*         }\\n*         \\n*     }\\n*         return -1;\\n*     }\\n*     void generate(TreeNode* root)\\n*     {\\n*         if(!root)\\n*             return;\\n*         mp.push_back(root->val);\\n*         generate(root->left);\\n*         generate(root->right);\\n*     }\\n* * };",
                "solutionTags": [],
                "code": "class Solution {\\n* public:\\n*     vector<int> mp;\\n*     int findSecondMinimumValue(TreeNode* root) {\\n*         generate(root);\\n*         sort(mp.begin(),mp.end());\\n*         int i, second;\\n*     second=mp[0];\\n*     for (i = 1; i < mp.size() ; i ++)\\n*     {\\n*        \\n*         if(mp[i]==second)\\n*         {\\n*             continue;\\n*         }",
                "codeTag": "Java"
            },
            {
                "id": 1627750,
                "title": "java-iterative-solution-on-time-space",
                "content": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        long min1 = Long.MAX_VALUE, min2 = Long.MAX_VALUE;\\n        Stack<TreeNode> s = new Stack<>();\\n        TreeNode curr = root;\\n\\n        while (curr != null || !s.isEmpty()) {\\n            while (curr != null) {\\n                s.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = s.pop();\\n            if (curr.val < min1 && curr.val != min2) {\\n                min2 = min1;\\n                min1 = curr.val;\\n            } else if (curr.val < min2 && curr.val != min1) {\\n                min2 = curr.val;\\n            }\\n\\n            curr = curr.right;\\n        }\\n        return (int) min2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        long min1 = Long.MAX_VALUE, min2 = Long.MAX_VALUE;\\n        Stack<TreeNode> s = new Stack<>();\\n        TreeNode curr = root;\\n\\n        while (curr != null || !s.isEmpty()) {\\n            while (curr != null) {\\n                s.push(curr);\\n                curr = curr.left;\\n            }\\n\\n            curr = s.pop();\\n            if (curr.val < min1 && curr.val != min2) {\\n                min2 = min1;\\n                min1 = curr.val;\\n            } else if (curr.val < min2 && curr.val != min1) {\\n                min2 = curr.val;\\n            }\\n\\n            curr = curr.right;\\n        }\\n        return (int) min2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587628,
                "title": "c-simple-faster-than-100",
                "content": "class Solution {\\npublic:\\n    set<int>s;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        s.insert(root->val);\\n        inorder(root->right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n    inorder(root);    \\n        if(s.size()<2)\\n            return -1;\\n\\t\\tauto it=s.begin();\\n        it++;\\n        return *it;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    set<int>s;\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        s.insert(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1501928,
                "title": "c-easy-to-understand-2-methods-dfs",
                "content": "**Method 1**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        sort(v.begin(),v.end());\\n        int i=0;\\n        while(i<v.size()&&v[i]==v[0])\\n        i++;\\n        if(i==v.size())\\n        return -1;\\n    \\n        return v[i];\\n    }\\n};\\n```\\n**Method 2**\\n```\\nclass Solution {\\npublic:\\n    int minVal(TreeNode* root,int rootVal)\\n    {\\n        if(!root)\\n        return -1;\\n        if(root->val!=rootVal)\\n        return root->val;\\n        \\n        int left=minVal(root->left,rootVal),right=minVal(root->right,rootVal);\\n        if(left==-1)\\n        return right;\\n        if(right==-1)\\n        return left;\\n        return min(left,right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n    if(root==NULL)\\n    return -1;\\n        int ans=minVal(root,root->val);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        inorder(root->left,v);\\n        v.push_back(root->val);\\n        inorder(root->right,v);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n        vector<int> v;\\n        inorder(root,v);\\n        sort(v.begin(),v.end());\\n        int i=0;\\n        while(i<v.size()&&v[i]==v[0])\\n        i++;\\n        if(i==v.size())\\n        return -1;\\n    \\n        return v[i];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minVal(TreeNode* root,int rootVal)\\n    {\\n        if(!root)\\n        return -1;\\n        if(root->val!=rootVal)\\n        return root->val;\\n        \\n        int left=minVal(root->left,rootVal),right=minVal(root->right,rootVal);\\n        if(left==-1)\\n        return right;\\n        if(right==-1)\\n        return left;\\n        return min(left,right);\\n    }\\n    int findSecondMinimumValue(TreeNode* root) {\\n    if(root==NULL)\\n    return -1;\\n        int ans=minVal(root,root->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471390,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n    int min1=INT_MAX,min2=INT_MAX;\\n    bool flag=true;\\n        \\n    void traverse(TreeNode* root){\\n            \\n           if(root==NULL)return ;\\n            \\n           int val=root->val;\\n            \\n           if(val<min1){\\n               min2=min1;\\n               min1=val;\\n           }\\n           else if(val<=min2 && val!=min1){\\n               flag=false;\\n               min2=val;    \\n           }\\n            \\n           traverse(root->left);\\n           traverse(root->right);\\n            \\n    }    \\n        \\n    int findSecondMinimumValue(TreeNode* root) {\\n          \\n          traverse(root);  \\n           \\n          if(flag)return -1;\\n            \\n     return min2;       \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    int min1=INT_MAX,min2=INT_MAX;\\n    bool flag=true;\\n        \\n    void traverse(TreeNode* root){\\n            \\n           if(root==NULL)return ;\\n            \\n           int val=root->val;\\n            \\n           if(val<min1){\\n               min2=min1;\\n               min1=val;\\n           }\\n           else if(val<=min2 && val!=min1){\\n               flag=false;\\n               min2=val;    \\n           }\\n            \\n           traverse(root->left);\\n           traverse(root->right);\\n            \\n    }    \\n        \\n    int findSecondMinimumValue(TreeNode* root) {\\n          \\n          traverse(root);  \\n           \\n          if(flag)return -1;\\n            \\n     return min2;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1661296,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1573515,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 2014518,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1846447,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1662247,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 2024994,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1994401,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1954761,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1572234,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1572031,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1661296,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1573515,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 2014518,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1846447,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1662247,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 2024994,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1994401,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1954761,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1572234,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 1572031,
                "content": [
                    {
                        "username": "HapticBovine",
                        "content": "wtf get grammarly already"
                    },
                    {
                        "username": "Akbkuku",
                        "content": "[@bhuppidhamii](/bhuppidhamii) If you couldn\\'t spot the numerous grammatical mistakes, then look at \"with the non-negative value\" (should be \"with a non-negative value\") and \"two or zero sub-node\" (which should obviously be \"sub-nodes\" as its a plural noun). In fact the phrase \"second minimum\" is incorrect as well (should be \"second smallest\") and is used several times throughout the problem."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "??\\n"
                    },
                    {
                        "username": "boskoculibrk94",
                        "content": "![image](https://assets.leetcode.com/users/boskoculibrk94/image_1584043914.png)\\n"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "I used brute force method and it told me that my TC is better than 100% of others and SC is better than over 90% of others. So what the purpose of the problem?"
                    },
                    {
                        "username": "Ares2k",
                        "content": "The question doesn\\'t mention it but it\\'s a BST. You can try create your own test case which violates BST properties and you will see."
                    },
                    {
                        "username": "AMBER_FATIMA",
                        "content": "no its not bst , try\\n root =[1,3,1]"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "actually, it just define the relationship between root\\'s value and children\\'s values. It doesn\\'t define the relationship between children\\'s values. I think this will be a kind of min heap instead of the BST"
                    },
                    {
                        "username": "HapticBovine",
                        "content": "I solved it 0ms, 100%/95%, the Description is written in bad English but the examples clarify it. Ask me if you have a problem.\\n\\nMain thing is don\\'t walk deeper into the tree than needed, and the 2 \"minimums\" must be unique."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "Iterative Linear $O(N)$ solution, Beats `100%` Runtime in `Python`:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3943623/iterative-linear-o-n-approach-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "oyemayanq",
                        "content": "Approach:\\n1. Find the first value that is just larger than the root node value from left subtree and right subtree. \\n2. Take the base case as `if(root == NULL) {return -1;}` \\n3. If one of them is -1, return the other value else return the minimum from both of them.\\n\\n[ Check my solution here](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/submissions/1008456344/)"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ EASY DFS(Preorder) solution\\n\\n# Approach\\n\\n1. The algorithm defines a recursive function called \"rec\" that takes three parameters: a TreeNode pointer \"root\" representing the current node being processed, an integer reference \"mini\" representing the minimum value found so far in the tree, and a long long reference \"ans\" representing the current second minimum value found so far.\\n\\n2. If the current node \"root\" is null (i.e., there is no node), the function returns and exits.\\n\\n3. If the value of the current node \"root\" is not equal to the minimum value \"mini\" and is less than the current second minimum value \"ans\", it means we have found a new potential second minimum value. In this case, we update \"ans\" with the value of the current node.\\n\\n4. The algorithm then recursively calls the \"rec\" function on the left child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n5. Similarly, the algorithm recursively calls the \"rec\" function on the right child of the current node, passing the same minimum value \"mini\" and the updated second minimum value \"ans\".\\n\\n6. The main function \"findSecondMinimumValue\" initializes the \"ans\" variable with the maximum value possible for a long long type (LONG_MAX). This is done to ensure that if a second minimum value is not found in the tree, the \"ans\" variable remains unchanged.\\n\\n7. The \"rec\" function is called with the root of the tree, the value of the root node as the initial minimum value, and the \"ans\" variable as the initial second minimum value.\\n\\n8. Finally, the function returns the second minimum value found (if it exists) by checking if \"ans\" has been updated (i.e., it is not equal to LONG_MAX). If \"ans\" is still equal to LONG_MAX, it means a second minimum value was not found, and -1 is returned instead.\\n\\n-----------------------------\\n# Complexity\\n- Time complexity:\\nt.C=O(n) upto n node in worst case.\\n\\n- Space complexity:\\nS.C=O(n) upto n recursive stack size.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/second-minimum-node-in-a-binary-tree/solutions/3713222/c-easy-dfs-preorder-solution/"
                    },
                    {
                        "username": "sarayang27",
                        "content": "Is this special binary tree a min heap? since it said that the node is smaller than its sub-nodes.."
                    },
                    {
                        "username": "pylSER",
                        "content": "If the input is `[2,2,5,null,null,5,5] ` then answer is 5.\\nIf the input is `[2,2,5,null,null,7,7] ` then answer is 5.\\n\\nWHY?"
                    },
                    {
                        "username": "singhvaibhav1434",
                        "content": "this is not a valid tree as per the question is stated"
                    }
                ]
            },
            {
                "id": 2068730,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2062102,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1902139,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1900743,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1820570,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1820569,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1795232,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1728233,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1716181,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1711891,
                "content": [
                    {
                        "username": "flower2",
                        "content": "Good, easy problem."
                    },
                    {
                        "username": "FrankSC",
                        "content": "Easily the worst question I\\'ve seen on Leetcode"
                    },
                    {
                        "username": "mEEt126",
                        "content": "`In simple words` here, question requires you to get 2nd distinct smallest element from tree. \\n- Using Tree-set (sorted set) will give you the answer efficiently.  "
                    },
                    {
                        "username": "Prajju22",
                        "content": "2 min for solving the question and 30 min for edge case of a = INT_MAX and b=INT_MAX\\n\\njust use a flag =false \\nif you encounter INT_MAX in root->val and mark it  true\\n\\nwhen you return value of b(second smaller ) just put a condition if (a==INT_MAX or b==INT_MAX) and flag==false\\nreturn -1\\nelse\\nreturn b\\n"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "harshmangalamv",
                        "content": "this might happen with the case when the res contains only one number. to avoid that you can check for this case when size of res is one, returning -1 for that."
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "Can someone tell me why when I print(res) I get the output list but when I return res[1] it says \"index out of bounds\"?\\n```\\ndef getlist(root):\\n            return [root.val] + getlist(root.left) + getlist(root.right) if root else []\\n        res = getlist(root)\\n        res = sorted(set(res))\\n        print(res)\\n        return res[1]\\n```"
                    },
                    {
                        "username": "natrajansamarth",
                        "content": "Will Inorder traversal of this tree be in sorted order?\\n"
                    },
                    {
                        "username": "Ares2k",
                        "content": "No because this is not a BST"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "dubeyaman157",
                        "content": "What I did for this solution is simple DFS to just get all the elements  in the tree in a list. Once that is done use for loop to find the smallest and the second smallest once you have that return the second smallest\\n\\n `\\nclass Solution:\\n    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:\\n        #the approch is to do dfs and get all the elements in this tree\\n        def dfs(node):\\n            if node:\\n                return [node.val] + dfs(node.left) + dfs(node.right)\\n            else:\\n                return []\\n        \\n        list1 = dfs(root)\\n        print(list1)\\n        a = b = float(\"inf\")\\n        for val in list1:\\n            if val<a:\\n                b=a\\n                a = val\\n            elif val<b and val!=a:\\n                b = val\\n        \\n        if b==inf:\\n            return -1\\n        else:\\n            return b\\n`"
                    },
                    {
                        "username": "Sripesh",
                        "content": "Easy C++ code | | Using SET\\n\\n```\\nclass Solution {\\n    # ordered set will store the elements in sorted order\\n    set<int>s;\\n\\n    # this function is to iterate through every node and store the value in the set\\n    void traverse(TreeNode* root)\\n    {\\n        s.insert(root->val);\\n        # using this no base condition is required in recursion\\n        if(root->left)\\n        traverse(root->left);\\n        if(root->right)\\n        traverse(root->right);\\n    }\\npublic:\\n    int findSecondMinimumValue(TreeNode* root) {\\n        int k=1;\\n        traverse(root);\\n        # You can use `auto` in for loop instead of iterator declaration\\n        set<int>::iterator i;\\n        for(i=s.begin();i!=s.end();i++)\\n        {\\n            # the condition to get the second minimum element \\n            # and break out of the loop\\n            if(!k)\\n            {\\n                return *i;\\n            }\\n            k--;\\n        }\\n        # if second element doesn\\'t exist then return -1\\n        return -1;\\n    }\\n};\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Jewels and Stones",
        "question_content": "<p>You&#39;re given strings <code>jewels</code> representing the types of stones that are jewels, and <code>stones</code> representing the stones you have. Each character in <code>stones</code> is a type of stone you have. You want to know how many of the stones you have are also jewels.</p>\n\n<p>Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> jewels = \"aA\", stones = \"aAAbbbb\"\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> jewels = \"z\", stones = \"ZZ\"\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;jewels.length, stones.length &lt;= 50</code></li>\n\t<li><code>jewels</code> and <code>stones</code> consist of only English letters.</li>\n\t<li>All the characters of&nbsp;<code>jewels</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113574,
                "title": "1-liners-python-java-ruby",
                "content": "### Ruby\\n```\\ndef num_jewels_in_stones(j, s)\\n  s.count(j)\\nend\\n```\\n```\\ndef num_jewels_in_stones(j, s)\\n  s.scan(/[#{j}]/).size\\nend\\n```\\n```\\ndef num_jewels_in_stones(j, s)\\n  s.chars.count { |c| j.include?(c) }\\nend\\n```\\n\\n### Python\\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(map(J.count, S))\\n```\\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(map(S.count, J))               # this one after seeing https://discuss.leetcode.com/post/244105\\n```\\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(s in J for s in S)\\n```\\n### Java\\n\\n    public int numJewelsInStones(String J, String S) {\\n        return S.replaceAll(\"[^\" + J + \"]\", \"\").length();\\n    }",
                "solutionTags": [],
                "code": "```\\ndef num_jewels_in_stones(j, s)\\n  s.count(j)\\nend\\n```\n```\\ndef num_jewels_in_stones(j, s)\\n  s.scan(/[#{j}]/).size\\nend\\n```\n```\\ndef num_jewels_in_stones(j, s)\\n  s.chars.count { |c| j.include?(c) }\\nend\\n```\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(map(J.count, S))\\n```\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(map(S.count, J))               # this one after seeing https://discuss.leetcode.com/post/244105\\n```\n```\\ndef numJewelsInStones(self, J, S):\\n    return sum(s in J for s in S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113553,
                "title": "c-java-python-set-solution-o-j-s",
                "content": "## **Explanation**\\n1. read `J` and build jewels hash set.\\n2. read `S` and count jewels.\\n\\n## **Complexity**\\nI used hash set and it\\'s `O(1)` time to check if it contains an element.\\nSo the total time complexity will be **O(J+S)**, instead of O(JS)\\nSpace is `O(J)`\\n\\n\\n**Java**\\n```java\\n    public int numJewelsInStones(String J, String S) {\\n        int res = 0;\\n        Set setJ = new HashSet();\\n        for (char j: J.toCharArray())\\n            setJ.add(j);\\n        for (char s: S.toCharArray())\\n            if (setJ.contains(s)) res++;\\n        return res;\\n    }\\n```\\n\\n\\n**C++**\\n```cpp\\n    int numJewelsInStones(string J, string S) {\\n        int res = 0;\\n        unordered_set<char> setJ(J.begin(), J.end());\\n        for (char s : S)\\n            if (setJ.count(s)) res++;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```python\\ndef numJewelsInStones(self, J, S):\\n        setJ = set(J)\\n        return sum(s in setJ for s in S)\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numJewelsInStones(String J, String S) {\\n        int res = 0;\\n        Set setJ = new HashSet();\\n        for (char j: J.toCharArray())\\n            setJ.add(j);\\n        for (char s: S.toCharArray())\\n            if (setJ.contains(s)) res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int numJewelsInStones(string J, string S) {\\n        int res = 0;\\n        unordered_set<char> setJ(J.begin(), J.end());\\n        for (char s : S)\\n            if (setJ.count(s)) res++;\\n        return res;\\n    }\\n```\n```python\\ndef numJewelsInStones(self, J, S):\\n        setJ = set(J)\\n        return sum(s in setJ for s in S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1168186,
                "title": "c-fastest-2-liner-you-will-love-it-guaranteed",
                "content": "If you Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\n```\\nint numJewelsInStones(string jewels, string stones) {\\n    int num = 0;\\n    for (int i = 0; i < jewels.size(); i++){\\n        num += count(stones.begin(), stones.end(), jewels[i]);\\n    }\\n    return num;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numJewelsInStones(string jewels, string stones) {\\n    int num = 0;\\n    for (int i = 0; i < jewels.size(); i++){\\n        num += count(stones.begin(), stones.end(), jewels[i]);\\n    }\\n    return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607855,
                "title": "java-count-clean-code-o-j-s",
                "content": "```java\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int[] cnt = new int[128];\\n        for (char c : S.toCharArray())\\n            cnt[c]++;\\n        int ans = 0;\\n        for (char c : J.toCharArray())\\n            ans += cnt[c];\\n        return ans;\\n    }\\n}\\n```\\n**Complexity**\\n- Time: `O(j+s)`, where `j` is length of string `J` and `s` is the length of string `S`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int[] cnt = new int[128];\\n        for (char c : S.toCharArray())\\n            cnt[c]++;\\n        int ans = 0;\\n        for (char c : J.toCharArray())\\n            ans += cnt[c];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113563,
                "title": "two-line-javascript-solution",
                "content": "```\\nconst numJewelsInStones = (J, S) => {\\n    const jewels = new Set(J)\\n    return S.split('').reduce((res, s) => res + jewels.has(s), 0)\\n};\\n```\\nThis is O(S) space and time - could be taken down to O(J) space by normal iteration.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numJewelsInStones = (J, S) => {\\n    const jewels = new Set(J)\\n    return S.split('').reduce((res, s) => res + jewels.has(s), 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191468,
                "title": "simple-java-soln-using-indexof",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int num = 0;\\n\\t\\tfor (int i = 0 ; i < stones.length(); i ++) {\\n\\t\\t\\tif(jewels.indexOf(stones.charAt(i)) != -1) {\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int num = 0;\\n\\t\\tfor (int i = 0 ; i < stones.length(); i ++) {\\n\\t\\t\\tif(jewels.indexOf(stones.charAt(i)) != -1) {\\n\\t\\t\\t\\tnum++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156976,
                "title": "java-one-loop-solution-in-0ms",
                "content": " ```\\n     public static int numJewelsInStones(String J, String S) {\\n        int res=0;\\n        for(char c : S.toCharArray()){\\n            if(J.indexOf(c) != -1){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n     public static int numJewelsInStones(String J, String S) {\\n        int res=0;\\n        for(char c : S.toCharArray()){\\n            if(J.indexOf(c) != -1){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113552,
                "title": "java-o-s-j-time-and-o-1-space",
                "content": "```class Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        if(J.length() == 0 || S.length() == 0)\\n            return 0;\\n        \\n        // Using helper array for O(1) loopkup when traversing S\\n        int[] jewels = new int[58];\\n        for(int i=0; i<J.length(); i++) {\\n            jewels[(J.charAt(i) - 'A')] = 1;\\n        }\\n        \\n        int result = 0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(jewels[(S.charAt(i) - 'A')] == 1) {\\n                result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\nWhy an array of length 58? Two reasons\\n1. We need to consider both upper-case and lower-case characters\\n2. ASCII of 'z' - 'A' is 58. (https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html)\\n\\nThanks to @thaliahard for pointing out the reduction in array size.",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        if(J.length() == 0 || S.length() == 0)\\n            return 0;\\n        \\n        // Using helper array for O(1) loopkup when traversing S\\n        int[] jewels = new int[58];\\n        for(int i=0; i<J.length(); i++) {\\n            jewels[(J.charAt(i) - 'A')] = 1;\\n        }\\n        \\n        int result = 0;\\n        for(int i=0; i<S.length(); i++) {\\n            if(jewels[(S.charAt(i) - 'A')] == 1) {\\n                result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199672,
                "title": "javascript-one-liner-beats-98-80-56ms-runtime",
                "content": "```\\nconst numJewelsInStones = (J, S) => S.split(\\'\\').filter(char => J.indexOf(char) !== -1).length;\\n```",
                "solutionTags": [],
                "code": "```\\nconst numJewelsInStones = (J, S) => S.split(\\'\\').filter(char => J.indexOf(char) !== -1).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362196,
                "title": "solution-in-python-3-beats-94-one-line-three-solutions",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(i in J for i in S)\\n\\n\\n\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(S.count(i) for i in J)\\n\\n\\n\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(Counter(S)[i] for i in J)\\n\\t\\t\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(i in J for i in S)\\n\\n\\n\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(S.count(i) for i in J)\\n\\n\\n\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n    \\treturn sum(Counter(S)[i] for i in J)\\n\\t\\t\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 711118,
                "title": "c-speed-mem-o-j-s-o-1-simple-video",
                "content": "https://www.youtube.com/watch?v=Se3kXWEtxrw&feature=youtu.be\\n```\\nclass Solution {\\npublic:\\n    \\n    // ascii from A to z\\n    bool list[58];\\n    \\n    int numJewelsInStones(string J, string S) {\\n        int cnt=0;\\n                \\n        for(int i=0; i < J.size(); i++)\\n            list[J[i]-65]=true;\\n        \\n        for(int i=0; i < S.size(); i++)\\n            if(list[S[i]-65])\\n                cnt++;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // ascii from A to z\\n    bool list[58];\\n    \\n    int numJewelsInStones(string J, string S) {\\n        int cnt=0;\\n                \\n        for(int i=0; i < J.size(); i++)\\n            list[J[i]-65]=true;\\n        \\n        for(int i=0; i < S.size(); i++)\\n            if(list[S[i]-65])\\n                cnt++;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132077,
                "title": "java-python-clear-code-using-hashing",
                "content": "**Java**\\n```\\n    public int numJewelsInStones(String J, String S) {\\n        // Corner cases.\\n        if (J == null || S == null || J.length() == 0 || S.length() == 0)\\n            return 0;\\n        \\n        // Map char to its frequency in S.\\n        int[] charToFreq = new int[256]; \\n        for (char ch : S.toCharArray()) {\\n            charToFreq[ch]++;\\n        }\\n        \\n        int numJewels = 0; // Number of jewels among stones.\\n        for (char ch : J.toCharArray()) {\\n            if (charToFreq[ch] > 0) {\\n                numJewels += charToFreq[ch];\\n            }\\n        }\\n        \\n        return numJewels;\\n    }\\n```\\n**Python**\\n```\\n    def numJewelsInStones(self, J, S):\\n        charToFreqS = {}  # Map character to its frequency in S.\\n        numJewels = 0  # Total number of jewels.\\n        \\n        for ch in S:\\n            if ch not in charToFreqS:\\n                charToFreqS[ch] = 1\\n            else:\\n                charToFreqS[ch] += 1\\n        \\n        for ch in J:\\n            if ch in charToFreqS:\\n                numJewels += charToFreqS[ch]\\n                \\n        return numJewels\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numJewelsInStones(String J, String S) {\\n        // Corner cases.\\n        if (J == null || S == null || J.length() == 0 || S.length() == 0)\\n            return 0;\\n        \\n        // Map char to its frequency in S.\\n        int[] charToFreq = new int[256]; \\n        for (char ch : S.toCharArray()) {\\n            charToFreq[ch]++;\\n        }\\n        \\n        int numJewels = 0; // Number of jewels among stones.\\n        for (char ch : J.toCharArray()) {\\n            if (charToFreq[ch] > 0) {\\n                numJewels += charToFreq[ch];\\n            }\\n        }\\n        \\n        return numJewels;\\n    }\\n```\n```\\n    def numJewelsInStones(self, J, S):\\n        charToFreqS = {}  # Map character to its frequency in S.\\n        numJewels = 0  # Total number of jewels.\\n        \\n        for ch in S:\\n            if ch not in charToFreqS:\\n                charToFreqS[ch] = 1\\n            else:\\n                charToFreqS[ch] += 1\\n        \\n        for ch in J:\\n            if ch in charToFreqS:\\n                numJewels += charToFreqS[ch]\\n                \\n        return numJewels\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 118399,
                "title": "c-6ms-solution-using-vector-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        vector<int> map(128, 0);\\n        int res = 0;        \\n        for (char& c : J) map[c]++;\\n        for (char& c : S) if (map[c]) res++; \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        vector<int> map(128, 0);\\n        int res = 0;        \\n        for (char& c : J) map[c]++;\\n        for (char& c : S) if (map[c]) res++; \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574703,
                "title": "java-100-fastest-simple",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count=0;\\n        for(char c:stones.toCharArray()){\\n            if(jewels.indexOf(c)!=-1)count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count=0;\\n        for(char c:stones.toCharArray()){\\n            if(jewels.indexOf(c)!=-1)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842275,
                "title": "c-short-comment-explanation-easy-to-understand",
                "content": "Here just need to count all stones. first for loop in code is to count stones.\\n\\nfollowed by we need only stones, who are in jewels array. So, second for loop is to sum all valid jewels.\\n\\nHere, to store stones and its count, I have used map data structure.\\n\\nThank YOU.\\t\\n\\n\\n\\t    int ans=0; \\n        map<char,int>count;\\n\\n        //counting all stones\\n        for(int i=0;i<stones.size();i++)\\n            count[stones[i]]++;          \\n\\n        //sum all valid jewels stone\\n        for(int i=0;i<jewels.size();i++)\\n            ans+=count[jewels[i]];           \\n    \\n        return ans;\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String"
                ],
                "code": "Here just need to count all stones. first for loop in code is to count stones.\\n\\nfollowed by we need only stones, who are in jewels array. So, second for loop is to sum all valid jewels.\\n\\nHere, to store stones and its count, I have used map data structure.\\n\\nThank YOU.\\t\\n\\n\\n\\t    int ans=0; \\n        map<char,int>count;\\n\\n        //counting all stones\\n        for(int i=0;i<stones.size();i++)\\n            count[stones[i]]++;          \\n\\n        //sum all valid jewels stone\\n        for(int i=0;i<jewels.size();i++)\\n            ans+=count[jewels[i]];           \\n    \\n        return ans;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 326518,
                "title": "python-3-94-easy-to-understand",
                "content": "Python 3\\n```\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        counter = 0\\n        jewels = set(J) # search in a set is instant - O(1)\\n        for stone in S:\\n            if stone in jewels:\\n                counter += 1\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        counter = 0\\n        jewels = set(J) # search in a set is instant - O(1)\\n        for stone in S:\\n            if stone in jewels:\\n                counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982072,
                "title": "two-simple-java-solutions-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```Java\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count=0;\\n        for(char c:stones.toCharArray()){\\n            if(jewels.indexOf(c)!=-1)count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Code2\\n```Java\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n        str.append(jewels);\\n\\n        for (char c : stones.toCharArray())\\n        {\\n            if ( str.toString().contains(String.valueOf(c))) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/cf750df2-139c-47cf-89f4-fd50c6869005_1693424073.3338153.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count=0;\\n        for(char c:stones.toCharArray()){\\n            if(jewels.indexOf(c)!=-1)count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        StringBuilder str = new StringBuilder();\\n        str.append(jewels);\\n\\n        for (char c : stones.toCharArray())\\n        {\\n            if ( str.toString().contains(String.valueOf(c))) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616284,
                "title": "o-n-solution-using-maps",
                "content": "**Step1:** frequency count of stones we have in S\\n**Step2:** check if we have the jewel in our map, if yes count=count+(count of current jewel)\\n\\nActual time complexity (***n log m***), n = size of J, m = size of S. Since search time of map is log(m).\\n\\n```\\nclass Solution {\\npublic:\\n    map<char,int> umap;\\n    int numJewelsInStones(string J, string S) {\\n        for(char c:S){\\n            umap[c]++;\\n        }\\n        int count=0;\\n        for(char c:J){\\n            if(umap.count(c)){\\n                count+=umap[c];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nwe can improve the time complexity by using another data structure, i.e, unordered_map instead of map. Since search time of **unordered_map** is O(1). \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<char,int> umap;\\n    int numJewelsInStones(string J, string S) {\\n        for(char c:S){\\n            umap[c]++;\\n        }\\n        int count=0;\\n        for(char c:J){\\n            if(umap.count(c)){\\n                count+=umap[c];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nThanks for reading the post, If you liked it, I request you to give a upvote.",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,int> umap;\\n    int numJewelsInStones(string J, string S) {\\n        for(char c:S){\\n            umap[c]++;\\n        }\\n        int count=0;\\n        for(char c:J){\\n            if(umap.count(c)){\\n                count+=umap[c];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<char,int> umap;\\n    int numJewelsInStones(string J, string S) {\\n        for(char c:S){\\n            umap[c]++;\\n        }\\n        int count=0;\\n        for(char c:J){\\n            if(umap.count(c)){\\n                count+=umap[c];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213126,
                "title": "c-4ms-o-m-n",
                "content": "```\\nint numJewelsInStones(char* J, char* S) {\\n    int  a      = 0;\\n    char t[128] = {};\\n\\n    for (char* p = J; *p; ++p) t[*p] = (char) 1;\\n    for (char* p = S; *p; ++p) a     = a + t[*p];\\n    \\n    return a;    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numJewelsInStones(char* J, char* S) {\\n    int  a      = 0;\\n    char t[128] = {};\\n\\n    for (char* p = J; *p; ++p) t[*p] = (char) 1;\\n    for (char* p = S; *p; ++p) a     = a + t[*p];\\n    \\n    return a;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123408,
                "title": "c-using-linq",
                "content": "Just one Line and Beat 99% C# Code:\\n```\\nreturn S.Count(c => J.Contains(c));\\n```",
                "solutionTags": [],
                "code": "```\\nreturn S.Count(c => J.Contains(c));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235591,
                "title": "java-0ms-fast-4-line-code-solution",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n=stones.length();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(jewels.indexOf(stones.charAt(i))>-1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n=stones.length();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(jewels.indexOf(stones.charAt(i))>-1) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154006,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func numJewelsInStones(_ j: String, _ s: String) -> Int {\\n        return s.filter({ j.contains($0) }).count\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n\\n    func test0() {\\n        let value = solution.numJewelsInStones(\"aA\", \"aAAbbbb\")\\n        XCTAssertEqual(value, 3)\\n    }\\n\\n    func test1() {\\n        let value = solution.numJewelsInStones(\"z\", \"ZZ\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func numJewelsInStones(_ j: String, _ s: String) -> Int {\\n        return s.filter({ j.contains($0) }).count\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n\\n    func test0() {\\n        let value = solution.numJewelsInStones(\"aA\", \"aAAbbbb\")\\n        XCTAssertEqual(value, 3)\\n    }\\n\\n    func test1() {\\n        let value = solution.numJewelsInStones(\"z\", \"ZZ\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400984,
                "title": "javascript-simple-hashmap-solution-o-n",
                "content": "```\\n/**\\n * @param {string} J\\n * @param {string} S\\n * @return {number}\\n */\\nvar numJewelsInStones = function(J, S) {\\n\\t\\tvar obj = {};\\n\\t\\tvar count = 0;\\n\\t\\tfor (let i = 0; i < J.length; i++)\\n\\t\\t\\tobj[J[i]] = true;\\n\\n\\t\\tfor (let i = 0; i < S.length; i++) {\\n\\t\\t\\tif (obj[S[i]]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} J\\n * @param {string} S\\n * @return {number}\\n */\\nvar numJewelsInStones = function(J, S) {\\n\\t\\tvar obj = {};\\n\\t\\tvar count = 0;\\n\\t\\tfor (let i = 0; i < J.length; i++)\\n\\t\\t\\tobj[J[i]] = true;\\n\\n\\t\\tfor (let i = 0; i < S.length; i++) {\\n\\t\\t\\tif (obj[S[i]]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323088,
                "title": "idiomatic-rust",
                "content": "```\\nimpl Solution {\\n    pub fn num_jewels_in_stones(j: String, s: String) -> i32 {\\n        s.chars().filter(|&stoun| j.contains(stoun)).count() as i32\\n    }             \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_jewels_in_stones(j: String, s: String) -> i32 {\\n        s.chars().filter(|&stoun| j.contains(stoun)).count() as i32\\n    }             \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 292222,
                "title": "python-1-line-solution-faster-than-99-99",
                "content": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        return sum(S.count(j) for j in J)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        return sum(S.count(j) for j in J)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157697,
                "title": "python-1-line-code-beats-100",
                "content": "My Python 1-line code that beats 100%: store the bool variable in a list to fasten the speed\\n```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([i in J for i in S])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([i in J for i in S])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116051,
                "title": "swift",
                "content": "```\nclass Solution {\n    func numJewelsInStones(_ J: String, _ S: String) -> Int {\n        var jewels = 0\n        for s in S where J.contains(s) {\n            jewels += 1\n        }\n        return jewels\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    func numJewelsInStones(_ J: String, _ S: String) -> Int {\n        var jewels = 0\n        for s in S where J.contains(s) {\n            jewels += 1\n        }\n        return jewels\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761039,
                "title": "java-super-easy-and-short-solution-efficient",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        List<Character> list = new ArrayList<>();\\n        int ans = 0;\\n        for(int i = 0; i < jewels.length(); i++)\\n            list.add(jewels.charAt(i));\\n        \\n        for(int i = 0; i < stones.length(); i++)\\n            if(list.contains(stones.charAt(i)))ans++;\\n        \\n        return ans;\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nThanks : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        List<Character> list = new ArrayList<>();\\n        int ans = 0;\\n        for(int i = 0; i < jewels.length(); i++)\\n            list.add(jewels.charAt(i));\\n        \\n        for(int i = 0; i < stones.length(); i++)\\n            if(list.contains(stones.charAt(i)))ans++;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447630,
                "title": "java-two-easy-solutions-with-and-without-hashmap",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            //Solution #01\\n         /*-----------------------------------------------------------------\\n          int count=0;\\n            for(int i=0; i<stones.length(); i++)\\n                  if(jewels.contains(Character.toString(stones.charAt(i))))\\n                          count++;\\n         return count; \\n         -------------------------------------------------------------------*/\\n            //Solution #02\\n            int count=0;\\n            HashMap<Integer,Character> map = new HashMap<>() ;\\n            for(int i=0; i<jewels.length(); i++)\\n                    map.put(i, jewels.charAt(i) );\\n            for(int i=0; i<stones.length(); i++)\\n                   if( map.containsValue(stones.charAt(i)))\\n                           count++;\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            //Solution #01\\n         /*-----------------------------------------------------------------\\n          int count=0;\\n            for(int i=0; i<stones.length(); i++)\\n                  if(jewels.contains(Character.toString(stones.charAt(i))))\\n                          count++;\\n         return count; \\n         -------------------------------------------------------------------*/\\n            //Solution #02\\n            int count=0;\\n            HashMap<Integer,Character> map = new HashMap<>() ;\\n            for(int i=0; i<jewels.length(); i++)\\n                    map.put(i, jewels.charAt(i) );\\n            for(int i=0; i<stones.length(); i++)\\n                   if( map.containsValue(stones.charAt(i)))\\n                           count++;\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261850,
                "title": "javascript-faster-than-98",
                "content": "```\\nvar numJewelsInStones = function(J, S) {\\n\\n\\t// declare a count & length variable \\n\\n    let count = 0\\n    let len = S.length\\n\\t\\n\\t// Iterate through the longest array S. Increment count by 1 if it exists in J\\n\\t\\n    for (let i = 0; i < len; i++){\\n        if (J.indexOf(S[i]) >= 0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```\\n\\nI am happy to hear any suggestions on improving upon this!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numJewelsInStones = function(J, S) {\\n\\n\\t// declare a count & length variable \\n\\n    let count = 0\\n    let len = S.length\\n\\t\\n\\t// Iterate through the longest array S. Increment count by 1 if it exists in J\\n\\t\\n    for (let i = 0; i < len; i++){\\n        if (J.indexOf(S[i]) >= 0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 527360,
                "title": "several-python-solution-w-explanation",
                "content": "Several Python solution.\\n\\n---\\n\\n**Explanation**:\\n\\nThis is a classical question about **occurrence counting** and **element-set relationship**.\\n\\nIt can be solved by two kinds of viewpoints.\\n\\n**Method_#1**: \\nIterate on stones, check if current stone is also a jewel, and accumulate the counter if it is.\\n\\n**Method_#2**:\\nIterate on jewels, accumulate the occurrence of corresponding jewel in stone.\\n\\n---\\n**Implementation_1-a**:\\nTraditional loop, like what we do in other high-level languages, such as C++/Java/Go/Scala\\n\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewels = set(J)\\n        count_of_jewel = 0\\n        \\n        for item in S:\\n            if item in jewels:\\n                count_of_jewel += 1\\n\\n        return count_of_jewel\\n```\\n\\n---\\n**Implementation_1-b**:\\nWith the same concept, rewrite in generator expression in Python\\n\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewel = set(J)\\n        return sum( 1 for item in S if item in jewel )\\n```\\n\\n---\\n**Implementation_1-c**:\\nWith the same concept, rewrite in list comprehension in Python\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewel = set(J)\\n        return sum( [1 for item in S if item in jewel ] )\\n```\\n\\n---\\n**Implementation_2-a**:\\nTraditional loop, like what we do in other high-level languages, such as C++/Java/Go/Scala\\n\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        count_of_jewels = 0\\n\\n        for j in J:\\n            count_of_jewels += S.count(j)\\n\\n        return count_of_jewels\\n```\\n\\n---\\n**Implementation_2-b**:\\nWith the same concept, rewrite in generator expression in Python\\n\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        return sum( S.count(jewel) for jewel in J )\\n```\\n\\n---\\n**Implementation_2-c**:\\nWith the same concept, rewrite in list comprehension in Python\\n\\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        return sum( [ S.count(jewel) for jewel in J ] )\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about generator expression ( ... )](https://www.python.org/dev/peps/pep-0289/)\\n\\n[2] [Python official docs about list comprehension [ ... ]](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)\\n\\n[3] [Python official docs about built-in function: sum( )](https://docs.python.org/3/library/functions.html?highlight=sum#sum)\\n\\n[4] [Python official docs about str.count( )](https://docs.python.org/3/library/stdtypes.html?highlight=str%20count#str.count)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewels = set(J)\\n        count_of_jewel = 0\\n        \\n        for item in S:\\n            if item in jewels:\\n                count_of_jewel += 1\\n\\n        return count_of_jewel\\n```\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewel = set(J)\\n        return sum( 1 for item in S if item in jewel )\\n```\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        jewel = set(J)\\n        return sum( [1 for item in S if item in jewel ] )\\n```\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        count_of_jewels = 0\\n\\n        for j in J:\\n            count_of_jewels += S.count(j)\\n\\n        return count_of_jewels\\n```\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        return sum( S.count(jewel) for jewel in J )\\n```\n```\\nclass Solution:\\n    \\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        \\n        return sum( [ S.count(jewel) for jewel in J ] )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248945,
                "title": "clean-one-line-solution-python",
                "content": "The cons is can be slow because `S if i in J` has O(len(J)) time. In total, it results in O(len(S)len(J)).\\n```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([1 for i in S if i in J])\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([1 for i in S if i in J])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130497,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun numJewelsInStones(J: String, S: String): Int {\\n        val jewels = J.toSet()\\n        return S.filter { jewels.contains(it) }.length\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numJewelsInStones(J: String, S: String): Int {\\n        val jewels = J.toSet()\\n        return S.filter { jewels.contains(it) }.length\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3048195,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse of set\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly,insert the jewels values to the set.\\nAnd then using the count function,check whether the elements in stones\\nmatches the elements present in the set(jewels).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n       \\n       set<int> set;\\n      for(auto i:jewels){\\n          set.insert(i);\\n      }\\n      for(auto x:stones){\\n          if(set.count(x))\\n          count++;\\n      }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n       \\n       set<int> set;\\n      for(auto i:jewels){\\n          set.insert(i);\\n      }\\n      for(auto x:stones){\\n          if(set.count(x))\\n          count++;\\n      }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024711,
                "title": "javascript-easy-solution-using-regex",
                "content": "hope you like it !\\n```\\nvar numJewelsInStones = function(jewels, stones) {\\n    const REGEX = new RegExp(`[${jewels}]`,\\'g\\')\\n    \\n    return stones.match(REGEX) ? stones.match(REGEX).length : 0;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/f7c7ae64-28da-4793-9823-bb2c3da0fee3_1611071585.351251.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numJewelsInStones = function(jewels, stones) {\\n    const REGEX = new RegExp(`[${jewels}]`,\\'g\\')\\n    \\n    return stones.match(REGEX) ? stones.match(REGEX).length : 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258383,
                "title": "java-solution-faster-than-97",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        if(J.isEmpty()) return 0;\\n\\t\\tint cnt = 0;\\n\\t\\tfor(int i = 0 ; i < S.length() ; i++) {\\n\\t\\t\\tif(J.indexOf(S.charAt(i)) != -1) cnt++;\\n\\t\\t}\\n\\t\\treturn cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        if(J.isEmpty()) return 0;\\n\\t\\tint cnt = 0;\\n\\t\\tfor(int i = 0 ; i < S.length() ; i++) {\\n\\t\\t\\tif(J.indexOf(S.charAt(i)) != -1) cnt++;\\n\\t\\t}\\n\\t\\treturn cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214587,
                "title": "2-line-rust",
                "content": "```\\nimpl Solution {\\n    pub fn num_jewels_in_stones(j: String, s: String) -> i32 {\\n        use std::collections::HashSet;\\n        let jewels: HashSet<char> = j.chars().collect();\\n        s.chars().filter(|ch| jewels.contains(ch)).count() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_jewels_in_stones(j: String, s: String) -> i32 {\\n        use std::collections::HashSet;\\n        let jewels: HashSet<char> = j.chars().collect();\\n        s.chars().filter(|ch| jewels.contains(ch)).count() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208023,
                "title": "java-solution-beats-99-71",
                "content": "```\\npublic int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) > -1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/nataliiak/image_1546539147.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) > -1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156288,
                "title": "a-simple-c-solution-beats-100-00-accepted-runtime-4-ms",
                "content": "```\\nint numJewelsInStones(char* J, char* S) {\\n    int hash[123]={0};\\n    int Jlen=strlen(J);\\n    int Slen=strlen(S);\\n    int ret=0;\\n    for(int i=0;i<Jlen;i++){\\n        hash[J[i]]++;\\n    }\\n    for(int i=0;i<Slen;i++){\\n        if(hash[S[i]]!=0){\\n            ret++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numJewelsInStones(char* J, char* S) {\\n    int hash[123]={0};\\n    int Jlen=strlen(J);\\n    int Slen=strlen(S);\\n    int ret=0;\\n    for(int i=0;i<Jlen;i++){\\n        hash[J[i]]++;\\n    }\\n    for(int i=0;i<Slen;i++){\\n        if(hash[S[i]]!=0){\\n            ret++;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828068,
                "title": "easy-c-unordered-map-solution-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**1)**Here we will use char as index and increase the count of that  char that is present in the stones (using unordered_map)\\n**2)**then we will look for jewels in our map if present add the count in res to return the final count of jewels present in the stones\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) \\n    {\\n        int res=0; \\n        unordered_map<int,int>m;\\n        for(auto j:stones)\\n        {\\n            m[j]++;// increasing count of stones present (using ASCII code of the char as index )\\n\\n        }\\n        for(auto i: jewels)\\n        {\\n            if(m[i]>0)// if > then 0 that means the jewel is there in our stone \\n            {\\n                 res+=m[i];// incresing count of our jewels in our stone\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) \\n    {\\n        int res=0; \\n        unordered_map<int,int>m;\\n        for(auto j:stones)\\n        {\\n            m[j]++;// increasing count of stones present (using ASCII code of the char as index )\\n\\n        }\\n        for(auto i: jewels)\\n        {\\n            if(m[i]>0)// if > then 0 that means the jewel is there in our stone \\n            {\\n                 res+=m[i];// incresing count of our jewels in our stone\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040705,
                "title": "simple-python-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        count=0\\n        for i in stones:\\n            if i in jewels:\\n                count+=1\\n        return count\\n```\\n![image](https://assets.leetcode.com/users/images/f8b230f4-9db3-4333-a9fd-8a649bb508ae_1652598282.8882153.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        count=0\\n        for i in stones:\\n            if i in jewels:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052374,
                "title": "python-one-liner-86-faster",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return sum(map(stones.count, list(jewels)))\\n```\\nExplanation:\\n* ```stones.count(\\'a\\')``` counts amount of \\'a\\' inside the string ```stones```\\n* ```list(jewels)``` makes a list where each element is a chr inside the ```jewels``` string e.g. ```jewels = \\'aA\\'``` to ```[\\'a\\', \\'A\\']```\\n* with ```map()``` the ```stones.count``` can be applied to every element in ```list(jewels)```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return sum(map(stones.count, list(jewels)))\\n```\n```stones.count(\\'a\\')```\n```stones```\n```list(jewels)```\n```jewels```\n```jewels = \\'aA\\'```\n```[\\'a\\', \\'A\\']```\n```map()```\n```stones.count```\n```list(jewels)```",
                "codeTag": "Java"
            },
            {
                "id": 941825,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<char> st(J.begin(), J.end());\\n        int c=0;\\n        for(char i:S) \\n            c+=st.count(i);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<char> st(J.begin(), J.end());\\n        int c=0;\\n        for(char i:S) \\n            c+=st.count(i);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444163,
                "title": "java-faster-than-95-o-n-m-time-100-less-space",
                "content": "Basically pass through J and add to a HashSet O(n)\\nPass through S O(m)\\nCheck if char is in set O(1)\\n\\nSpace  is O(n) because of hashSet.\\n```\\n    public int numJewelsInStones(String J, String S) {\\n        //Make HasSet\\n        HashSet<Character> jewels = new HashSet<>();\\n        \\n        for(int i=0; i<J.length(); i++){\\n            char c = J.charAt(i);\\n            if(!jewels.contains(c)){\\n                jewels.add(c);\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<S.length(); i++){\\n            char c = S.charAt(i);\\n            if(jewels.contains(c)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numJewelsInStones(String J, String S) {\\n        //Make HasSet\\n        HashSet<Character> jewels = new HashSet<>();\\n        \\n        for(int i=0; i<J.length(); i++){\\n            char c = J.charAt(i);\\n            if(!jewels.contains(c)){\\n                jewels.add(c);\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0; i<S.length(); i++){\\n            char c = S.charAt(i);\\n            if(jewels.contains(c)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118264,
                "title": "1l-scala-solution",
                "content": "``` scala\\ndef numJewelsInStones(J: String, S: String): Int = S.filter(c => J.contains(c)).length\\n```",
                "solutionTags": [],
                "code": "``` scala\\ndef numJewelsInStones(J: String, S: String): Int = S.filter(c => J.contains(c)).length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 113579,
                "title": "python-brute-force",
                "content": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        for c in S:\\n            if c in J:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        count=0\\n        for c in S:\\n            if c in J:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113587,
                "title": "a-few-solutions",
                "content": "Use an unordered set for O(1) lookups for characters in the input string `s`, then filter the input string `t`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numJewelsInStones(s: String, t: String): Int {\\n        var seen = s.toSet()\\n        return t.toCharArray().filter{ seen.contains(it) }.size\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numJewelsInStones = (s, t, seen = new Set(s.split(\\'\\'))) => t.split(\\'\\').filter(c => seen.has(c)).length;\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    numJewelsInStones = lambda self, s, t: len([c for c in t if c in set(list(s))])\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_jewels_in_stones(s: String, t: String) -> i32 {\\n        let seen: HashSet<char> = s.chars().collect();\\n        t.chars().filter(|c| seen.contains(c)).collect::<Vec<char>>().len() as i32\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int numJewelsInStones(string s, string t) {\\n        Set seen{ s.begin(), s.end() };\\n        return count_if(t.begin(), t.end(), [&](auto c) { return seen.find(c) != seen.end(); });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numJewelsInStones(s: String, t: String): Int {\\n        var seen = s.toSet()\\n        return t.toCharArray().filter{ seen.contains(it) }.size\\n    }\\n}\\n```\n```\\nlet numJewelsInStones = (s, t, seen = new Set(s.split(\\'\\'))) => t.split(\\'\\').filter(c => seen.has(c)).length;\\n```\n```\\nclass Solution:\\n    numJewelsInStones = lambda self, s, t: len([c for c in t if c in set(list(s))])\\n```\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn num_jewels_in_stones(s: String, t: String) -> i32 {\\n        let seen: HashSet<char> = s.chars().collect();\\n        t.chars().filter(|c| seen.contains(c)).collect::<Vec<char>>().len() as i32\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int numJewelsInStones(string s, string t) {\\n        Set seen{ s.begin(), s.end() };\\n        return count_if(t.begin(), t.end(), [&](auto c) { return seen.find(c) != seen.end(); });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538828,
                "title": "js-best-solution-with-hashmap-faster-than-100",
                "content": "```\\nvar numJewelsInStones = function(jewels, stones) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < jewels.length; i++) {\\n        const jewel = jewels[i];\\n        hashmap.set(jewel, i);\\n    }\\n    \\n    for (let i = 0; i < stones.length; i++) {\\n        const stone = stones[i];\\n        if(hashmap.has(stone)) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numJewelsInStones = function(jewels, stones) {\\n    const hashmap = new Map();\\n    let output = 0;\\n    \\n    for (let i = 0; i < jewels.length; i++) {\\n        const jewel = jewels[i];\\n        hashmap.set(jewel, i);\\n    }\\n    \\n    for (let i = 0; i < stones.length; i++) {\\n        const stone = stones[i];\\n        if(hashmap.has(stone)) output++;\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505325,
                "title": "javascript-with-hashmap-easy-solution-for-you",
                "content": "```\\n// Runtime: 63 ms, faster than 96.51% of JavaScript online submissions for Jewels and Stones\\nvar numJewelsInStones = function(jewels, stones) {\\n    let map = new Map();\\n    let count = 0;\\n    for(let i = 0; i < stones.length; i++){\\n        if(map.has(stones[i]))\\n            map.set(stones[i], map.get(stones[i]) + 1);\\n        else\\n            map.set(stones[i], 1);\\n    }\\n    for(let i = 0; i < jewels.length; i++)\\n        if(map.has(jewels[i]))\\n            count += map.get(jewels[i])\\n    return count;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Runtime: 63 ms, faster than 96.51% of JavaScript online submissions for Jewels and Stones\\nvar numJewelsInStones = function(jewels, stones) {\\n    let map = new Map();\\n    let count = 0;\\n    for(let i = 0; i < stones.length; i++){\\n        if(map.has(stones[i]))\\n            map.set(stones[i], map.get(stones[i]) + 1);\\n        else\\n            map.set(stones[i], 1);\\n    }\\n    for(let i = 0; i < jewels.length; i++)\\n        if(map.has(jewels[i]))\\n            count += map.get(jewels[i])\\n    return count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2050586,
                "title": "java-runtime-0-ms-faster-than-100-00",
                "content": "```\\n        int count = 0 ;\\n        for(int i = 0 ; i < stones.length() ; i++) \\n            if(jewels.indexOf(stones.charAt(i)) != -1)\\n                count++;\\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n        int count = 0 ;\\n        for(int i = 0 ; i < stones.length() ; i++) \\n            if(jewels.indexOf(stones.charAt(i)) != -1)\\n                count++;\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301063,
                "title": "go-o-n-time-0ms-100-2-1mb",
                "content": "```\\nfunc numJewelsInStones(jewels string, stones string) int {\\n    jewelsMap := map[rune]bool{}\\n    for _, jewel := range jewels {\\n        jewelsMap[jewel] = true\\n    }\\n    \\n    result := 0\\n    for _, stone := range stones {\\n        if jewelsMap[stone] {\\n            result++\\n        }\\n    }\\n    return result\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numJewelsInStones(jewels string, stones string) int {\\n    jewelsMap := map[rune]bool{}\\n    for _, jewel := range jewels {\\n        jewelsMap[jewel] = true\\n    }\\n    \\n    result := 0\\n    for _, stone := range stones {\\n        if jewelsMap[stone] {\\n            result++\\n        }\\n    }\\n    return result\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 670563,
                "title": "c-0ms-100-2-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        set<char> j(J.begin(), J.end());\\n        return count_if(S.begin(), S.end(), [&j] (const char& c) { return j.count(c) == 1; });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        set<char> j(J.begin(), J.end());\\n        return count_if(S.begin(), S.end(), [&j] (const char& c) { return j.count(c) == 1; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328607,
                "title": "java-0ms-100-34-9mb-99-22",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Jewels and Stones.\\nMemory Usage: 34.9 MB, less than 99.22% of Java online submissions for Jewels and Stones.\\n\\n    public int numJewelsInStones(String J, String S) {\\n        //assert J.length() <= 50 && S.length() <= 50: \"S and J will consist of letters and have length at most 50.\";\\n        //\"The characters in J are distinct.\";\\n        int result = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) != -1) result++;\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Jewels and Stones.\\nMemory Usage: 34.9 MB, less than 99.22% of Java online submissions for Jewels and Stones.\\n\\n    public int numJewelsInStones(String J, String S) {\\n        //assert J.length() <= 50 && S.length() <= 50: \"S and J will consist of letters and have length at most 50.\";\\n        //\"The characters in J are distinct.\";\\n        int result = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) != -1) result++;\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 190922,
                "title": "javascript",
                "content": "```\nvar numJewelsInStones = function(J, S) {\n    let result = 0;\n    for(let i = 0; i < S.length; i++) {\n        if(J.indexOf(S.charAt(i)) >= 0)\n            result++;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numJewelsInStones = function(J, S) {\n    let result = 0;\n    for(let i = 0; i < S.length; i++) {\n        if(J.indexOf(S.charAt(i)) >= 0)\n            result++;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 143428,
                "title": "simple-java-solution",
                "content": "**Idea**\\n\\'z\\' = 122 is the highest index we will ever need. So declare int array of that size. Use ascii codes of chars in J as index positions to remember what are jewels, then count them iterativng over S.\\n```\\npublic int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        int[] jewels = new int[\\'z\\'+1];\\n        for(char j : J.toCharArray())\\n            jewels[j] = 1;\\n        for(char s : S.toCharArray())\\n            if(jewels[s] == 1)\\n                ++count;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        int[] jewels = new int[\\'z\\'+1];\\n        for(char j : J.toCharArray())\\n            jewels[j] = 1;\\n        for(char s : S.toCharArray())\\n            if(jewels[s] == 1)\\n                ++count;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784943,
                "title": "optimum-solution-with-space-complexity-o-1",
                "content": "\\n\\n# Intuition\\nThe problem asks us to count the number of stones that are considered jewels. We are given two strings: jewels, representing the types of jewels, and stones, representing the stones we have. We need to determine how many stones in our collection match the jewel types.\\n\\n\\n# Approach\\nTo solve the problem, your approach can be explained as follows:\\n\\n1. We start with a counter variable called count to keep track of the number of jewels found.\\n1. We look at each stone in our collection, one by one.\\n1. For each stone, we check if it matches any of the jewel types by looking at the jewels string.\\n1. If we find a match, it means the stone is a jewel, so we increment the count variable.\\n1. After checking all the stones, we return the final value of the count variable, which represents the total number of stones that are also jewels.\\n# Complexity\\n- Time complexity:\\nThe time it takes to execute your solution depends on the number of stones and jewels we have. We need to compare each stone with each jewel to determine if there is a match. So, the time complexity can be thought of as $$O(n * m)$$, where n is the number of stones and m is the number of jewel types.\\n\\n- Space complexity:\\nThe space required by your solution is minimal. It does not depend on the input size because you only use a constant amount of extra space. So, the space complexity can be considered as $$O(1)$$.\\n# Code\\n```java []\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        \\n        // Iterate through each stone in the stones string\\n        for (int i = 0; i < stones.length(); i++) {\\n            char ch = stones.charAt(i);\\n            \\n            // Check if the stone is a jewel by searching for it in the jewels string\\n            if (jewels.contains(String.valueOf(ch))) {\\n                count++; // Increment the count if the stone is a jewel\\n            }        \\n        }\\n        \\n        return count; // Return the final count of jewels found in the stones\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def numJewelsInStones(self, jewels, stones):\\n        count = 0\\n        \\n        # Iterate through each stone\\n        for ch in stones:\\n            \\n            # Check if the stone is a jewel\\n            if ch in jewels:\\n                count += 1\\n        \\n        return count\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count = 0;\\n        \\n        // Iterate through each stone in the stones string\\n        for (char ch : stones) {\\n            \\n            // Check if the stone is a jewel by searching for it in the jewels string\\n            if (jewels.find(ch) != string::npos) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        \\n        // Iterate through each stone in the stones string\\n        for (int i = 0; i < stones.length(); i++) {\\n            char ch = stones.charAt(i);\\n            \\n            // Check if the stone is a jewel by searching for it in the jewels string\\n            if (jewels.contains(String.valueOf(ch))) {\\n                count++; // Increment the count if the stone is a jewel\\n            }        \\n        }\\n        \\n        return count; // Return the final count of jewels found in the stones\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def numJewelsInStones(self, jewels, stones):\\n        count = 0\\n        \\n        # Iterate through each stone\\n        for ch in stones:\\n            \\n            # Check if the stone is a jewel\\n            if ch in jewels:\\n                count += 1\\n        \\n        return count\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count = 0;\\n        \\n        // Iterate through each stone in the stones string\\n        for (char ch : stones) {\\n            \\n            // Check if the stone is a jewel by searching for it in the jewels string\\n            if (jewels.find(ch) != string::npos) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383731,
                "title": "the-time-complexity-of-the-given-code-is-o-nm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is a JavaScript function named numJewelsInStones, which takes two arguments, jewels and stones. The function is designed to count the number of occurrences of characters in jewels in the string stones. The function uses a loop to iterate over each character in jewels and creates a regular expression object using the new RegExp() method. The function then checks if the regular expression matches any characters in stones using the match() method, and if there are matches, it increments the res variable by the number of matches.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function uses a simple approach of iterating over the jewels string and creating a regular expression object using the new RegExp() method with the g flag to match all occurrences of the character in stones. It then uses the match() method to check if the regular expression matches any characters in stones and increments the res variable by the number of matches. Finally, the function returns the res variable, which contains the count of all occurrences of characters in jewels in the string stones.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(nm), where n and m are the lengths of the jewels and stones strings, respectively. This is because the function iterates over each character in jewels and creates a regular expression object using the new RegExp() method. The regular expression object is then used with the match() method, which searches the entire stones string for matches. Therefore, the time complexity of the match() method is O(m). Since this operation is performed for each character in jewels, the total time complexity of the function is O(nm). The space complexity of the function is O(1), as it only uses a single variable res to store the count of matches and a regular expression object.\\n# Code\\n```\\n/**\\n * @param {string} jewels\\n * @param {string} stones\\n * @return {number}\\n */\\nvar numJewelsInStones = function (jewels, stones) {\\n  let res = 0;\\n\\n  for (let index = 0; index < jewels.length; index++) {\\n    let re = new RegExp(jewels[index], \"g\");\\n    if (stones.match(re) != null) res += stones.match(re).length;\\n  }\\n\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} jewels\\n * @param {string} stones\\n * @return {number}\\n */\\nvar numJewelsInStones = function (jewels, stones) {\\n  let res = 0;\\n\\n  for (let index = 0; index < jewels.length; index++) {\\n    let re = new RegExp(jewels[index], \"g\");\\n    if (stones.match(re) != null) res += stones.match(re).length;\\n  }\\n\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327554,
                "title": "python-solution-without-using-of-any-built-in-function-by-dictionary-data-type-beat-50-solution",
                "content": "# Intuition\\nfirst understand the probelm very well and write down what to do \\n\\n# Approach\\nThink about what to do and how to do first make program on notebook\\nand than dry run \\n\\n\\nit took me 2 days to make programm for this\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        dictj={}\\n        for i in jewels:\\n            if i in dictj:\\n                dictj[i]+=1\\n            else:\\n                dictj[i]=1\\n        sum=0\\n        for j in stones:\\n            if j in dictj:\\n                sum+=dictj[j]\\n                \\n        return(sum)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        dictj={}\\n        for i in jewels:\\n            if i in dictj:\\n                dictj[i]+=1\\n            else:\\n                dictj[i]=1\\n        sum=0\\n        for j in stones:\\n            if j in dictj:\\n                sum+=dictj[j]\\n                \\n        return(sum)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192843,
                "title": "2-approaches-brute-and-optimized",
                "content": "\\n# Approach 1 (Brute Force)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses two for loops to iterate through the characters of both strings. For each character in the stones string, it checks if that character is also present in the jewels string. If it is, then it adds one to the count. At the end, it returns the total count of jewels found in stones.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\nwhere n = stones length & m = jewel length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        for(int i=0; i<stones.length(); i++){\\n            for(int j=0; j<jewels.length(); j++){\\n                if(jewels.charAt(j)==stones.charAt(i)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n\\n\\n# Approach 2 (Using HashSet)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a set to store the jewels, then iterates through the stones and checks if they are in the set. If they are, we increment count.\\n\\n# Complexity\\n- Time complexity: $$O(n+m)$$\\nwhere n = stones length & m = jewel length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        Set set = new HashSet<>();\\n     for(int i: jewels.toCharArray())\\n         set.add(i);\\n     for(int j: stones.toCharArray())\\n         if(set.contains(j)) count++;\\n        return count;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        for(int i=0; i<stones.length(); i++){\\n            for(int j=0; j<jewels.length(); j++){\\n                if(jewels.charAt(j)==stones.charAt(i)){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        Set set = new HashSet<>();\\n     for(int i: jewels.toCharArray())\\n         set.add(i);\\n     for(int j: stones.toCharArray())\\n         if(set.contains(j)) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147045,
                "title": "c-2-solutions-using-map-and-iterative",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - 1\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        map <char, int> m ;\\n        for (int i = 0 ; i < stones.length() ; i ++)\\n        {\\n            m[stones[i]] ++;\\n        }\\n        int cnt = 0 ; \\n        for (auto i : m)\\n        {\\n            for (int j = 0 ; j < jewels.length() ; j ++)\\n            if (i.first == jewels[j])\\n            {\\n                cnt += i.second ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```\\n\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int cnt = 0 ;\\n        for (int j = 0 ; j < jewels.length() ; j++)\\n        {\\n            for (int i = 0 ; i < stones.length() ; i++)\\n            {\\n                if (jewels[j] == stones[i])\\n                {\\n                    cnt++ ; \\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/5c9730c7-0dfd-4673-a880-bbeb747cb533_1675613484.911542.png)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        map <char, int> m ;\\n        for (int i = 0 ; i < stones.length() ; i ++)\\n        {\\n            m[stones[i]] ++;\\n        }\\n        int cnt = 0 ; \\n        for (auto i : m)\\n        {\\n            for (int j = 0 ; j < jewels.length() ; j ++)\\n            if (i.first == jewels[j])\\n            {\\n                cnt += i.second ; \\n            }\\n        }\\n        return cnt ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int cnt = 0 ;\\n        for (int j = 0 ; j < jewels.length() ; j++)\\n        {\\n            for (int i = 0 ; i < stones.length() ; i++)\\n            {\\n                if (jewels[j] == stones[i])\\n                {\\n                    cnt++ ; \\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772246,
                "title": "hashmaps-for-beginners",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        for(char ch : stones.toCharArray())\\n            hm.put(ch,hm.getOrDefault(ch,0)+1);\\n        int res=0;\\n        for(char ch : jewels.toCharArray())\\n            res+=hm.getOrDefault(ch,0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        for(char ch : stones.toCharArray())\\n            hm.put(ch,hm.getOrDefault(ch,0)+1);\\n        int res=0;\\n        for(char ch : jewels.toCharArray())\\n            res+=hm.getOrDefault(ch,0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929699,
                "title": "beginner-friendly-solution-using-frequency-map-and-character-array-concepts",
                "content": "```\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        \\n        \\n        HashMap<Character, Integer> stonesMap = new HashMap<>();\\n        char[] stonesArray = stones.toCharArray();\\n        char[] jewelArray = jewels.toCharArray();\\n        \\n        int count=0;\\n        for(int i=0;i<stones.length();i++){\\n        \\n            stonesMap.put(stonesArray[i], stonesMap.getOrDefault(stonesArray[i],0)+1);\\n        }\\n        \\n        for(int i=0;i<jewels.length();i++){\\n            \\n            if(stonesMap.containsKey(jewelArray[i])){\\n                count+=stonesMap.get(jewelArray[i]);\\n            }\\n            \\n        }\\n        \\n       // System.out.println(stonesMap);\\n        \\n        return count;\\n    }\\n\\t\\n\\t}\\n```\\n\\nStep-1: Create a frequency map of characters in stones string.\\nStep-2: Initialize a count variable.\\nStep-3: Create a character array for the jewel string.\\nStep-4: Look for each occurence of a character found in jewel string in the frequency map of stone string and increment the counter everytime you find a common character.\\nReturn the counter.\\n\\n\\t\\n\\t",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        \\n        \\n        HashMap<Character, Integer> stonesMap = new HashMap<>();\\n        char[] stonesArray = stones.toCharArray();\\n        char[] jewelArray = jewels.toCharArray();\\n        \\n        int count=0;\\n        for(int i=0;i<stones.length();i++){\\n        \\n            stonesMap.put(stonesArray[i], stonesMap.getOrDefault(stonesArray[i],0)+1);\\n        }\\n        \\n        for(int i=0;i<jewels.length();i++){\\n            \\n            if(stonesMap.containsKey(jewelArray[i])){\\n                count+=stonesMap.get(jewelArray[i]);\\n            }\\n            \\n        }\\n        \\n       // System.out.println(stonesMap);\\n        \\n        return count;\\n    }\\n\\t\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765861,
                "title": "c-easy-to-understand-with-explanation",
                "content": "Jewels and Stones -\\n \\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int> mp;                         //  Declare a map to store each character and its count\\n        int ans=0;                                          // Declare a variable to store the total occurences\\n        for(int i=0;i<stones.size();i++)                 \\n        {\\n            mp[stones[i]]++;                                // Store all the characters of stones with their count in the map\\n        }\\n        \\n        for(auto s:jewels)                                  // To check every char of jewels \\n        {\\n            if(mp.find(s)!=mp.end())                     \\n            {\\n                ans+=mp.find(s)->second;                    // If char in jewels is also found in map then add its count to the ans variable \\n            }\\n        }\\n       return ans; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int> mp;                         //  Declare a map to store each character and its count\\n        int ans=0;                                          // Declare a variable to store the total occurences\\n        for(int i=0;i<stones.size();i++)                 \\n        {\\n            mp[stones[i]]++;                                // Store all the characters of stones with their count in the map\\n        }\\n        \\n        for(auto s:jewels)                                  // To check every char of jewels \\n        {\\n            if(mp.find(s)!=mp.end())                     \\n            {\\n                ans+=mp.find(s)->second;                    // If char in jewels is also found in map then add its count to the ans variable \\n            }\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366370,
                "title": "javascript-hashmap",
                "content": "Runtime: 68 ms, faster than 97.43% of JavaScript online submissions for Jewels and Stones.\\nMemory Usage: 40.5 MB, less than 15.40% of JavaScript online submissions for Jewels and Stones.\\n\\n```\\n/**\\n * @param {string} jewels\\n * @param {string} stones\\n * @return {number}\\n */\\nvar numJewelsInStones = function(jewels, stones) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (let c of jewels) {\\n        map[c] = true\\n    }\\n    \\n    for (let c of stones) {\\n        if (map[c]) {\\n            count++\\n        }\\n    }\\n    return count\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} jewels\\n * @param {string} stones\\n * @return {number}\\n */\\nvar numJewelsInStones = function(jewels, stones) {\\n    const map = {}\\n    let count = 0\\n    \\n    for (let c of jewels) {\\n        map[c] = true\\n    }\\n    \\n    for (let c of stones) {\\n        if (map[c]) {\\n            count++\\n        }\\n    }\\n    return count\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1016607,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        occ=dict()\\n        for i in stones:\\n            if i in occ.keys():\\n                occ[i]+=1\\n            else:\\n                occ.update({i:1})\\n        res=0\\n        for i in jewels:\\n            if i in occ.keys():\\n                res+=occ[i]\\n            \\n        return res\\n```\\n\\nOR\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        res=0\\n        for i in stones:\\n            if i in set(jewels):\\n                res+=1\\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        occ=dict()\\n        for i in stones:\\n            if i in occ.keys():\\n                occ[i]+=1\\n            else:\\n                occ.update({i:1})\\n        res=0\\n        for i in jewels:\\n            if i in occ.keys():\\n                res+=occ[i]\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        res=0\\n        for i in stones:\\n            if i in set(jewels):\\n                res+=1\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 609425,
                "title": "c-one-liner",
                "content": "Seems like if it is maximum 50 chars length - it is not necessary to build hash )\\n```\\n    public int NumJewelsInStones(string J, string S) =>\\n        S.Count(J.Contains);\\n```",
                "solutionTags": [],
                "code": "```\\n    public int NumJewelsInStones(string J, string S) =>\\n        S.Count(J.Contains);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608952,
                "title": "java-using-hashset-100-time-o-s",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        Set<Character> set = new HashSet<Character>();\\n        int counter = 0;\\n        for(int i = 0; i < J.length(); i++)\\n            set.add(J.charAt(i));\\n        for(int i = 0; i < S.length(); i++)\\n            if(set.contains(S.charAt(i)))\\n                counter++;\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        Set<Character> set = new HashSet<Character>();\\n        int counter = 0;\\n        for(int i = 0; i < J.length(); i++)\\n            set.add(J.charAt(i));\\n        for(int i = 0; i < S.length(); i++)\\n            if(set.contains(S.charAt(i)))\\n                counter++;\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607804,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    \\n\\tint numJewelsInStones(string J, string S) {\\n        map<char ,int> occurences ; // this map will store occurences of each character in S\\n        for(char x : S)\\n            occurences[x]++;\\n        int ans = 0 ;\\n        for(char y : J)\\n            ans += occurences[y]; \\n        \\n        return ans ;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\tint numJewelsInStones(string J, string S) {\\n        map<char ,int> occurences ; // this map will store occurences of each character in S\\n        for(char x : S)\\n            occurences[x]++;\\n        int ans = 0 ;\\n        for(char y : J)\\n            ans += occurences[y]; \\n        \\n        return ans ;\\n            \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 487624,
                "title": "c-one-liner-with-linq",
                "content": "```\\n    public int NumJewelsInStones(string J, string S)\\n        => (from j in J from s in S where j == s select s).Count();\\n```",
                "solutionTags": [],
                "code": "```\\n    public int NumJewelsInStones(string J, string S)\\n        => (from j in J from s in S where j == s select s).Count();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349691,
                "title": "python-one-liner-faster-than-99",
                "content": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return len([char for char in S if char in J])\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return len([char for char in S if char in J])\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 340814,
                "title": "java-very-easy-solution-100-99-8",
                "content": "```\\n    public int numJewelsInStones(String J, String S) {\\n        int res = 0;\\n        for(char s : S.toCharArray()){\\n            if (J.indexOf(s) != -1) res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numJewelsInStones(String J, String S) {\\n        int res = 0;\\n        for(char s : S.toCharArray()){\\n            if (J.indexOf(s) != -1) res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 310607,
                "title": "simple-c-solution",
                "content": "A simple and elegant C# solution. No need for a HashMap/Dictionary, or to count the number of times each jewel appears - you only care about the grand total. Feedback would be appreciated!\\n\\n```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        int sum = 0;\\n        foreach (char c in S.ToCharArray())\\n        {\\n            if (J.Contains(c))\\n            {\\n                sum++;\\n            }   \\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        int sum = 0;\\n        foreach (char c in S.ToCharArray())\\n        {\\n            if (J.Contains(c))\\n            {\\n                sum++;\\n            }   \\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246113,
                "title": "java-solution-using-the-regex",
                "content": "It\\'s simple when using regex operation :) I just remove any character that does not match letters used in the J string\\n\\n```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        return S.replaceAll(\"[^\" + J + \"]\", \"\").length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        return S.replaceAll(\"[^\" + J + \"]\", \"\").length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164780,
                "title": "javascript-solution-beats-98-94",
                "content": "```\\n/**\\n * @param {string} J\\n * @param {string} S\\n * @return {number}\\n */\\nvar numJewelsInStones = function(J, S) {\\n    if (!J || !S) return 0;\\n    \\n    let count = 0;\\n    for (const c of S) {\\n        if (J.includes(c)) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} J\\n * @param {string} S\\n * @return {number}\\n */\\nvar numJewelsInStones = function(J, S) {\\n    if (!J || !S) return 0;\\n    \\n    let count = 0;\\n    for (const c of S) {\\n        if (J.includes(c)) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164657,
                "title": "javascript-solution",
                "content": "```\\nvar numJewelsInStones = function(J, S) {\\n    let map = {};\\n    let res = 0;\\n    for(let i = 0; i < J.length; i ++){\\n        map[J[i]] = true;\\n    }\\n    for(let i = 0; i < S.length; i ++){\\n        if(map[S[i]] === true){\\n            res ++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numJewelsInStones = function(J, S) {\\n    let map = {};\\n    let res = 0;\\n    for(let i = 0; i < J.length; i ++){\\n        map[J[i]] = true;\\n    }\\n    for(let i = 0; i < S.length; i ++){\\n        if(map[S[i]] === true){\\n            res ++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129066,
                "title": "1-liner-javascript",
                "content": "inspired by java solution in https://leetcode.com/problems/jewels-and-stones/discuss/113574/1-liners-PythonJavaRuby\\n```\\nvar numJewelsInStones = function(J, S) {\\n    return S.replace(new RegExp(`[^${J}]`, \\'g\\'), \\'\\').length;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numJewelsInStones = function(J, S) {\\n    return S.replace(new RegExp(`[^${J}]`, \\'g\\'), \\'\\').length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786742,
                "title": "easy-c-solution",
                "content": "# **please upvote my solution if you like it**\\n\\n\\nint numJewelsInStones(string jewels, string stones) {\\n     int c=0;\\n     for(int i=0;i<jewels.length();i++){\\n         for(int j=0;j<stones.length();j++){\\n             if(jewels[i]==stones[j]){\\n                 c=c+1;\\n             }\\n         }\\n     }\\n        return c;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "# **please upvote my solution if you like it**\\n\\n\\nint numJewelsInStones(string jewels, string stones) {\\n     int c=0;\\n     for(int i=0;i<jewels.length();i++){\\n         for(int j=0;j<stones.length();j++){\\n             if(jewels[i]==stones[j]){\\n                 c=c+1;\\n             }\\n         }\\n     }\\n        return c;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3493890,
                "title": "c-python-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count = 0;\\n        for(auto i : stones) {\\n            if(jewels.find(i) != -1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        count = 0\\n        for i in stones:\\n            if i in jewels:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count = 0;\\n        for(auto i : stones) {\\n            if(jewels.find(i) != -1) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        count = 0\\n        for i in stones:\\n            if i in jewels:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880981,
                "title": "python-solution-easy",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        output = 0\\n        for word in list(jewels):\\n                output += stones.count(word)\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        output = 0\\n        for word in list(jewels):\\n                output += stones.count(word)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404269,
                "title": "jewels-and-stones-javascript",
                "content": "```\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count=0;\\n    for(let i in jewels){\\n        for(let j in stones){\\n            if(jewels[i]==stones[j]) count=count+1\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count=0;\\n    for(let i in jewels){\\n        for(let j in stones){\\n            if(jewels[i]==stones[j]) count=count+1\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804792,
                "title": "python-3-simple-solution",
                "content": "**1)** First option, faster than 62%, converts both to lists and finds the commen elemnts through list comprehension and returns the length of that list.\\n\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        stones = list(stones)\\n        jewels = list(jewels)\\n        \\n        match = len([i for i in stones if i in jewels])\\n        \\n        return match\\n```\\n\\n**2)** That can be reduced to the following, but it\\'s a tad slower at 57%.\\n\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return len([i for i in list(stones) if i in list(jewels)])\\n```\\n\\nThere are of course faster ways to do this, but I didn\\'t see this method posted (probably for good reason haha) so I wanted to share it.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        stones = list(stones)\\n        jewels = list(jewels)\\n        \\n        match = len([i for i in stones if i in jewels])\\n        \\n        return match\\n```\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return len([i for i in list(stones) if i in list(jewels)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791598,
                "title": "easy-c-solution-2-different-approach",
                "content": "Hash Map Solution\\n\\nTime:O(n)\\nAux Space:O(n)\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n   int c=0;\\n        unordered_set<char>s;\\n       \\n           \\n        for(auto i:jewels)\\n             s.insert(i);\\n        \\n         for(auto j:stones)\\n                if(s.find(j)!=s.end())\\n                c++;\\n        \\n        return c;\\n    }\\n};\\n```\\n\\nOther Approach\\n\\nTime:O(n^2)\\nSpace:O(1)\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n   int c=0;\\n        for(auto j:stones)\\n          for(auto i:jewels)\\n                if(j==i)\\n                {c++;break;}\\n        return c;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n   int c=0;\\n        unordered_set<char>s;\\n       \\n           \\n        for(auto i:jewels)\\n             s.insert(i);\\n        \\n         for(auto j:stones)\\n                if(s.find(j)!=s.end())\\n                c++;\\n        \\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n   int c=0;\\n        for(auto j:stones)\\n          for(auto i:jewels)\\n                if(j==i)\\n                {c++;break;}\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697391,
                "title": "python-code-jewels-and-stones",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        ct=0\\n        for i in range(len(stones)):\\n            if stones[i] in jewels:\\n                ct+=1\\n        return ct\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        ct=0\\n        for i in range(len(stones)):\\n            if stones[i] in jewels:\\n                ct+=1\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304948,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int b=0;\\n        unordered_map<char,bool>umap;\\n        for(auto c:jewels){\\n            if(umap[c]==0){\\n                umap[c]=1;\\n            }\\n        }\\n        for(auto c:stones){\\n            if(umap[c]==1)\\n                b++;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int b=0;\\n        unordered_map<char,bool>umap;\\n        for(auto c:jewels){\\n            if(umap[c]==0){\\n                umap[c]=1;\\n            }\\n        }\\n        for(auto c:stones){\\n            if(umap[c]==1)\\n                b++;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047701,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, j: str, s: str) -> int:\\n        return sum(i in j for i in s)\\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, j: str, s: str) -> int:\\n        return sum(i in j for i in s)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045273,
                "title": "javascript-one-line-without-regex-solution",
                "content": "```\\nconst numJewelsInStones = (jewels, stones) => stones.split(\\'\\').filter(s => jewels.split(\\'\\').includes(s)).length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numJewelsInStones = (jewels, stones) => stones.split(\\'\\').filter(s => jewels.split(\\'\\').includes(s)).length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1027353,
                "title": "c-java-set-solution-simple-solution",
                "content": "***Implementation***\\n\\n**1st Approach in C++**\\nTime Complexity = O(jewels.size() + stones.size()), Space Complexity = O(jewels.size())\\n```\\nint numJewelsInStones(string jewels, string stones) {\\n    int count = 0;\\n    unordered_set<char> setJewels(jewels.begin(), jewels.end());\\n    for(char ch : stones){\\n        if(setJewels.find(ch) != setJewels.end()) count++;  \\n    }\\n    return count;\\n}\\n```\\n**2nd Approach in Java**\\nTime Complexity = O(jewels.length() + stones.length()), Space Complexity = O(jewels.length())\\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n    int count = 0;        \\n    Set setJewels = new HashSet();\\n    for(int itr = 0; itr < jewels.length(); itr++)\\n        setJewels.add(jewels.charAt(itr)); \\n    \\n    for(int itr = 0; itr < stones.length(); itr++){\\n        if(setJewels.contains(stones.charAt(itr))) count++;  \\n    }\\n    return count;\\n}\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nint numJewelsInStones(string jewels, string stones) {\\n    int count = 0;\\n    unordered_set<char> setJewels(jewels.begin(), jewels.end());\\n    for(char ch : stones){\\n        if(setJewels.find(ch) != setJewels.end()) count++;  \\n    }\\n    return count;\\n}\\n```\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n    int count = 0;        \\n    Set setJewels = new HashSet();\\n    for(int itr = 0; itr < jewels.length(); itr++)\\n        setJewels.add(jewels.charAt(itr)); \\n    \\n    for(int itr = 0; itr < stones.length(); itr++){\\n        if(setJewels.contains(stones.charAt(itr))) count++;  \\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674219,
                "title": "java-set",
                "content": "```\\n\\tpublic int numJewelsInStones(String J, String S) {\\n        Set<Character> js = new HashSet<>();\\n        for (char c : J.toCharArray()) {\\n            js.add(c);\\n        }\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (js.contains(c)) res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numJewelsInStones(String J, String S) {\\n        Set<Character> js = new HashSet<>();\\n        for (char c : J.toCharArray()) {\\n            js.add(c);\\n        }\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (js.contains(c)) res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609154,
                "title": "python-solution-o-1-space-without-array-and-dictionary",
                "content": "```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n        \"\"\" O(n + m) time complexity, O(1) space complexity (using only 2 variables)\"\"\"\\n        count = 0\\n        bitfield = 0\\n        \\n        # Using bits in @bitfield as an array of boolean values\\n        # First loop sets bits from @J\\n        for c in J:\\n            idx = ord(c) - 65\\n            bitfield |= (1 << idx)\\n            \\n        # Second loop checks if the bit is set, if it is then increment the counter\\n        for c in S:\\n            idx = ord(c) - 65\\n            if (bitfield & (1 << idx)):\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n        \"\"\" O(n + m) time complexity, O(1) space complexity (using only 2 variables)\"\"\"\\n        count = 0\\n        bitfield = 0\\n        \\n        # Using bits in @bitfield as an array of boolean values\\n        # First loop sets bits from @J\\n        for c in J:\\n            idx = ord(c) - 65\\n            bitfield |= (1 << idx)\\n            \\n        # Second loop checks if the bit is set, if it is then increment the counter\\n        for c in S:\\n            idx = ord(c) - 65\\n            if (bitfield & (1 << idx)):\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 442124,
                "title": "c-linq-simple-one-liner",
                "content": "```\\nusing System.Linq;\\n\\npublic class Solution \\n{\\n    public int NumJewelsInStones(string J, string S) \\n    {\\n        return S.Count(stone => J.Contains(stone));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Linq;\\n\\npublic class Solution \\n{\\n    public int NumJewelsInStones(string J, string S) \\n    {\\n        return S.Count(stone => J.Contains(stone));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379843,
                "title": "a-simple-c-hashset-solution",
                "content": "A simple C# linear scan solution. Feel free to suggest improvements.\\n\\n**Time Complexity:** O(Max(n, m)) where n is the length of J (Jewels string) and m is the length of S (Stones string)\\n**Space Complexity:** O(n) where n is the length of J (Jewels string)\\n\\nRuntime: 72 ms, faster than 95.83% of C# online submissions for Jewels and Stones.\\nMemory Usage: 21.4 MB, less than 7.14% of C# online submissions for Jewels and Stones.\\n\\n\\n```\\n    public int NumJewelsInStones(string J, string S) {\\n        if(string.IsNullOrEmpty(S) || string.IsNullOrEmpty(J)){\\n            return 0;\\n        }\\n        \\n        HashSet<char> jewels = new HashSet<char>();\\n        int jewelCount = 0;\\n        \\n        for(int i = 0; i < J.Length; i++){\\n            jewels.Add(J[i]);\\n        }\\n        for(int i = 0; i < S.Length; i++){\\n            if(jewels.Contains(S[i])){\\n                jewelCount++;\\n            }\\n        }\\n        return jewelCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int NumJewelsInStones(string J, string S) {\\n        if(string.IsNullOrEmpty(S) || string.IsNullOrEmpty(J)){\\n            return 0;\\n        }\\n        \\n        HashSet<char> jewels = new HashSet<char>();\\n        int jewelCount = 0;\\n        \\n        for(int i = 0; i < J.Length; i++){\\n            jewels.Add(J[i]);\\n        }\\n        for(int i = 0; i < S.Length; i++){\\n            if(jewels.Contains(S[i])){\\n                jewelCount++;\\n            }\\n        }\\n        return jewelCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375800,
                "title": "100-100",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        char []temp = S.toCharArray();\\n        int n = 0;\\n        for(int i = 0; i < temp.length; ++i){\\n            if(J.indexOf(temp[i]) != -1){\\n                n++;\\n            }\\n        }\\n        return n;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        char []temp = S.toCharArray();\\n        int n = 0;\\n        for(int i = 0; i < temp.length; ++i){\\n            if(J.indexOf(temp[i]) != -1){\\n                n++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 267731,
                "title": "python-2-lines-beats-100",
                "content": "We could do this in one line, but converting J to a set gives us O(1) lookup \\n```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n        jewels = set([j for j in J])\\n        return len([s for s in S if s in jewels])",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "We could do this in one line, but converting J to a set gives us O(1) lookup \\n```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n        jewels = set([j for j in J])\\n        return len([s for s in S if s in jewels])",
                "codeTag": "Python3"
            },
            {
                "id": 248782,
                "title": "c-fast-and-easy-way-vector-or-hash-table",
                "content": "```\\n1. Using Vector \\n\\nint numJewelsInStones(string J, string S) {\\n        vector<int> vec(128, 0);\\n        int result = 0;\\n        \\n        for(auto j : J)\\n            vec[j]= 1;\\n        \\n        for(auto s : S){\\n            if(vec[s] > 0)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n\\t2. Using unordered_map(Hash Table)\\n\\n\\t    int numJewelsInStones(string J, string S) {\\n        unordered_map<int, int> map(128);\\n        int result = 0;\\n        \\n        for(auto j : J)\\n            map.insert({j, 1});\\n        \\n        for(auto s : S){\\n            if(map[s] > 0)\\n                result++;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n1. Using Vector \\n\\nint numJewelsInStones(string J, string S) {\\n        vector<int> vec(128, 0);\\n        int result = 0;\\n        \\n        for(auto j : J)\\n            vec[j]= 1;\\n        \\n        for(auto s : S){\\n            if(vec[s] > 0)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n\\t\\n\\t2. Using unordered_map(Hash Table)\\n\\n\\t    int numJewelsInStones(string J, string S) {\\n        unordered_map<int, int> map(128);\\n        int result = 0;\\n        \\n        for(auto j : J)\\n            map.insert({j, 1});\\n        \\n        for(auto s : S){\\n            if(map[s] > 0)\\n                result++;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 240076,
                "title": "faster-than-99-79-java-solutions",
                "content": "public int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        for(int i=0; i<S.length(); i++) \\n            count = J.indexOf(S.charAt(i)) >= 0 ? ++count : count;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "public int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        for(int i=0; i<S.length(); i++) \\n            count = J.indexOf(S.charAt(i)) >= 0 ? ++count : count;\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 204663,
                "title": "javascript-2-line-regex-solution-56ms-99",
                "content": "var numJewelsInStones = function(J, S) {\\n    var re = new RegExp(\\'[^\\' + J + \\']\\',\\'g\\');\\n    return S.replace(re,\\'\\').length;\\n};",
                "solutionTags": [],
                "code": "var numJewelsInStones = function(J, S) {\\n    var re = new RegExp(\\'[^\\' + J + \\']\\',\\'g\\');\\n    return S.replace(re,\\'\\').length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 204326,
                "title": "python-one-line",
                "content": "```class Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([1 if char in set(J) else 0 for char in S])",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        return sum([1 if char in set(J) else 0 for char in S])",
                "codeTag": "Java"
            },
            {
                "id": 175557,
                "title": "one-line-c-solution",
                "content": "```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        return S.Count(i => J.Contains(i));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        return S.Count(i => J.Contains(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150288,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.Counter(S)\\n        count = 0\\n        for ch in J:\\n            count += counter[ch]\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, J, S):\\n        \"\"\"\\n        :type J: str\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        counter = collections.Counter(S)\\n        count = 0\\n        for ch in J:\\n            count += counter[ch]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 144786,
                "title": "o-n-c-solution",
                "content": "This is my solution in C#\\n```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        char[] types = new char[60];\\n       \\n        int count=0;\\n        foreach(var c in J)\\n        {\\n            types[c-\\'A\\']++;\\n        }\\n         foreach(var c in S )\\n         {\\n             if(types[c-\\'A\\']>0)\\n                 count++;\\n         }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumJewelsInStones(string J, string S) {\\n        char[] types = new char[60];\\n       \\n        int count=0;\\n        foreach(var c in J)\\n        {\\n            types[c-\\'A\\']++;\\n        }\\n         foreach(var c in S )\\n         {\\n             if(types[c-\\'A\\']>0)\\n                 count++;\\n         }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123247,
                "title": "1-line-swift-solution",
                "content": "```\\nclass Solution {\\n    func numJewelsInStones(_ J: String, _ S: String) -> Int {\\n        return (S.filter { J.contains($0) } as [Character]).count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numJewelsInStones(_ J: String, _ S: String) -> Int {\\n        return (S.filter { J.contains($0) } as [Character]).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113562,
                "title": "java-solution",
                "content": "```\\nint res = 0, index = 0;\\nfor (int i = 0; i < J.length(); i++) {\\n        char jewel = J.charAt(i);\\n        while ((index = S.indexOf(String.valueOf(jewel), index)) != -1) {\\n            ++res;\\n            ++index;\\n        }\\n    }\\nreturn res;\\n```",
                "solutionTags": [],
                "code": "```\\nint res = 0, index = 0;\\nfor (int i = 0; i < J.length(); i++) {\\n        char jewel = J.charAt(i);\\n        while ((index = S.indexOf(String.valueOf(jewel), index)) != -1) {\\n            ++res;\\n            ++index;\\n        }\\n    }\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 113581,
                "title": "java-5-liner-hashset",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        Set<Character> set = new HashSet<>();\\n        for (char c : J.toCharArray()) set.add(c);\\n        int res = 0;\\n        for (char c : S.toCharArray()) if (set.contains(c)) res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        Set<Character> set = new HashSet<>();\\n        for (char c : J.toCharArray()) set.add(c);\\n        int res = 0;\\n        for (char c : S.toCharArray()) if (set.contains(c)) res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958673,
                "title": "python3-hash-map-beats-98-25-runtime-65-81-memory",
                "content": "# Intuition\\nJust count the number of occurrences of each jewel in stones via a hash map.\\n\\n# Approach\\nCreate a hash map with each character in jewels as key and their frequency in stones as value. Initially all jewel counts are set to 0. Iterate over the stones string checking on each iteration whether it is a jewel or not, if so we increment they key-value pair by 1. \\n\\n# Complexity\\n\\nLet m & n be lengths of jewels and stones strings respectively.\\n\\n- Time complexity: $$\\\\bold O(\\\\bold n)$$\\n\\n- Space complexity: $$\\\\bold O(\\\\bold m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n\\n        jewel_map = {j:0 for j in jewels}\\n\\n        for s in stones:\\n            if s in jewel_map:\\n                jewel_map[s] += 1\\n        \\n        return sum(jewel_map.values())\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n\\n        jewel_map = {j:0 for j in jewels}\\n\\n        for s in stones:\\n            if s in jewel_map:\\n                jewel_map[s] += 1\\n        \\n        return sum(jewel_map.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758449,
                "title": "simple-easy-to-understand-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(Character i : stones.toCharArray()){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Character i : jewels.toCharArray()){\\n            if(map.get(i) != null)\\n                ans += map.get(i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for(Character i : stones.toCharArray()){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        int ans = 0;\\n        for(Character i : jewels.toCharArray()){\\n            if(map.get(i) != null)\\n                ans += map.get(i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709715,
                "title": "simple-code-working",
                "content": "# Intuition\\nIterate over stones and see it the stone is jewel or not\\n\\n# Approach\\n1. Change jewels from str to list\\n2. Iterate on stones [For Loop]\\n3. If stone is jewel, increment the result\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        result = 0\\n        for s in stones:\\n            if s in jewels:\\n                result += 1\\n        return result\\n```\\nPlease upvote if you found this helpful.\\nThank you :)\\n\\nYours-Truly-Rshi",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        result = 0\\n        for s in stones:\\n            if s in jewels:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637481,
                "title": "92-beats-in-runtime-84-beats-in-memory-easy-way-using-loops-not-nested",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int res = 0;\\n        int[] arr = new int[26];\\n        int[] arr2 = new int[26];\\n        for(int i = 0; i < stones.length(); i++) {\\n            char c = stones.charAt(i);\\n            if (Character.isLowerCase(c)){\\n                arr[c - \\'a\\']++;\\n            }\\n            else arr2[c - \\'A\\']++;\\n            \\n        }\\n\\n        for(int i = 0; i < jewels.length(); i++) {\\n            char c = jewels.charAt(i);\\n            if (Character.isLowerCase(c)){\\n                if (arr[c - \\'a\\'] != 0 ) res += arr[c - \\'a\\'];\\n            }\\n            else {\\n                if (arr2[c - \\'A\\'] != 0 ) res += arr2[c - \\'A\\'];\\n\\n            }\\n            \\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int res = 0;\\n        int[] arr = new int[26];\\n        int[] arr2 = new int[26];\\n        for(int i = 0; i < stones.length(); i++) {\\n            char c = stones.charAt(i);\\n            if (Character.isLowerCase(c)){\\n                arr[c - \\'a\\']++;\\n            }\\n            else arr2[c - \\'A\\']++;\\n            \\n        }\\n\\n        for(int i = 0; i < jewels.length(); i++) {\\n            char c = jewels.charAt(i);\\n            if (Character.isLowerCase(c)){\\n                if (arr[c - \\'a\\'] != 0 ) res += arr[c - \\'a\\'];\\n            }\\n            else {\\n                if (arr2[c - \\'A\\'] != 0 ) res += arr2[c - \\'A\\'];\\n\\n            }\\n            \\n        }\\n\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558208,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        int i = stones.length() - 1;\\n        while(i >= 0) {\\n            count += jewels.indexOf(stones.charAt(i)) > -1 ? 1 : 0;\\n            i--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n        int i = stones.length() - 1;\\n        while(i >= 0) {\\n            count += jewels.indexOf(stones.charAt(i)) > -1 ? 1 : 0;\\n            i--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542650,
                "title": "simple-java-100",
                "content": "# Upvote when you find usefull.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        char a[]=jewels.toCharArray();\\n        char b[]=stones.toCharArray();\\n        int count=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            for(int j=0;j<a.length;j++)\\n            {\\n                if(a[j]==b[i])count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "String Matching",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        char a[]=jewels.toCharArray();\\n        char b[]=stones.toCharArray();\\n        int count=0;\\n        for(int i=0;i<b.length;i++)\\n        {\\n            for(int j=0;j<a.length;j++)\\n            {\\n                if(a[j]==b[i])count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349614,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        counter = 0\\n        for i in stones:\\n            if i in jewels:\\n                counter += 1\\n        return counter\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        counter = 0\\n        for i in stones:\\n            if i in jewels:\\n                counter += 1\\n        return counter\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186752,
                "title": "hashing-detailed-explanation",
                "content": "\\n# Approach\\nFirstly, I created an array of chars with 256 length.\\nSecondly, using for-loop I:\\n- Placed each character of the string on the chracter\\'s ASCII code position, so \\'A\\' would have index equal to 65, \\'B\\' would have index 66 etc.\\n- With every letter at its own position I increased number at that position using \\'++\\'. Thus, if \\'A\\' would occur twice, array \\'arrstones\\' at index 65 would have 2.\\nThirdly, I used next for-loop to find frequency of every letter in the \\'jewels\\', that is stored in \\'arrstones\\' under the letter\\'s ASCII code index\\n\\nP.S. If you liked my solution and explanation, please, like it, I would be really grateful for it\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        vector<char> arrstones(256);\\n        for (int i = 0; i < stones.length(); i++)\\n        {\\n            arrstones[stones[i]]++;\\n        }\\n\\n        int result = 0;\\n        \\n        for (int i = 0; i < jewels.length(); i++)\\n        {\\n            result += arrstones[jewels[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        vector<char> arrstones(256);\\n        for (int i = 0; i < stones.length(); i++)\\n        {\\n            arrstones[stones[i]]++;\\n        }\\n\\n        int result = 0;\\n        \\n        for (int i = 0; i < jewels.length(); i++)\\n        {\\n            result += arrstones[jewels[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140336,
                "title": "best-and-easy-to-understand-solution-c",
                "content": "class Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int k, y = 0;\\n        int n = jewels.size();\\n        for (int i = 0; i <n; i++) {\\n            k = count (stones.begin(), stones.end(), jewels[i]);\\n            y += k;\\n        }\\n        return y;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int k, y = 0;\\n        int n = jewels.size();\\n        for (int i = 0; i <n; i++) {\\n            k = count (stones.begin(), stones.end(), jewels[i]);\\n            y += k;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3043325,
                "title": "python-1-simple-solution-3-one-liner-solutions",
                "content": "# Code\\n```\\ndef numJewelsInStones(jewels, stones):\\n    count = 0\\n    for i in stones:\\n        if i in jewels:\\n            count += 1\\n    return count\\n\\n    # 1 liners\\n    return len([i for i in stones if i in jewels])\\n    return sum([stones.count(i) for i in jewels])\\n    return sum([i in jewels for i in stones])  # returns sum(boolean list)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numJewelsInStones(jewels, stones):\\n    count = 0\\n    for i in stones:\\n        if i in jewels:\\n            count += 1\\n    return count\\n\\n    # 1 liners\\n    return len([i for i in stones if i in jewels])\\n    return sum([stones.count(i) for i in jewels])\\n    return sum([i in jewels for i in stones])  # returns sum(boolean list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2980228,
                "title": "easiest-beats-100-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int jlen=jewels.size();char str;int slen=stones.size();\\n        int i,j,ctr=0;\\n        for(i=0;i<jlen;i++){\\n            str=jewels[i];\\n            for(j=0;j<slen;j++){\\n                if(str==stones[j]){\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int jlen=jewels.size();char str;int slen=stones.size();\\n        int i,j,ctr=0;\\n        for(i=0;i<jlen;i++){\\n            str=jewels[i];\\n            for(j=0;j<slen;j++){\\n                if(str==stones[j]){\\n                    ctr++;\\n                }\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787673,
                "title": "c-hashmap-beginner-easy",
                "content": "# Approach\\nFirst, we take all the jewel elements and store it in a hashmap. Then we take the stones and compare if it is present in the jewel map or not\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int> jew;\\n        int ret = 0;\\n\\n        for(auto x: jewels)\\n        {\\n            jew[x]++;\\n        }\\n        for(auto x: stones)\\n        {\\n            if(jew[x] > 0)\\n            {\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int> jew;\\n        int ret = 0;\\n\\n        for(auto x: jewels)\\n        {\\n            jew[x]++;\\n        }\\n        for(auto x: stones)\\n        {\\n            if(jew[x] > 0)\\n            {\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633905,
                "title": "python-easy-solution-in-5-lines",
                "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        c=0\\n        for i in stones:\\n            if i in jewels:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        c=0\\n        for i in stones:\\n            if i in jewels:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515310,
                "title": "java-simple-one-line-3-other-solutions",
                "content": "\\n**One line solution**\\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\treturn (int) stones.chars().filter(c -> jewels.contains(String.valueOf((char) c))).count();\\n}\\n```\\n---\\n**Two lines solution**\\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\tSet<Character> jewelStore = jewels.chars().mapToObj(c -> (char) c).collect(Collectors.toSet());\\n\\treturn (int) stones.chars().filter(c -> jewelStore.contains((char) c)).count();\\n}\\n```\\n---\\n**Standard Approach**\\n\\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\tSet<Character> jewelStore = new HashSet<>();\\n\\tfor (char c : jewels.toCharArray()) {\\n\\t\\tjewelStore.add(c);\\n\\t}\\n\\tint count = 0;\\n\\tfor (int i = 0; i < stones.length(); i++) {\\n\\t\\tif (jewelStore.contains(stones.charAt(i))) {\\n\\t\\t\\tcount += 1;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n---\\n**Another one liner from discuss section...**\\n```\\n# This one after seeing this - https://leetcode.com/problems/jewels-and-stones/discuss/113574\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\treturn stones.replaceAll(\"[^\" + jewels + \"]\", \"\").length();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\treturn (int) stones.chars().filter(c -> jewels.contains(String.valueOf((char) c))).count();\\n}\\n```\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\tSet<Character> jewelStore = jewels.chars().mapToObj(c -> (char) c).collect(Collectors.toSet());\\n\\treturn (int) stones.chars().filter(c -> jewelStore.contains((char) c)).count();\\n}\\n```\n```\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\tSet<Character> jewelStore = new HashSet<>();\\n\\tfor (char c : jewels.toCharArray()) {\\n\\t\\tjewelStore.add(c);\\n\\t}\\n\\tint count = 0;\\n\\tfor (int i = 0; i < stones.length(); i++) {\\n\\t\\tif (jewelStore.contains(stones.charAt(i))) {\\n\\t\\t\\tcount += 1;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\n```\\n# This one after seeing this - https://leetcode.com/problems/jewels-and-stones/discuss/113574\\npublic int numJewelsInStones(String jewels, String stones) {\\n\\treturn stones.replaceAll(\"[^\" + jewels + \"]\", \"\").length();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2212943,
                "title": "c-2-lines-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string j, string s) {\\n        int ans=0;\\n        for( char c: s){\\n            if(j.find(c)!=string::npos)\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numJewelsInStones(string j, string s) {\\n        int ans=0;\\n        for( char c: s){\\n            if(j.find(c)!=string::npos)\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2165889,
                "title": "python3-o-j-s-o-1-runtime-27ms-97-69-memory-10mb-10-87",
                "content": "```\\nclass Solution:\\n# O(j+s) where j is jewels and s is stones\\n# memory: O(1) we will english letters.\\n#   Runtime: 27ms 97.69% memory: 10mb 10.87%\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        jewelsMap = dict()\\n        for i in jewels:\\n            jewelsMap[i] = jewelsMap.get(i, 0) + 1\\n\\n        oldSum = sum(jewelsMap.values())\\n\\n        for i in stones:\\n            if i in jewelsMap:\\n                jewelsMap[i] = jewelsMap.get(i, 0) + 1\\n\\n\\n        return sum(jewelsMap.values()) - oldSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n# O(j+s) where j is jewels and s is stones\\n# memory: O(1) we will english letters.\\n#   Runtime: 27ms 97.69% memory: 10mb 10.87%\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        jewelsMap = dict()\\n        for i in jewels:\\n            jewelsMap[i] = jewelsMap.get(i, 0) + 1\\n\\n        oldSum = sum(jewelsMap.values())\\n\\n        for i in stones:\\n            if i in jewelsMap:\\n                jewelsMap[i] = jewelsMap.get(i, 0) + 1\\n\\n\\n        return sum(jewelsMap.values()) - oldSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153437,
                "title": "c-simple-solution-using-hashset",
                "content": "```\\npublic int NumJewelsInStones(string jewels, string stones) {\\n        HashSet<char> charHash = new HashSet<char>(jewels);\\n        int count = 0;\\n        \\n        foreach(char c in stones){\\n            if(charHash.Contains(c))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\npublic int NumJewelsInStones(string jewels, string stones) {\\n        HashSet<char> charHash = new HashSet<char>(jewels);\\n        int count = 0;\\n        \\n        foreach(char c in stones){\\n            if(charHash.Contains(c))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2027693,
                "title": "python-easy-solution-with-explanation",
                "content": "Iterate through jewels and see how many of that letter there is in stones. Add that amount to count.\\n\\n```\\nclass Solution(object):\\n    def numJewelsInStones(self, jewels, stones):\\n        \"\"\"\\n        :type jewels: str\\n        :type stones: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(jewels)):\\n            count = count + stones.count(jewels[i])  \\n        return count\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numJewelsInStones(self, jewels, stones):\\n        \"\"\"\\n        :type jewels: str\\n        :type stones: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(jewels)):\\n            count = count + stones.count(jewels[i])  \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901102,
                "title": "c-hashmap-solution-commented-explanation",
                "content": "Please upvote if you liked it :)\\nif you still have any doubts, feel free to ask in the comments\\n\\n```\\nint numJewelsInStones(string jewels, string stones)\\n{\\n\\t// it will store count of characters in string \\'stones\\'\\n    unordered_map<char, int> cnt;\\n    \\n    for (const char &c : stones)\\n    {\\n        cnt[c]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (const char &c : jewels)\\n    {\\n        // we are checking the chars of jewels in cnt(that is count of chars of \\'stones\\')\\n        // \\'it\\' will have a value if char c of jewls is present in cnt (\\'stones\\')\\n        // else \\'it\\' will be cnt.end()\\n        auto it = cnt.find(c);\\n\\n        // if \\'it\\' is not cnt.end() then we are incrementing count by value of \\'it\\'\\n        if (it != cnt.end())\\n            count += it->second;\\n    }\\n\\n    return count;\\n}\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Please upvote if you liked it :)\\nif you still have any doubts, feel free to ask in the comments\\n\\n```\\nint numJewelsInStones(string jewels, string stones)\\n{\\n\\t// it will store count of characters in string \\'stones\\'\\n    unordered_map<char, int> cnt;\\n    \\n    for (const char &c : stones)\\n    {\\n        cnt[c]++;\\n    }\\n\\n    int count = 0;\\n\\n    for (const char &c : jewels)\\n    {\\n        // we are checking the chars of jewels in cnt(that is count of chars of \\'stones\\')\\n        // \\'it\\' will have a value if char c of jewls is present in cnt (\\'stones\\')\\n        // else \\'it\\' will be cnt.end()\\n        auto it = cnt.find(c);\\n\\n        // if \\'it\\' is not cnt.end() then we are incrementing count by value of \\'it\\'\\n        if (it != cnt.end())\\n            count += it->second;\\n    }\\n\\n    return count;\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1850774,
                "title": "easy-java-solution-with-efficient-approach-100-faster-o-1-space-complexity",
                "content": "**Easy Solution !!!**\\n\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n     int count=0;\\n\\n    for(int i=0;i<stones.length();i++)\\n    {\\n        if(jewels.indexOf(stones.charAt(i))!=-1) \\n            count++;\\n    }\\n        return count;\\n    }\\n}\\n```\\n\\n**Comment if You have better Approach & found it helpful !!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n     int count=0;\\n\\n    for(int i=0;i<stones.length();i++)\\n    {\\n        if(jewels.indexOf(stones.charAt(i))!=-1) \\n            count++;\\n    }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761061,
                "title": "simplest-way-in-c-must-see",
                "content": "\\'\\'\\'\\n\\n    class Solution {\\n    public:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            for(int j=0;j<jewels.size();j++)\\n            {\\n                if(stones[i]==jewels[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            for(int j=0;j<jewels.size();j++)\\n            {\\n                if(stones[i]==jewels[j])\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1697195,
                "title": "java-easy-to-understand-using-one-loop-o-s-complexity",
                "content": "The idea is to iterate the string and check whether the character in stone string is present in jewels string or not. If present then count it , if not then skip it. \\nTime - O(s) Space - O(1)\\nPlease upvote if you find it helpful. Thanks\\n```\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int result = 0;\\n        for(int i = 0; i < stones.length(); i++){\\n            if(jewels.indexOf(stones.charAt(i)) != -1){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int result = 0;\\n        for(int i = 0; i < stones.length(); i++){\\n            if(jewels.indexOf(stones.charAt(i)) != -1){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1375777,
                "title": "java-100-faster-easy-solution",
                "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        \\n        boolean[] jewelSet = new boolean[150];\\n        for(int i = 0; i < jewels.length(); i++){\\n            jewelSet[jewels.charAt(i)] = true;\\n            \\n        }\\n        \\n        int c = 0;\\n        for(int i = 0; i < stones.length(); i++){\\n            if(jewelSet[stones.charAt(i)]){\\n                c++;\\n            }\\n        }\\n        \\n        return c;        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        \\n        boolean[] jewelSet = new boolean[150];\\n        for(int i = 0; i < jewels.length(); i++){\\n            jewelSet[jewels.charAt(i)] = true;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316968,
                "title": "java-simple-0ms-o-n",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int[] arr = new int[128];      \\n        for(char c : jewels.toCharArray()){\\n          arr[c]++;\\n        }\\n        int count = 0;\\n        for(char each : stones.toCharArray()){\\n          if(arr[each]>=1){\\n            count++;\\n          }\\n        }\\n          \\n      return count;\\n      \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int[] arr = new int[128];      \\n        for(char c : jewels.toCharArray()){\\n          arr[c]++;\\n        }\\n        int count = 0;\\n        for(char each : stones.toCharArray()){\\n          if(arr[each]>=1){\\n            count++;\\n          }\\n        }\\n          \\n      return count;\\n      \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295422,
                "title": "c-solution-100-faster-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n        for(int i=0;i<stones.length();i++) {\\n            size_t found = jewels.find(stones[i]);\\n            if (found != string::npos)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int count=0;\\n        for(int i=0;i<stones.length();i++) {\\n            size_t found = jewels.find(stones[i]);\\n            if (found != string::npos)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269527,
                "title": "faseter-than-98-online-submission-javascript",
                "content": "var numJewelsInStones = function(jewels, stones) {\\nlet count = 0;\\nfor(let val of stones){\\nif(jewels.includes(val)){\\ncount++;\\n}\\n}\\nreturn count;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var numJewelsInStones = function(jewels, stones) {\\nlet count = 0;\\nfor(let val of stones){\\nif(jewels.includes(val)){\\ncount++;\\n}\\n}\\nreturn count;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1195731,
                "title": "easy-c-solution-using-hashmap-without-using-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int s1 = jewels.size();\\n        int s2 = stones.size();\\n        \\n        vector<int> hash(256, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<s1; i++) {\\n            hash[jewels[i]]++;\\n        }\\n        \\n        for(int j=0; j<s2; j++) {\\n            if(hash[stones[j]]>0) {\\n                ans = ans + hash[stones[j]];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string jewels, string stones) {\\n        int s1 = jewels.size();\\n        int s2 = stones.size();\\n        \\n        vector<int> hash(256, 0);\\n        int ans = 0;\\n        \\n        for(int i=0; i<s1; i++) {\\n            hash[jewels[i]]++;\\n        }\\n        \\n        for(int j=0; j<s2; j++) {\\n            if(hash[stones[j]]>0) {\\n                ans = ans + hash[stones[j]];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150489,
                "title": "simple-java-solution-in-o-n",
                "content": "Simple and easy java Solution in O(n) using Set.\\n\\nFirst traverse the Jewels and keep all the char in **set** (why? because all the char in Jewel are unique).\\nWhy Set? (Since the Search operation of a set is O(1). Hence program runs faster.\\nNow traverse the Stones one by one character, if they match, increment the count for that. Finally return the count\\nas answer.\\n\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        Set<Character> set = new HashSet<>();\\n        for(char k:jewels.toCharArray())\\n            set.add(k);\\n        int count = 0;\\n        for(char k:stones.toCharArray())\\n            if(set.contains(k)) \\n                count ++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        Set<Character> set = new HashSet<>();\\n        for(char k:jewels.toCharArray())\\n            set.add(k);\\n        int count = 0;\\n        for(char k:stones.toCharArray())\\n            if(set.contains(k)) \\n                count ++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086986,
                "title": "c-0ms-100-hashtable",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Jewels and Stones.\\nMemory Usage: 6.1 MB, less than 92.56% of C++ online submissions for Jewels and Stones.\\n```\\nclass Solution {\\npublic:\\n  int numJewelsInStones(string jewels, string stones) {\\n    int frec[128] = {0};\\n    for(int i =0; i < jewels.size();i++) frec[jewels[i]] = 1;\\n    \\n    int count = 0;\\n    for(int i = 0; i < stones.size();i++)\\n      if(frec[stones[i]]) count++;\\n    \\n    return count;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numJewelsInStones(string jewels, string stones) {\\n    int frec[128] = {0};\\n    for(int i =0; i < jewels.size();i++) frec[jewels[i]] = 1;\\n    \\n    int count = 0;\\n    for(int i = 0; i < stones.size();i++)\\n      if(frec[stones[i]]) count++;\\n    \\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066705,
                "title": "kotlin-1-line",
                "content": "```\\nfun numJewelsInStones(j: String, s: String) = s.count { j.contains(it) }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun numJewelsInStones(j: String, s: String) = s.count { j.contains(it) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035354,
                "title": "python-one-liner",
                "content": "```\\ndef numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return sum([1 if i in jewels else 0 for i in stones])\\n```",
                "solutionTags": [],
                "code": "```\\ndef numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        return sum([1 if i in jewels else 0 for i in stones])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 834304,
                "title": "java-code-0-ms",
                "content": "class Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int count=0;\\n        \\n        for (int i = 0;i<J.length();i++){\\n            for (int k = 0;k<S.length();k++){\\n                if (J.charAt(i)==S.charAt(k))\\n                    count++; \\n            }\\n        }return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int count=0;\\n        \\n        for (int i = 0;i<J.length();i++){\\n            for (int k = 0;k<S.length();k++){\\n                if (J.charAt(i)==S.charAt(k))\\n                    count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 702190,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) != -1)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int count = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (J.indexOf(S.charAt(i)) != -1)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669027,
                "title": "c-100",
                "content": "```\\nint numJewelsInStones(char * J, char * S){\\n    int alpha[123] = {0};\\n    int jewels = 0;\\n    \\n    while (*J)\\n        alpha[*J++]++;\\n    \\n    while (*S)\\n        jewels += alpha[*S++];\\n    \\n    return jewels;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numJewelsInStones(char * J, char * S){\\n    int alpha[123] = {0};\\n    int jewels = 0;\\n    \\n    while (*J)\\n        alpha[*J++]++;\\n    \\n    while (*S)\\n        jewels += alpha[*S++];\\n    \\n    return jewels;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608517,
                "title": "python-my-brute-force-and-hashmap-solutions",
                "content": "- **Brute Force**\\n\\n```python\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        res = 0\\n        \\n        for l1 in J:\\n            for l2 in S:\\n                if l1 == l2:\\n                    res += 1\\n        \\n        return res\\n```\\n\\n**Time:** `O(J * S)`\\n**Space:** `O(1)`\\n\\n- **Hashmap**\\n\\n```python\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        res, count = 0, {}\\n        \\n        for l in S:\\n            if l in count: count[l] += 1\\n            else: count[l] = 1\\n        \\n        for l in J:\\n            if l in count:\\n                res += count[l]\\n        \\n        return res\\n```\\n\\n**Time:** `O(J + S)`\\n**Space:** `O(S)`\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        res = 0\\n        \\n        for l1 in J:\\n            for l2 in S:\\n                if l1 == l2:\\n                    res += 1\\n        \\n        return res\\n```\n```python\\nclass Solution:\\n    def numJewelsInStones(self, J: str, S: str) -> int:\\n        res, count = 0, {}\\n        \\n        for l in S:\\n            if l in count: count[l] += 1\\n            else: count[l] = 1\\n        \\n        for l in J:\\n            if l in count:\\n                res += count[l]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 608308,
                "title": "c-solution-beats-100-0-ms-runtime",
                "content": "2-step solution:\\n1. Use a range constructor to initialize an unordered_set from the characters in J. \\n2. Loop over the string S and for each character in S that is also present in the unordered_set, increase the count of jewels.\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<char> n(J.begin(), J.end());\\n        int jewels=0;\\n        for(int i=0; i<S.length(); i++){\\n            if(n.count(S[i])!=0) jewels++;\\n        }\\n        return jewels;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<char> n(J.begin(), J.end());\\n        int jewels=0;\\n        for(int i=0; i<S.length(); i++){\\n            if(n.count(S[i])!=0) jewels++;\\n        }\\n        return jewels;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607913,
                "title": "javascript-set-solution-easy-to-understand",
                "content": "For set reference kindly follow this https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\\n```\\nvar numJewelsInStones = function(J, S) {\\n    let Jewels = new Set(J);\\n    let count =0;\\n    for(let i=0;i<S.length;i++){\\n        if(Jewels.has(S.charAt(i))){\\n            count++;\\n}\\n}\\n    return count;\\n};\\n```\\nRuntime: 52 ms, faster than 91.95% of JavaScript online submissions for Jewels and Stones.\\nMemory Usage: 34 MB, less than 65.67% of JavaScript online submissions for Jewels and Stones.",
                "solutionTags": [],
                "code": "```\\nvar numJewelsInStones = function(J, S) {\\n    let Jewels = new Set(J);\\n    let count =0;\\n    for(let i=0;i<S.length;i++){\\n        if(Jewels.has(S.charAt(i))){\\n            count++;\\n}\\n}\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518131,
                "title": "java-foreach",
                "content": "```\\npublic int numJewelsInStones(String J, String S) {\\n\\n\\tint count = 0;\\n\\n\\tfor(Character c : S.toCharArray()){\\n\\t\\tboolean check = J.contains(c.toString());\\n\\t\\tif(check) count++;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numJewelsInStones(String J, String S) {\\n\\n\\tint count = 0;\\n\\n\\tfor(Character c : S.toCharArray()){\\n\\t\\tboolean check = J.contains(c.toString());\\n\\t\\tif(check) count++;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497007,
                "title": "single-line-python-solution-runtime-24ms-top-20",
                "content": "Used built-in list comprehensions.\\n\\n```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n\\treturn len([i for i in S if i in J])\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef numJewelsInStones(self, J: str, S: str) -> int:\\n\\treturn len([i for i in S if i in J])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 462170,
                "title": "100-00-faster-than-other-c-solutions-using-hashtable-hashset-hashmap",
                "content": "-------\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.7 MB, less than **21.25%** of C++ online submissions for Jewels and Stones.\\nread J and build jewels hash set.\\nread S and count jewels.\\nComplexity\\nuse hash set and it\\'s O(1) time to check if it contains an element.\\nSo the total time complexity will be **O(J+S)**\\nSpace is **O(J)**\\n\\n```\\nclass Solution { // using HashSet, check stones one by one and increment if any one is jewels\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<int> jewels(J.begin(),J.end());\\n        \\n        int numOfJewelsInStones(0);\\n        for(char stone: S){\\n            if(jewels.find(stone)!=jewels.end())\\n                numOfJewelsInStones++;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n\\n```\\n\\n------\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.6 MB, less than **33.75%** of C++ online submissions for Jewels and Stones.\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        vector<int> map(123,0); // of size 128 and initialize with 0 to all size is (65-90 A to Z and 97-122 a-z)\\n        \\n        for(auto jwel: J){\\n            map[jwel]=1;\\n        }\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            numOfJewelsInStones+=map[stone];\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\\n\\n------\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.2 MB, less than **92.50%** of C++ online submissions for Jewels and Stones.\\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            for(auto jewl: J){\\n                if(stone==jewl)\\n                    numOfJewelsInStones++;\\n            }\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\\n\\n------\\nRuntime: 4 ms, faster than 65.07% of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.4 MB, less than 60.00% of C++ online submissions for Jewels and Stones.\\n```\\nclass Solution { // using std::count\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0),i(0);\\n        \\n        while(i<J.length()){\\n            numOfJewelsInStones += count(S.begin(),S.end(),J[i]);\\n            ++i;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\\n\\n------\\nRuntime: 4 ms, faster than 65.07% of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.4 MB, less than 57.50% of C++ online submissions for Jewels and Stones.\\n```\\nclass Solution { // using std::count\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            if(J.find(stone)!=string::npos) // use find() with string::npos\\n                numOfJewelsInStones++;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\\n\\n-----\\nRuntime: 4 ms, faster than 65.07% of C++ online submissions for Jewels and Stones.\\nMemory Usage: 8.9 MB, less than 5.00% of C++ online submissions for Jewels and Stones.\\n\\n```\\nclass Solution { // using HashMap\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_map<char,int> hashTable;\\n        \\n        for(auto jwel: J){\\n            hashTable[jwel]=1;\\n        }\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            numOfJewelsInStones+=hashTable[stone];\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution { // using HashSet, check stones one by one and increment if any one is jewels\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_set<int> jewels(J.begin(),J.end());\\n        \\n        int numOfJewelsInStones(0);\\n        for(char stone: S){\\n            if(jewels.find(stone)!=jewels.end())\\n                numOfJewelsInStones++;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        vector<int> map(123,0); // of size 128 and initialize with 0 to all size is (65-90 A to Z and 97-122 a-z)\\n        \\n        for(auto jwel: J){\\n            map[jwel]=1;\\n        }\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            numOfJewelsInStones+=map[stone];\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            for(auto jewl: J){\\n                if(stone==jewl)\\n                    numOfJewelsInStones++;\\n            }\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\n```\\nclass Solution { // using std::count\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0),i(0);\\n        \\n        while(i<J.length()){\\n            numOfJewelsInStones += count(S.begin(),S.end(),J[i]);\\n            ++i;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\n```\\nclass Solution { // using std::count\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            if(J.find(stone)!=string::npos) // use find() with string::npos\\n                numOfJewelsInStones++;\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```\n```\\nclass Solution { // using HashMap\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        unordered_map<char,int> hashTable;\\n        \\n        for(auto jwel: J){\\n            hashTable[jwel]=1;\\n        }\\n        int numOfJewelsInStones(0);\\n        for(auto stone: S){\\n            numOfJewelsInStones+=hashTable[stone];\\n        }\\n        return numOfJewelsInStones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451434,
                "title": "4ms-14-6-mb-easy-php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $J\\n     * @param String $S\\n     * @return Integer\\n     */\\n    function numJewelsInStones($J, $S) {\\n        $result = 0;\\n        for ($i = 0; $i < strlen ($J); $i++) {\\n            $result += substr_count ($S, $J[$i]);\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $J\\n     * @param String $S\\n     * @return Integer\\n     */\\n    function numJewelsInStones($J, $S) {\\n        $result = 0;\\n        for ($i = 0; $i < strlen ($J); $i++) {\\n            $result += substr_count ($S, $J[$i]);\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449445,
                "title": "c-0ms-8-2mb-solution",
                "content": "```\\nint numJewelsInStones(string J, string S) \\n    {\\n        int out = 0;\\n        for(char s : S)\\n        {\\n            if(std::string::npos != J.find(s))\\n                out++;\\n        }\\n        return out;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numJewelsInStones(string J, string S) \\n    {\\n        int out = 0;\\n        for(char s : S)\\n        {\\n            if(std::string::npos != J.find(s))\\n                out++;\\n        }\\n        return out;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 418004,
                "title": "java-single-loop-solution",
                "content": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int counter = 0;\\n        for(int i = 0; i < S.length(); i++) {\\n            if(J.contains(S.charAt(i)+\"\")) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numJewelsInStones(String J, String S) {\\n        int counter = 0;\\n        for(int i = 0; i < S.length(); i++) {\\n            if(J.contains(S.charAt(i)+\"\")) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417605,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int sum = 0;\\n        for(auto i:J)\\n        {\\n            for(auto j:S)\\n            {\\n                if(i==j) sum++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numJewelsInStones(string J, string S) {\\n        int sum = 0;\\n        for(auto i:J)\\n        {\\n            for(auto j:S)\\n            {\\n                if(i==j) sum++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374210,
                "title": "javascript-solution",
                "content": "```\\nvar numJewelsInStones = function(J, S) {\\n    var sum = 0;\\n    for (var i = 0; i < S.length; i++) {\\n        var sChar = S[i];\\n        for(var j = 0; j < J.length; j++) {\\n            var jChar = J[j];\\n            if (jChar == sChar) {\\n               sum++;\\n            }\\n        }        \\n    }    \\n    \\n    return sum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numJewelsInStones = function(J, S) {\\n    var sum = 0;\\n    for (var i = 0; i < S.length; i++) {\\n        var sChar = S[i];\\n        for(var j = 0; j < J.length; j++) {\\n            var jChar = J[j];\\n            if (jChar == sChar) {\\n               sum++;\\n            }\\n        }        \\n    }    \\n    \\n    return sum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 360874,
                "title": "ruby-one-liner-97-28ms-runtime-100-9-2mb-memory",
                "content": "```\\ndef num_jewels_in_stones(j, s)\\n  s.count(j)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_jewels_in_stones(j, s)\\n  s.count(j)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 348853,
                "title": "php-solution-4ms",
                "content": "Runtime: 4 ms, faster than 91.39% of PHP online submissions\\nMemory Usage: 14.7 MB, less than 93.55% of PHP online submissions\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $J\\n     * @param String $S\\n     * @return Integer\\n     */\\n    function numJewelsInStones($J, $S)\\n    {\\n        $a = array_fill(65, 58, 0);\\n        for ($i = 0; $i < strlen($S); $i++) $a[ord($S[$i])]++;\\n        $result = 0;\\n        for ($i = 0; $i < strlen($J); $i++) $result += $a[ord($J[$i])];\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $J\\n     * @param String $S\\n     * @return Integer\\n     */\\n    function numJewelsInStones($J, $S)\\n    {\\n        $a = array_fill(65, 58, 0);\\n        for ($i = 0; $i < strlen($S); $i++) $a[ord($S[$i])]++;\\n        $result = 0;\\n        for ($i = 0; $i < strlen($J); $i++) $result += $a[ord($J[$i])];\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1766700,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1568385,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1573675,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1569265,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1911614,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 2023209,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1794289,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1573609,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1572331,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1576511,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1766700,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1568385,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1573675,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1569265,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1911614,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 2023209,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1794289,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1573609,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1572331,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1576511,
                "content": [
                    {
                        "username": "odinicc",
                        "content": "May be it will be helpful for someone. \\n\\nInput: jewels = \"aA\", stones = \"aAAbbbb\"\\nOutput: 3\\n\\nExplanation:\\nFirst stone in \\u201Cstones\\u201D - a -  \"a\"AAbbbb\\nSecond stone in \\u201Cstones\\u201D - A -  a\"A\"Abbbb\\nThird stone in \\u201Cstones\\u201D - A -  aA\"A\"bbbb\"\\n\\nOveral: 3\\n"
                    },
                    {
                        "username": "jedi8380",
                        "content": "[@thesagittario](/thesagittario) He literally says that in his explanation bruh"
                    },
                    {
                        "username": "thesagittario",
                        "content": "No, Its one \\'a\\' and Two \\'A\\'s . Total 3"
                    },
                    {
                        "username": "a-20200522",
                        "content": "I used HashSet solution and it only beats 28% \\n\\nshouldn\\'t Map be faster than nested loop? O(n^2) run time vs HashSet of O(n)?"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@monikkacha](/monikkacha) I think it is fast for large inputs, but here inputs are small so brute force is working faster\\uD83E\\uDD14"
                    },
                    {
                        "username": "monikkacha",
                        "content": "just tried nested loop and shows beats 96% , i believe hash map should be faster "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "llk333",
                        "content": "I see so many O(m * n) runtime solution that beats O(m + n) where m is size of J and n is size of S. I think the reason is that the O(m * n) solution uses J.indexOf() but the size of J in the tests cases is small enough that indexOf() can be faster than the time to construct HashSet and subsequent O(1) lookups.\\n\\nThis is not good for new comers who are trying to learn algorithms!"
                    },
                    {
                        "username": "LincolnDai",
                        "content": "\\treturn sum([S.count(j) for j in J])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "samcod0334",
                        "content": "I don\\'t understand the problem. Someone can explain me that, please."
                    },
                    {
                        "username": "hkp-",
                        "content": "You have some kind of a catalog to identify jewels. And you have a bag of stones which might be jewels.  \\nNow you take a look at every stone you have and try to find it in your catalog. If it is in your catalog, you have found another jewel. If its not in the catalog, its a simple plain stone you dont have to count."
                    },
                    {
                        "username": "sopheary",
                        "content": "I noticed some easy problems of the example, the writer do not provide explanation. As my suggestion , the writer should. It would help leetcoder understand in a very quick and save time."
                    },
                    {
                        "username": "omenida",
                        "content": "agreed"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int n = jewels.length();\\n        int m = stones.length();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(jewels.charAt(i)==stones.charAt(j)){\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@one_an_only_alqama](/one_an_only_alqama) according to me he is comparing characters from strings so it will work"
                    },
                    {
                        "username": "one_an_only_alqama",
                        "content": "\"==\" shouldn\\'t work here in case of string."
                    },
                    {
                        "username": "Korai",
                        "content": "\\treturn sum([S.count(i) for i in J])"
                    },
                    {
                        "username": "abx56",
                        "content": "\\treturn(len([x for x in S if x in J]))"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "apayziev",
                        "content": "return sum(letter in jewels for letter in stones)"
                    }
                ]
            },
            {
                "id": 1575602,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1572573,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1571867,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1569857,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 2072139,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 2051700,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 2023566,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 2017731,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1945322,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1785093,
                "content": [
                    {
                        "username": "tanviJ025",
                        "content": "\"\"\"return(len([i for i in stones if i in jewels]))\"\"\""
                    },
                    {
                        "username": "badal1443",
                        "content": "Faster than 99.65% of Python3 online submissions for Jewels and Stones."
                    },
                    {
                        "username": "scala62",
                        "content": "  def numJewelsInStones(J: String, S: String): Int = {\n    val jSet = J.toCharArray.toSet\n    S.toCharArray.foldLeft(0)((s,e) =>  if (jSet.contains(e)) s +1 else s )\n  }"
                    },
                    {
                        "username": "geek_",
                        "content": "Check out this:\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/jewels-and-stones.html"
                    },
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "easy for a reason."
                    },
                    {
                        "username": "troysleet",
                        "content": "Can someone help why this doesn\\'t work here?\\n```\\nanswer_list = []\\n\\nfor i in stones:\\n\\n    for j in \\'\\'.join(set(jewels)):\\n\\n        if i in j:\\n\\n            answer_list.append(i)\\n\\n        return len(answer_list)\\n```"
                    },
                    {
                        "username": "preyom2000ghosh",
                        "content": "int numJewelsInStones(string jewels, string stones) {\\n        unordered_map<char,int>m;\\n        int s=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            m[stones[i]]++;\\n        }\\n        for(int i=0;i<jewels.size();i++)\\n        {\\n        for(auto it : m)\\n        {\\n            if(jewels[i]==it.first)\\n             s+=it.second;\\n        }\\n    }\\n    return s;\\n    }"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The submission runtime calculator of leetcode is seriously broken, It shows O(n^2) as the best optimal solution than something with O(n) time complexity."
                    },
                    {
                        "username": "rayyan3353",
                        "content": "ok I solve it was good practice for using hash map. However there is something annoying when it comes about the logic of control of flow in java script, because when I use if statement like this if(map[stones[i]]) some time it can contain 0 and the zero value is treated like false. Hence I recommend to the value to any key to be boolean or just make the if statment only except if it is not equal to undefined and the zero will not treated as false anymore like this if(map[stones[i]] !== undefined){ // do this }"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "Hint: use a hash map"
                    }
                ]
            },
            {
                "id": 1783291,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1782163,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1775240,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1752002,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1732509,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1723794,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1722035,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1711638,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1676988,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            },
            {
                "id": 1647617,
                "content": [
                    {
                        "username": "satyam_rai15",
                        "content": "I ran the same solution twice. It gave 46% beats for the first time but 100% on the second time. Leetcode should consider fixing this."
                    },
                    {
                        "username": "rafiul29",
                        "content": "javascript solution\\n\\n `your inline code...your inline code...\\nvar numJewelsInStones = function(jewels, stones) {\\n    let count =0\\n    let jewelsArr=jewels.split(\"\")\\n    let stonesArr=stones.split(\"\")\\n    for(let i=0;i<jewelsArr.length;i++){\\n        for(let j=0;j<stonesArr.length;j++){\\n            if(jewelsArr[i]==stonesArr[j]){\\n                count++\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n`"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "SurendraChakravarthula",
                        "content": "**Without using set-O(J+S)\\nStore stones in an array with their frequency\\nIterate jewels and find the corresponding jewel frequency in the array.\\n\\nFor reference**\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/3033399/only-arrays-o-j-s-o-1/"
                    },
                    {
                        "username": "imanjari",
                        "content": "Can someone explain why by using set in python the T.C is O(jewels+stones) and not O(jewels*stones) ? Search time in set is O(1) ."
                    },
                    {
                        "username": "402Coder",
                        "content": "This is b/c you only have to iterate through the jewels string once, and only once, to create the set of jewels.  Then you can iterate through stones (again only once) to check if each stone is in the jewelSet.  checking if an element is in the keys of a set is constant time complexity.  So we\\'re only counting the time of iterating through each string one time as the constant time doesn\\'t matter."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/771_jewels_and_stones.cpp"
                    },
                    {
                        "username": "anshs16",
                        "content": "I tried this question in python. Do I need to explicitly implement a dictionary in order to speed this code up? Or the \\'in\\' method and \\'count\\' method of str working the same? Thanks for the help.\\n\\n\\n `\\n  class Solution(object):\\n\\n    def numJewelsInStones(self, jewels, stones):\\n        a = stones\\n        b = jewels\\n        count = 0\\n        c = 0\\n\\n        for j in b:\\n            if j in a:\\n                c = a.count(j)\\n                count = count+c\\n        \\n        return count\\n`"
                    },
                    {
                        "username": "RutikJ173",
                        "content": "Simple Brute force approach\\n\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n            int count =0;\\n       for(int i=0; i<jewels.length(); i++){\\n          for(int j=0; j<stones.length(); j++){\\n            if(jewels.charAt(i) == stones.charAt(j)){\\n                count++;\\n            }\\n          }\\n       }\\n       return count;\\n    }\\n}"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# C++ Fastest 2 liner( You will love it guaranteed)\\nhttps://leetcode.com/problems/jewels-and-stones/solutions/2201046/c-fastest-2-liner-you-will-love-it-guaranteed/"
                    },
                    {
                        "username": "sahasourav1170",
                        "content": "```\\nclass Solution:\\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        d = {}\\n        ans = 0\\n        for i in jewels:\\n            d[i] = 1\\n        for i in stones:\\n            if i in d:\\n                ans += 1\\n        return ans\\n``` "
                    },
                    {
                        "username": "user3238Gj",
                        "content": "    def numJewelsInStones(self, jewels: str, stones: str) -> int:\\n        set_jewels = set(jewels)\\n        result = 0\\n        for stone in stones:\\n            result += stone in set_jewels\\n        \\n        return result"
                    }
                ]
            }
        ]
    }
]