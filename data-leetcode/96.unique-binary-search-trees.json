[
    {
        "title": "Unique Binary Search Trees",
        "question_content": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.\n&nbsp;\nExample 1:\n\nInput: n = 3\nOutput: 5\n\nExample 2:\n\nInput: n = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 19",
        "solutions": [
            {
                "id": 31666,
                "title": "dp-solution-in-6-lines-with-explanation-f-i-n-g-i-1-g-n-i",
                "content": "The problem can be solved in a dynamic programming way. I\\u2019ll explain the intuition and formulas in the following. \\n\\nGiven a sequence 1\\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots.\\n\\nThe problem is to calculate the number of unique BST. To do so, we need to define two functions: \\n\\n`G(n)`: the number of unique BST for a sequence of length n. \\n\\n`F(i, n), 1 <= i <= n`: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n. \\n\\nAs one can see, `G(n)` is the actual function we need to calculate in order to solve the problem. And `G(n)` can be derived from `F(i, n)`, which at the end, would recursively refer to `G(n)`.\\n\\nFirst of all, given the above definitions, we can see that the total number of unique BST `G(n)`, is the sum of BST `F(i)` using each number i as a root. \\n*i.e.* \\n\\n    G(n) = F(1, n) + F(2, n) + ... + F(n, n). \\n\\nParticularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). \\n*i.e.*\\n\\n    G(0)=1, G(1)=1. \\n\\nGiven a sequence 1\\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root `F(i)`, is the cartesian product of the number of BST for its left and right subtrees. For example, `F(3, 7)`: the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (*i.e.* cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as `G(2)`, and the number of of unique BST out of sequence [4, 5, 6, 7] as `G(4)`. Therefore, `F(3,7) = G(2) * G(4)`.\\n\\n*i.e.*\\n\\n    F(i, n) = G(i-1) * G(n-i)\\t1 <= i <= n \\n\\n\\nCombining the above two formulas, we obtain the recursive formula for `G(n)`. *i.e.*\\n\\n    G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \\u2026 + G(n-1) * G(0) \\n\\nIn terms of calculation, we need to start with the lower number, since the value of `G(n)` depends on the values of `G(0) \\u2026 G(n-1)`. \\n\\nWith the above explanation and formulas, here is the implementation in Java. \\n\\n    public int numTrees(int n) {\\n      int [] G = new int[n+1];\\n      G[0] = G[1] = 1;\\n        \\n      for(int i=2; i<=n; ++i) {\\n        for(int j=1; j<=i; ++j) {\\n          G[i] += G[j-1] * G[i-j];\\n        }\\n\\t  }\\n      return G[n];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "The problem can be solved in a dynamic programming way. I\\u2019ll explain the intuition and formulas in the following. \\n\\nGiven a sequence 1\\u2026n, to construct a Binary Search Tree (BST) out of the sequence, we could enumerate each number i in the sequence, and use the number as the root, naturally, the subsequence 1\\u2026(i-1) on its left side would lay on the left branch of the root, and similarly the right subsequence (i+1)\\u2026n lay on the right branch of the root. We then can construct the subtree from the subsequence recursively. Through the above approach, we could ensure that the BST that we construct are all unique, since they have unique roots.\\n\\nThe problem is to calculate the number of unique BST. To do so, we need to define two functions: \\n\\n`G(n)`: the number of unique BST for a sequence of length n. \\n\\n`F(i, n), 1 <= i <= n`: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n. \\n\\nAs one can see, `G(n)` is the actual function we need to calculate in order to solve the problem. And `G(n)` can be derived from `F(i, n)`, which at the end, would recursively refer to `G(n)`.\\n\\nFirst of all, given the above definitions, we can see that the total number of unique BST `G(n)`, is the sum of BST `F(i)` using each number i as a root. \\n*i.e.* \\n\\n    G(n) = F(1, n) + F(2, n) + ... + F(n, n). \\n\\nParticularly, the bottom cases, there is only one combination to construct a BST out of a sequence of length 1 (only a root) or 0 (empty tree). \\n*i.e.*\\n\\n    G(0)=1, G(1)=1. \\n\\nGiven a sequence 1\\u2026n, we pick a number i out of the sequence as the root, then the number of unique BST with the specified root `F(i)`, is the cartesian product of the number of BST for its left and right subtrees. For example, `F(3, 7)`: the number of unique BST tree with number 3 as its root. To construct an unique BST out of the entire sequence [1, 2, 3, 4, 5, 6, 7] with 3 as the root, which is to say, we need to construct an unique BST out of its left subsequence [1, 2] and another BST out of the right subsequence [4, 5, 6, 7], and then combine them together (*i.e.* cartesian product). The tricky part is that we could consider the number of unique BST out of sequence [1,2] as `G(2)`, and the number of of unique BST out of sequence [4, 5, 6, 7] as `G(4)`. Therefore, `F(3,7) = G(2) * G(4)`.\\n\\n*i.e.*\\n\\n    F(i, n) = G(i-1) * G(n-i)\\t1 <= i <= n \\n\\n\\nCombining the above two formulas, we obtain the recursive formula for `G(n)`. *i.e.*\\n\\n    G(n) = G(0) * G(n-1) + G(1) * G(n-2) + \\u2026 + G(n-1) * G(0) \\n\\nIn terms of calculation, we need to start with the lower number, since the value of `G(n)` depends on the values of `G(0) \\u2026 G(n-1)`. \\n\\nWith the above explanation and formulas, here is the implementation in Java. \\n\\n    public int numTrees(int n) {\\n      int [] G = new int[n+1];\\n      G[0] = G[1] = 1;\\n        \\n      for(int i=2; i<=n; ++i) {\\n        for(int j=1; j<=i; ++j) {\\n          G[i] += G[j-1] * G[i-j];\\n        }\\n\\t  }\\n      return G[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1565543,
                "title": "c-python-5-easy-solutions-w-explanation-optimization-from-brute-force-to-dp-to-catalan-o-n",
                "content": "\\u274C ***Solution - I (Brute-Force) [TLE]***\\n\\nLet\\'s start by trying to solve the problem in Brute-Force manner. To form structurally unique BST consisting of `n` nodes, we can start by taking any of the node `1...n` as the root node. Let the chosen root node be `i`. Then, we have a BST where the root node is `i`, the left child consist of all nodes from `1...i-1` (since left sub-tree must have only less than root\\'s value) and right child consist of all nodes from `i+1...n`.\\n\\n```python\\n\\t\\n              1            1                   2                    3               3\\n\\t           \\\\            \\\\                 / \\\\                  /               /\\n    \\t        3             2              1   3                2               1\\n               /               \\\\                                 /                 \\\\\\n              2                 3                              1                    2\\n                     i = 1                   i = 2                       i = 3           \\n(i = root node)\\n```\\n\\nNow, we need to realize that the number of structurally unique BST formable with nodes having value `i+1...n` is equal to the number of structurally unique BST formable with nodes having value `i+1-i...n-i = 1...n-i`. Why? Because we only need to find BST which are structurally unique irrespective of their values and we can form an equal number of them with nodes from `1...n` or `2...n+1` or `n...2n-1` and so on. So, the number only depends on number of nodes using which BST is to be formed.\\n\\nNow, when we choose `i` as root node, we will have nodes from `1...i-1` (`i-1` nodes in total) in left sub-tree and nodes from `i+1...n` (`n-i` nodes in total) in the right side. We can then form  `numTrees(i-1)` BSTs for left sub-tree and `numTrees(n-i)` BSTs for the right sub-tree. The total number of structurally unique BSTs formed having root `i` will be equal to product of these two, i.e, `numTrees(i-1) * numTrees(n-i)`. The same can be followed recursively till we reach base case - `numTrees(0) = numTrees(1) = 1` because we can form only a single empty BST and single node BST in these cases respectively.\\n\\nThe final answer will be summation of answers considering all `1...n` as root nodes.\\n\\n```python\\n           3                          2                         1               \\n          / \\\\                        / \\\\                      /   \\\\      \\nnumTrees(2) numTrees(0)    numTrees(1) numTrees(1)   numTrees(0) numTrees(2)              \\n         i = 3                      i = 2                     i = 1           \\n\\t\\t \\n                      i\\n\\t=>              /   \\\\ \\n         numTrees(i-1)\\tnumTrees(n-i)\\n```\\n\\nWith that in mind, we have the following - \\n\\n<p align=\\'middle\\'>\\n<img src=https://assets.leetcode.com/users/images/be0cf3dd-364d-49d2-af1b-471be3a94855_1636332760.2597368.png />\\n</p>\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) \\n            ans += numTrees(i-1) * numTrees(n-i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1: return 1\\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))\\n```\\n\\n***Time Complexity :*** <code><b>O(3<sup>N</sup>)</b></code>, where `N` is the given number of nodes in BST. Read **[here](https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity)** for proof.\\n***Space Complexity :*** **`O(N)`**, the maximum recursive stack depth.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nThe above approach times out due to lots of unnecessary repeated calculation.\\n\\n```ruby\\nf(i) = numTrees(i)\\n                                                                 f(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t__________________________________|____________________________________________\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t                  \\u2199                            \\u2193                \\u2193                \\u2193                 \\u2198\\n\\t\\t        (f(0)*           f(4))                 f(1)*f(3)        f(2)*f(2)        f(3)*f(1)          f(4)*f(0)\\n\\t\\t\\t\\t     _____________|_____________             \\u2B06\\uFE0F          \\u2B06\\uFE0F  \\u2B06\\uFE0F         \\u2B06\\uFE0F                 \\u2B06\\uFE0F\\n\\t\\t            \\u2199        \\u2193        \\u2193         \\u2198  \\t   \\n\\t        f(0)f(3)     f(1)f(2)   f(2)f(1)   f(3)f(0)      \\n\\t\\t   ______|_____       \\u2B06\\uFE0F\\t \\u2B06\\uFE0F        \\u2B06\\uFE0F\\n          \\u2199      \\u2193     \\u2198\\n      f(0)f(2) f(1)f(1) f(2)f(1)\\n          __|__\\t         \\u2B06\\uFE0F \\n     \\t\\u2199       \\u2198\\n     f(0)f(1)  f(1)f(0)\\n```\\n\\nIn the above diagram, drawing out even the partial recursion tree for the above approach, we can find that there are many redundant repeated calculations. We can instead store or memoize these result and later avoid repeated calculations over and over again.\\n\\nThe approach and code will be very similar. The only change is every time we calculate the result for `numTrees(i)`, we store the result in `dp[i]` and only then return it. After that, each time we encounter `dp[i]` that\\'s already calculated, we can directly return the result. This way, we won\\'t solve for the same `numTrees(i)` multiple times. \\n\\n**C++**\\n \\n```cpp\\nclass Solution {\\npublic:\\n    int dp[20]{};\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        if(dp[n]) return dp[n];\\n        for(int i = 1; i <= n; i++) \\n            dp[n] += numTrees(i-1) * numTrees(n-i);\\n        return dp[n];\\n    }\\n};\\n```\\n\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    @cache\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1: return 1\\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))\\n```\\n\\n***Time Complexity :*** <code><b>O(N<sup>2</sup>)</b></code> \\nHere we calculate `numTrees(i)` (for `1<=i<=N`) only once and memoize it which will take `O(N)`. For calculating each of `numTrees(i)`, we need `N` iterations to calculate `numTrees(0)*numTrees(i) + numTrees(1)*numTrees(i-1) + numTrees(2)*numTrees(i-2)+ ... + numTrees(i)*numTrees(0)`. Thus, the overall time complexity becomes `O(N*N)`.\\n***Space Complexity :*** **`O(N)`**, required for recursion and memoization\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can also solve it using iterative dynamic programming. Again, the logic is similar to above with slight change in approach that we start from base conditions instead of other way around. \\n* We have base conditions of `dp[0] = dp[1] = 1`. \\n* Then we calculate result for each number of nodes `i` from `2...n` one after another.\\n* For `i` nodes. we can consider each of the node `j` from `1...i` as the root node of BST.\\n* Considering the `j`th node as the root node in BST having total of `i` nodes, the final result is summation  of `dp[j-1] * dp[i-j]`, for all `j` from `1...i`. (Comparing to above solution `dp[j-1] = numTrees(j-1)` and `dp[i-j]=numTrees(i-j)`)\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        for(int i = 2; i <= n; i++) \\n            for(int j = 1; j <= i; j++)\\n                dp[i] += dp[j-1] * dp[i-j];\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        dp = [0]*(n+1)\\n        dp[0], dp[1] = 1, 1\\n        for i in range(2, n+1):\\n            for j in range(1, i+1):\\n                dp[i] += dp[j-1] * dp[i-j]\\n        return dp[n]\\n```\\n\\n***Time Complexity :*** <code><b>O(N<sup>2</sup>)</b></code>, we iterate over the range `i=[2, n]` and iteratively calculate `dp[i]`. The total number of operations performed equals <code>2+3+4+5..n = (n*(n+1)/2)-1 \\u2248 O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **`O(N)`**, required to store the results in `dp`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Catalan Numbers)***\\n\\nObserving the series we get above for various `numTrees(n)`, we see that it is infact a series of popular numbers known as **[Catalan Numbers](https://en.wikipedia.org/wiki/Catalan_number)**. This approach is hard to get unless you are already familiar with catalan numbers and probably wont be expected in interview either. But I am mentioning this approach as another possible and more efficient solution to this question.\\n\\nWe can use the following formula for calculating catalan numbers <code>C<sub>n</sub></code> to calculate the result in `O(N)` time complexity -\\n\\n<p align=\\'middle\\'>\\n<img src=\"https://assets.leetcode.com/users/images/426d7a29-90f5-4316-8125-9eabbe88ebc9_1636339303.3556454.png\" width=300 />\\n</p>\\n\\nWe will use 1st equation of above image with binomial coefficient function - `ncr` in C++ to avoid overflow. In python, we can directly calculate factorial as it can handle long numbers\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long ncr(int n, int r) {\\n        long ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= n-i;\\n            ans /= i+1;\\n        }\\n        return ans;   \\n    }\\n    int numTrees(int n) {\\n        return ncr(2*n, n) / (n + 1);\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\uD83D\\uDC49 Further Simplified! </b></summary>\\n\\nWe can further expand the above equation as follows to simplify the implementation in code -\\n\\n<p align=\\'middle\\'>\\n<img src=https://assets.leetcode.com/users/images/4d8fa0c1-0609-4b5c-a20e-07045e3308c6_1636369013.2969224.png />\\n</p>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long ans = 1;\\n        for(int i = 1; i < n; i++)  \\n            ans = ans*(n+i+1) / i;    // do note that numerator and denominator will always be divisible\\n        return ans / n;\\n    }\\n};\\n```\\n</details>\\n</blockquote>\\n\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return factorial(2*n) // (factorial(n)*factorial(n+1))\\n```\\n\\n***Time Complexity :*** <code><b>O(N)</b></code> The `ncr` function runs in `O(N)` time. In python, the factorial function takes `O(N)` time as well.\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Catalan Numbers - 2)***\\n\\nThe **[Catalan Numbers](https://en.wikipedia.org/wiki/Catalan_number)** also follow the below recurrence relation - \\n\\n<p align=\\'middle\\'>\\n<img src=https://assets.leetcode.com/users/images/44f67316-d59f-48f5-9537-9f4991aa7e96_1636340974.5645378.png />\\n</p>\\n\\nThis can be said to be a kind of dynamic programming approach where our next result depends only on previous one. This is slightly easier to implement in code than the 1st formula for catalan numbers.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long ans = 1;\\n        for(int i = 0; i < n; i++) \\n            ans *= (4*i+2) / (i+2.);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return int(prod((4*i+2) / (i+2) for i in range(n)))\\n```\\n\\n***Time Complexity :*** <code><b>O(N)</b></code>\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```python\\n\\t\\n              1            1                   2                    3               3\\n\\t           \\\\            \\\\                 / \\\\                  /               /\\n    \\t        3             2              1   3                2               1\\n               /               \\\\                                 /                 \\\\\\n              2                 3                              1                    2\\n                     i = 1                   i = 2                       i = 3           \\n(i = root node)\\n```\n```python\\n           3                          2                         1               \\n          / \\\\                        / \\\\                      /   \\\\      \\nnumTrees(2) numTrees(0)    numTrees(1) numTrees(1)   numTrees(0) numTrees(2)              \\n         i = 3                      i = 2                     i = 1           \\n\\t\\t \\n                      i\\n\\t=>              /   \\\\ \\n         numTrees(i-1)\\tnumTrees(n-i)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) \\n            ans += numTrees(i-1) * numTrees(n-i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1: return 1\\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))\\n```\n```ruby\\nf(i) = numTrees(i)\\n                                                                 f(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t__________________________________|____________________________________________\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t                  \\u2199                            \\u2193                \\u2193                \\u2193                 \\u2198\\n\\t\\t        (f(0)*           f(4))                 f(1)*f(3)        f(2)*f(2)        f(3)*f(1)          f(4)*f(0)\\n\\t\\t\\t\\t     _____________|_____________             \\u2B06\\uFE0F          \\u2B06\\uFE0F  \\u2B06\\uFE0F         \\u2B06\\uFE0F                 \\u2B06\\uFE0F\\n\\t\\t            \\u2199        \\u2193        \\u2193         \\u2198  \\t   \\n\\t        f(0)f(3)     f(1)f(2)   f(2)f(1)   f(3)f(0)      \\n\\t\\t   ______|_____       \\u2B06\\uFE0F\\t \\u2B06\\uFE0F        \\u2B06\\uFE0F\\n          \\u2199      \\u2193     \\u2198\\n      f(0)f(2) f(1)f(1) f(2)f(1)\\n          __|__\\t         \\u2B06\\uFE0F \\n     \\t\\u2199       \\u2198\\n     f(0)f(1)  f(1)f(0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[20]{};\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        if(dp[n]) return dp[n];\\n        for(int i = 1; i <= n; i++) \\n            dp[n] += numTrees(i-1) * numTrees(n-i);\\n        return dp[n];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    @cache\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1: return 1\\n        return sum(self.numTrees(i-1) * self.numTrees(n-i) for i in range(1, n+1))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0] = dp[1] = 1;\\n        for(int i = 2; i <= n; i++) \\n            for(int j = 1; j <= i; j++)\\n                dp[i] += dp[j-1] * dp[i-j];\\n        return dp[n];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        dp = [0]*(n+1)\\n        dp[0], dp[1] = 1, 1\\n        for i in range(2, n+1):\\n            for j in range(1, i+1):\\n                dp[i] += dp[j-1] * dp[i-j]\\n        return dp[n]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long ncr(int n, int r) {\\n        long ans = 1;\\n        for(int i = 0; i < r; i++) {\\n            ans *= n-i;\\n            ans /= i+1;\\n        }\\n        return ans;   \\n    }\\n    int numTrees(int n) {\\n        return ncr(2*n, n) / (n + 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long ans = 1;\\n        for(int i = 1; i < n; i++)  \\n            ans = ans*(n+i+1) / i;    // do note that numerator and denominator will always be divisible\\n        return ans / n;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return factorial(2*n) // (factorial(n)*factorial(n+1))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long ans = 1;\\n        for(int i = 0; i < n; i++) \\n            ans *= (4*i+2) / (i+2.);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return int(prod((4*i+2) / (i+2) for i in range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31707,
                "title": "fantastic-clean-java-dp-solution-with-detail-explaination",
                "content": "First note that dp[k] represents the number of BST trees built from 1....k;\\n\\nThen assume we have the number of the first 4 trees: dp[1] = 1 ,dp[2] =2 ,dp[3] = 5, dp[4] =14 , how do we get dp[5] based on these four numbers is the core problem here.\\n\\nThe essential process is: to build a tree, we need to pick a root node, then we need to know how many possible left sub trees and right sub trees can be held under that node, finally multiply them.\\n\\nTo build a tree contains {1,2,3,4,5}. First we pick 1 as root, for the left sub tree, there are none; for the right sub tree, we need count how many possible trees are there constructed from {2,3,4,5}, apparently it's the same number as {1,2,3,4}. So the total number of trees under \"1\" picked as root is dp[0] * dp[4] = 14. (assume dp[0] =1). Similarly, root 2 has dp[1]*dp[3] = 5 trees. root 3 has dp[2]*dp[2] = 4, root 4 has dp[3]*dp[1]= 5 and root  5 has dp[0]*dp[4] = 14. Finally sum the up and it's done.\\n\\nNow, we may have a better understanding of the dp[k], which essentially represents the number of BST trees with k consecutive nodes. It is used as database when we need to know how many left sub trees are possible for k nodes when picking (k+1) as root. \\n\\n     public int numTrees(int n) {\\n        int [] dp = new int[n+1];\\n        dp[0]= 1;\\n        dp[1] = 1;\\n        for(int level = 2; level <=n; level++)\\n            for(int root = 1; root<=level; root++)\\n                dp[level] += dp[level-root]*dp[root-1];\\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "First note that dp[k] represents the number of BST trees built from 1....k;\\n\\nThen assume we have the number of the first 4 trees: dp[1] = 1 ,dp[2] =2 ,dp[3] = 5, dp[4] =14 , how do we get dp[5] based on these four numbers is the core problem here.\\n\\nThe essential process is: to build a tree, we need to pick a root node, then we need to know how many possible left sub trees and right sub trees can be held under that node, finally multiply them.\\n\\nTo build a tree contains {1,2,3,4,5}. First we pick 1 as root, for the left sub tree, there are none; for the right sub tree, we need count how many possible trees are there constructed from {2,3,4,5}, apparently it's the same number as {1,2,3,4}. So the total number of trees under \"1\" picked as root is dp[0] * dp[4] = 14. (assume dp[0] =1). Similarly, root 2 has dp[1]*dp[3] = 5 trees. root 3 has dp[2]*dp[2] = 4, root 4 has dp[3]*dp[1]= 5 and root  5 has dp[0]*dp[4] = 14. Finally sum the up and it's done.\\n\\nNow, we may have a better understanding of the dp[k], which essentially represents the number of BST trees with k consecutive nodes. It is used as database when we need to know how many left sub trees are possible for k nodes when picking (k+1) as root. \\n\\n     public int numTrees(int n) {\\n        int [] dp = new int[n+1];\\n        dp[0]= 1;\\n        dp[1] = 1;\\n        for(int level = 2; level <=n; level++)\\n            for(int root = 1; root<=level; root++)\\n                dp[level] += dp[level-root]*dp[root-1];\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 703049,
                "title": "python-math-oneliner-o-n-using-catalan-number-explained",
                "content": "In this problem we are asked to get number of trees and not necceseraly to return all trees, only **number**. Here we can use the idea of **dynamic programming**, let `dp[n]` be the number of unique Binary Search Trees with `n` nodes. How can we evaluate them: we need to choose number of nodes in the left subtree and number of nodes in the right subtree, for example `n=5`, then we have options:\\n1. left subtree has 0 nodes, root = 1, and right subtree has 4 nodes, number of options `f[0]*f[4]`\\n2. left subtree has 1 nodes, root = 2, and right subtree has 3 nodes, number of options `f[1]*f[3]`\\n3. left subtree has 2 nodes, root = 3, and right subtree has 2 nodes, number of options `f[2]*f[2]`\\n4. left subtree has 3 nodes, root = 4, and right subtree has 1 nodes, number of options `f[3]*f[1]`\\n5. left subtree has 4 nodes, root = 5, and right subtree has 0 nodes, number of options `f[4]*f[0]`\\n\\nSo, in total `f[5] = f[0]*f[4] + f[1]*f[3] + f[2]*f[2] + f[3]*f[1] + f[4]*f[0]`, and in general:\\n`f[n] = f[0]*f[n-1] + f[1]*f[n-2] + ... + f[n-2]*f[1] + f[n-1]*f[0]`.\\n\\nWe can solve this in classical **dynamic programming** way with `O(n^2)` complexity. However we can recognize in this formula **Catalan Numbers**: https://en.wikipedia.org/wiki/Catalan_number and there is direct formula to evaluate them:\\n`f[n] = (2n)!/(n! * n! * (n+1))`.\\n\\n**Complexity**: time complexity is `O(n)` to evaluate all factorials, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def numTrees(self, n):\\n        return factorial(2*n)//factorial(n)//factorial(n)//(n+1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n):\\n        return factorial(2*n)//factorial(n)//factorial(n)//(n+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109205,
                "title": "detailed-analysis-3-different-approaches-explained",
                "content": "Let `C(i)` denote the number of nodes on left side of `root` \\n-> `C(n-i-1)` denotes the number of nodes on right side of `root`\\nHence the total number of **BST** possible will be : `C(i) * C(n-i-1)` **for a given root** \\n->Total number of BST possible will be : `m * C(i) * C(n-i-1)` , where `m`: number of different root configurations\\nSo, for example , the various *BST* for n=3:\\n![image](https://assets.leetcode.com/users/images/f1bb3c6c-f7ee-4276-ae1f-a4d09289a885_1615722107.5216558.png)\\n\\n`C(0)*C(2)  +  C(2)*C(0) + C(1)* C(1)` --> **This is known as Catalan number**\\nHence, the given question is asking us to find the **Catalan Number** `C` of a number `n`:\\n`C(n)= C(i) * C(n-i-1)` => `i` varies from `0` to `n-1`\\n\\nIt can be found in three ways:\\n\\n**1.) Recursion:** Worst approach (results in TLE)\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int result=0;\\n        if(n==1 || n==0)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n            result+=numTrees(i)*numTrees(n-i-1);\\n        return result;\\n    }\\n};\\n```\\n*Time Complexity: O(3^n)*\\n*For more details on this, visit this:* [https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity](http://)\\n\\n**2.) Dynamic Programming:** Better than Recursion\\nConcept: Instead of doing recursive calls to calculate `C(n-2).....C(1)` every time, we store the results of previous iteration in an array `result` . Doing so results in making only one call per function as we already know the value of `C(n-1)`,reducing overall runtime\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int>result(n+1,0); //Initializing vector with 0\\n        result[1]=result[0]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                result[i]+=result[j]*result[i-j-1]; //Calculating C(i) to use for C(i+1) and storing it in result\\n            }\\n        }\\n        return result[n]; //return answer\\n    }\\n};\\n```\\n*Time Complexity : O(n^2)\\nSpace Complexity : O(n)*\\n\\n**3.) Binomial Coefficient:** Best approach\\nConcept: Instead of doing it again and again like in DP and recursion, there is a well known formula to calculate Catalan Number, which is\\n\\n\\t\\t\\t\\t\\t\\t`C(n)=Ci(2n,n)/n+1`\\nwhere `Ci`: Binomial Coefficient\\n\\n*For those interested in proof of this, visit this link:* [https://en.wikipedia.org/wiki/Catalan_number](http://) \\n```\\nclass Solution {\\npublic:\\n    long CalculateCoeff(int n,int k) //Function to calculate Ci(n.k)\\n    {\\n        long res=1;\\n        if(k>n-k)\\n            k=n-k;                    //Since Ci(n,k)=Ci(n,n-k), property of binomial coefficients\\n        for(int i=0;i<k;i++)\\n        {\\n            res*=(n-i);\\n            res/=(i+1);\\n        }\\n        return res;\\n    }\\n    int numTrees(int n) {\\n        return CalculateCoeff(2*n,n)/(n+1);\\n    }\\n};\\n```\\n*Time Complexity : O(n)\\nSpace Complexity : O(n)*\\n***Runtime** in both Approach 2 and Approach 3 is **0ms***\\n\\nI hope this article helped some of you, I tried my best to eplain everything \\nIf you like, please **UPVOTE**\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int result=0;\\n        if(n==1 || n==0)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n            result+=numTrees(i)*numTrees(n-i-1);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int>result(n+1,0); //Initializing vector with 0\\n        result[1]=result[0]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            {\\n                result[i]+=result[j]*result[i-j-1]; //Calculating C(i) to use for C(i+1) and storing it in result\\n            }\\n        }\\n        return result[n]; //return answer\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long CalculateCoeff(int n,int k) //Function to calculate Ci(n.k)\\n    {\\n        long res=1;\\n        if(k>n-k)\\n            k=n-k;                    //Since Ci(n,k)=Ci(n,n-k), property of binomial coefficients\\n        for(int i=0;i<k;i++)\\n        {\\n            res*=(n-i);\\n            res/=(i+1);\\n        }\\n        return res;\\n    }\\n    int numTrees(int n) {\\n        return CalculateCoeff(2*n,n)/(n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31706,
                "title": "dp-problem-10-lines-with-comments",
                "content": "    /**\\n     * Taking 1~n as root respectively:\\n     *      1 as root: # of trees = F(0) * F(n-1)  // F(0) == 1\\n     *      2 as root: # of trees = F(1) * F(n-2) \\n     *      3 as root: # of trees = F(2) * F(n-3)\\n     *      ...\\n     *      n-1 as root: # of trees = F(n-2) * F(1)\\n     *      n as root:   # of trees = F(n-1) * F(0)\\n     *\\n     * So, the formulation is:\\n     *      F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0)\\n     */\\n\\n    int numTrees(int n) {\\n        int dp[n+1];\\n        dp[0] = dp[1] = 1;\\n        for (int i=2; i<=n; i++) {\\n            dp[i] = 0;\\n            for (int j=1; j<=i; j++) {\\n                dp[i] += dp[j-1] * dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Taking 1~n as root respectively:\\n     *      1 as root: # of trees = F(0) * F(n-1)  // F(0) == 1\\n     *      2 as root: # of trees = F(1) * F(n-2) \\n     *      3 as root: # of trees = F(2) * F(n-3)\\n     *      ...\\n     *      n-1 as root: # of trees = F(n-2) * F(1)\\n     *      n as root:   # of trees = F(n-1) * F(0)\\n     *\\n     * So, the formulation is:\\n     *      F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0)\\n     */\\n\\n    int numTrees(int n) {\\n        int dp[n+1];\\n        dp[0] = dp[1] = 1;\\n        for (int i=2; i<=n; i++) {\\n            dp[i] = 0;\\n            for (int j=1; j<=i; j++) {\\n                dp[i] += dp[j-1] * dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31826,
                "title": "python-solutions-dp-catalan-number",
                "content": "   \\n    # DP\\n    def numTrees1(self, n):\\n        res = [0] * (n+1)\\n        res[0] = 1\\n        for i in xrange(1, n+1):\\n            for j in xrange(i):\\n                res[i] += res[j] * res[i-1-j]\\n        return res[n]\\n     \\n    # Catalan Number  (2n)!/((n+1)!*n!)  \\n    def numTrees(self, n):\\n        return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1))",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "   \\n    # DP\\n    def numTrees1(self, n):\\n        res = [0] * (n+1)\\n        res[0] = 1\\n        for i in xrange(1, n+1):\\n            for j in xrange(i):\\n                res[i] += res[j] * res[i-1-j]\\n        return res[n]\\n     \\n    # Catalan Number  (2n)!/((n+1)!*n!)  \\n    def numTrees(self, n):\\n        return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1))",
                "codeTag": "Python3"
            },
            {
                "id": 409987,
                "title": "summary-of-all-solutions-in-java-with-explanations",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/unique-binary-search-trees/) <span class=\"gray\">EPI 15.9</span>\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n## Problem\\n\\n> Given `n`, how many structurally unique BST\\'s (binary search trees) that store values `1 ... n`?\\n\\n**Example:** \\n\\n```java\\nInput: 3\\nOutput: 5\\nExplanation:\\nGiven n = 3, there are a total of 5 unique BST\\'s:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\\n\\n## Analysis\\n\\n### DP (Recursion)\\n\\nReference: [LeetCode Solution](https://leetcode.com/problems/unique-binary-search-trees/solution/)\\n\\nGiven a sequence `1, 2, ..., n`, we enumerate each number `i` in the sequence and take it as the root to form binary trees.\\n\\nWe define two functions:\\n\\n- `G(n)`: the number of unique BST for a sequence of length `n` (number of nodes).\\n- `F(i, n)`: the number of unique BST, where the number `i` (`1 <= i <= n`) is the root.\\n\\nWe construct `G(n)` by the sum of `F(i, n)`:\\n\\n`G(n) = \\\\sum^n_{i=1}F(i, n) = F(1, n) + F(2, n) + ... + F(n, n)`\\n\\nNotice that when we select `i` as a root i.e. `F(i, n)`, we have `i - 1` nodes which can be used to form a left subtree; similarly we have `n - i` nodes to form a right subtree. \\n\\n`F(i,n) = G(i - 1) x G(n - i)`\\n\\nThus, `F(i, n)` can be calculated by the product of the number of unique BST with `i - 1` nodes and the number of unique BST with `n - i` nodes. **Uniqueness is guaranteed by the sizes of the left subtree and the right subtree.**\\n\\nParticularly, consider two base cases when `i = 1` and `i = 2`:\\n\\n- `i = 1`: `F(1, n) = G(0) x G(n - 1)`. The empty left subtree is still a subtree, so `G(0) = 1`.\\n- `i = 2`: `F(2, n) = G(1) x G(n - 2)`. With one node we can only construct one unique left subtree, so `G(1) = 1`.\\n\\nFinally, we have the recurrence:\\n\\n`G(n) = \\\\sum^n_{i=1}F(i,n) = \\\\sum^n_{i=1} G(i - 1) x G(n - i)`\\n`\\\\text{where}\\\\ \\\\  G(0)=1, G(1)=1`\\n\\nHere is the code without memoization.\\n\\n```java\\n// numTress(n) is G(n)\\npublic int numTrees(int n) {\\n  if (n == 0 || n == 1) {\\n    return 1;\\n  }\\n  int sum = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    sum += numTrees(i - 1) * numTrees(n - i);\\n  }\\n  return sum;\\n}\\n```\\n\\nHere is the recurrence tree:\\n\\n```java\\n                               G(4)\\n                     /      |        |        \\\\\\n             G(0)G(3)     G(1)G(2)  G(2)G(1)   G(3)G(0)        // 4\\n            /    |    \\\\\\n    G(0)G(2)  G(1)G(1)  G(2)G(0)                               // 4 x 3\\n    /     \\\\\\nG(0)G(1)  G(1)G(0) // base case                                // 4 x 3 x 2\\n```\\n\\n`C(N) = N x N!`\\n\\n**Time:** It is at most bounded by `O(N x N!)`. A tighter bound would be Catalan number times `N` since we\\'ve done `N` times, which is `N x G_N = O(N x \\\\frac{4^N}{N^{3/2}}) = O(\\\\frac{4^N}{N^{1/2}})`.\\n**Space:** `O(N)`\\n\\nExamining the recurrence carefully, we find that there are repeated calculations.\\n\\n```java\\nG(3) = G(0) x G(2)  // i = 1\\n     = G(1) x G(1)  // i = 2\\n     = G(2) x G(0)  // i = 3\\n\\nG(4) = G(0) x G(3)  // i = 1\\n     = G(1) x G(2)  // i = 2\\n     = G(2) x G(1)  // i = 3\\n     = G(3) x G(0)  // i = 4\\n```\\n\\nTherefore, we can use a `hash map` or an `integer array` to store calculated `G(n)`. Here is the hash map version.\\n\\n```java\\nMap<Integer, Integer> map = new HashMap<>();\\npublic int numTrees(int n) {\\n  if (n == 0 || n == 1) {\\n    return 1;\\n  }\\n  int sum = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    if (!map.containsKey(i - 1)) {\\n      map.put(i - 1, numTrees(i - 1));\\n    }\\n    if (!map.containsKey(n - i)) {\\n      map.put(n - i, numTrees(n - i));\\n    }\\n    sum += map.get(i - 1) * map.get(n - i);\\n  }\\n  return sum;\\n}\\n```\\n\\nHere is the recurrence tree:\\n\\n```java\\n                               G(4)\\n                     /      |        |        \\\\\\n             G(0)G(3)     G(1)G(2)  G(2)G(1)   G(3)G(0)\\n            /    |    \\\\\\n    G(0)G(2)  G(1)G(1)  G(2)G(0)\\n    /     \\\\\\nG(0)G(1)  G(1)G(0) // base case\\n```\\n\\n**Note:** Without memoization, the time complexity is upper bounded by `O(N x N!)`.\\n\\nBy calculating the leftmost nodes, we have `G(0), G(1), ..., G(N)`, which takes `O(N)` time. Besides, we have to do product computations at each level, which takes `2 + 3 + 4 + ... + N = O(N^2)` time in total.\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)` because of call stacks.\\n\\n\\n### DP (Iteration)\\n\\nBy observation, we can construct our solution by a bottom-up approach.\\n\\nThe recurrence formula: `G(n) = \\\\sum^n_i G(i - 1) x G(n - i)`\\n\\nFor example, `G(4) = G(0) x G(3) + G(1) x G(2) + G(2) x G(1) + G(3) x G(0)`\\n\\n```java\\nG(0) G(1)\\n// With these initially two base-case values, we can calculate G(2)\\nG(0) G(1) G(2)\\n// With these three values we have G(3)\\nG(0) G(1) G(2) G(3)\\n// ...\\n```\\n\\n**Note:** Notice that it is `G[i - j]` instead of `G[n - j]` and it is `j <= i` instead of `j <= n`.\\n\\n```java\\npublic int numTrees(int n) {\\n  int[] G = new int[n + 1];\\n  G[0] = 1; G[1] = 1; // init\\n  for (int i = 2; i <= n; ++i) {\\n    for (int j = 1; j <= i; ++j) { // sum\\n      G[i] += G[j - 1] * G[i - j];\\n    }\\n  }\\n  return G[n];\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)`\\n\\n\\n\\n\\n\\n### Mathematical Deduction\\n\\nThe sequence of `G(n)` function results is known as `Catelan number` `C_n`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/0bq2c.png)\\n\\n**Note:** Use `long` type.\\n\\n```java\\nC = 2 * (2 * i + 1) / (i + 2) * C;\\n```\\n\\n\\nIf we put `C` at the end of the statement, the result is not correct. **Do all multiplications first!** For example, when `i = 2` and `C_2 = 2`, we would have:\\n\\n- `C = 2 * (2 * 2 + 1) / (2 + 2) * C_2 = 2 * (5) / 4 * 2 = 10 / 4 * 2 = 4`\\n- instead of `C = 2 * 10 / 4 = 5`.\\n\\n```java\\npublic int numTrees(int n) {\\n  long C = 1;\\n  for (int i = 0; i < n; ++i) { // i stops at n - 1\\n    C = C * 2 * (2 * i + 1) / (i + 2); // calculate C_i+1\\n  }\\n  return (int) C;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: 3\\nOutput: 5\\nExplanation:\\nGiven n = 3, there are a total of 5 unique BST\\'s:\\n\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\n```java\\n// numTress(n) is G(n)\\npublic int numTrees(int n) {\\n  if (n == 0 || n == 1) {\\n    return 1;\\n  }\\n  int sum = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    sum += numTrees(i - 1) * numTrees(n - i);\\n  }\\n  return sum;\\n}\\n```\n```java\\n                               G(4)\\n                     /      |        |        \\\\\\n             G(0)G(3)     G(1)G(2)  G(2)G(1)   G(3)G(0)        // 4\\n            /    |    \\\\\\n    G(0)G(2)  G(1)G(1)  G(2)G(0)                               // 4 x 3\\n    /     \\\\\\nG(0)G(1)  G(1)G(0) // base case                                // 4 x 3 x 2\\n```\n```java\\nG(3) = G(0) x G(2)  // i = 1\\n     = G(1) x G(1)  // i = 2\\n     = G(2) x G(0)  // i = 3\\n\\nG(4) = G(0) x G(3)  // i = 1\\n     = G(1) x G(2)  // i = 2\\n     = G(2) x G(1)  // i = 3\\n     = G(3) x G(0)  // i = 4\\n```\n```java\\nMap<Integer, Integer> map = new HashMap<>();\\npublic int numTrees(int n) {\\n  if (n == 0 || n == 1) {\\n    return 1;\\n  }\\n  int sum = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    if (!map.containsKey(i - 1)) {\\n      map.put(i - 1, numTrees(i - 1));\\n    }\\n    if (!map.containsKey(n - i)) {\\n      map.put(n - i, numTrees(n - i));\\n    }\\n    sum += map.get(i - 1) * map.get(n - i);\\n  }\\n  return sum;\\n}\\n```\n```java\\n                               G(4)\\n                     /      |        |        \\\\\\n             G(0)G(3)     G(1)G(2)  G(2)G(1)   G(3)G(0)\\n            /    |    \\\\\\n    G(0)G(2)  G(1)G(1)  G(2)G(0)\\n    /     \\\\\\nG(0)G(1)  G(1)G(0) // base case\\n```\n```java\\nG(0) G(1)\\n// With these initially two base-case values, we can calculate G(2)\\nG(0) G(1) G(2)\\n// With these three values we have G(3)\\nG(0) G(1) G(2) G(3)\\n// ...\\n```\n```java\\npublic int numTrees(int n) {\\n  int[] G = new int[n + 1];\\n  G[0] = 1; G[1] = 1; // init\\n  for (int i = 2; i <= n; ++i) {\\n    for (int j = 1; j <= i; ++j) { // sum\\n      G[i] += G[j - 1] * G[i - j];\\n    }\\n  }\\n  return G[n];\\n}\\n```\n```java\\nC = 2 * (2 * i + 1) / (i + 2) * C;\\n```\n```java\\npublic int numTrees(int n) {\\n  long C = 1;\\n  for (int i = 0; i < n; ++i) { // i stops at n - 1\\n    C = C * 2 * (2 * i + 1) / (i + 2); // calculate C_i+1\\n  }\\n  return (int) C;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31696,
                "title": "simple-recursion-java-solution-with-explanation",
                "content": "The idea is to use each number i as root node, then the left branch will be what's less than i, the right branch will be what's larger than i. The total number of distinct structure is their product. Thus, sum up the product for all numbers. Use a map to memorize the visited number.\\n\\n    public class Solution {\\n        public int numTrees(int n) {\\n            Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            map.put(0,1);\\n            map.put(1,1);\\n            return numTrees(n, map);\\n        }\\n        \\n        private int numTrees(int n, Map<Integer, Integer> map){\\n            // check memory\\n            if(map.containsKey(n)) return map.get(n);\\n            // recursion\\n            int sum = 0;\\n            for(int i = 1;i <= n;i++)\\n                sum += numTrees(i-1, map) * numTrees(n-i, map);\\n            map.put(n, sum);\\n            return sum;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n        public int numTrees(int n) {\\n            Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n            map.put(0,1);\\n            map.put(1,1);\\n            return numTrees(n, map);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 703644,
                "title": "python-easy-dp-solution-explained-by-someone-who-used-to-struggle-to-understand-dp",
                "content": "First of all, I am so happy because I was able to solve this problem without any help :) So, I am going to explained how I improved my DP skills. Of course, this is a \"medium\" question and I still struggle with the hard ones but I can see some improvement and I want to share my tips with you.\\n\\n***How to understand if a problem is DP problem?***\\nWell, I still struggle to understand that for some problem types but basically if you think that you can solve the problem easily by knowing the solution for previous values(like the solution on the previous grids for 2D cases or the solution for n-1 etc.), it is probably a DP problem.\\n\\nDP problems are usually an iterative version of a recursive solution. I find it easy to think about recursive solution first and then convert it to DP. \\n\\n**1. Recursive + Memoization**\\n\\nWe need to calculate how many possible trees can be made. \\nIf there is only ```1``` node then it is easy. The answer is 1. \\nFor ```2``` we can construct ```2``` different trees: One of the node is root, the second one can either be a left child or right child.\\n```\\nn = 2\\n\\n   1                            1\\n  /              or               \\\\\\n2\\t                                2\\n```\\nEasy!\\nWhat about n=3?\\n```\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n\\t---------------------------------- Let\\'s cut the trees from here\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n ```\\nAs you can see, from where we cut, the bottom of the tree is actually another tree where the same logic applies. So the only thing we need to decide is how to distrubute the remaining nodes to childs of the root. The options can be:\\n```\\n------num of nodes------\\nleft_child   right_child\\n     0             2 --> These are the subtrees, like the new trees with n = 0 and n = 2\\n     1             1\\n     2             0\\n```\\nTo find how many possible solutions are there for n=3, add up all these possibilities . We can call the same function for calculating the values in all the options because it is actually the same problem. \\nTo sum up, we picked the root and then we need to decide on how the left and right subtrees will look like. The options are how many nodes can be on the left and right subtree at the same time.\\n\\n```\\n       -------------- 3 ---------------\\n\\t  /\\t\\t          |                \\\\\\n  /      \\\\\\t      /      \\\\\\t \\t   /\\t    \\\\\\n  0     --2--    1        1     --2--        0\\n       /     \\\\                 /     \\\\  \\n\\t /\\\\       /\\\\             /\\\\       /\\\\\\n\\t1  0     0  1           1  0     0  1\\n\\n```\\nHere is my attempt to draw the recursion tree. Even for a small n value there are multiple overlapping problems. So I used a memoization table and saved the values on that table before returning the total value from the function and if the value that we are looking for exists on the table, return that value without doing any extra calculations.\\n\\nHere is the code:\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        self.table = [-1] * (n+1)\\n        self.table[0] = 1\\n        return self.numTreesRec(n)\\n        \\n    def numTreesRec(self, n):\\n        if self.table[n] != -1:\\n            return self.table[n]\\n        total = 0\\n        for m in range(n):\\n            total += (self.numTreesRec(n-1-m) * self.numTreesRec(m))\\n        self.table[n] = total\\n        return total\\n```\\n\\n**2. Dynamic Programming**\\nNow, we have our recursive solution. As you can see from the above recursion tree, values are calculated starting from 0 and then 1 and goes like this until n. The means we can do it iteratively. We can start from 1 (n=0 are our base case) and calculate the values upto n. So, I created a dp table and the solution for n = i is stored at dp[i]. Now, if we go back to our example, for n=3:\\n```\\n0 2 \\n1 1\\n2 0\\n```\\nWe have these options for distributing the remaining nodes to subtrees. We already calculated the values for 0, 1 and 2 because we used iterative approach. Therefore solution for dp[3] will be\\n```\\ndp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0]\\n```\\n\\nwhich is done by the inner for loop in the code.\\n\\nHere is the code:\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                dp[i] += dp[j] * dp[i- 1 - j]\\n        return dp[n]\\n```\\n\\nThe time complexity is O(n^2) and the space complexity is O(n). There is a better solution by using catalan numbers. \\n\\nI tried  my best to explain how I think when solving  a dp problem. Hope that it helps and don\\'t worry if you are having diffuculties. Practice makes perfect!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```1```\n```2```\n```2```\n```\\nn = 2\\n\\n   1                            1\\n  /              or               \\\\\\n2\\t                                2\\n```\n```\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n\\t---------------------------------- Let\\'s cut the trees from here\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n ```\n```\\n------num of nodes------\\nleft_child   right_child\\n     0             2 --> These are the subtrees, like the new trees with n = 0 and n = 2\\n     1             1\\n     2             0\\n```\n```\\n       -------------- 3 ---------------\\n\\t  /\\t\\t          |                \\\\\\n  /      \\\\\\t      /      \\\\\\t \\t   /\\t    \\\\\\n  0     --2--    1        1     --2--        0\\n       /     \\\\                 /     \\\\  \\n\\t /\\\\       /\\\\             /\\\\       /\\\\\\n\\t1  0     0  1           1  0     0  1\\n\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        self.table = [-1] * (n+1)\\n        self.table[0] = 1\\n        return self.numTreesRec(n)\\n        \\n    def numTreesRec(self, n):\\n        if self.table[n] != -1:\\n            return self.table[n]\\n        total = 0\\n        for m in range(n):\\n            total += (self.numTreesRec(n-1-m) * self.numTreesRec(m))\\n        self.table[n] = total\\n        return total\\n```\n```\\n0 2 \\n1 1\\n2 0\\n```\n```\\ndp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0]\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        dp = [0] * (n+1)\\n        dp[0] = 1\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                dp[i] += dp[j] * dp[i- 1 - j]\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565533,
                "title": "java-simple-clean-dp-solution-w-detailed-example-beats-100-tc-o-n-2-sc-o-n",
                "content": "This is a **Dynamic Programming (DP) question**.\\n\\nLet us assume: \\n`R(n)` represents the total number of unique Binary Search Trees with `n` nodes.\\n\\nFor `n == 0`, empty tree is a valid BST. Thus `R(0) = 1`.\\nFor `n == 1`, valid BST can have only one node. Thus `R(1) = 1`.\\nFor `n == 2`, valid BST can have only two nodes. Thus there can be following valid BSTs:\\n```\\n   1                                2\\n\\t \\\\                            /\\n\\t   2                        1\\n```\\nThus, `R(2) = R(0)*R(1) + R(1)*R(0) = 1 + 1 = 2`\\n\\nFor `n == 3`, valid BST can have only three nodes. Thus there can be following valid BSTs:\\n```\\n   1                1                2                  3                 3\\n\\t\\\\                \\\\              / \\\\                /                 /\\n\\t 2                3            1   3              2                 1\\n      \\\\              /                               /                   \\\\\\n\\t   3            2                               1                     2\\n```\\nThus, `R(3) = R(0)*R(2) + R(1)*R(1) + R(2)*R(0) = 2 + 1 + 2 = 5`\\n\\nTherefore, our generalized DP equation is: \\n`R(n) = R(0)*R(n-1) + R(1)*R(n-2) + R(2)*R(n-3) + ...... + R(n-3)*R(2) + R(n-2)*R(1) + R(n-1)*R(0)`\\n\\n---\\n**Time Complexity:** `O(N * N/2) = O(N^2)`. --> We only traverse `half of i` for `dp[i]`, as the DP equation is symmetrical.\\n\\n**Space Complexity:** `O(N)` --> Required for DP array.\\n\\n---\\n**Solution**\\n\\n```java\\nclass Solution {\\n    public int numTrees(int n) {\\n        // Checking for Invalid Input\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        // For n == 0, empty tree is a valid BST.\\n        // For n == 1, valid BST can have only one node.\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            // We only need to do half as dp[i] is symmetrical.\\n            // For example, when i = 5:\\n            // dp[i] = dp[0]*dp[4] + dp[1]*dp[3] + dp[2]*dp[2] + dp[3]*dp[1] + dp[4]*dp[0]\\n            // Here except dp[2]*dp[2] all others are appearing twice.\\n            for (int j = 0; j < i / 2; j++) {\\n                dp[i] += dp[j] * dp[i - 1 - j];\\n            }\\n            dp[i] *= 2;\\n\\n            // Only add i/2 * i/2 for odd numbers.\\n            if ((i & 1) == 1) {\\n                dp[i] += dp[i / 2] * dp[i / 2];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n---\\n\\n<ins>Other Similar questions on LeetCode:</ins>\\n- [95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)\\n- [241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)\\n",
                "solutionTags": [],
                "code": "```\\n   1                                2\\n\\t \\\\                            /\\n\\t   2                        1\\n```\n```\\n   1                1                2                  3                 3\\n\\t\\\\                \\\\              / \\\\                /                 /\\n\\t 2                3            1   3              2                 1\\n      \\\\              /                               /                   \\\\\\n\\t   3            2                               1                     2\\n```\n```java\\nclass Solution {\\n    public int numTrees(int n) {\\n        // Checking for Invalid Input\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        // For n == 0, empty tree is a valid BST.\\n        // For n == 1, valid BST can have only one node.\\n        if (n <= 1) {\\n            return 1;\\n        }\\n\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n\\n        for (int i = 2; i <= n; i++) {\\n            // We only need to do half as dp[i] is symmetrical.\\n            // For example, when i = 5:\\n            // dp[i] = dp[0]*dp[4] + dp[1]*dp[3] + dp[2]*dp[2] + dp[3]*dp[1] + dp[4]*dp[0]\\n            // Here except dp[2]*dp[2] all others are appearing twice.\\n            for (int j = 0; j < i / 2; j++) {\\n                dp[i] += dp[j] * dp[i - 1 - j];\\n            }\\n            dp[i] *= 2;\\n\\n            // Only add i/2 * i/2 for odd numbers.\\n            if ((i & 1) == 1) {\\n                dp[i] += dp[i / 2] * dp[i / 2];\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31761,
                "title": "python-with-explanation-i-guess-you-could-call-this-dp",
                "content": "Let\\'s look at a naive recursive algorithm:\\n\\nSuppose you are given 1--n, and you want to generate all binary search trees.  How do you do it?  Suppose you put number i on the root, then simply\\n\\n 1. Generate all BST on the left branch by running the same algorithm\\n    with 1--(i-1), \\n 2. Generate all BST on the right branch by running the\\n    same algorithm with (i+1)--n.\\n 3. Take all combinations of left branch\\n    and right branch, and that\\'s it for i on the root.\\n\\nThen you let i go from 1 to n.  And that\\'s it.  If you want to write it in code, it\\'s like\\n\\n    def countTrees(n):\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 1\\n     \\n        Result = 0\\n        for i in xrange(n):\\n            LeftTrees = countTrees(i)\\n            RightTrees = countTrees(n - i - 1)\\n            Result += LeftTrees * RightTrees\\n        return Result\\n\\nThe only problem is, it\\'s very slow, because for large n, you\\'ll need to calculate `countTrees(i)` many many times, where i is a small number.  Naturally, to speed it up, you just need to remember the result of `countTrees(i)`, so that when you need it next time, you don\\'t need to calculate.  Let\\'s do that explicitly by having a list of n+1 numbers to store the calculation result!\\n\\n    def countTrees(n, cache):\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 1\\n    \\n        if cache[n] != -1: # -1 means we don\\'t know countTrees(n) yet.\\n            return cache[n]\\n    \\n        Result = 0\\n        for i in xrange(n):\\n            LeftTrees = countTrees(i, cache)\\n            RightTrees = countTrees(n - i - 1, cache)\\n            Result += LeftTrees * RightTrees\\n        cache[n] = Result\\n        return Result",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Let\\'s look at a naive recursive algorithm:\\n\\nSuppose you are given 1--n, and you want to generate all binary search trees.  How do you do it?  Suppose you put number i on the root, then simply\\n\\n 1. Generate all BST on the left branch by running the same algorithm\\n    with 1--(i-1), \\n 2. Generate all BST on the right branch by running the\\n    same algorithm with (i+1)--n.\\n 3. Take all combinations of left branch\\n    and right branch, and that\\'s it for i on the root.\\n\\nThen you let i go from 1 to n.  And that\\'s it.  If you want to write it in code, it\\'s like\\n\\n    def countTrees(n):\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 1\\n     \\n        Result = 0\\n        for i in xrange(n):\\n            LeftTrees = countTrees(i)\\n            RightTrees = countTrees(n - i - 1)\\n            Result += LeftTrees * RightTrees\\n        return Result\\n\\nThe only problem is, it\\'s very slow, because for large n, you\\'ll need to calculate `countTrees(i)` many many times, where i is a small number.  Naturally, to speed it up, you just need to remember the result of `countTrees(i)`, so that when you need it next time, you don\\'t need to calculate.  Let\\'s do that explicitly by having a list of n+1 numbers to store the calculation result!\\n\\n    def countTrees(n, cache):\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return 1\\n    \\n        if cache[n] != -1: # -1 means we don\\'t know countTrees(n) yet.\\n            return cache[n]\\n    \\n        Result = 0\\n        for i in xrange(n):\\n            LeftTrees = countTrees(i, cache)\\n            RightTrees = countTrees(n - i - 1, cache)\\n            Result += LeftTrees * RightTrees\\n        cache[n] = Result\\n        return Result",
                "codeTag": "Python3"
            },
            {
                "id": 31671,
                "title": "a-very-simple-and-straight-ans-based-on-math-catalan-number-o-n-times-o-1-space",
                "content": "        int numTrees(int n) {\\n        //cantalan\\u6811\\n        //C(2n,n)/(n+1)\\n        long long ans =1;\\n        for(int i=n+1;i<=2*n;i++){\\n            ans = ans*i/(i-n);\\n        }\\n        return ans/(n+1);\\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "        int numTrees(int n) {\\n        //cantalan\\u6811\\n        //C(2n,n)/(n+1)\\n        long long ans =1;\\n        for(int i=n+1;i<=2*n;i++){\\n            ans = ans*i/(i-n);\\n        }\\n        return ans/(n+1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 164915,
                "title": "python-solution",
                "content": "Denote by F(n) the number of unique BSTs containing 1,...,n. Now we can pick `root.val` be to any of the n values. Say we pick `root.val = i`, then the left subtree contains 1,...,i-1, and the right subtree contains i+1,...,n. The number of possible left subtrees is then F(i-1), and the number of possible right subtrees is F(n-i). The total number of BSTs with `root.val = i` is then `F(i-1)*F(n-i)`. The total number of BSTs is then obtained by summing over i = 0,1,...,n-1 the expression `F(i-1)*F(n-i)`. A naive recursive algorithm solving the recursion relation is:\\n```\\nclass Solution:\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        res = 0\\n        for i in range(1, n+1):\\n            res += self.numTrees(i-1)*self.numTrees(n-i)\\n        return res\\n```\\nWe can convert the above algorithm to a Dynamic Programming algorithm which costs O(n^2) time and O(n) space:\\n```\\nclass Solution:\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        arr = [0]*(n+1)\\n        arr[0] = 1\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                arr[i] += arr[j-1] * arr[i-j]\\n        return arr[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0:\\n            return 1\\n        res = 0\\n        for i in range(1, n+1):\\n            res += self.numTrees(i-1)*self.numTrees(n-i)\\n        return res\\n```\n```\\nclass Solution:\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        arr = [0]*(n+1)\\n        arr[0] = 1\\n        for i in range(1, n+1):\\n            for j in range(1, i+1):\\n                arr[i] += arr[j-1] * arr[i-j]\\n        return arr[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31809,
                "title": "c-code-w-explanation",
                "content": "    class Solution {\\n    public:\\n        int numTrees(int n) {\\n            vector<int> f;\\n            f.push_back(1);\\n            for (int i = 1; i <= n; ++i) {\\n                int t = 0;\\n                for (int j = 0; j < i; ++j)\\n                    t += f[j] * f[i-j-1];\\n                f.push_back(t);\\n            }\\n            return f.back();\\n        }\\n    };\\n\\n\\nConsider f_i:\\n\\n - choose 1 as the root, we have 0 node for the left tree, i-1 for the\\n   right;\\n - choose 2 as the root, we have 1 node for the left tree, i-2 for the\\n   right;\\n - ...\\n - choose i as the root, we have i-1 nodes for the left tree, 0 for the\\n   right.\\n\\nTherefore, the recursive solution is f_i = \\\\sum_{j=0}^{i-1} f_j f_{i-j-1}",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numTrees(int n) {\\n            vector<int> f;\\n            f.push_back(1);\\n            for (int i = 1; i <= n; ++i) {\\n                int t = 0;\\n                for (int j = 0; j < i; ++j)\\n                    t += f[j] * f[i-j-1];\\n                f.push_back(t);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1565599,
                "title": "c-easy-intuitive-sol-2-approaches-recursive-dp-catalan-numbers",
                "content": "Hello Everyone, thank you for reading in advance!\\n\\n**Approach 1 (Catalan Number):**\\nWe can find the number of BST\\u2019s by thinking in recursive manner for ease:\\n\\n1. Choose 1 as root, no element present on left-subtree. N-1 elements present on the right subtree.\\n\\n2. Choose 2 as root, 1 element present on the left-subtree. N-2 elements present on the right-subtree.\\n\\n3. Similarly, Choose i as root, i-1 elements present on the left-subtree. N-i elements on the right-subtree.\\n\\nThen, Total number of BST\\u2019s ***C(N) = C(0)C(N-1) + C(1)C(N-2) +\\u2026\\u2026\\u2026+ C(i-1)C(N-i) +\\u2026\\u2026\\u2026\\u2026.+ C(N-1)C(0).***\\nwhere C(i) is the number of unique BST with i nodes.\\n\\nwhich is: ![image](https://assets.leetcode.com/users/images/9da2e01b-2240-45bc-b3b3-04ae93111c69_1636336728.9467251.png)\\n\\nThis formula is also called as Nth-Catalan Number. And finding unique BST with n nodes is one of the applications of catalan numbers!\\n\\n**Time Complexity:** O(N^2)\\n\\nBelow is the code for my approach:\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int>cat(n+1, 0);\\n        \\n        cat[0] = 1;\\n        cat[1] = 1;\\n        \\n        for(int i{2}; i<=n; ++i){\\n            \\n            for(int j{}; j<i; ++j){\\n                \\n                cat[i] += cat[j]*cat[i-j-1];\\n            }\\n        }\\n        \\n        return cat[n];\\n    }\\n};\\n```\\n\\n**Approach 2 (Recursive DP):** \\n\\n1. My intuition is that if we have numbers from `1` to `N`, then we will make each `i` as root once, and then send the nodes `(1 to i-1)` to the` left subtree` and the nodes` (i+1 to N)` to the` right subtree.`\\n\\n2.  Note that the unique subtree for nodes `(1 to X)` is same as unique subtrees for `(X+1 to 2X)`, i.e., if we have `X` number of nodes irrespective of their values then the unique BST for those nodes will be same no matter what value they holds. For eg: the nodes 3 4 5 will make same number of unique BST as the nodes with values 7 8 9 as the number of nodes is same.\\n\\n3. So in our recursive solution, for a node `i` that will be root, then `numTrees(i-1)` will give answer for our `left subtree` for nodes `(1 to i-1)` and `numTrees(N-i)` will give answer for our right subtree for nodes `(i+1 to n)` because we will have `(N-i)` number of nodes in this range and we only care about the `number of nodes`.\\n\\n4. And then the answer for our node i will be the product of answer of left subtree and answer of right subtree, i.e. , `numTrees(i-1) * numTrees(N-i)`.\\n\\n5. We will store our precomputed answers in our dp vector so that no repeated call is made for same number.\\n\\n**Time Complexity:** O(N^2)\\n\\nHere is the code for my approach mentioned above:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n, vector<int>&dp){\\n        if(n <= 1) return 1;\\n        if(dp[n] != -1) return dp[n];\\n        \\n        int res{};\\n        \\n        for(int i{1}; i<=n; ++i)\\n            res += solve(i-1, dp)*solve(n-i, dp);\\n        \\n        return dp[n] = res;\\n    }\\n    \\n    int numTrees(int n) {\\n        vector<int>dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int>cat(n+1, 0);\\n        \\n        cat[0] = 1;\\n        cat[1] = 1;\\n        \\n        for(int i{2}; i<=n; ++i){\\n            \\n            for(int j{}; j<i; ++j){\\n                \\n                cat[i] += cat[j]*cat[i-j-1];\\n            }\\n        }\\n        \\n        return cat[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n, vector<int>&dp){\\n        if(n <= 1) return 1;\\n        if(dp[n] != -1) return dp[n];\\n        \\n        int res{};\\n        \\n        for(int i{1}; i<=n; ++i)\\n            res += solve(i-1, dp)*solve(n-i, dp);\\n        \\n        return dp[n] = res;\\n    }\\n    \\n    int numTrees(int n) {\\n        vector<int>dp(n+1, -1);\\n        return solve(n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31714,
                "title": "simple-solution-with-easy-explaination",
                "content": "WE can know that by zero we can have 1 bst of null\\nby 1 we have 1 bst of 1\\nand for 2 we can arrange using two ways\\nNow idea is simple for rest numbers. for n=3 make 1 as root node so there will be 0 nodes in left subtree and 2 nodes in right subtree. we know the solution for 2 nodes that they can be used to make 2 bsts.\\nNow making 2 as the root node , there will be 1 in left subtree and 1 node in right subtree. ! node results in 1 way for making a BST. \\nNow making 3 as root node. There will be 2 nodes in left subtree and 0 nodes in right subtree. We know 2 will give 2 BST and zero will give 1 BST.\\nTotalling the result of all the 3 nodes as root will give 5. Same process can be applied for more numbers.\\n        \\n\\n\\n\\n        public int number(int n){\\n    \\tif(n==0)return 1;\\n    \\t\\tif(n==1)return 1;\\n    \\t\\t\\n    \\t\\tint result[]=new int [n+1];\\n    \\t\\tresult[0]=1;\\n    \\t\\tresult[1]=1;\\n    \\t\\tresult[2]=2;\\n    \\t\\tif(n<3){\\n    \\t\\t\\treturn result[n];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor(int i=3;i<=n;i++){\\n    \\t\\t\\tfor(int k=1;k<=i;k++){\\n  \\n    \\t\\t\\t\\tresult[i]=result[i]+result[k-1]*result[i-k];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t\\n    \\t\\treturn result[n];\\n    \\t}",
                "solutionTags": [],
                "code": "WE can know that by zero we can have 1 bst of null\\nby 1 we have 1 bst of 1\\nand for 2 we can arrange using two ways\\nNow idea is simple for rest numbers. for n=3 make 1 as root node so there will be 0 nodes in left subtree and 2 nodes in right subtree. we know the solution for 2 nodes that they can be used to make 2 bsts.\\nNow making 2 as the root node , there will be 1 in left subtree and 1 node in right subtree. ! node results in 1 way for making a BST. \\nNow making 3 as root node. There will be 2 nodes in left subtree and 0 nodes in right subtree. We know 2 will give 2 BST and zero will give 1 BST.\\nTotalling the result of all the 3 nodes as root will give 5. Same process can be applied for more numbers.\\n        \\n\\n\\n\\n        public int number(int n){\\n    \\tif(n==0)return 1;\\n    \\t\\tif(n==1)return 1;\\n    \\t\\t\\n    \\t\\tint result[]=new int [n+1];\\n    \\t\\tresult[0]=1;\\n    \\t\\tresult[1]=1;\\n    \\t\\tresult[2]=2;\\n    \\t\\tif(n<3){\\n    \\t\\t\\treturn result[n];\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor(int i=3;i<=n;i++){\\n    \\t\\t\\tfor(int k=1;k<=i;k++){\\n  \\n    \\t\\t\\t\\tresult[i]=result[i]+result[k-1]*result[i-k];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\t\\n    \\t\\treturn result[n];\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1456611,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Solution 1: Top down DP**\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return 1\\n            ans = 0\\n            for i in range(left, right + 1):\\n                ans += dfs(left, i-1) * dfs(i+1, right)\\n            return ans\\n        \\n        return dfs(1, n)\\n```\\nComplexity:\\n- Time: `O(N^3)`, where `N <= 19`\\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dfs(left, right):\\n            if left > right: return 1\\n            ans = 0\\n            for i in range(left, right + 1):\\n                ans += dfs(left, i-1) * dfs(i+1, right)\\n            return ans\\n        \\n        return dfs(1, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681756,
                "title": "c-simple-solution-with-explanation-dp-memorization-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Intuition for this solution is using Dynamic Programming with memorization. For all possible values of i, consider i as root, then [1 . . . i-1] numbers will fall in the left subtree and [i+1 . . . N] numbers will fall in the right subtree. \\n\\nThen all possible BST\\u2019s will be\\\\\\n `numTrees(N)` = summation of `(numTrees(i-1)*numTrees(N-i))` where i lies in the range [1, N].\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFollow the below steps to Implement the idea:\\n\\n- Create an array dp of size 20 (max 20 nodes as given)\\n- ` dp[0] = 1 and dp[1] = 1.` (Base condition)\\n- Run for loop from `i = 1 to i <= n` and call recursion for each i.\\n- `dp[n] += numTrees(i-1) * numTrees(n-i);` , this line fills the complete dp array.\\n- `if(dp[n]) return dp[n];` , here we simply return the dp[n] if it\\'s already filled so that we can avoid unneccesary recursion and calculations.\\n- finally, `return dp[n] ;`\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[20]{};\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        if(dp[n]) return dp[n];\\n        for(int i = 1; i <= n; i++) \\n            dp[n] += numTrees(i-1) * numTrees(n-i);\\n        return dp[n];\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.**\\n\\n![Untitled video - Made with Clipchamp.gif](https://assets.leetcode.com/users/images/78b96441-bf24-4020-891f-a1c1ad3e91cd_1687707374.8100693.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[20]{};\\n    int numTrees(int n) {\\n        if(n <= 1) return 1;\\n        if(dp[n]) return dp[n];\\n        for(int i = 1; i <= n; i++) \\n            dp[n] += numTrees(i-1) * numTrees(n-i);\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31815,
                "title": "a-0-ms-c-solution-with-my-explanation",
                "content": "set `t[0]=1`; just for easy calculation.\\n\\n`t[1]=1`, means when there is one node, return 1.\\n\\nWhen n=2, {1,2}:\\n\\nIf '1' is root, there is 0 node left to build up left branch, and 1 node left to build up right branch. Thus when n=2, '1' is root, there are `t[0] * t[1]` trees.\\n\\nIf '2' is root, there is 1 node to build left branch, and 0 node to build right branch. Thus n=2, '2' is root, there are `t[1] * t[0]` trees.\\n\\nSo when n=2, there are `t[0]*t[1] + t[1]*t[0];` trees. \\n\\nUse the 'root' to divide 1...n into two parts, then there are `t[remaining number of left] * t[remaining number of right]` trees for each 'root'.\\n\\n    int numTrees(int n) \\n    {\\n    \\tvector<int> t(n + 1, 0);\\n    \\tt[0] = t[1] = 1;\\n    \\tint i, j;\\n    \\tfor (i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tfor (j = 1; j <= i / 2; ++j)\\n    \\t\\t\\tt[i] += t[j - 1] * t[i - j];\\n    \\t\\tt[i] *= 2;\\n    \\t\\tif (i % 2)\\n    \\t\\t\\tt[i] += t[i / 2] * t[i / 2];//Plus the middle 'root' trees.\\n    \\t}\\n    \\treturn t[n];\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "set `t[0]=1`; just for easy calculation.\\n\\n`t[1]=1`, means when there is one node, return 1.\\n\\nWhen n=2, {1,2}:\\n\\nIf '1' is root, there is 0 node left to build up left branch, and 1 node left to build up right branch. Thus when n=2, '1' is root, there are `t[0] * t[1]` trees.\\n\\nIf '2' is root, there is 1 node to build left branch, and 0 node to build right branch. Thus n=2, '2' is root, there are `t[1] * t[0]` trees.\\n\\nSo when n=2, there are `t[0]*t[1] + t[1]*t[0];` trees. \\n\\nUse the 'root' to divide 1...n into two parts, then there are `t[remaining number of left] * t[remaining number of right]` trees for each 'root'.\\n\\n    int numTrees(int n) \\n    {\\n    \\tvector<int> t(n + 1, 0);\\n    \\tt[0] = t[1] = 1;\\n    \\tint i, j;\\n    \\tfor (i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tfor (j = 1; j <= i / 2; ++j)\\n    \\t\\t\\tt[i] += t[j - 1] * t[i - j];\\n    \\t\\tt[i] *= 2;\\n    \\t\\tif (i % 2)\\n    \\t\\t\\tt[i] += t[i / 2] * t[i / 2];//Plus the middle 'root' trees.\\n    \\t}\\n    \\treturn t[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1565544,
                "title": "c-easy-clean-solution-fastest-all-4-methods-detailed-explanation-comments",
                "content": "##### Method1: Recursion (TLE) [T(n) = O(3^n) and S(n) = O(n) [recursion stack]]\\nProblem is to find the no. of BSTs that are possible for given n: no. of nodes in BST. To solve this recursively, we need to build a recurrance relation [Inductive Hypothesis] and a base case.\\n`Let C(n) := no. of unique BSTs possible with n no. of nodes where n >= 0` \\nClearly, a null node and a single node, both are BSTs (only 1 unique BST for each). So, we have got our base case i.e `C(0) = C(1) = 1` or`C(n) = 1 when n <= 1`.\\nNow, Let\\'s break `n nodes of BST` into `1, i - 1, and n - i nodes`, where, 1 node is given to root, i - 1 nodes are given to left BST subtree and n - i nodes are given to right BST subtree respectively s.t overall we still have `1 + i - 1 + n - i = n nodes`. Cleary here, `1 <= i <= n` as both left and right BST subtrees can have: `atleast 0 and atmost n - 1 nodes`.\\n```\\n\\t\\t   (1)\\n\\t\\t  /   \\\\\\n\\t (i - 1)  (n - i)\\n\\t   \\ns.t total BST nodes are: 1 + i - 1 + n - i = n nodes\\nwhere (x) denotes x no. of nodes in BST and 1 <= i <= n\\n```\\nNow, we know that: `C(n) depends on C(i - 1) and C(n - i) where 1 <= i <= n`.\\nUpon experimentation, we can observe: `C(2) = C(0) * C(1) + C(1) * C(0) = 1 + 1 = 2`.\\n```\\n1                   2\\n  \\\\                /\\n\\t2            1\\ni = 1          i = 2\\n```\\nSimilarly, `C(3) = C(0) * C(2) + C(1) * C(1) + C(2) * C(0) = 2 + 1 + 2 = 5`.\\n```\\n   1                1                2                  3                 3\\n\\t\\\\                \\\\              / \\\\                /                 /\\n\\t 2                3            1   3              2                 1\\n      \\\\              /                               /                   \\\\\\n\\t   3            2                               1                     2\\n  i = 1            i = 1           i = 2         i = 3               i = 3         \\n```\\nSo, we have the recurrance relation: `C(n) := sum(C(i - 1) * C(n - i)), 1 <= i <= n`.\\n\\n**NOTE:** \\n1. Regarding the Time Complexity of above recurrance relation, please read [here](https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity) for more details.\\n2. This problem is actually the application of *[nth Catalan Number](https://en.wikipedia.org/wiki/Catalan_number)* [See Method4 Below for its implementation].\\n\\n```\\nint numTrees(int n) {\\n\\t// base case\\n\\tif (n <= 1) return 1;\\n\\tint ans = 0;\\n\\t// recursion\\n\\tfor (int i = 1; i <= n; i++)\\n\\t\\tans += numTrees(i - 1) * numTrees(n - i);\\n\\treturn ans;\\n}\\n```\\n\\n##### Method2: Recursion + Memoization (AC) [T(n) = O(n^2) and S(n) = O(n)] \\nIf you have understood the basics explained in Method1, it is obvious to see the overlapping subproblems in C(n), so, we can definitely use cache (called memoization) [:= memo in code] to solve subproblems only once in Top Down Approach. It drastically improves the Time Complexity from exponential to Polynomial (Quadratic) as now each subproblem is solved exactly once.\\n\\n```\\n// recursion + memoization\\nint numTrees(int n, vector<int> &memo) {\\n\\t// base case\\n\\tif (n <= 1) return 1;\\n\\t// if subProblem is not solved\\n\\tif (not memo[n])\\n\\t\\t// recursion\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tmemo[n] += numTrees(i - 1, memo) * numTrees(n - i, memo);\\n\\t// return solved subProblem\\n\\treturn memo[n];\\n}\\n\\n// main\\nint numTrees(int n) {\\n\\t// init memo\\n\\tvector<int> memo(20);\\n\\treturn numTrees(n, memo);\\n}\\n```\\n\\n##### Method3: DP (AC) [T(n) = O(n^2) and S(n) = O(n)]\\nIf you have understood above methods, its not difficult to convert Method2 into Bottom Up DP. A nice trick is to first initialise the DP and then, replace in Method2, `n by i and i by j and func call by DP using two for loops` and we are done!\\nWe have now removed the explicit recursion stack space: O(n) from Method2 using this Bottom Up DP solution. The time and space complexity however remains same.\\n\\n```\\nint numTrees(int n) {\\n\\t// init dp\\n\\tvector<int> dp(n + 1);\\n\\tdp[0] = dp[1] = 1;\\n\\t// fill dp\\n\\tfor(int i = 2; i <= n; i++)\\n\\t\\tfor(int j = 1;  j <= i; j++)\\n\\t\\t\\tdp[i] += dp[j - 1] * dp[i - j];\\n\\t// return ans\\n\\treturn dp[n];\\n}\\n```\\n\\n##### Method4: Nth Catalan Number using Math (AC) [T(n) = O(n) and S(n) = O(1)]\\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/58374aa2b2e2c016a5b313e2bbd59940a2e1a5f9)\\n\\n**NOTE:**\\n1. This method is not intuitive and requires Combinatorics as pre-requisite, but I am still presenting it here for your reference.\\n1. I have used `long double` instead of `long long` in the code below because `long long` would lead to `int division` (kind of `floor` of what we need in the subsequent products) and thus will result into wrong answer. So, use `long double` instead to get the right division in subsequent products and thus the right answer. Finally, since the return type of func. is `int`, so the ans is type-casted by compiler to `int`:)\\n\\n```\\nint numTrees(int n) {\\n\\tlong double ans = 1;\\n\\tfor (int k = 2; k <= n; k++)\\n\\t\\tans *= (n + k), ans /= k;\\n\\treturn ans;\\n}\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written posts on:\\n1. All C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n2. Kadane\\'s Algorithm and Follow up Questions [C++] in a cleaner way [here](https://leetcode.com/problems/maximum-subarray/discuss/1470547/C++-Easy-and-Clean-Solution-or-Fastest:-0ms-or-All-Methods-or-Follow-Ups-or-Detailed-Explanation) on leetcode.\\n\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t   (1)\\n\\t\\t  /   \\\\\\n\\t (i - 1)  (n - i)\\n\\t   \\ns.t total BST nodes are: 1 + i - 1 + n - i = n nodes\\nwhere (x) denotes x no. of nodes in BST and 1 <= i <= n\\n```\n```\\n1                   2\\n  \\\\                /\\n\\t2            1\\ni = 1          i = 2\\n```\n```\\n   1                1                2                  3                 3\\n\\t\\\\                \\\\              / \\\\                /                 /\\n\\t 2                3            1   3              2                 1\\n      \\\\              /                               /                   \\\\\\n\\t   3            2                               1                     2\\n  i = 1            i = 1           i = 2         i = 3               i = 3         \\n```\n```\\nint numTrees(int n) {\\n\\t// base case\\n\\tif (n <= 1) return 1;\\n\\tint ans = 0;\\n\\t// recursion\\n\\tfor (int i = 1; i <= n; i++)\\n\\t\\tans += numTrees(i - 1) * numTrees(n - i);\\n\\treturn ans;\\n}\\n```\n```\\n// recursion + memoization\\nint numTrees(int n, vector<int> &memo) {\\n\\t// base case\\n\\tif (n <= 1) return 1;\\n\\t// if subProblem is not solved\\n\\tif (not memo[n])\\n\\t\\t// recursion\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tmemo[n] += numTrees(i - 1, memo) * numTrees(n - i, memo);\\n\\t// return solved subProblem\\n\\treturn memo[n];\\n}\\n\\n// main\\nint numTrees(int n) {\\n\\t// init memo\\n\\tvector<int> memo(20);\\n\\treturn numTrees(n, memo);\\n}\\n```\n```\\nint numTrees(int n) {\\n\\t// init dp\\n\\tvector<int> dp(n + 1);\\n\\tdp[0] = dp[1] = 1;\\n\\t// fill dp\\n\\tfor(int i = 2; i <= n; i++)\\n\\t\\tfor(int j = 1;  j <= i; j++)\\n\\t\\t\\tdp[i] += dp[j - 1] * dp[i - j];\\n\\t// return ans\\n\\treturn dp[n];\\n}\\n```\n```\\nint numTrees(int n) {\\n\\tlong double ans = 1;\\n\\tfor (int k = 2; k <= n; k++)\\n\\t\\tans *= (n + k), ans /= k;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364615,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Dynamic Programming Approach):**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Unique Binary Search Trees.\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        // Create \\'sol\\' array of length n+1...\\n        int[] sol = new int[n+1];\\n        // The value of the first index will be 1.\\n        sol[0] = 1;\\n        // Run a loop from 1 to n+1...\\n        for(int i = 1; i <= n; i++) {\\n            // Within the above loop, run a nested loop from 0 to i...\\n            for(int j = 0; j < i; j++) {\\n                // Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1];\\n            }\\n        }\\n        // Return the value of the nth index of the array to get the solution...\\n        return sol[n];\\n    }\\n}\\n```\\n\\n# **C++ Solution (Dynamic Programming Approach):**\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        // If n <= 1, then return 1\\n        if (n <= 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n        // Create \\'sol\\' array of length n+1...\\n        vector<int> sol(n+1, 0);\\n        // The value of the first and second index will be 1.\\n        sol[0] = sol[1] = 1;\\n        // Run a loop from 2 to n...\\n        for (int i = 2; i <= n; ++i) {\\n            // within the above loop, run a nested loop from 0 to i...\\n            for (int j = 0; j < i; j++) {\\n                // Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1];\\n            }\\n        }\\n        // Return the value of the nth index of the array to get the solution...\\n        return sol[n];\\n    }\\n};\\n```\\n\\n# **Python Solution (Dynamic Programming Approach):**\\nRuntime: 17 ms, faster than 90.77% of Python online submissions for Unique Binary Search Trees.\\n```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        if n == 0 or n == 1:\\n            return 1\\n        # Create \\'sol\\' array of length n+1...\\n        sol = [0] * (n+1)\\n        # The value of the first index will be 1.\\n        sol[0] = 1\\n        # Run a loop from 1 to n+1...\\n        for i in range(1, n+1):\\n            # Within the above loop, run a nested loop from 0 to i...\\n            for j in range(i):\\n                # Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1]\\n        # Return the value of the nth index of the array to get the solution...\\n        return sol[n]\\n```\\n        \\n# **JavaScript Solution (Dynamic Programmming Approach):**\\n```\\nvar numTrees = function(n) {\\n    // Create \\'sol\\' array to store the solution...\\n    var sol = [1, 1];\\n    // Run a loop from 2 to n...\\n    for (let i = 2; i <= n; i++) {\\n        sol[i] = 0;\\n        // Within the above loop, run a nested loop from 1 to i...\\n        for (let j = 1; j <= i; j++) {\\n            // Update the i-th position of the array by adding the multiplication of the respective index...\\n            sol[i] += sol[i - j] * sol[j - 1];\\n        }\\n    }\\n    // Return the value of the nth index of the array to get the solution...\\n    return sol[n];\\n};\\n```\\n\\n# **C Language (Catalan Math Approach):**\\nRuntime: 0 ms, faster than 100.00% of C online submissions for Unique Binary Search Trees.\\n```\\nint numTrees(int n){\\n    long sol = 1;\\n    for (int i = 0; i < n; ++i) {\\n        sol = sol * 2 * (2 * i + 1) / (i + 2);\\n    }\\n    return (int) sol;\\n}\\n```\\n\\n# **Python3 Solution (Catalan Math Approach):**\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        sol = 1\\n        for i in range (0, n):\\n            sol = sol * 2 * (2 * i + 1) / (i + 2)\\n        return int(sol)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        // Create \\'sol\\' array of length n+1...\\n        int[] sol = new int[n+1];\\n        // The value of the first index will be 1.\\n        sol[0] = 1;\\n        // Run a loop from 1 to n+1...\\n        for(int i = 1; i <= n; i++) {\\n            // Within the above loop, run a nested loop from 0 to i...\\n            for(int j = 0; j < i; j++) {\\n                // Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1];\\n            }\\n        }\\n        // Return the value of the nth index of the array to get the solution...\\n        return sol[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        // If n <= 1, then return 1\\n        if (n <= 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0return 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n        // Create \\'sol\\' array of length n+1...\\n        vector<int> sol(n+1, 0);\\n        // The value of the first and second index will be 1.\\n        sol[0] = sol[1] = 1;\\n        // Run a loop from 2 to n...\\n        for (int i = 2; i <= n; ++i) {\\n            // within the above loop, run a nested loop from 0 to i...\\n            for (int j = 0; j < i; j++) {\\n                // Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1];\\n            }\\n        }\\n        // Return the value of the nth index of the array to get the solution...\\n        return sol[n];\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        if n == 0 or n == 1:\\n            return 1\\n        # Create \\'sol\\' array of length n+1...\\n        sol = [0] * (n+1)\\n        # The value of the first index will be 1.\\n        sol[0] = 1\\n        # Run a loop from 1 to n+1...\\n        for i in range(1, n+1):\\n            # Within the above loop, run a nested loop from 0 to i...\\n            for j in range(i):\\n                # Update the i-th position of the array by adding the multiplication of the respective index...\\n                sol[i] += sol[j] * sol[i-j-1]\\n        # Return the value of the nth index of the array to get the solution...\\n        return sol[n]\\n```\n```\\nvar numTrees = function(n) {\\n    // Create \\'sol\\' array to store the solution...\\n    var sol = [1, 1];\\n    // Run a loop from 2 to n...\\n    for (let i = 2; i <= n; i++) {\\n        sol[i] = 0;\\n        // Within the above loop, run a nested loop from 1 to i...\\n        for (let j = 1; j <= i; j++) {\\n            // Update the i-th position of the array by adding the multiplication of the respective index...\\n            sol[i] += sol[i - j] * sol[j - 1];\\n        }\\n    }\\n    // Return the value of the nth index of the array to get the solution...\\n    return sol[n];\\n};\\n```\n```\\nint numTrees(int n){\\n    long sol = 1;\\n    for (int i = 0; i < n; ++i) {\\n        sol = sol * 2 * (2 * i + 1) / (i + 2);\\n    }\\n    return (int) sol;\\n}\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        sol = 1\\n        for i in range (0, n):\\n            sol = sol * 2 * (2 * i + 1) / (i + 2)\\n        return int(sol)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071904,
                "title": "optimal-binary-search-tree",
                "content": "I could\\'nt find the Optimal Binary Search Tree, on leetcode. But learning from this problem made me do OBST.\\n\\nQuestion:\\nGiven a sorted array keys[0.. n-1] of search keys and an array freq[0.. n-1] of frequency counts, where freq[i] is the number of searches to keys[i]. Construct a binary search tree of all keys such that the total cost of all the searches is as small as possible.\\nLet us first define the cost of a BST. The cost of a BST node is level of that node multiplied by its frequency. Level of root is 1.\\n\\nExamples:\\n\\n```\\nInput:  keys[] = {10, 12}, freq[] = {34, 50}\\nThere can be following two possible BSTs \\n        10                       12\\n          \\\\                     / \\n           12                 10\\n          I                     II\\nFrequency of searches of 10 and 12 are 34 and 50 respectively.\\nThe cost of tree I is 34*1 + 50*2 = 134\\nThe cost of tree II is 50*1 + 34*2 = 118 \\n\\n\\nInput:  keys[] = {10, 12, 20}, freq[] = {34, 8, 50}\\nThere can be following possible BSTs\\n    10                12                 20         10              20\\n      \\\\             /    \\\\              /             \\\\            /\\n      12          10     20           12               20         10  \\n        \\\\                            /                 /           \\\\\\n         20                        10                12             12  \\n     I               II             III             IV             V\\nAmong all possible BSTs, cost of the fifth BST is minimum.  \\nCost of the fifth BST is 1*50 + 2*34 + 3*8 = 142\\n```\\n### Pattern: Dyanmic Programming Merge Intervals.\\n### Solution: \\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nclass Solution_2 {\\n    int min = Integer.MAX_VALUE;\\n    List<Element> elementList = new ArrayList<>();\\n    int[][][] dp;\\n\\n    private int binaryTree(int[] nodes, int[] freq) {\\n        dp = new int[nodes.length][nodes.length][nodes.length];\\n        for (int i = 0; i < nodes.length; i++) {\\n            elementList.add(new Element(nodes[i], freq[i]));\\n        }\\n        elementList.sort((a, b) -> a.val - b.val);\\n        return binaryTree(0, nodes.length - 1, 1);\\n    }\\n\\n    private int binaryTree(int left, int right, int level) {\\n        if (left > right) return 0;\\n        if (left == right) {\\n            return level * elementList.get(left).freq;\\n        }\\n        if (dp[left][right][level] != 0) {\\n            return dp[left][right][level];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int mid = left; mid <= right; mid++) {\\n            int leftValue = binaryTree(left, mid - 1, level + 1);\\n            int rightValue = binaryTree(mid + 1, right, level + 1);\\n            min = Math.min(min, (elementList.get(mid).freq * level) + leftValue + rightValue);\\n        }\\n        return dp[left][right][level] = min;\\n    }\\n}\\n\\nclass Element {\\n    int val;\\n    int freq;\\n\\n    public Element(int node, int i) {\\n        val = node;\\n        freq = i;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nInput:  keys[] = {10, 12}, freq[] = {34, 50}\\nThere can be following two possible BSTs \\n        10                       12\\n          \\\\                     / \\n           12                 10\\n          I                     II\\nFrequency of searches of 10 and 12 are 34 and 50 respectively.\\nThe cost of tree I is 34*1 + 50*2 = 134\\nThe cost of tree II is 50*1 + 34*2 = 118 \\n\\n\\nInput:  keys[] = {10, 12, 20}, freq[] = {34, 8, 50}\\nThere can be following possible BSTs\\n    10                12                 20         10              20\\n      \\\\             /    \\\\              /             \\\\            /\\n      12          10     20           12               20         10  \\n        \\\\                            /                 /           \\\\\\n         20                        10                12             12  \\n     I               II             III             IV             V\\nAmong all possible BSTs, cost of the fifth BST is minimum.  \\nCost of the fifth BST is 1*50 + 2*34 + 3*8 = 142\\n```\n```\\nimport java.util.ArrayList;\\nimport java.util.HashSet;\\nimport java.util.List;\\nimport java.util.Set;\\n\\nclass Solution_2 {\\n    int min = Integer.MAX_VALUE;\\n    List<Element> elementList = new ArrayList<>();\\n    int[][][] dp;\\n\\n    private int binaryTree(int[] nodes, int[] freq) {\\n        dp = new int[nodes.length][nodes.length][nodes.length];\\n        for (int i = 0; i < nodes.length; i++) {\\n            elementList.add(new Element(nodes[i], freq[i]));\\n        }\\n        elementList.sort((a, b) -> a.val - b.val);\\n        return binaryTree(0, nodes.length - 1, 1);\\n    }\\n\\n    private int binaryTree(int left, int right, int level) {\\n        if (left > right) return 0;\\n        if (left == right) {\\n            return level * elementList.get(left).freq;\\n        }\\n        if (dp[left][right][level] != 0) {\\n            return dp[left][right][level];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int mid = left; mid <= right; mid++) {\\n            int leftValue = binaryTree(left, mid - 1, level + 1);\\n            int rightValue = binaryTree(mid + 1, right, level + 1);\\n            min = Math.min(min, (elementList.get(mid).freq * level) + leftValue + rightValue);\\n        }\\n        return dp[left][right][level] = min;\\n    }\\n}\\n\\nclass Element {\\n    int val;\\n    int freq;\\n\\n    public Element(int node, int i) {\\n        val = node;\\n        freq = i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565526,
                "title": "c-simple-6-line-dp-solution-clear-explanation",
                "content": "**Explanation:**\\nWe keep a dp vector. dp[i] = number of BSTs with i nodes.\\nWe know the base cases - dp[0] = 1 and dp[1] = 1.\\nNow, for example, n = 5.\\nSo we have {1,2,3,4,5}\\nFor each node, we can use it as a root and then we have sub problems - the right and left subtrees.\\nThis is typical **dynamic programming**.\\nFor example, if we are up to node #2. We use it as a root, now it\\'s a BST so all the smaller ones are in the left and all the greater ones in the right.\\nSo we take {1} as the left subtree - look for dp[1]\\nand {3,4,5} as the right subtree - look for dp[3] (three nodes).\\nNow, we can use each combination so we multiply the values.\\n\\n`dp[i-j]` is the right subtree - `i` is the current number of nodes and `j` is the current root.\\n`dp[j-1]` is the left subtree.\\n\\n**Time Complexity:** O(n^2)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0] = 1, dp[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n            for (int j = 1; j <= i; j++)\\n                dp[i] += dp[i-j] * dp[j-1];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0] = 1, dp[1] = 1;\\n        for (int i = 2; i <= n; i++)\\n            for (int j = 1; j <= i; j++)\\n                dp[i] += dp[i-j] * dp[j-1];\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126879,
                "title": "swift-unique-binary-search-trees",
                "content": "#### Studying graph theory didn\\'t go in vain \\uD83E\\uDD78\\n\\n```swift\\nimport Foundation\\n\\nclass Solution {\\n    func numTrees(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        \\n        var arr: [Int] = .init(repeating: 0, count: n + 1)\\n        arr[0] = 1; arr[1] = 1\\n        \\n        for i in 2...n where n >= 2 {\\n            for j in 0..<i {\\n                arr[i] += arr[j] * arr[i - 1 - j]\\n            }\\n        }\\n        return arr[n]\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.numTrees(3) == 5) // good\\n    assert(s.numTrees(1) == 1) // good\\n}\\n\\ntests()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nimport Foundation\\n\\nclass Solution {\\n    func numTrees(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        \\n        var arr: [Int] = .init(repeating: 0, count: n + 1)\\n        arr[0] = 1; arr[1] = 1\\n        \\n        for i in 2...n where n >= 2 {\\n            for j in 0..<i {\\n                arr[i] += arr[j] * arr[i - 1 - j]\\n            }\\n        }\\n        return arr[n]\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.numTrees(3) == 5) // good\\n    assert(s.numTrees(1) == 1) // good\\n}\\n\\ntests()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370252,
                "title": "how-to-think-for-solution-java",
                "content": "There is some common pattern for binary tree , if we have to answer something for root , we generally ask for answer from left child and right child , then give answer for complete tree\\neg.,\\n1  finding maximum in tree \\n2 . Height of tree \\n3 .  diameter of tree \\nHere  for n =  4 , consider it like an array **{10,20,30,40}** and this array is sorted array , and we have choice to make any of these element as root . \\nlet explore what  all unique  trees are possible  \\n* if we pick **10** the all element are greater than 10 , goes its right , **{20,30,40}** goes right  and this again become sub-problem . \\n\\n\\t\\t\\t\\t\\tans =  left_count * right_count \\n\\n```\\n\\t\\t10\\n\\t\\t    \\\\  [20,30 , 40]  // now find solution for this subproblem  for size 3 \\n```\\n\\t\\t\\n* if we pick 20 as root then smaller element than 10 goes to left and all element greater than 10 goes to right \\n```\\n\\t\\t      20\\n\\t  [10] /      \\\\  [30 , 40]  // now find solution for this subproblem  size 1 on left side and 2 size on right side\\n```\\n\\nif we pick 30 as root :\\n\\n```\\n\\t\\t        30\\n\\t[10 , 20] /\\t    \\\\  [ 40]  // now find solution for this subproblem 2 size for left and 1 size for right\\n\\t\\n\\t \\n```\\n\\nif we pick 40 as root :\\n```\\n\\t\\t            40\\n\\t[10 , 20,30] /\\t    // now find solution for this subproblem 3 size for left \\n\\t\\t \\n```\\n\\nNow suppose we have answer for all subproblem then it is really going very easy to answer for n size problem . so now what we do is , find solution for smaller problem on top of that we answer bigger size problem \\n\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int dp[] =  new int[n+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(i<=2){ dp[i] =  i; continue;}\\n            for(int k=0;k<i;k++){\\n                dp[i] += ( dp[k]*dp[i-1-k]); // dp[i] =  left_count * right_count \\n            }                        \\n        }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\t10\\n\\t\\t    \\\\  [20,30 , 40]  // now find solution for this subproblem  for size 3 \\n```\n```\\n\\t\\t      20\\n\\t  [10] /      \\\\  [30 , 40]  // now find solution for this subproblem  size 1 on left side and 2 size on right side\\n```\n```\\n\\t\\t        30\\n\\t[10 , 20] /\\t    \\\\  [ 40]  // now find solution for this subproblem 2 size for left and 1 size for right\\n\\t\\n\\t \\n```\n```\\n\\t\\t            40\\n\\t[10 , 20,30] /\\t    // now find solution for this subproblem 3 size for left \\n\\t\\t \\n```\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int dp[] =  new int[n+1];\\n        dp[0] = 1;\\n        \\n        for(int i=1;i<=n;i++){\\n            if(i<=2){ dp[i] =  i; continue;}\\n            for(int k=0;k<i;k++){\\n                dp[i] += ( dp[k]*dp[i-1-k]); // dp[i] =  left_count * right_count \\n            }                        \\n        }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853183,
                "title": "python-recursion-memoization",
                "content": "Hi,\\n\\nI solved this problem by using recursion + memoization.\\nThe result is close to the DP solution.\\n\\n```\\ndef numTrees(self, n: int) -> int:\\n        return self.count_bsts(1, n, {})\\n        \\ndef count_bsts(self, min_val: int, max_val: int, memo: dict) -> int:\\n\\tif min_val >= max_val:\\n\\t\\treturn 1\\n\\n\\telif (min_val, max_val) in memo:\\n\\t\\treturn memo[(min_val, max_val)]\\n\\n\\tbsts_count = 0\\n\\tfor val in range(min_val, max_val + 1):\\n\\n\\t\\tleft_subtrees_count = self.count_bsts(min_val, val - 1, memo)\\n\\t\\tright_subtrees_count = self.count_bsts(val + 1, max_val, memo)\\n\\n\\t\\tbsts_count += left_subtrees_count * right_subtrees_count\\n\\n\\tmemo[(min_val, max_val)] = bsts_count\\n        \\n\\treturn bsts_count\\n\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndef numTrees(self, n: int) -> int:\\n        return self.count_bsts(1, n, {})\\n        \\ndef count_bsts(self, min_val: int, max_val: int, memo: dict) -> int:\\n\\tif min_val >= max_val:\\n\\t\\treturn 1\\n\\n\\telif (min_val, max_val) in memo:\\n\\t\\treturn memo[(min_val, max_val)]\\n\\n\\tbsts_count = 0\\n\\tfor val in range(min_val, max_val + 1):\\n\\n\\t\\tleft_subtrees_count = self.count_bsts(min_val, val - 1, memo)\\n\\t\\tright_subtrees_count = self.count_bsts(val + 1, max_val, memo)\\n\\n\\t\\tbsts_count += left_subtrees_count * right_subtrees_count\\n\\n\\tmemo[(min_val, max_val)] = bsts_count\\n        \\n\\treturn bsts_count\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1150728,
                "title": "javascript-recursive-memo-explanation",
                "content": "First, consider what a BST is. Given a node N, every node in the left tree is < N and every node in the right tree is > N. We don\\'t actually have to build the trees, just figure out for the given n how many trees exist.\\n\\nLet\\'s walk through manually starting with the base case of n = 1, the set of nodes is [1]\\n1.  there is only one possible BST, the root is 1 with no left or gith.\\nTotal BSTs = 1\\n\\nNow for n = 2, the set is [1, 2].\\n1. pick 1 as the root node\\n2. there is nothing < 1, so we have no left tree.\\n3. we determine the number of bsts in the right tree [2]\\n4. the right tree has single node, so we know that is just 1 tree.\\n5. Repeat, picking 2 as the root node.\\n\\nAnd finally for n = 3, [1,2,3]\\n\\n1. pick 1 as the root node, and look into the right [2,3], you\\'ll notice n == 2 which we already solved above.\\n2. When we pick 2, and look at the left and right tree, both have a single node.\\n3. when we pick 3, it\\'s basically the same as 1.\\n\\nWe can implement this as a recursive function, and we want to use a cache (memo) since we will be solving the same sub-problems multiple times.\\n\\n\\n```\\nvar numTrees = function(n) {\\n    const cache = []\\n    return numTreeMemo(n, cache)\\n}\\n\\nvar numTreeMemo = function(n, cache) {\\n    // Base case\\n    if (n == 1) return 1\\n    // If we solved for n before, return saved answer\\n    if(cache[n]) return cache[n]\\n    \\n    let totalTrees = 0;\\n    //Pick each \\'node\\' once as the root node\\n    for (let root = 1; root <= n; root ++) {\\n        let leftTrees = 1\\n        //Determine the number of unique BST on the left side of the root\\n        if (root > 1)  leftTrees = numTreeMemo(root-1, cache)\\n        let rightTrees = 1\\n        // And then on the right\\n        if (root < n) rightTrees = numTreeMemo(n - root, cache)\\n        //If left has 2 unique trees, and right has 3\\n        //that equals 2 * 3 for the total combinations\\n        totalTrees += leftTrees * rightTrees\\n    }\\n    cache[n] = totalTrees\\n    return totalTrees\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvar numTrees = function(n) {\\n    const cache = []\\n    return numTreeMemo(n, cache)\\n}\\n\\nvar numTreeMemo = function(n, cache) {\\n    // Base case\\n    if (n == 1) return 1\\n    // If we solved for n before, return saved answer\\n    if(cache[n]) return cache[n]\\n    \\n    let totalTrees = 0;\\n    //Pick each \\'node\\' once as the root node\\n    for (let root = 1; root <= n; root ++) {\\n        let leftTrees = 1\\n        //Determine the number of unique BST on the left side of the root\\n        if (root > 1)  leftTrees = numTreeMemo(root-1, cache)\\n        let rightTrees = 1\\n        // And then on the right\\n        if (root < n) rightTrees = numTreeMemo(n - root, cache)\\n        //If left has 2 unique trees, and right has 3\\n        //that equals 2 * 3 for the total combinations\\n        totalTrees += leftTrees * rightTrees\\n    }\\n    cache[n] = totalTrees\\n    return totalTrees\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331678,
                "title": "with-illutrations-explanation-dp-solution",
                "content": "Let\\'s look at the simplest example first,where n=1 and n=2 :\\n![image](https://assets.leetcode.com/users/planegoose/image_1562758074.png)\\nThen let\\'s think about how to solve the problem when n=3.\\nWhen n=3,we have three conditions : the root of BST is 1,2 or 3.\\nWhen the root is 1,it has no left child,and have a two-element right subtree,so we have res[2] possible choices if the root is 1.It make the same sense when the root is 2 or 3.\\n![image](https://assets.leetcode.com/users/planegoose/image_1562758262.png)\\nThen we can easily get the expression :\\nres[3] = res[2] + res[1]*res[1] + res[2]\\nWe can spread the conclusion to n =4,5 and more:\\n![image](https://assets.leetcode.com/users/planegoose/image_1562758515.png)\\nFinally we can get the formula (for convenience,I set res[0]=1):\\nres[n] = res[0]*res[n-1] + res[1]*res[n-2] + res[2]*res[n-3] + ... + res[n-2]*res[1] + res[n-1]*res[0]\\nThen we can use bottom-up DP to calculate out res[0..n].\\nHere is a python3 solution excelling 99% (but actually we can achieve it in any language after understanding the formula above) :\\n```\\n    def numTrees(self, n) :\\n        res = [0]*(n+1)\\n        res[0] = 1\\n        for i in range(1,n+1) :\\n            for j in range(i) :\\n                res[i] += res[j]*res[i-1-j]\\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def numTrees(self, n) :\\n        res = [0]*(n+1)\\n        res[0] = 1\\n        for i in range(1,n+1) :\\n            for j in range(i) :\\n                res[i] += res[j]*res[i-1-j]\\n        return res[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 488024,
                "title": "javascript-solution-dp-w-explanation",
                "content": "### The idea\\nA few key facts we have to understand:\\n1. The question is simply asking the sum of different combinations of BST if every number between 1 - n is used as a root node\\n2. If number `i` is the root node, then the total combinations for `i` will equal to the combination of BST to its left `[1... i-1]` times the combination of BST to its right `[i+1]...n`. \\n3. Think of BST are just combination of nodes instead of actual numbers, this means, the BST combinations for [1,2,3,4] equals to the BST combinations for [7,8,9,10] because they all have 4 elements. \\n4. When we calculate the product of left & right, we are mix and match different combinations of BST. And we don\\'t really care what are the actual numbers are, but instead, the length of the elements we are dealing with.\\n\\n``` javascript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar numTrees = function(n) {\\n    let G = new Array(n+1).fill(0);\\n    G[0] = 1;\\n    G[1] = 1;\\n    for (let i=2;i<=n;i++) {\\n        for (let j=1;j<=i;j++) {\\n            G[i]+=G[j-1] * G[i - j];\\n        }\\n    }\\n    return G[n];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar numTrees = function(n) {\\n    let G = new Array(n+1).fill(0);\\n    G[0] = 1;\\n    G[1] = 1;\\n    for (let i=2;i<=n;i++) {\\n        for (let j=1;j<=i;j++) {\\n            G[i]+=G[j-1] * G[i - j];\\n        }\\n    }\\n    return G[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703488,
                "title": "detailed-explanation-mental-leap-on-why-the-approach-actually-works",
                "content": "```\\npublic static int numTrees(int n) {\\n        /**\\n         * \\n         * Okay so Approach...... we know 2 things for sure when we have 0 nodes, how many unique BST we can make\\n         * just 1. right (it will be EMPTY BST)\\n         * Okay so now similarly when we have 1 node how many unique BST can we make .... just 1 node sitting at Root.\\n         *\\n         * Now interesting thing starts at when 2 nodes are there [1,2]\\n         * we can either put 2 as Root or 1 as root.... in both the cases we have 1 side empty.\\n         *    2          or        1\\n         *   /                      \\\\\\n         *  /                        \\\\\\n         * 1                          2\\n         *\\n         * Let\\'s check [1,2,3]\\n         * Keep 1 as root.                     keeping 2 as root.               keeping 1 as root.\\n         *\\n         *      1                   1                       2                      3        or     3\\n         *       \\\\                   \\\\                     / \\\\                    /               /\\n         *        \\\\                  3                    1   3                  1               2\\n         *        2                 /                                             \\\\             /\\n         *         \\\\               /                                               \\\\           1\\n         *          \\\\             2                                                 2\\n         *           3\\n         *\\n         *  So to get NumTrees At (N) it\\'s a combination of Number of Combination by putting [1..........N] numbers as root.\\n         *  NumTrees or G[3] = F[1, 3] + F[2, 3] + F[3,3]    where F is a function F(i=currentRoot, N=TotalNodes)\\n         *\\n         *                                        N u m T r e e s [3]\\n         *                                      /         |          \\\\\\n         *                                   F[1,3]      F[2]         F[3]\\n         *                                   /  \\\\        /  \\\\       /  \\\\\\n         *                                  /    \\\\      /    \\\\     /    \\\\\\n         *                                 G(0) G(2)  G(1)   G(1) G(2)  G(0)\\n         *  General Formula:\\n         *  F(i, n) = G(i-1) * G(n-i).\\n         */\\n        if (n <= 1) return 1;\\n        int[] G = new int[n + 1];\\n        G[0] = 1;\\n        G[1] = 1; // Base Clause.\\n\\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                G[i] += G[j - 1] * G[i - j];\\n            }\\n        }\\n        return G[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int numTrees(int n) {\\n        /**\\n         * \\n         * Okay so Approach...... we know 2 things for sure when we have 0 nodes, how many unique BST we can make\\n         * just 1. right (it will be EMPTY BST)\\n         * Okay so now similarly when we have 1 node how many unique BST can we make .... just 1 node sitting at Root.\\n         *\\n         * Now interesting thing starts at when 2 nodes are there [1,2]\\n         * we can either put 2 as Root or 1 as root.... in both the cases we have 1 side empty.\\n         *    2          or        1\\n         *   /                      \\\\\\n         *  /                        \\\\\\n         * 1                          2\\n         *\\n         * Let\\'s check [1,2,3]\\n         * Keep 1 as root.                     keeping 2 as root.               keeping 1 as root.\\n         *\\n         *      1                   1                       2                      3        or     3\\n         *       \\\\                   \\\\                     / \\\\                    /               /\\n         *        \\\\                  3                    1   3                  1               2\\n         *        2                 /                                             \\\\             /\\n         *         \\\\               /                                               \\\\           1\\n         *          \\\\             2                                                 2\\n         *           3\\n         *\\n         *  So to get NumTrees At (N) it\\'s a combination of Number of Combination by putting [1..........N] numbers as root.\\n         *  NumTrees or G[3] = F[1, 3] + F[2, 3] + F[3,3]    where F is a function F(i=currentRoot, N=TotalNodes)\\n         *\\n         *                                        N u m T r e e s [3]\\n         *                                      /         |          \\\\\\n         *                                   F[1,3]      F[2]         F[3]\\n         *                                   /  \\\\        /  \\\\       /  \\\\\\n         *                                  /    \\\\      /    \\\\     /    \\\\\\n         *                                 G(0) G(2)  G(1)   G(1) G(2)  G(0)\\n         *  General Formula:\\n         *  F(i, n) = G(i-1) * G(n-i).\\n         */\\n        if (n <= 1) return 1;\\n        int[] G = new int[n + 1];\\n        G[0] = 1;\\n        G[1] = 1; // Base Clause.\\n\\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 1; j <= i; j++) {\\n                G[i] += G[j - 1] * G[i - j];\\n            }\\n        }\\n        return G[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566035,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    public int numTrees(int n) {\\n        if(n==0 || n==1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        \\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           c+=numTrees(i-1)*numTrees(n-i);    \\n        }\\n        map.put(n,c);\\n        return map.get(n);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a079eaf4-4a88-4269-af0a-6d344411aeb1_1636354636.9797418.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    public int numTrees(int n) {\\n        if(n==0 || n==1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        \\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           c+=numTrees(i-1)*numTrees(n-i);    \\n        }\\n        map.put(n,c);\\n        return map.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232364,
                "title": "c-code-with-explanation-100-faster-easy-approach",
                "content": "class Solution {\\npublic:\\n    \\nset t[0]=1; just for easy calculation.\\n\\nt[1]=1, means when there is one node, return 1.\\n\\nWhen n=2, {1,2}:\\n\\nIf \\'1\\' is root, there is 0 node left to build up left branch, and 1 node left to build up right branch. Thus when n=2, \\'1\\' is root, there are t[0]  t[1] trees.\\n\\nIf \\'2\\' is root, there is 1 node to build left branch, and 0 node to build right branch. Thus n=2, \\'2\\' is root, there are t[1]  t[0] trees.\\n\\nSo when n=2, there are t[0]t[1] + t[1]t[0]; trees.\\n\\nUse the \\'root\\' to divide 1...n into two parts, then there are t[remaining number of left]  t[remaining number of right] trees for each \\'root\\'\\n    \\n    int numTrees(int n) {\\n        \\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0]=1; //unique bst with zero node is one\\n        dp[1]=1; //unique bst with one node is one\\n        for(int i=2;i<=n;i++){\\n            int left=0;\\n            int right=i-1;\\n            while(left<=i-1){\\n                dp[i]+= dp[left]*dp[right];\\n                left++;\\n                right--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\t//Upvote if you find it useful\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\nset t[0]=1; just for easy calculation.\\n\\nt[1]=1, means when there is one node, return 1.\\n\\nWhen n=2, {1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1185579,
                "title": "cpp-one-line-solution-iterative-catalan-number-100-fast-and-o-1-space",
                "content": "The number of distinct structural BSTs with nodes labelled 1 to n (inclusive) for a given number \\'n\\' can be calculated using the catalan number. \\n\\nBut calculating the cattlan number using iteration can lead to overflow.\\n\\nSo, I tried to minimize the number of operation as shown below:\\n![image](https://assets.leetcode.com/users/images/20b918e8-4eb2-475b-9b77-5be01d705c97_1619873793.3850749.png)\\n\\nHere i denotes the numerator calculation and j denotes the denominator calculaltion of the above equation. \\n```\\n\\tint numTrees(int n) {\\n        double prod=1.0;\\n        for(double i=2*n,j=n;i>n+1,j>1;i-=1,j-=1) prod*=(i/j);\\n        return round(prod);\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n\\tint numTrees(int n) {\\n        double prod=1.0;\\n        for(double i=2*n,j=n;i>n+1,j>1;i-=1,j-=1) prod*=(i/j);\\n        return round(prod);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475097,
                "title": "c-dp-solution-w-o-catalan-no-memoization-tabulation",
                "content": "```C++\\nclass Solution {\\npublic:\\n    /*\\n    Without using catalan number, pure DP.\\n    Let T(i, j) be the number of BSTs using number in range [i, j]. Then:\\n    T(i, j) = 1, if i >= j\\n    T(i, j) = SUM{ T(i, root-1) * T(root+1, j) }, for root = [i, j]\\n    */\\n    \\n    int numTrees(int n) {\\n        return memoization(n);\\n    }\\n    \\n    // recursive\\n    // TLE\\n    int recursive(int l, int r) {\\n        if (l >= r) return 1;\\n        \\n        int res = 0;\\n        for (int root = l; root <= r; ++root) {\\n            res += recursive(l, root-1) * recursive(root+1, r);\\n        }\\n        return res;\\n    }\\n    \\n    // memoization\\n    int memoization(int n) {\\n        vector<vector<int>> mem(n+1, vector<int>(n+1, -1));\\n        return solve(mem, 1, n);\\n    }\\n    \\n    int solve(vector<vector<int>>& mem, int l, int r) {\\n        if (l >= r) return 1;\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = 0;\\n        for(int root = l; root <= r; ++root) {\\n            mem[l][r] += solve(mem, l, root-1) * solve(mem, root+1, r);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    int tabulation(int n) {\\n        // tab[i][j] = 1, if i >= j\\n        vector<vector<int>> tab(n+2, vector<int>(n+2, 1)); \\n        // For \"tab[l][r] += tab[l][root-1] * tab[root+1][r]\", the minimum\\n        // value of index is 0 and the maximum value of index is n+1. Thus,\\n        // the dimension of the dp table is n+2 x n+2.\\n        \\n        for(int l = n; l >= 1; --l) {\\n            for(int r = l + 1; r <= n; ++r) {\\n                tab[l][r] = 0;\\n                for(int root = l; root <= r; ++root) {\\n                    tab[l][r] += tab[l][root-1] * tab[root+1][r];\\n                }\\n            }\\n        }\\n        \\n        return tab[1][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    /*\\n    Without using catalan number, pure DP.\\n    Let T(i, j) be the number of BSTs using number in range [i, j]. Then:\\n    T(i, j) = 1, if i >= j\\n    T(i, j) = SUM{ T(i, root-1) * T(root+1, j) }, for root = [i, j]\\n    */\\n    \\n    int numTrees(int n) {\\n        return memoization(n);\\n    }\\n    \\n    // recursive\\n    // TLE\\n    int recursive(int l, int r) {\\n        if (l >= r) return 1;\\n        \\n        int res = 0;\\n        for (int root = l; root <= r; ++root) {\\n            res += recursive(l, root-1) * recursive(root+1, r);\\n        }\\n        return res;\\n    }\\n    \\n    // memoization\\n    int memoization(int n) {\\n        vector<vector<int>> mem(n+1, vector<int>(n+1, -1));\\n        return solve(mem, 1, n);\\n    }\\n    \\n    int solve(vector<vector<int>>& mem, int l, int r) {\\n        if (l >= r) return 1;\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = 0;\\n        for(int root = l; root <= r; ++root) {\\n            mem[l][r] += solve(mem, l, root-1) * solve(mem, root+1, r);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    int tabulation(int n) {\\n        // tab[i][j] = 1, if i >= j\\n        vector<vector<int>> tab(n+2, vector<int>(n+2, 1)); \\n        // For \"tab[l][r] += tab[l][root-1] * tab[root+1][r]\", the minimum\\n        // value of index is 0 and the maximum value of index is n+1. Thus,\\n        // the dimension of the dp table is n+2 x n+2.\\n        \\n        for(int l = n; l >= 1; --l) {\\n            for(int r = l + 1; r <= n; ++r) {\\n                tab[l][r] = 0;\\n                for(int root = l; root <= r; ++root) {\\n                    tab[l][r] += tab[l][root-1] * tab[root+1][r];\\n                }\\n            }\\n        }\\n        \\n        return tab[1][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276140,
                "title": "javascript-simplest-just-math-no-loops-faster-than-97",
                "content": "I\\'ve seen a lot of solutions that are very programmatic using for loops and such to do node traversal. But node combinations can be calculated with a simple Catalan number factorial equation: 2n!/(n+1)!n!\\n\\n```\\nvar numTrees = function(n) {\\n    return factorial( 2 * n ) / ( factorial( n + 1 ) * factorial( n ) );\\n};\\n\\nfunction factorial( num ){\\n    if( num <= 0 )\\n        return 1;\\n    else\\n        return num * factorial( num - 1 );\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numTrees = function(n) {\\n    return factorial( 2 * n ) / ( factorial( n + 1 ) * factorial( n ) );\\n};\\n\\nfunction factorial( num ){\\n    if( num <= 0 )\\n        return 1;\\n    else\\n        return num * factorial( num - 1 );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31782,
                "title": "easy-to-understand-top-down-dp-solution",
                "content": "For a valid BST, there must be a node that is the root. The root can be any number between 1 and n. What if the root is k where k is in between 1 and n? It becomes obvious that 1 to k-1 should be k's left children and k+1 to n should be k's right children. Thus, a recursive formula is formulated as follows:\\n\\n    number of BSTs with k being the root \\n    = count of BSTs of k-1 consecutive numbers * count of BSTs of n-k consecutive numbers\\n\\nAnd since we have a total of n choices for k, total number of BSTs is thus a sum of all n choices for k.\\n\\nCode in Java:\\n\\n    public int numTrees(int n) {\\n        return numTrees(n, new int[n]);\\n    }\\n    \\n    private int numTrees(int n, int[] arr) {\\n        if(n<=1) return 1;\\n        if(arr[n-1] > 0) return arr[n-1];\\n        \\n        int num = 0;\\n        for(int i=1; i<=n; i++) \\n            num += numTrees(i-1, arr) * numTrees(n-i, arr);\\n\\n        arr[n-1] = num; // store for reuse\\n        return num;\\n    }",
                "solutionTags": [],
                "code": "For a valid BST, there must be a node that is the root. The root can be any number between 1 and n. What if the root is k where k is in between 1 and n? It becomes obvious that 1 to k-1 should be k's left children and k+1 to n should be k's right children. Thus, a recursive formula is formulated as follows:\\n\\n    number of BSTs with k being the root \\n    = count of BSTs of k-1 consecutive numbers * count of BSTs of n-k consecutive numbers\\n\\nAnd since we have a total of n choices for k, total number of BSTs is thus a sum of all n choices for k.\\n\\nCode in Java:\\n\\n    public int numTrees(int n) {\\n        return numTrees(n, new int[n]);\\n    }\\n    \\n    private int numTrees(int n, int[] arr) {\\n        if(n<=1) return 1;\\n        if(arr[n-1] > 0) return arr[n-1];\\n        \\n        int num = 0;\\n        for(int i=1; i<=n; i++) \\n            num += numTrees(i-1, arr) * numTrees(n-i, arr);\\n\\n        arr[n-1] = num; // store for reuse\\n        return num;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31802,
                "title": "9-line-clean-java-dp-solution",
                "content": "    public int numTrees(int n) {\\n    \\t\\tif (n < 2) return n;\\n    \\t\\tint[] dp = new int[n + 1];\\n    \\t\\tdp[0] = 1; dp[1] = 1;\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tint sum = 0;\\n    \\t\\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t\\t\\tsum += dp[j] * dp[i - j - 1];\\n    \\t\\t\\tdp[i] = sum;\\n    \\t\\t}\\n    \\t\\treturn dp[n];\\n    \\t}",
                "solutionTags": [],
                "code": "    public int numTrees(int n) {\\n    \\t\\tif (n < 2) return n;\\n    \\t\\tint[] dp = new int[n + 1];\\n    \\t\\tdp[0] = 1; dp[1] = 1;\\n    \\t\\tfor (int i = 2; i <= n; i++) {\\n    \\t\\t\\tint sum = 0;\\n    \\t\\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t\\t\\tsum += dp[j] * dp[i - j - 1];\\n    \\t\\t\\tdp[i] = sum;\\n    \\t\\t}\\n    \\t\\treturn dp[n];\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1926210,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func numTrees(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        \\n        var map: [Int] = [1, 1]\\n        \\n        for i in 2...n {\\n            var tmp = 0\\n            \\n            for j in 0..<i {\\n                tmp += map[j] * map[i - j - 1]\\n            }\\n            map.append(tmp)\\n        }\\n        \\n        return map[n]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numTrees(_ n: Int) -> Int {\\n        guard n > 1 else { return 1 }\\n        \\n        var map: [Int] = [1, 1]\\n        \\n        for i in 2...n {\\n            var tmp = 0\\n            \\n            for j in 0..<i {\\n                tmp += map[j] * map[i - j - 1]\\n            }\\n            map.append(tmp)\\n        }\\n        \\n        return map[n]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083012,
                "title": "c-easy-short-simple-o-n-hindi-comments-dynamic-programming",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int numTrees(int n) \\n    {\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2 ; i<n+1 ; i++)\\n        {\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left<=i-1)\\n            {\\n                dp[i] += dp[left] * dp[right];\\n                left++;\\n                right--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n    manlo koi element nii h {} to 1 way hoga bnane ka\\n    ek element hoga {10} to v 1 way hoga\\n    2 elements k liye {10,20} 2 ways h\\n    3 elements k liye { 10,20,30 } aise bnega :\\n    \\n            10                   Left me ek v element ni h mtlb 0 element bnane ka 1 way\\n           / \\\\              ===> Ab wo {20,30} bnane ka 2 tareeka hoskta h kyuki 2 element h\\n         {}  {20,30}             Mtlb  (1 * 2) ways hoga\\n         \\n            20\\n           / \\\\              ===> 1-1 element h dono side mtlb 1*1 way h\\n        {10}  {30}\\n        \\n            30\\n           / \\\\              ===> left me 2 element mtlb 2 ways ar right me 0 element mtlb 1 way\\n     {10,20}   {}                Mtlb 2*1 ways\\n     \\n                        TOTAL => 1*2 + 1*1 + 2*1 = 5 ways\\n                    \\n                    Hmlg ye notice krenge ki left =0 se start hora h dp me ar right n-1\\n                    ar phr left har bar 1 badhra h ar right har bar 1 ghatra h to isiko hmlog\\n                    use krke dp table construct krlete h \\nSMJH GYE NA BRO !!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int numTrees(int n) \\n    {\\n        vector<int> dp(n+1, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for(int i=2 ; i<n+1 ; i++)\\n        {\\n            int left = 0;\\n            int right = i-1;\\n            \\n            while(left<=i-1)\\n            {\\n                dp[i] += dp[left] * dp[right];\\n                left++;\\n                right--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983454,
                "title": "visualize-the-intuition-step-by-step-with-added-diagrams-efficient-clean-c-solution",
                "content": "Let\\'s visualize and find out the number of structurally unique BST\\'s for some of the smallest valid values of \\'n\\', i.e. when n = 1, 2, 3, 4.\\n\\n![image](https://assets.leetcode.com/users/images/08ad0984-a2c1-4be2-ae4f-7aa47fb80a5a_1608737376.0809412.png)\\n\\n![image](https://assets.leetcode.com/users/images/76cffad1-b0bf-428d-b365-d0e68a62ca21_1608737451.4126863.png)\\n\\n![image](https://assets.leetcode.com/users/images/d8e31cba-ddc0-4e49-a7ff-98cada26e688_1608737469.9255254.png)\\n\\nIf n = 4, we can calculate the result, if we know the number of structurally unique BST\\'s possible when n = 3, 2 and 1. \\n\\n**N.B.:** Why are we multiplying the possible structurally unique BST\\'s we get from the root node\\'s left and right subtree ? As because we need to consider all the structurally unique BST combinations which we can get via rearranging the nodes in the left and right subtree of the root node.\\n\\nSimilarly, when **n = 5**, the total number of structurally unique BST\\'s would be: \\n```\\ndp[5] = dp[4] + (dp[1] * dp[3]) + (dp[2] * dp[2]) + (dp[3] * dp[1]) + dp[4]\\n\\t\\t = 14 + (1 * 5) + (2 * 2) + (5 * 1) + 14\\n         = 42\\n```\\n\\nIf n = 5, we can calculate the result, if we know the number of structurally unique BST\\'s possible when n = 4, 3, 2 and 1.\\nThus, we can see the presence of overlapping sub-problems, and in order to avoid the repetitive computation of the same set of sub-problems we would store the result of a computed sub-problem (here we are using an 1D array \\'dp\\'), and access it in future as and when needed. \\n\\nNow, a bit careful observation, and we can spot a pattern like this:\\n```\\n(dp[0] * dp[n - 1]) +\\n(dp[1] * dp[n - 2]) +\\n(dp[2] * dp[n - 3]) +\\n.... + \\n(dp[n - 1] * dp[0]).\\n```\\n\\nAs evident from above that, if dp[0] is 0, it will make `(dp[0] * dp[n - 1])` and `(dp[n - 1] * dp[0])` result to 0. Hence, we initialize dp[0] as 1.\\n\\nWe compute the result sequentially, (i.e. when i = 1, 2, 3, ..., n ) according to pattern described as follows:\\n```\\nfor (int i = 1; i < n + 1; ++i) {\\n\\tfor (int j = 0; j < i; ++j) {\\n\\t\\tdp[i] += dp[j] * dp[i - j - 1];\\n\\t}\\n}\\n```\\n\\nWoohoo ! That\\'s all.\\n\\n**Implementation in C++:** \\n\\n**Bottom-Up Approach:**\\n```\\nclass Solution {\\npublic:\\n    int dp[20];  // 1 <= n <= 19\\n    \\n    int numTrees(int n) {\\n        \\n        fill(dp, dp + 20, 0);\\n        \\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < n + 1; ++i) {\\n            \\n            for (int j = 0; j < i; ++j) {\\n                \\n                dp[i] += dp[j] * dp[i - j - 1];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Top-Down Approach:**\\n```\\nclass Solution {\\npublic:\\n    int dp[20];   // 1 <= n <= 19\\n    \\n    int numTreesUtil(int n) {\\n        \\n        if (n < 1)\\n            return 1;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < n; ++i)\\n            res += numTreesUtil(i) * numTreesUtil(n - i - 1);\\n        \\n        return dp[n] = res;\\n    }\\n    \\n    int numTrees(int n) {\\n        fill(dp, dp + 20, -1);\\n        return numTreesUtil(n);\\n    }\\n};\\n```\\n\\n*Cheers !*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[5] = dp[4] + (dp[1] * dp[3]) + (dp[2] * dp[2]) + (dp[3] * dp[1]) + dp[4]\\n\\t\\t = 14 + (1 * 5) + (2 * 2) + (5 * 1) + 14\\n         = 42\\n```\n```\\n(dp[0] * dp[n - 1]) +\\n(dp[1] * dp[n - 2]) +\\n(dp[2] * dp[n - 3]) +\\n.... + \\n(dp[n - 1] * dp[0]).\\n```\n```\\nfor (int i = 1; i < n + 1; ++i) {\\n\\tfor (int j = 0; j < i; ++j) {\\n\\t\\tdp[i] += dp[j] * dp[i - j - 1];\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[20];  // 1 <= n <= 19\\n    \\n    int numTrees(int n) {\\n        \\n        fill(dp, dp + 20, 0);\\n        \\n        dp[0] = 1;\\n        \\n        for (int i = 1; i < n + 1; ++i) {\\n            \\n            for (int j = 0; j < i; ++j) {\\n                \\n                dp[i] += dp[j] * dp[i - j - 1];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[20];   // 1 <= n <= 19\\n    \\n    int numTreesUtil(int n) {\\n        \\n        if (n < 1)\\n            return 1;\\n        \\n        if (dp[n] != -1)\\n            return dp[n];\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < n; ++i)\\n            res += numTreesUtil(i) * numTreesUtil(n - i - 1);\\n        \\n        return dp[n] = res;\\n    }\\n    \\n    int numTrees(int n) {\\n        fill(dp, dp + 20, -1);\\n        return numTreesUtil(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515632,
                "title": "easy-understand-dp-solution-with-dictionary-beat-90-time-and-100-space",
                "content": "Unlike most people use list as cache, I use dictionary here. The performance for add and get will be exactly same. It is only good for when you want to print the DP result.\\n\\nSo DP dictionary has key, value pair. The key represent the number of left side children or the number of right side children and the value represnt the number of possible subtree. The answer is sum of each root\\'s posibilities of substree\\n\\nFor example:\\n\\nn = 1, the root is 1\\nthere is 0 left childen or 0 right children, root is the only node\\ndp[0] = 1 represnt there is 1 possible substree for the root has 0 left children or 0 right children. Here 1 possible subtree is node(None)\\nso when n = 1, ans is dp[0]xdp[0] = 1\\n```\\n\\t1\\n```\\n\\nn = 2, the root is either 1 or 2\\nwhen root is 1 there is 0 left children and 1 right children\\nwhen root is 2 there is 1 left children and 0 right children\\ndp[1]=1 represent there is 1 possible substree for the root has 1 left children or 1 right children. Here the 1 possible substree is left child node(1) when 2 is the root and right child node(2) when 1 is the root.\\n\\nso when n =2, the ans is dp[1]xdp[0]+dp[0]xdp[1] = 2\\n```\\n\\t   2                   1 \\n\\t  /          or          \\\\\\n\\t 1                        2\\n```\\n\\nn = 3, the root is 1,2 or 3\\nwhen root is 1 there is 0 left children and 2 right children\\nwhen root is 2 there is 1 left children and 1 right children\\nwhen root is 3 there is 2 left children and 0 right children\\ndp[2] = 2 represent there is 2 possible substree for the root has 2 left children or 2 right children. \\nand based on the above pattern we know that when root has 1 left children or 1 right children, here the 2 possible substree is left children node(1or 2) when root is 3 or right children node (2,3) when root is 1.\\nwhen n = 3, the ans is dp[0]xdp[2] + dp[2]xdp[0] + dp[2]xdp[0] + dp[1]xdp[1] + dp[0]xdp[1]=5\\n```\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\\n``` python\\ndef numTrees(self, n: int) -> int:\\n        dp = {0:1, 1:1, 2:2}\\n        if n < 3: return dp[n]\\n        for i in range(3, n+1):\\n            num = 0\\n            for j in range(i):\\n                num += dp[j]*dp[i-j-1]\\n            dp[i] = num\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t1\\n```\n```\\n\\t   2                   1 \\n\\t  /          or          \\\\\\n\\t 1                        2\\n```\n```\\n   1         3     3      2      1\\n    \\\\       /     /      / \\\\      \\\\\\n     3     2     1      1   3      2\\n    /     /       \\\\                 \\\\\\n   2     1         2                 3\\n```\n``` python\\ndef numTrees(self, n: int) -> int:\\n        dp = {0:1, 1:1, 2:2}\\n        if n < 3: return dp[n]\\n        for i in range(3, n+1):\\n            num = 0\\n            for j in range(i):\\n                num += dp[j]*dp[i-j-1]\\n            dp[i] = num\\n        return dp[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 132609,
                "title": "java-python-dp-on-tree",
                "content": "The problem is to get the number of unique structurally BST that stores `1...n`.\\n\\n* If `n = 1`, there is only one BST.\\n* If `n > 1`, each `r` for `1 <= r <= n` can be root. Then the problem is **divided** into two subproblems \\n\\t* How many structurally unique BST\\'s that store values `1 ... r-1`? (subproblem overlap)\\n\\t* How many structurally unique BST\\'s that store values `r+1 ... n`?\\n\\tThe answer is the same as `How many structurally unique BST\\'s that store values 1 ... n-r` (subproblem overlap) because values in tree don\\'t matter.\\n\\n```\\nIf we define\\nresult[i] as number of unique structurally BST that stores 1...i\\n\\nthen,\\nresult[i] = sum(result[r-1]* result[i-r]) for `1 <= r <= n`\\n\\nbase case result[0] = 1 which represents an empty tree\\n```\\n\\nWe can implement the idea above by Bottom-up Dp as below :\\n```\\n    public int numTrees(int n) {\\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        for (int i = 1; i <= n; i++) {          \\n            for (int r = 1; r <= i; r++) {\\n                result[i] += result[r - 1] * result[i - r];\\n            }\\n        }\\n        return result[n];\\n    }\\n```\\nWe can also apply Recursion and Memorization technique :\\n```\\n    public int numTrees(int n) {\\n        // Memorization.\\n        int[] memo = new int[n + 1];        \\n        Arrays.fill(memo, -1);\\n        // Base case.\\n        memo[0] = 1;\\n        memo[1] = 1;\\n        \\n        return numTrees(n, memo);\\n    }\\n    \\n    private int numTrees(int n, int[] memo) {\\n        if (memo[n] != -1)\\n            return memo[n];\\n\\n        // Recursive case.\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            int leftRes = numTrees(n - i - 1, memo);\\n            memo[n - i - 1] = leftRes;\\n            int rightRes = numTrees(i, memo);\\n            memo[i] = rightRes;\\n            sum += leftRes * rightRes;\\n        }\\n        return sum;\\n    }\\n```\\n**Python**\\n```\\n    def numTrees(self, n):\\n        if n == 1:\\n            return 1\\n        state = [0] * (n+1)  # Number of structurally unique BST\\'s that store values 1..n\\n        \\n        state[0] = 1\\n        for i in range(1, n + 1):  \\n            for r in range(1, i + 1):  # Root candidates [1, i].\\n                state[i] += state[r - 1] * state[i - r]\\n                \\n        return state[n]\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nIf we define\\nresult[i] as number of unique structurally BST that stores 1...i\\n\\nthen,\\nresult[i] = sum(result[r-1]* result[i-r]) for `1 <= r <= n`\\n\\nbase case result[0] = 1 which represents an empty tree\\n```\n```\\n    public int numTrees(int n) {\\n        int[] result = new int[n + 1];\\n        result[0] = 1;\\n        for (int i = 1; i <= n; i++) {          \\n            for (int r = 1; r <= i; r++) {\\n                result[i] += result[r - 1] * result[i - r];\\n            }\\n        }\\n        return result[n];\\n    }\\n```\n```\\n    public int numTrees(int n) {\\n        // Memorization.\\n        int[] memo = new int[n + 1];        \\n        Arrays.fill(memo, -1);\\n        // Base case.\\n        memo[0] = 1;\\n        memo[1] = 1;\\n        \\n        return numTrees(n, memo);\\n    }\\n    \\n    private int numTrees(int n, int[] memo) {\\n        if (memo[n] != -1)\\n            return memo[n];\\n\\n        // Recursive case.\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            int leftRes = numTrees(n - i - 1, memo);\\n            memo[n - i - 1] = leftRes;\\n            int rightRes = numTrees(i, memo);\\n            memo[i] = rightRes;\\n            sum += leftRes * rightRes;\\n        }\\n        return sum;\\n    }\\n```\n```\\n    def numTrees(self, n):\\n        if n == 1:\\n            return 1\\n        state = [0] * (n+1)  # Number of structurally unique BST\\'s that store values 1..n\\n        \\n        state[0] = 1\\n        for i in range(1, n + 1):  \\n            for r in range(1, i + 1):  # Root candidates [1, i].\\n                state[i] += state[r - 1] * state[i - r]\\n                \\n        return state[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3658717,
                "title": "easy-c-code-for-beginners-0ms",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Idea behind this problem :\\n\\nWe should iterate every possible node between 1 and n as a root node. Calculate the number of possible combinations for each root node by calculating the number of possible combinations of left subtree and right subtree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet us suppose we take n=5\\nwe should iterate every root from 1 to 5 as a root node.\\nIf the root node is 3 we can have 1 and 2 in left subtree, 4 and 5 in right subtree. \\nThe number of possible combinations of left subtree = 2 \\nThe number of possible combinations of right subtree = 2\\n\\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/9d80b89c-d77a-4f7e-8a10-5b67e4168a24_1687207458.5306914.jpeg)\\n\\nThe number of possible ways to build a binary tree with root node 3 = (The number of possible ways to build left binary subtree)*(The number of possible ways to build right binary subtree) = 4.\\n\\nTherefore the total number of possible binary search trees with value of n = The sum of the total number of possible binary search trees with every node as root node.\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                sum+=dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Hope this helps you.**\\n**Thank you : )**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sum=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                sum+=dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851000,
                "title": "easy-c-dp-solution-faster-then-100",
                "content": "Recursive \\n```\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        \\n        int sum = 0;\\n        \\n        for(int i=1;i<=n;i++) {\\n            \\n            sum+=(numTrees(i-1) * numTrees(n-i));\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```\\n\\ndp : memoization\\n```\\nclass Solution {\\npublic:\\n\\n    int makeTree(vector<int>& dp,int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        \\n        int sum = 0;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1;i<=n;i++) {\\n            \\n            sum+=(makeTree(dp, i-1) * makeTree(dp, n-i));\\n        }\\n        dp[n] = sum;\\n        return dp[n];\\n    }\\n    int numTrees(int n) {\\n        vector<int> dp(20,-1);\\n\\n        dp[n] = makeTree(dp, n);\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        \\n        int sum = 0;\\n        \\n        for(int i=1;i<=n;i++) {\\n            \\n            sum+=(numTrees(i-1) * numTrees(n-i));\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int makeTree(vector<int>& dp,int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        \\n        int sum = 0;\\n        if(dp[n]!=-1) return dp[n];\\n        \\n        for(int i=1;i<=n;i++) {\\n            \\n            sum+=(makeTree(dp, i-1) * makeTree(dp, n-i));\\n        }\\n        dp[n] = sum;\\n        return dp[n];\\n    }\\n    int numTrees(int n) {\\n        vector<int> dp(20,-1);\\n\\n        dp[n] = makeTree(dp, n);\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769437,
                "title": "o-n-time-o-1-space-solution-catalan-numbers-video-solution",
                "content": "This problem can be solved using Catalan Numbers..\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iqv-qo_6xvE\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "This problem can be solved using Catalan Numbers..\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/iqv-qo_6xvE\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 674968,
                "title": "very-intuitive-recursive-solution",
                "content": "We are supposed to find out the number of unique binary trees from the sequence 1....n \\nThis means the number of nodes is n\\n1. Lets us start by saying that we will have 0 left nodes. That means right nodes will be  n - 1. We are subtracting 1 from n because out of the n nodes there will be a root too. Hence, n - 1 right nodes.\\n2. Similarly if we have 1 left node that means right nodes will be n - 1 - 1. One 1 is being subracted from n because of the root node and one 1 is being subtracted because of 1 left node.\\n3. We will have to do this for 0 left nodes to n -1 left nodes. Read ( range(0,n) in python)\\n4. Now since we know the number of nodes in left and right subtrees, we can recursively call the function on these.\\n5. Our base case if n == 0, which is 1 because if n = 0, only null/empty tree would be present.\\n\\n**Basic/Naive Algorithm**\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        numSubtrees = 0\\n        for leftSubtreeNodeCount in range(n):\\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\\n            leftSubtrees = self.numTrees(leftSubtreeNodeCount)\\n            rightSubtrees = self.numTrees(rightSubtreeNodeCount)\\n            numSubtrees += leftSubtrees * rightSubtrees\\n        return numSubtrees\\n```\\n\\n**With memoization to prevent calculating for same n multiple times. Similar to Fibonacci**\\n```\\nclass Solution:\\n    def numTrees(self, n: int, cache={}) -> int:\\n        if n == 0:\\n            return 1\\n        if n in cache:\\n            return cache[n]\\n        numSubtrees = 0\\n        for leftSubtreeNodeCount in range(n):\\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\\n            leftSubtrees = self.numTrees(leftSubtreeNodeCount, cache)\\n            rightSubtrees = self.numTrees(rightSubtreeNodeCount, cache)\\n            numSubtrees += leftSubtrees * rightSubtrees\\n        cache[n] = numSubtrees\\n        return numSubtrees\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        numSubtrees = 0\\n        for leftSubtreeNodeCount in range(n):\\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\\n            leftSubtrees = self.numTrees(leftSubtreeNodeCount)\\n            rightSubtrees = self.numTrees(rightSubtreeNodeCount)\\n            numSubtrees += leftSubtrees * rightSubtrees\\n        return numSubtrees\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int, cache={}) -> int:\\n        if n == 0:\\n            return 1\\n        if n in cache:\\n            return cache[n]\\n        numSubtrees = 0\\n        for leftSubtreeNodeCount in range(n):\\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\\n            leftSubtrees = self.numTrees(leftSubtreeNodeCount, cache)\\n            rightSubtrees = self.numTrees(rightSubtreeNodeCount, cache)\\n            numSubtrees += leftSubtrees * rightSubtrees\\n        cache[n] = numSubtrees\\n        return numSubtrees\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591544,
                "title": "faster-than-100-0ms-2-line-of-logic-sinlge-forloop-java-without-dp",
                "content": "**Logic**\\n\\n*i have just used the combination formula, C(n, k) = ( n ! ) / [ (n-k)! * k! ] = **[** n*(n-1)(n-2)(n-3)....1 **]** **/** **[** (n-k) ! * k ! **]**\\n\\t\\t\\t = **[**  n * (n-1)(n-2)...(n-k)! **]** **/** (n-k)! * k !\\n\\t\\t\\t \\nNow (n-k)! factor get cancelled from Numerator and Denominator , and we got\\nC(n, k) = **[** n(n-1)...( n-(k+1) ) **]** **/** **[** k*(k-1)*(k-2)....1 **]**.\\n          = **[** (n-1)/1 **]** * **[** ( n-2)/2 **]** * **[** (n-3) / 3 **]**.....**[** (n- (k+1) / k **]**\\n\\nAnd finally by usnig single for loop startng from 0 upto k times\\njust multiply and divide.\\n\\n\\n\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        long ans = 1;\\n\\t\\tint k = n;\\n        n = 2*n;\\n        \\n        for(int i = 0  ; i < k ;i++){\\n            ans *=  (n-i);\\n            ans /=  (i+1);\\n        }\\n        return (int)(ans/(k+1));       \\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        long ans = 1;\\n\\t\\tint k = n;\\n        n = 2*n;\\n        \\n        for(int i = 0  ; i < k ;i++){\\n            ans *=  (n-i);\\n            ans /=  (i+1);\\n        }\\n        return (int)(ans/(k+1));       \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977541,
                "title": "solving-it-by-pattern",
                "content": "**Case 1 :**\\n\\nWe will start of solving this problem with base cases. If it\\'s just 1 node, it\\'s obvious that there will be only possibility\\n\\n**Case 2 :**\\n\\nFor 2 nodes (n = 2), there will be two possibilities \\n1. ```1```node as root and ```2```as right child\\n2. ```2```node as root and ```1```as left child\\n\\n\\nFrom the above, it can also be observed that irrespective of the node values, two nodes with ascending values will always have only 2 combinations.\\n\\n**Case 3 :**\\n\\nFor finding the number of combinations for n = 3, the possible root values are ```1, 2, 3``` \\n1. If we have ```1``` as root, ```2, 3```will be on the right which boils down to ```case 2``` which is 2 possibilities\\n2. If we have ```2```as root, ```1```will be on the left and ```3```will be on the right which boils down to ```case 1``` which is 1 possibility\\n3. If we have ```3```as root, ```2, 1```will be on the left which again boils down to ```case 2```which is 2 possibility\\n\\nIf we add all the combinations, it\\'s 2 + 1 + 2 = 5 combinations. Hence, for n = 3, the result is 5\\n\\n**Conclusion**\\n\\nIf u observe carefully, we are getting a pattern here. For any value of n, there will be \\'n\\' possible values of root and for each root node, there will be certain number of left and right subtrees totalling all of which gives the total number of combinations. For example, if we take n = 4, the possible root values are 1 to 4. For each root node value from 1 to 4, \\n1. the number of left nodes can be calculated by subracting the current root node value by 1\\n2. the number of right nodes can be calculated by subracting the total number of nodes by the current value\\n\\nThat is for dp[4], it\\'s the sum of\\n1. dp[0] * dp[3] => for root node \\'1\\' [0 left child, 3 right child]\\n2. dp[1] * dp[2] => for root node \\'2\\' [1 left child, 2 right child]\\n3. dp[2] * dp[1] => for root node \\'3\\' [2 left child, 1 right child]\\n4. dp[3] * dp[0] => for root node \\'4\\' [3 left child, 0 right child]\\n\\nSince, it\\'s obvious that there is a lot of re-computation, we can store the result of each computation against that certain number of nodes and reuse it.\\n\\n**Code :**\\n\\n```\\npublic int numTrees(int n) {\\n\\t\\t// array to cache the number of combinations against node count\\n        int[] dp = new int[n + 1];\\n\\t\\t// base case\\n\\t\\tdp[0] = dp[1] = 1;\\n\\t\\t// traversing from 1 to n even though we need the result of n because for finding the nth node, we need the sub nodes value.\\n        for (int node = 2; node <= n; ++node) {\\n\\t\\t\\t// for each root node, calculating the left and right node count and finding the number of possible combinations from the cached array\\n            for (int root = 1; root <= node; ++root) {\\n                int left = root - 1, right = node - root;\\n                dp[node] += dp[left] * dp[right];\\n            }\\n        }\\n\\t\\t// returning the last count since it gives the nth count\\n        return dp[n];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```1```\n```2```\n```2```\n```1```\n```1, 2, 3```\n```1```\n```2, 3```\n```case 2```\n```2```\n```1```\n```3```\n```case 1```\n```3```\n```2, 1```\n```case 2```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431292,
                "title": "0-ms-100-faster-dynamic-programming-memoization",
                "content": "assume every value as root and find the permutations around both sides of that value.\\n\\n```\\nclass Solution {\\npublic:\\n    int findx(vector<int> &dp,int n){\\n        if(n==1) return dp[n] = 1;\\n        if(n==2) return dp[n] = 2;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            ans += (findx(dp,i-1)*findx(dp,n-i));\\n        }\\n       return dp[n] = ans;\\n    }\\n    int numTrees(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        return findx(dp,n);\\n    }\\n};\\n```\\n\\n**Do upvote if code helps you**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findx(vector<int> &dp,int n){\\n        if(n==1) return dp[n] = 1;\\n        if(n==2) return dp[n] = 2;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            ans += (findx(dp,i-1)*findx(dp,n-i));\\n        }\\n       return dp[n] = ans;\\n    }\\n    int numTrees(int n) {\\n        vector<int> dp(n+1,-1);\\n        dp[0] = 1;\\n        return findx(dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703124,
                "title": "dp-solution-using-catalan-number-0ms-run-time",
                "content": "```\\n  public int numTrees(int n) {\\n        //catalan Number\\n     int v[]= new int[n+2];\\n        v[0]=1;\\n        v[1]=1;\\n        \\n        for(int i=2; i<=n; i++){\\n            v[i]=0;\\n            for(int j=0; j<i; j++){\\n                v[i]+=v[j]*v[i-j-1];\\n            }\\n        }\\n        return v[n];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n  public int numTrees(int n) {\\n        //catalan Number\\n     int v[]= new int[n+2];\\n        v[0]=1;\\n        v[1]=1;\\n        \\n        for(int i=2; i<=n; i++){\\n            v[i]=0;\\n            for(int j=0; j<i; j++){\\n                v[i]+=v[j]*v[i-j-1];\\n            }\\n        }\\n        return v[n];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 588903,
                "title": "dp-c-100-both-space-and-time",
                "content": "If you like or understood please upvote\\n```\\nint numTrees(int n) {\\n        if(n==1)\\n            return 1;\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;dp[1]=1;\\n        dp[2]=2;\\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[i+1]+=dp[j]*dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numTrees(int n) {\\n        if(n==1)\\n            return 1;\\n        vector<int> dp(n+1,0);\\n        dp[0]=1;dp[1]=1;\\n        dp[2]=2;\\n\\t\\t\\n        for(int i=2;i<n;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[i+1]+=dp[j]*dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419773,
                "title": "easy-to-understand-java-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/cglotr/image_1572783162.png)\\n\\n`dp[n]` answers the question of \"what is the number of configurations if I have `n` numbers\".\\n\\nThe next important idea is that we don\\'t care what is the structure of the trees in the _boxes_ that\\nI drew in the above example. What we care is how many numbers that are inside the _box_.\\n\\nIt\\'s easy to answer that question since we can get it from `dp[n]`.\\n\\nNotice that to calculate `dp[n]`, we need to know `dp[n - 1]`, `dp[n - 2]`, and so on until we reach\\nthe base case which is `dp[0]` & `dp[1]`.\\n\\nNotice the pattern, `dp[n] = d[n - 1] * dp[0] + ... + dp[0] * d[n - 1]`. Therefore, we can build the Dynamic\\nProgramming (DP) table with bottom up fashion.\\n\\n**Code**\\n\\n```Java\\nclass Solution {\\n    \\n    public int numTrees(int n) {\\n        if (n < 2) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                dp[i] += dp[i - 1 - j] * dp[j];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    \\n    public int numTrees(int n) {\\n        if (n < 2) {\\n            return 1;\\n        }\\n        \\n        int[] dp = new int[n + 1];\\n        \\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                dp[i] += dp[i - 1 - j] * dp[j];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343283,
                "title": "catalan-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n      int dp[n+1];\\n      if(n==0 || n==1) return n;\\n      dp[0]=1; dp[1]=1;\\n      for(int i=2;i<=n;i++)\\n      {\\n          dp[i]=0;\\n          for(int j=0;j<i;j++)\\n          {\\n              dp[i]+=dp[j]*dp[i-j-1];\\n          }\\n      }\\n        return dp[n];\\n    }\\n};\\n```\\nhttps://www.geeksforgeeks.org/program-nth-catalan-number/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n      int dp[n+1];\\n      if(n==0 || n==1) return n;\\n      dp[0]=1; dp[1]=1;\\n      for(int i=2;i<=n;i++)\\n      {\\n          dp[i]=0;\\n          for(int j=0;j<i;j++)\\n          {\\n              dp[i]+=dp[j]*dp[i-j-1];\\n          }\\n      }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305547,
                "title": "faster-than-100-00-of-java-most-detailed-chart-explanation",
                "content": "![image](https://assets.leetcode.com/users/python_qhuan/image_1559658584.png)\\nGive my clear DP thinking\\uFF1A\\nAs we all know ,  when n = 0\\uFF1Ares = 0;  when n = 1\\uFF1Ares = 1;   when n = 2: res = 2\\nso when n = 3\\uFF0Cwe can think like this:  \\u2461 show have two numbers Smaller than 3\\uFF0Cas a whole\\uFF0Conly this 3 structures\\uFF1A\\n**Attention\\uFF1Adp[0] = 1, it plays an auxiliary role.**\\n![image](https://assets.leetcode.com/users/python_qhuan/image_1559661396.png)\\n```\\nso  dp[3] = dp[2]dp[0] + dp[1]*dp[1] + dp[0]*dp[2] = 2 + 1 + 2 = 5\\n```\\n\\nso when n = 4\\uFF0Cwe can think like this: \\u2462 show have three numbers Smaller than 4:  only this 4 structures\\n![image](https://assets.leetcode.com/users/python_qhuan/image_1559661405.png)\\n```\\nso dp[4] = dp[3]*dp[0]  + dp[2]*dp[1] + dp[1]*dp[2] + dp[0] *dp[3] = 5 + 2 + 2 + 5 = 14\\t\\n```\\n\\n\\nso when n = 5\\uFF0Cwe can think like this: \\u2463 show have four numbers Smaller than 5:  only this 5 structures\\n![image](https://assets.leetcode.com/users/python_qhuan/image_1559661418.png)\\n```\\nso dp[5] = dp[4]*dp[0] + dp[3]*dp[1] + dp[2]*dp[2] + dp[1]*dp[3] + dp[0]*dp[4] = 14 + 5 + 2*2 + 5 + 14 = 42;\\n```\\n\\n\\nlike this,you can find the regular \\uFF0Cso my code is under\\uFF0Cthink  even and odd cases\\uFF1A\\n```\\npublic  int numTrees(int n) {\\n        if (n < 3) return n;\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            int j = i - 1;\\n            int mid = i >> 1;\\n            if (i % 2 == 0) {\\n                while (j >= mid ) {\\n                    dp[i] += ((dp[j] * dp[i - 1 - j]) << 1);\\n                    j--;\\n                }\\n            } else {\\n                while (j > mid ) {\\n                    dp[i] += ((dp[j] * dp[i - 1 - j]) << 1);\\n                    j--;\\n                }\\n                dp[i] += dp[mid] * dp[mid];\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\nIf it helps you, can you give me a thumbs up  \\uD83D\\uDC4D ? Thanks ha\\'ha",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nso  dp[3] = dp[2]dp[0] + dp[1]*dp[1] + dp[0]*dp[2] = 2 + 1 + 2 = 5\\n```\n```\\nso dp[4] = dp[3]*dp[0]  + dp[2]*dp[1] + dp[1]*dp[2] + dp[0] *dp[3] = 5 + 2 + 2 + 5 = 14\\t\\n```\n```\\nso dp[5] = dp[4]*dp[0] + dp[3]*dp[1] + dp[2]*dp[2] + dp[1]*dp[3] + dp[0]*dp[4] = 14 + 5 + 2*2 + 5 + 14 = 42;\\n```\n```\\npublic  int numTrees(int n) {\\n        if (n < 3) return n;\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        dp[2] = 2;\\n        for (int i = 3; i <= n; i++) {\\n            int j = i - 1;\\n            int mid = i >> 1;\\n            if (i % 2 == 0) {\\n                while (j >= mid ) {\\n                    dp[i] += ((dp[j] * dp[i - 1 - j]) << 1);\\n                    j--;\\n                }\\n            } else {\\n                while (j > mid ) {\\n                    dp[i] += ((dp[j] * dp[i - 1 - j]) << 1);\\n                    j--;\\n                }\\n                dp[i] += dp[mid] * dp[mid];\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268910,
                "title": "c-dp-solution-with-detailed-explanation",
                "content": "we set dp[n] is the number of BST that store n consecutive values\\nwe can get dp[n] as follows:\\n\\nwe set 1 as root node, so left subtree has 0 children, right subtree has n - 1 children, the number of bst is dp[0] * dp[n - 1](we set dp[0] = 1);\\n\\nwe set 2 as root node, so left subtree has 1 children, right subtree has n - 2 children, the number of bst is dp[1] * dp[n - 2];\\n\\ngenerally, we set k as root noode, so left subtree has k - 1 children, right subtree has n - k children, the number of bst is dp[k - 1] * dp[n - k];\\n\\ndp[n] = d[0] * dp[n - 1] + ... + dp[k - 1] * dp[n - k] + ... + dp[n - 1] * dp[0];\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 1; k <= i; ++k) {\\n                dp[i] += dp[k - 1] * dp[i - k];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 1; k <= i; ++k) {\\n                dp[i] += dp[k - 1] * dp[i - k];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31743,
                "title": "simple-c-dp-solution",
                "content": "    int numTrees(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n    \\t    for (int j = 0; j < i; j++) {\\n    \\t\\t    dp[i] += dp[j] * dp[i - 1 - j];\\n    \\t    }\\n        }\\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "    int numTrees(int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <= n; i++) {\\n    \\t    for (int j = 0; j < i; j++) {\\n    \\t\\t    dp[i] += dp[j] * dp[i - 1 - j];\\n    \\t    }\\n        }\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31745,
                "title": "attention-adding-five-lines-code-can-help-reducing-running-time-from-1140ms-to-4ms",
                "content": "if you comment the code between //code-start and //code-end, the running time will up to exceed 1000ms.\\nthis code avoid redundant calculation of the same size BST, because any sequence with the same size has the same BST number. for example, {1,2,3} has 5 BST, so does {1,2,4},{4,5,6}, ...{a,b,c}...\\n\\nclass Solution {\\npublic:\\n    \\n    int divideTrees(int start, int end, map<int,int> &mp)\\n    {\\n        if(start >= end)\\n        {\\n            return 1;\\n        }\\n        int k = end-start+1;\\n        //code-start\\n        if(mp.find(k) != mp.end())\\n        {\\n            return mp[k];\\n        }\\n        //code-end\\n        int res = 0;\\n        for(int i = start; i <= end; ++i)\\n        {\\n            int res1 = divideTrees(start, i-1, mp);\\n            int res2 = divideTrees(i+1,end,mp);\\n            res += res1*res2;\\n            mp[i-1-start+1] = res1;\\n            mp[end-i-1+1] = res2;\\n        }\\n        return res;\\n    }\\n    int numTrees(int n) {\\n        // IMPORTANT: Please reset any member data you declared, as\\n        // the same Solution instance will be reused for each test case.\\n        map<int,int> mp;\\n        mp[1] = 1;\\n        mp[2] = 2;\\n        return divideTrees(1,n,mp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int divideTrees(int start, int end, map<int,int> &mp)\\n    {\\n        if(start >= end)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1793822,
                "title": "beats-100-4-lines-easy-solution",
                "content": "```\\npublic:\\n    \\n//C(2n,n)/(n+1)\\n    \\n    int numTrees(int n) {\\n    long long ans=1;\\n    for(int i=1;i<=n;i++){\\n        ans=ans*(n+i)/i;\\n    }\\n    return ans/(n+1);\\n    }\\n\\t\\n\\tAbove solution is using formula of catalan number 2nCn/n+1\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    \\n//C(2n,n)/(n+1)\\n    \\n    int numTrees(int n) {\\n    long long ans=1;\\n    for(int i=1;i<=n;i++){\\n        ans=ans*(n+i)/i;\\n    }\\n    return ans/(n+1);\\n    }\\n\\t\\n\\tAbove solution is using formula of catalan number 2nCn/n+1\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1686365,
                "title": "c-3-approaches-clean-and-concise",
                "content": "**1. Simple Catalan Number Logic**\\n\\nCatalan Numbers are defined as:\\n\\nCn=(2*nCn)/(n+1)\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        \\n        \\n        long long int a=2*n;\\n        int b=n;\\n\\t\\t\\n        int i,j;\\n        long long int ans=1;\\n        for(i=0;i<b;i++)\\n        {\\n            ans*=(a-i);\\n            ans/=(i+1);\\n        }\\n        return ans/(b+1);\\n    }\\n};\\n\\n```\\n\\n**2. DP Based Solution ( Memoization )**\\n\\n**Time Complexity : O(n*n)\\nSpace Complexity : O(n)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[20];\\n    int solve(int n) {\\n        if(n <= 1)\\n            return 1;\\n        if(dp[n] != -1)\\n            return dp[n];\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            ans += (solve(i) * solve(n - i - 1));\\n        return dp[n] = ans;\\n    }\\n    int numTrees(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n);\\n    }\\n};\\n```\\n\\n\\n**3. DP Based Solution ( Tabulation )**\\n\\n**Time Complexity : O(n*n)\\nSpace Complexity : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        \\n        int dp[20];\\n        memset(dp,0,sizeof dp);\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        int i,j;\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=0;j<i;j++)\\n            {\\n                dp[i]=dp[i]+dp[j]*dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n\\n**Pls upvote if you found helpful**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        \\n        \\n        long long int a=2*n;\\n        int b=n;\\n\\t\\t\\n        int i,j;\\n        long long int ans=1;\\n        for(i=0;i<b;i++)\\n        {\\n            ans*=(a-i);\\n            ans/=(i+1);\\n        }\\n        return ans/(b+1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[20];\\n    int solve(int n) {\\n        if(n <= 1)\\n            return 1;\\n        if(dp[n] != -1)\\n            return dp[n];\\n        int ans = 0;\\n        for(int i = 0; i < n; ++i)\\n            ans += (solve(i) * solve(n - i - 1));\\n        return dp[n] = ans;\\n    }\\n    int numTrees(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        \\n        int dp[20];\\n        memset(dp,0,sizeof dp);\\n        dp[0]=1;\\n        dp[1]=1;\\n        \\n        int i,j;\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=0;j<i;j++)\\n            {\\n                dp[i]=dp[i]+dp[j]*dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519729,
                "title": "python-recursive-solution-with-explanation",
                "content": "### Introduction\\n\\nConsider the nodes with values ```1 - n``` in a list-like representation as follows:\\n\\n```\\n[ 1, 2, 3, 4, ..., n - 2, n - 1, n ]\\n  ^                              ^\\n  |                              |\\nstart                           end\\n```\\n\\nHere, ```start``` refers to the node with the least value, and ```end``` refers to the node with the greatest value. The  goal is to find the number of unique structural binary search trees (BST) that can be formed from ```start``` to ```end```, inclusive.\\n\\n---\\n\\n### Breaking it down\\n\\nConsider the simple example ```n = 3```. We have the following cases:\\n\\n1. ```start``` is the root node of the BST.\\n\\n```\\n[ 1, 2, 3 ]\\n  ^     ^\\n  |     |\\nstart  end\\n root\\n```\\n\\nPer BST rules, the remaining nodes with values 2 and 3 are to be added to the right subtree of the root node ```start```. How the remaining nodes are to be added is not of concern. But, **since the left subtree is left empty**, the number of distinct structural BSTs that can be formed **depend on the number of distinct structural BSTs that form from the right subtree**.\\n\\n2. ```end``` is the root node of the BST.\\n\\n```\\n[ 1, 2, 3 ]\\n  ^     ^\\n  |     |\\nstart  end\\n       root\\n```\\n\\nSimilar to case 1, the remaining nodes with values 1 and 2 have to be added to the left subtree. Since the right subtree is left empty, the number of distinct structural BSTs depend on the number of distinct structural BSTs that form from the left subtree.\\n\\nGeneralising cases 1 and 2, **if one subtree has _```N```_ distinct structures, and the other subtree is empty (```0``` distinct structures), then the BST represented by the current node has _```N```_ distinct structures.**\\n\\n3. The node with value 2 is the root of the BST.\\n\\n```\\n[ 1,    2,    3 ]\\n  ^     ^     ^\\n  |     |     |\\nstart  root  end\\n```\\n\\nAccordingly, the ```start``` node becomes the left subtree, and the ```end``` node becomes the right subtree. Since there is only one node at either subtree, the number of distinct structural BST subtrees for both the left and right subtrees is 1. Therefore, there is only 1 possible BST structure if the root node has value 2.\\n\\nWe can generalise this case as follows: **For any given node, if one subtree has _M_ distinct structures, and the other subtree has _N_ distinct structures (_```M```_```, ```_```N```_```> 0```), the BST with the node as its root will have _```M```_``` x ```_```N```_ distinct structures**.\\n\\nTo see why this is the case, consider the following illustration:\\n\\n```\\nConsider the root node of a given BST. Label as root.\\n\\nLabel the distinct structures of the left subtree as follows:\\nL1, L2, L3, ..., Lm.  --> Total of M distinct structures, M > 0.\\n\\nLabel the distinct structures of the right subtree as follows:\\nR1, R2, R3, ..., Rn.  --> Total of N distinct structures, N > 0.\\n\\nThen, the following BST structures are all distinct:\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nL1      R1     L1      R2     L1      R3           L1      Rn\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nL2      R1     L2      R2     L2      R3           L2      Rn\\n\\n...\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nLm      R1     Lm      R2     Lm      R3           Lm      Rn\\n\\nM rows x N columns = MN distinct structures.\\n```\\n\\n---\\n\\n### Implementation\\n\\nUsing ```start``` and ```end``` as \"pointers\", we can tell our function:\\n\\n- Which portion of the BST we are working on.\\n- How many nodes to consider as the current root node.\\n\\nWe can also cache our results so that they don\\'t need to be recomputed later.\\n\\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        cache = {}  # to store results\\n        \\n        def dp(start: int, end: int) -> int:\\n            if end <= start:  # this is an invalid subsequence of nodes\\n                return 1      # return 1 because 1 will not affect the multiplication formula\\n            elif (start, end) in cache.keys():\\n                return cache[(start, end)]  # use saved result\\n            result = 0\\n            for i in range(end-start+1):          # let each node be the root node once\\n\\t\\t\\t\\t# now that the node start+i is the root node,\\n\\t\\t\\t\\t# left subtree: start ~ (start+i)-1,\\n\\t\\t\\t\\t# right subtree: (start+i)+1 ~ end\\n                result += dp(start, start+i-1) \\\\  # distinct structures of the left subtree\\n\\t\\t\\t\\t\\t\\t* dp(start+i+1, end)      # distinct structures of the right subtree\\n            cache[(start, end)] = result  # store the result\\n            return result\\n        \\n        return dp(1, n)  # inclusive\\n```\\n\\n**EDIT:** We can get rid of the inner `dp()` function by calling `numTrees` with `end-start` instead.\\n\\n```python\\nclass Solution:\\n    @cache\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1:\\n            return 1\\n        result = 0\\n        for i in range(n):\\n            result += self.numTrees(i)*self.numTrees(n-i-1)\\n        return result\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/ad4f746e-9804-4ef8-bbed-2638a1861c53_1634144681.9373739.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```1 - n```\n```\\n[ 1, 2, 3, 4, ..., n - 2, n - 1, n ]\\n  ^                              ^\\n  |                              |\\nstart                           end\\n```\n```start```\n```end```\n```start```\n```end```\n```n = 3```\n```start```\n```\\n[ 1, 2, 3 ]\\n  ^     ^\\n  |     |\\nstart  end\\n root\\n```\n```start```\n```end```\n```\\n[ 1, 2, 3 ]\\n  ^     ^\\n  |     |\\nstart  end\\n       root\\n```\n```N```\n```0```\n```N```\n```\\n[ 1,    2,    3 ]\\n  ^     ^     ^\\n  |     |     |\\nstart  root  end\\n```\n```start```\n```end```\n```M```\n```, ```\n```N```\n```> 0```\n```M```\n``` x ```\n```N```\n```\\nConsider the root node of a given BST. Label as root.\\n\\nLabel the distinct structures of the left subtree as follows:\\nL1, L2, L3, ..., Lm.  --> Total of M distinct structures, M > 0.\\n\\nLabel the distinct structures of the right subtree as follows:\\nR1, R2, R3, ..., Rn.  --> Total of N distinct structures, N > 0.\\n\\nThen, the following BST structures are all distinct:\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nL1      R1     L1      R2     L1      R3           L1      Rn\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nL2      R1     L2      R2     L2      R3           L2      Rn\\n\\n...\\n\\n   root           root           root                 root\\n  /    \\\\         /    \\\\         /    \\\\      ...      /    \\\\\\nLm      R1     Lm      R2     Lm      R3           Lm      Rn\\n\\nM rows x N columns = MN distinct structures.\\n```\n```start```\n```end```\n```python\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        cache = {}  # to store results\\n        \\n        def dp(start: int, end: int) -> int:\\n            if end <= start:  # this is an invalid subsequence of nodes\\n                return 1      # return 1 because 1 will not affect the multiplication formula\\n            elif (start, end) in cache.keys():\\n                return cache[(start, end)]  # use saved result\\n            result = 0\\n            for i in range(end-start+1):          # let each node be the root node once\\n\\t\\t\\t\\t# now that the node start+i is the root node,\\n\\t\\t\\t\\t# left subtree: start ~ (start+i)-1,\\n\\t\\t\\t\\t# right subtree: (start+i)+1 ~ end\\n                result += dp(start, start+i-1) \\\\  # distinct structures of the left subtree\\n\\t\\t\\t\\t\\t\\t* dp(start+i+1, end)      # distinct structures of the right subtree\\n            cache[(start, end)] = result  # store the result\\n            return result\\n        \\n        return dp(1, n)  # inclusive\\n```\n```python\\nclass Solution:\\n    @cache\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1:\\n            return 1\\n        result = 0\\n        for i in range(n):\\n            result += self.numTrees(i)*self.numTrees(n-i-1)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788990,
                "title": "98-47-simple-python-solution-explanation-dp-catalan",
                "content": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n                \\n        # G(n) = solutions for n elements\\n        # F(i,n) = element i as root, n elements\\n        \\n        \\n        # Pseudo Code\\n        #G(n) = Sum of all F(i,n)\\n        #F(i,n) = G(i-1)*G(n-i)\\n        \\n        \\n        # Example\\n        # n = 3\\n        \\n        # base cases\\n        # G(0) = 1\\n        # G(1) = 1\\n        \\n        # G(3) = F(1,3)+F(2,3)+F(3,3)\\n        \\n        \\n        # F(1,3) = G(0)*G(2) = 2\\n        # Explanation \\n        # Ex: G(0) = no elements on the left branch\\n        # Ex: G(2) = 2 elements on the right branch\\n        \\n        # F(2,3) = G(1)*G(1) = 1\\n        # Explanation\\n        # Ex: G(1) = 1 element on the left branch\\n        # Ex: G(1) = 1 element on the right branch\\n        \\n        # F(3,3) = G(2)*G(0) = 2\\n        # Explanation \\n        # Ex: G(2) = 2 elements on the left branch\\n        # Ex: G(0) = no elements on the right branch\\n        \\n\\n        g_array = [1,1]\\n        \\n        for j in range(2,n+1):\\n            sum_g = 0\\n            for i in range(1,j+1):\\n                f_i = g_array[i-1]*g_array[j-i]\\n                sum_g += f_i\\n            g_array.append(sum_g)\\n                        \\n        return g_array[n]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n                \\n        # G(n) = solutions for n elements\\n        # F(i,n) = element i as root, n elements\\n        \\n        \\n        # Pseudo Code\\n        #G(n) = Sum of all F(i,n)\\n        #F(i,n) = G(i-1)*G(n-i)\\n        \\n        \\n        # Example\\n        # n = 3\\n        \\n        # base cases\\n        # G(0) = 1\\n        # G(1) = 1\\n        \\n        # G(3) = F(1,3)+F(2,3)+F(3,3)\\n        \\n        \\n        # F(1,3) = G(0)*G(2) = 2\\n        # Explanation \\n        # Ex: G(0) = no elements on the left branch\\n        # Ex: G(2) = 2 elements on the right branch\\n        \\n        # F(2,3) = G(1)*G(1) = 1\\n        # Explanation\\n        # Ex: G(1) = 1 element on the left branch\\n        # Ex: G(1) = 1 element on the right branch\\n        \\n        # F(3,3) = G(2)*G(0) = 2\\n        # Explanation \\n        # Ex: G(2) = 2 elements on the left branch\\n        # Ex: G(0) = no elements on the right branch\\n        \\n\\n        g_array = [1,1]\\n        \\n        for j in range(2,n+1):\\n            sum_g = 0\\n            for i in range(1,j+1):\\n                f_i = g_array[i-1]*g_array[j-i]\\n                sum_g += f_i\\n            g_array.append(sum_g)\\n                        \\n        return g_array[n]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741635,
                "title": "unique-binary-search-tree-python3-solution-with-a-detailed-explanation",
                "content": "Read [this](https://leetcode.com/problems/unique-binary-search-trees/discuss/703488/Detailed-Explanation-%3A-Mental-Leap-on-Why-the-approach-actually-works) first to get a better idea of how we\\'re going to proceed. \\n\\nThe high level idea is that for whatever `n` you assume, you have right and left sub-trees! Each of these sub-trees can be further broken down into smaller pieces. The first way that might come to your mind is to find the unique trees for each `n` (check [this](https://leetcode.com/problems/unique-binary-search-trees/discuss/31761/Python-with-explanation.-I-guess-you-could-call-this-%22DP%22...) out) and sum all of them to get to the total unique trees. If that\\'s what you have in mind, you can come up with something like this:\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        unique_trees = 0\\n        for i in range(n):\\n            left_trees = self.numTrees(i)\\n            right_trees = self.numTrees(n-i-1)\\n            unique_trees += left_trees*right_trees\\n            \\n        return unique_trees\\n```\\n\\nThis solution, altough correct, would give you time limit error when you submit it. This is because we\\'re trying to solve `numTrees` multiple times for every `n` (which is not required right?). Better would be to store what you once calculated and use it for later calculations. There are two ways of doing this: 1) bottom-up and 2) top-down.The main difference between the approach is that one start from bases cases when `n=0` or `n=1`. However, in the top-down, we assume different values as the root node and calculate unique left and right subtrees with all the n values.\\n\\n**1) Bottom-up**\\nIn this approach (as you see in a lot of posts in the discussion), you build from base cases ( `n=0` and `n=1`) to the desired `n`. Following code is doing such a thing. You initialize a `cache` array to keep track of already calculated cases. When `n = 0`, we have one tree. Similarly, when is `n=1`, we have one tree. For `n >= 2`, we follow similar approach to the above solution (that was top-down approach). For each value of `n >=2` (let\\'s say `n=3`), we calculate unique trees assuming all the numbers from `1` to `n` as root. In the case of `n=3`, we assume `1`, `2` and `3` to be root and calculate corresponding unique subtrees and sum them up (line `#1` and `#2`). And, finally, the last entry of `cache` is what we\\'re looking for. \\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        cache = [0]*(n+1)\\n        cache[0] = 1\\n        cache[1] = 1\\n        for i in range(2, n+1):\\n            for j in range(i): #1\\n                cache[i] += cache[j]*cache[i -j - 1] #2\\n            \\n        return cache[-1]\\n```\\n\\n\\n**1) Top-down**\\nIt\\'s different than bottom-up in a sense that it assumes all `n` numbers in the game every time, and just tries to change `root` value by looping over different numbers from `1` to `n`. The general idea is similar to the first solution of this post (the one with time error). \\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n\\n        cache = [-1]*(n+1)\\n        cache[0] = 1\\n        cache[1] = 1\\n        return self.helper(n, cache)\\n    \\n    def helper(self, n, cache):\\n        if cache[n] != -1:\\n            return cache[n]\\n        \\n        \\n        unique_trees = 0\\n        for i in range(n):\\n            left_trees = self.helper(i, cache)\\n            right_trees = self.helper(n - i -1, cache)\\n            unique_trees += left_trees*right_trees\\n        cache[n] = unique_trees\\n        return unique_trees\\n```\\n\\nThat\\'s it! \\n\\n=================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n == 0 or n == 1:\\n            return 1\\n        unique_trees = 0\\n        for i in range(n):\\n            left_trees = self.numTrees(i)\\n            right_trees = self.numTrees(n-i-1)\\n            unique_trees += left_trees*right_trees\\n            \\n        return unique_trees\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        cache = [0]*(n+1)\\n        cache[0] = 1\\n        cache[1] = 1\\n        for i in range(2, n+1):\\n            for j in range(i): #1\\n                cache[i] += cache[j]*cache[i -j - 1] #2\\n            \\n        return cache[-1]\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n\\n        cache = [-1]*(n+1)\\n        cache[0] = 1\\n        cache[1] = 1\\n        return self.helper(n, cache)\\n    \\n    def helper(self, n, cache):\\n        if cache[n] != -1:\\n            return cache[n]\\n        \\n        \\n        unique_trees = 0\\n        for i in range(n):\\n            left_trees = self.helper(i, cache)\\n            right_trees = self.helper(n - i -1, cache)\\n            unique_trees += left_trees*right_trees\\n        cache[n] = unique_trees\\n        return unique_trees\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471900,
                "title": "dp-solution-with-commented-code-in-python",
                "content": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # Intuition:\\n        #   - For each n we try to build BST with node i from 1 -> n as root node\\n        #   - If n = 0 or 1 then only 1 way to form a BST tree\\n        #   - For each i we have i - 1 nodes on left subtree and n - i nodes on right subtree\\n        #   - The result is sum of all BST above. \\n        #       G(n) = f(1, n) + f(2, n) + ... + f(n, n)\\n        #   - For each BST tree above we calculate number of left subtree * number of right subtree. We can see the sub problem here\\n        #       f(i, n) = G(i - 1) * G(n - i)\\n        #   - Final formula:\\n        #       G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) + ... + G(n - 1) * G(0)\\n        \\n        # There is only one way to form BST with 0 or 1 node\\n        if n <= 1:\\n            return 1\\n        \\n        # Build up solution from 0 to n\\n        dp = [0] * (n + 1)\\n        # We already know the result for input = 1, input = 2\\n        dp[0], dp[1] = 1, 1\\n        \\n        # Continue calculate result for input from 2 -> n\\n        for i in range(2, n + 1):\\n            # For each i calculate all possible structurally BSTs that can form by j as root node\\n            for j in range(1, i + 1):\\n                dp[i] += dp[j - 1] * dp[i - j]\\n            \\n        return dp[n]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # Intuition:\\n        #   - For each n we try to build BST with node i from 1 -> n as root node\\n        #   - If n = 0 or 1 then only 1 way to form a BST tree\\n        #   - For each i we have i - 1 nodes on left subtree and n - i nodes on right subtree\\n        #   - The result is sum of all BST above. \\n        #       G(n) = f(1, n) + f(2, n) + ... + f(n, n)\\n        #   - For each BST tree above we calculate number of left subtree * number of right subtree. We can see the sub problem here\\n        #       f(i, n) = G(i - 1) * G(n - i)\\n        #   - Final formula:\\n        #       G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) + ... + G(n - 1) * G(0)\\n        \\n        # There is only one way to form BST with 0 or 1 node\\n        if n <= 1:\\n            return 1\\n        \\n        # Build up solution from 0 to n\\n        dp = [0] * (n + 1)\\n        # We already know the result for input = 1, input = 2\\n        dp[0], dp[1] = 1, 1\\n        \\n        # Continue calculate result for input from 2 -> n\\n        for i in range(2, n + 1):\\n            # For each i calculate all possible structurally BSTs that can form by j as root node\\n            for j in range(1, i + 1):\\n                dp[i] += dp[j - 1] * dp[i - j]\\n            \\n        return dp[n]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 406360,
                "title": "java-recursive-and-dp-solutions-with-clear-explanations-100-runtime",
                "content": "Before we reach the DP solution, it is useful to first think about recursion.\\n\\nWhen we first see the problem, we can try to come up with some examples to see if there are any patterns involved. Since `n = 3` is given in the problem, let\\'s try `n = 4`, with nodes [1, 2, 3, 4]. To find the number of trees systematically, we can start by letting the first node (i.e. 1) be the root node, and then let the second node be the root node and so on.\\n\\nFor the case where the root node is 1, how many possible BSTs are there? We know that everything on the left hand side must be less than the root, and everything on the right hand side must be more than the root. Since nothing is smaller than the root node here, the number of nodes on the left subtree is 0. Meanwhile, [2, 3, 4] are all larger than 1, and belong to the right subtree, so the right subtree has 3 roots. This means that we need to find the number of BSTs for the right subtree....which is essentially `numTrees(n - 1)`.\\n\\nSo we notice a pattern here:\\n- any value <= n can become the root node\\n- any value smaller than the current root node forms the left subtree\\n- any value bigger than the current root node forms the right subtree\\n- the total number of BSTs for the left subtree is `numTrees(# of nodes in leftTree)`\\n- the total number of BSTs for the right subtree is `numTrees(# of nodes in rightTree)`\\n- the total number of BSTs for the entire tree is `numTrees(# of nodes in leftTree) * numTrees(# of nodes in rightTree)` (by simple combinatorics)\\n\\nNow, we can write out a recursive solution:\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        \\n        int totalWays = 0;\\n\\t\\t\\n\\t\\t// i is the possible number of nodes in the left subtree\\n        for (int i = 0; i < n; i++) {\\n            totalWays += numTrees(i) * numTrees(n - i - 1);\\n        }\\n        \\n        return totalWays;   \\n    }\\n}\\n```\\n\\nThis solution works. However, we can make it better - there are repeated computations being done in the `for` loop. Let\\'s improve things using DP by storing the computed results in an array:\\n\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        \\n        int[] nums = new int[n + 1];\\n        nums[0] = 1;\\n        nums[1] = 1;\\n        \\n\\t\\t// computing bottom-up to tree with size n\\n        for (int i = 2; i <= n; i++) {\\n            int totalWays = 0;\\n\\t\\t\\t\\n\\t\\t\\t// j is the number of possible nodes in the left subtree\\n            for (int j = 0; j < i; j++) {\\n                totalWays += nums[j] * nums[i - j - 1];\\n            }\\n            nums[i] = totalWays;\\n        }\\n\\n        return nums[n];\\n    }\\n}\\n```\\n\\nThis is a solution that beats 100% of the other solutions in terms of the runtime.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        \\n        int totalWays = 0;\\n\\t\\t\\n\\t\\t// i is the possible number of nodes in the left subtree\\n        for (int i = 0; i < n; i++) {\\n            totalWays += numTrees(i) * numTrees(n - i - 1);\\n        }\\n        \\n        return totalWays;   \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n == 0 || n == 1) {\\n            return 1;\\n        }\\n        \\n        int[] nums = new int[n + 1];\\n        nums[0] = 1;\\n        nums[1] = 1;\\n        \\n\\t\\t// computing bottom-up to tree with size n\\n        for (int i = 2; i <= n; i++) {\\n            int totalWays = 0;\\n\\t\\t\\t\\n\\t\\t\\t// j is the number of possible nodes in the left subtree\\n            for (int j = 0; j < i; j++) {\\n                totalWays += nums[j] * nums[i - j - 1];\\n            }\\n            nums[i] = totalWays;\\n        }\\n\\n        return nums[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392368,
                "title": "simple-solution-provided-explanation-of-the-the-logic-with-comments",
                "content": "We can form a tree with n nodes using a tree with (n-1) nodes in 3 ways \\n1) Put n at the leaf node \\n2) Put n as the root node\\n3) n is an intermediate node\\n\\nThe count of new trees in 1) and 2) is  simply same as total number of trees with n-1 nodes.\\nIn 3) We can have nodes on both sides of node n.\\nWe split the count  in two parts: \\nTrees which can be formed above node n\\nTrees which can be formed below node n.\\nAnd total number of trees is the number of permuations of the trees above and below.\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1] = 1;\\n        for(int i=2; i<=n;i++){\\n            // when n is leaf node or root node, count of such trees is dp[n-1]\\n            dp[i]+= 2*dp[i-1];\\n\\n         // when n is intermediate node we have nodes on both sides of node n \\n        // if there are x nodes above node n, no of trees which can be formed above =dp[x]\\n        // There will be n-1 - x nodes below node n \\n        // no of trees which can be formed  below = dp[n-1-x]\\n    \\n        // we can select any permutation of the trees above and below\\n    //therefore total number of trees with node n as intermediate  =  dp[x] * dp[n-1-x]\\n            \\n            for(int j=1; j<i-1; j++)\\n                dp[i]+= dp[j]*dp[i-1-j];\\n         \\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1,0);\\n        dp[1] = 1;\\n        for(int i=2; i<=n;i++){\\n            // when n is leaf node or root node, count of such trees is dp[n-1]\\n            dp[i]+= 2*dp[i-1];\\n\\n         // when n is intermediate node we have nodes on both sides of node n \\n        // if there are x nodes above node n, no of trees which can be formed above =dp[x]\\n        // There will be n-1 - x nodes below node n \\n        // no of trees which can be formed  below = dp[n-1-x]\\n    \\n        // we can select any permutation of the trees above and below\\n    //therefore total number of trees with node n as intermediate  =  dp[x] * dp[n-1-x]\\n            \\n            for(int j=1; j<i-1; j++)\\n                dp[i]+= dp[j]*dp[i-1-j];\\n         \\n        }\\n        return dp[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384511,
                "title": "python-96-explaining-dp-solution-with-neat-example",
                "content": "Please note, I haven\\'t come up with a new logic, instead I have made sure to understand and explain the solution in detail with an example.\\nHave a look at how the recursive formula came in place.\\n```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        \"\"\"\\n        The recursive equation.\\n        Let G(n) be the function which returns number of uninque BSTs.\\n\\t\\tConsider [0,1,....i...., n]\\n        Let F(i,n) be the intermediate number of unique BSTs when i is the root.\\n        \\n        F(i,n) = G(i-1) * G(n-i) \\n        When i is the root, there are i-1 nodes to left & n-i nodes to right\\n        \\n        for example -  to find G(4), we must also calculate G(3), G(2), G(1), G(0):\\n        G(4) ==> F(1,4) + F(2,4) + F(3,4) + F(4,4)\\n            for i = 1 --> F(1,4) = G(0) * G(3) = 1 * 5 = 5\\n            for i = 2 --> F(2,4) = G(1) * G(2) = 1 * 2 = 2\\n            for i = 3 --> F(3,4) = G(2) * G(1) = 2 * 1 = 2\\n            for i = 4 --> F(4,4) = G(3) * G(0) = 5 * 1 = 5\\n            Therefore G(4) = [G(0) * G(3)] + [G(1) * G(2)] + [G(2) * G(1)] + [G(3) * G(0)]\\n            G(4) = \\u03A3(i = 1 to 4) G(i - 1) * G(4 - i)  \\n            G(4) = 5 + 2 + 2 + 5 = 14\\n        \\n        we know that G(0) = 1, G(1) = 1\\n        G(2) ==> F(1,2) + F(2,2)\\n            for i = 1 --> F(1,2) = G(0) * G(1) = 1\\n            for i = 2 --> F(2,2) = G(1) * G(0) = 1\\n            Therefore G(2) = 1 + 1 = 2\\n        \\n        G(3) ==> F(1,3) + F(2,3) + F(3,3)\\n            for i = 1 --> F(1,3) = G(0) * G(2) = 2 \\n            for i = 2 --> F(2,3) = G(1) * G(1) = 1\\n            for i = 3 --> F(3,3) = G(2) * G(0) = 2\\n            Therefore G(3) = 2 + 1 + 2 = 5\\n        \\n\\n\\t\\tTo generalize:\\n                G(n) = \\u03A3(i = 1 to n) G(i - 1) * G(n - i)  #Final formula\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        Clearly we can see that previous values of G are recomputed again and again \\n        hence we can memoize a.k.a Dynamic programming.\\n        \"\"\"\\n        \\n        G = [0]*(n+1)\\n        G[0], G[1] = 1, 1\\n        \\n        #G(n) = \\u03A3(i = 1 to n) G(i - 1) * G(n - i)\\n        for i in range(2, n+1):\\n            for j in range(1, i+1):\\n                G[i] += G[j-1] * G[i-j]\\n        \\n        return G[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        \"\"\"\\n        The recursive equation.\\n        Let G(n) be the function which returns number of uninque BSTs.\\n\\t\\tConsider [0,1,....i...., n]\\n        Let F(i,n) be the intermediate number of unique BSTs when i is the root.\\n        \\n        F(i,n) = G(i-1) * G(n-i) \\n        When i is the root, there are i-1 nodes to left & n-i nodes to right\\n        \\n        for example -  to find G(4), we must also calculate G(3), G(2), G(1), G(0):\\n        G(4) ==> F(1,4) + F(2,4) + F(3,4) + F(4,4)\\n            for i = 1 --> F(1,4) = G(0) * G(3) = 1 * 5 = 5\\n            for i = 2 --> F(2,4) = G(1) * G(2) = 1 * 2 = 2\\n            for i = 3 --> F(3,4) = G(2) * G(1) = 2 * 1 = 2\\n            for i = 4 --> F(4,4) = G(3) * G(0) = 5 * 1 = 5\\n            Therefore G(4) = [G(0) * G(3)] + [G(1) * G(2)] + [G(2) * G(1)] + [G(3) * G(0)]\\n            G(4) = \\u03A3(i = 1 to 4) G(i - 1) * G(4 - i)  \\n            G(4) = 5 + 2 + 2 + 5 = 14\\n        \\n        we know that G(0) = 1, G(1) = 1\\n        G(2) ==> F(1,2) + F(2,2)\\n            for i = 1 --> F(1,2) = G(0) * G(1) = 1\\n            for i = 2 --> F(2,2) = G(1) * G(0) = 1\\n            Therefore G(2) = 1 + 1 = 2\\n        \\n        G(3) ==> F(1,3) + F(2,3) + F(3,3)\\n            for i = 1 --> F(1,3) = G(0) * G(2) = 2 \\n            for i = 2 --> F(2,3) = G(1) * G(1) = 1\\n            for i = 3 --> F(3,3) = G(2) * G(0) = 2\\n            Therefore G(3) = 2 + 1 + 2 = 5\\n        \\n\\n\\t\\tTo generalize:\\n                G(n) = \\u03A3(i = 1 to n) G(i - 1) * G(n - i)  #Final formula\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n        Clearly we can see that previous values of G are recomputed again and again \\n        hence we can memoize a.k.a Dynamic programming.\\n        \"\"\"\\n        \\n        G = [0]*(n+1)\\n        G[0], G[1] = 1, 1\\n        \\n        #G(n) = \\u03A3(i = 1 to n) G(i - 1) * G(n - i)\\n        for i in range(2, n+1):\\n            for j in range(1, i+1):\\n                G[i] += G[j-1] * G[i-j]\\n        \\n        return G[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187711,
                "title": "95-38-unique-binary-search-trees-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSolution for Leetcode 96. Unique Binary Search Trees:\\n\\nTo solve this problem, we can use the dynamic programming approach. Let\\'s create an array dp of size n + 1, where dp[i] represents the number of unique BSTs that can be formed using i nodes.\\n\\nThe base cases are dp[0] = 1 and dp[1] = 1, as there is only one unique BST that can be formed using zero and one node(s) respectively.\\n\\nFor i nodes, we can select a root node in i different ways, and then recursively calculate the number of unique BSTs in the left and right subtrees. Finally, we can multiply the number of unique BSTs in the left and right subtrees and add it to the total count.\\n\\nTherefore, for i nodes, the number of unique BSTs that can be formed is given by the formula:\\n```\\ndp[i] = dp[0]*dp[i-1] + dp[1]*dp[i-2] + ... + dp[i-1]*dp[0]\\n```\\nThe above formula takes into account all the possible combinations of left and right subtrees.\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n) Beats\\n95.38%\\n\\n# Code\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # initialize the dp array with base cases\\n        dp = [0] * (n + 1)\\n        dp[0] = dp[1] = 1\\n        \\n        # calculate the number of unique BSTs for i nodes\\n        for i in range(2, n + 1):\\n            for j in range(1, i + 1):\\n                dp[i] += dp[j - 1] * dp[i - j]\\n        \\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndp[i] = dp[0]*dp[i-1] + dp[1]*dp[i-2] + ... + dp[i-1]*dp[0]\\n```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # initialize the dp array with base cases\\n        dp = [0] * (n + 1)\\n        dp[0] = dp[1] = 1\\n        \\n        # calculate the number of unique BSTs for i nodes\\n        for i in range(2, n + 1):\\n            for j in range(1, i + 1):\\n                dp[i] += dp[j - 1] * dp[i - j]\\n        \\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175621,
                "title": "python-recursion-memoization-easy-60-faster-explained",
                "content": "```\\n/*\\n    if we try to break this problem, we realize we can solve this using recursion\\n    for n = 1, number of trees that can be formed is 1\\n    for n = 2, number of trees that can be formed is 2\\n    for n = 3,\\n    we have to consider three cases:\\n    when root is 1:\\n    left subtree is empty\\n    right subtree can have two nodes 2, 3 so possible trees that can be made is 2\\n    \\n    when root is 2\\n    left subtree can have 1 node i.e. 1\\n    right subtree can have 1 node i.e. 3\\n    hence total trees with root as 2 can be 1\\n    \\n    when root is 3\\n    left subtree can have two nodes i.e. 1, 2 so possible trees that can be made using\\n    the two nodes will be 2\\n    hence there can be 2 subtrees with root as 3\\n    total trees with n=3 will be 2 + 1 + 2 = 5\\n    \\n    we apply the same logic for greater values of n\\n    we can use memoization to avoid solving the same overlapping problem again\\n    \\n */\\n```\\n\\n```\\nclass Solution:\\n\\n    def numTrees(self, n: int) -> int:\\n        question_bank = {}\\n        def fun(n):\\n            if n == 0 or n == 1:\\n                return 1\\n            if n == 2:\\n                return 2\\n            if n in question_bank:\\n                return question_bank[n]\\n            count = 0\\n            for i in range(1, n+1):\\n                left = i - 1\\n                right = n - i \\n                sub_left = fun(left)\\n                sub_right = fun(right)\\n                count += sub_left * sub_right\\n            question_bank[n] = count\\n            return question_bank[n]\\n        return fun(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\n    if we try to break this problem, we realize we can solve this using recursion\\n    for n = 1, number of trees that can be formed is 1\\n    for n = 2, number of trees that can be formed is 2\\n    for n = 3,\\n    we have to consider three cases:\\n    when root is 1:\\n    left subtree is empty\\n    right subtree can have two nodes 2, 3 so possible trees that can be made is 2\\n    \\n    when root is 2\\n    left subtree can have 1 node i.e. 1\\n    right subtree can have 1 node i.e. 3\\n    hence total trees with root as 2 can be 1\\n    \\n    when root is 3\\n    left subtree can have two nodes i.e. 1, 2 so possible trees that can be made using\\n    the two nodes will be 2\\n    hence there can be 2 subtrees with root as 3\\n    total trees with n=3 will be 2 + 1 + 2 = 5\\n    \\n    we apply the same logic for greater values of n\\n    we can use memoization to avoid solving the same overlapping problem again\\n    \\n */\\n```\n```\\nclass Solution:\\n\\n    def numTrees(self, n: int) -> int:\\n        question_bank = {}\\n        def fun(n):\\n            if n == 0 or n == 1:\\n                return 1\\n            if n == 2:\\n                return 2\\n            if n in question_bank:\\n                return question_bank[n]\\n            count = 0\\n            for i in range(1, n+1):\\n                left = i - 1\\n                right = n - i \\n                sub_left = fun(left)\\n                sub_right = fun(right)\\n                count += sub_left * sub_right\\n            question_bank[n] = count\\n            return question_bank[n]\\n        return fun(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566638,
                "title": "very-simple-dp-solution-c-with-comments",
                "content": "```\\nvoid recur(int n,unordered_map<int,int> &mp)\\n    {\\n\\t//base case\\n        if(n==0 || n==1) return;\\n\\t\\t\\n\\t\\t//recursive call for n-1\\n        recur(n-1,mp);\\n\\t\\t//variable to calculate answer for current n\\n        int val = 0;\\n\\t\\t\\n\\t\\t//for every i such that 1<=i<=n, we\\'ll calculate number of\\n\\t\\t//BSTs made by taking node with value i as root and\\n\\t\\t//add it to our val\\n        for(int i=1;i<=n;i++)\\n        {\\n\\t\\t\\t//to calculate no of BSTs after making ith node as root\\n\\t\\t\\t//we\\'ll first calculate no, of nodes in left and right subtree\\n\\t\\t\\t//(all those nodes with values less than i will be on left and rest will be\\n\\t\\t\\t//on right).\\n            int left = i-1;\\n            int right = n-i;\\n\\t\\t\\t\\n\\t\\t\\t//then we\\'ll use the dp map to calculate no. of BSTs\\n\\t\\t\\t//NOTE : it can be guaranteed that left and right will always be there in\\n\\t\\t\\t//map as left and right can be at max n-1 which is calculated earlier\\n\\t\\t\\t//when we made call for n-1\\n            val += mp[left]*mp[right];\\n        }\\n\\t\\t\\n\\t\\t//memoize the value for current n\\n        mp[n] = val;\\n    }\\n\\t\\n\\tint numTrees(int n) {\\n\\t\\t// map for memoization\\n        unordered_map<int,int> mp;\\n\\t\\t\\n\\t\\t//base cases , can be easily observed by drwaing on paper\\n        mp[0] = mp[1] = 1;\\n\\t\\t\\n\\t\\t//call recursion\\n        recur(n,mp);\\n\\t\\t\\n\\t\\treturn the answer\\n        return mp[n];\\n    }\\n```\\n\\n**Time Complexity :**  O(n * n) [for each n we made at most n iterations)\\n**Space Complexity :** O(n) (dp map) [ignoring recursion stack]",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nvoid recur(int n,unordered_map<int,int> &mp)\\n    {\\n\\t//base case\\n        if(n==0 || n==1) return;\\n\\t\\t\\n\\t\\t//recursive call for n-1\\n        recur(n-1,mp);\\n\\t\\t//variable to calculate answer for current n\\n        int val = 0;\\n\\t\\t\\n\\t\\t//for every i such that 1<=i<=n, we\\'ll calculate number of\\n\\t\\t//BSTs made by taking node with value i as root and\\n\\t\\t//add it to our val\\n        for(int i=1;i<=n;i++)\\n        {\\n\\t\\t\\t//to calculate no of BSTs after making ith node as root\\n\\t\\t\\t//we\\'ll first calculate no, of nodes in left and right subtree\\n\\t\\t\\t//(all those nodes with values less than i will be on left and rest will be\\n\\t\\t\\t//on right).\\n            int left = i-1;\\n            int right = n-i;\\n\\t\\t\\t\\n\\t\\t\\t//then we\\'ll use the dp map to calculate no. of BSTs\\n\\t\\t\\t//NOTE : it can be guaranteed that left and right will always be there in\\n\\t\\t\\t//map as left and right can be at max n-1 which is calculated earlier\\n\\t\\t\\t//when we made call for n-1\\n            val += mp[left]*mp[right];\\n        }\\n\\t\\t\\n\\t\\t//memoize the value for current n\\n        mp[n] = val;\\n    }\\n\\t\\n\\tint numTrees(int n) {\\n\\t\\t// map for memoization\\n        unordered_map<int,int> mp;\\n\\t\\t\\n\\t\\t//base cases , can be easily observed by drwaing on paper\\n        mp[0] = mp[1] = 1;\\n\\t\\t\\n\\t\\t//call recursion\\n        recur(n,mp);\\n\\t\\t\\n\\t\\treturn the answer\\n        return mp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1565610,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "For a value n, we fix root and find different combinations of left and right subtree with remaining n-1 nodes\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            int sum=0;\\n            for(int j=0;j<i;j++)\\n                sum+=(dp[j]*dp[i-1-j]);\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            int sum=0;\\n            for(int j=0;j<i;j++)\\n                sum+=(dp[j]*dp[i-1-j]);\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373703,
                "title": "cpp-catalan-numbers-dp-0-ms-100-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        //number of bsts is simply the nth catalan number\\n\\n        //Catalan Number, Cn = C0Cn-1 + C1Cn-2 + C2Cn-3 + .. \\n        \\n        //c[3] = C0C2 + C1C1 + C2C0\\n        \\n        int catalan[n+1];\\n        catalan[0] = 1;\\n        catalan[1] = 1;\\n        \\n        for(int i =2 ; i<=n; i++){\\n            int x = 0;\\n            for(int j = 0; j < i; j++)\\n                x+= catalan[j]*catalan[i-j - 1];\\n            catalan[i] = x;\\n        }\\n        \\n        return catalan[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        //number of bsts is simply the nth catalan number\\n\\n        //Catalan Number, Cn = C0Cn-1 + C1Cn-2 + C2Cn-3 + .. \\n        \\n        //c[3] = C0C2 + C1C1 + C2C0\\n        \\n        int catalan[n+1];\\n        catalan[0] = 1;\\n        catalan[1] = 1;\\n        \\n        for(int i =2 ; i<=n; i++){\\n            int x = 0;\\n            for(int j = 0; j < i; j++)\\n                x+= catalan[j]*catalan[i-j - 1];\\n            catalan[i] = x;\\n        }\\n        \\n        return catalan[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789982,
                "title": "runtime-0-ms-faster-than-100-00-c-2-approach-dp-without-dp",
                "content": "\\n\\t //1. without dp\\n\\t \\n     //as for n number of trees possible= ((2n)C(n))/(n+1)\\n     //(2n)C(n) is equal to ((2n)*(2n-1)*...n terms) / (n*(n-1)*...*1)\\n\\n     class Solution {\\n     public:\\n         int numTrees(int n) {\\n             double ans=1,i=2*n;\\n             for(int j=1;j<=n;j++,i--){\\n                 ans*=(i/j);\\n                  }\\n             return ans/(n+1);\\n         }\\n     };\\n\\t \\n\\t //2. with dp\\n\\t \\n\\t class Solution {\\n    public:\\n        int numTrees(int n) {\\n            vector<int> dp(n + 1);\\n            dp[0]=1;\\n            dp[1]=1;\\n            for(int i=2;i<=n;i++){\\n                for(int j=0;j<i;j++){\\n                    dp[i]+=dp[j]*dp[i-j-1];  //catalan number\\n                }\\n            }\\n            return dp[n];\\n        }\\n    };\\n\\t \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n     public:\\n         int numTrees(int n) {\\n             double ans=1,i=2*n;\\n             for(int j=1;j<=n;j++,i--){\\n                 ans*=(i/j);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 537764,
                "title": "my-c-0ms-solution-detailed-explanation",
                "content": "It is not hard to draw the conclusion that once the structure of the tree has been determined, the binary search tree will be also determined. Actually this problem is equivalent to the number of structures of binary trees that are consist of n nodes, so we don\\'t need to think about the definition of binary search trees.\\nMost binary tree problems can be solved in recursive methods, so it\\'s important to find the recursive relationship.\\nTake \"n=3\" for example, it must has a root node, then 2 nodes will be allocated to its left and right sides. There are 3 situations: left=2&right=0, left=1&right=1, left=0&right=2.\\nAssume the number of  structurally unique BST for n nodes is f(n), we can get the following recursive relationship:\\nf(n)=f(0)*f(n-1)+f(1)*f(n-2)+...+f(n-2)*f(1)+f(n-1)*f(0)\\nNote: Coding in a recursive way will result in time limit exceeding. But the recursive idea can help us better understand this problem.\\nSorry for my bad English, hope it won\\'t cause any misunderstanding.\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> nums(n+1, 0);\\n        nums[0]=1;  nums[1]=1;\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                nums[i]+=nums[j]*nums[i-1-j];\\n            }\\n        }\\n        return nums[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> nums(n+1, 0);\\n        nums[0]=1;  nums[1]=1;\\n        for(int i=2;i<=n;i++){\\n            for(int j=0;j<i;j++){\\n                nums[i]+=nums[j]*nums[i-1-j];\\n            }\\n        }\\n        return nums[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314746,
                "title": "detailed-analysis-of-how-to-approach-this-problem-using-dynamic-programming-no-need-to-know-catalan",
                "content": "Here is how I think of this problem and break it down into several steps to solve, hope it helps!\\n* since this problem is basically asking for number of possible ways to generate a BST using a given range of values from 1 to n. My first intuition would be using `dynamic programming` to solve for this since it falls into the one of three common categories that can be solved by dynamic programming.\\n* Dynamica programming requires us to find out the [optimal subsubstructure](https://en.wikipedia.org/wiki/Dynamic_programming) for the problem, which is the core to solve this problem. If we are able to find out the optimal substructure, we then usually break the current problem into several subproblems, solve subproblems and evenually we are able to solve the original problem using the solutions to its subproblems\\n* For example, let say `n = 3`, then there will be three nodes in the BST which are `1`, `2` and `3`. As shown in the problem description, each of these three values can be treated as the root for BST. Let\\'s treat `2` as the root of BST, then according to the property of BST, `1` has to be in its left subtree and `3` has to be in its right subtree. How many possible left subtree it can be, given the fact that this BST only contain one element which is `1`. Obviously, there is only one possible form of the left subtree. Similarly, there is only one possible form of the right subtree. As a result, given the root is `2`, and there is one possible left subtree that can be formed, one possible right subtree that can be formed. Together there will be only `1 * 1 = 1` possible form of BST that can be formed, given the root is `2`\\n* Observing the example above, we\\'ve found the `optimal substructure` of this problem: given `n`, if we choose root to be `i` where `1 <= i <= n`, then the number of possible BSTs can be formed is this case is the `number of possible left subtree (still a BST)` `*` `number of possible right subtree (still a BST)`. The left subtree will be using values from `0 to i - 1` so that their solution is just the solution to subproblem where `n = i - 1` and the right subtree will be using values from `i + 1 to n`, so that their solution is just the solution to the subproblem where `n = n (the original n) - i`. Eventually, the total number of BST that can be formed is just the sum of number of BST that can be formed with `1` as the root, with `2` as the root and so on.\\n* state transfer function: define `C(n)` as the total number of possible BSTs that can be formed using values from `1 to n`, then the recursive relation is that `C(n) = summation of C(i - 1) * C(n - i)` where `1 <= i <= n`\\n* base case: `C(0) = 1`\\n\\nSolution:\\n```java\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n < 0) return 1;\\n        \\n        int[] dp = new int[n + 1];\\n        // base case: dp[0] = 1 to avoid possible index out of bound exceptions\\n        dp[0] = 1;\\n        \\n        // state transfer function: dp[n] = summation of dp[i - 1] * dp[n - i] where 1 <= i <= n\\n        for (int nn = 1; nn <= n; ++nn) {\\n            for (int i = 1; i <= nn; ++i) {\\n                dp[nn] += dp[i - 1] * dp[nn - i];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\n```js\\nvar numTrees = function(n) {\\n  // state: dp[i] => number of different BST can be formed using 1...n\\n  // state transfer function:\\n  // take j as the root, where 1 <= j <= i\\n  // the number of different left subtree: dp[j - 1]\\n  // the number of different right subtree: dp[i - j]\\n  // dp[i] = sum(dp[j - 1] * dp[i - j] for 1 <= j <= i)\\n  // base case:\\n  // dp[0] = 1\\n  // dp[1] = 1\\n  const dp = Array(n + 1).fill(0);\\n  dp[0] = 1;\\n  dp[1] = 1;\\n\\n  for (let i = 2; i <= n; ++i) {\\n    for (let j = 1; j <= i; ++j) {\\n      dp[i] += dp[j - 1] * dp[i - j];\\n    }\\n  }\\n  return dp[n];\\n};\\n```\\n\\nHappy Coding~",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numTrees(int n) {\\n        if (n < 0) return 1;\\n        \\n        int[] dp = new int[n + 1];\\n        // base case: dp[0] = 1 to avoid possible index out of bound exceptions\\n        dp[0] = 1;\\n        \\n        // state transfer function: dp[n] = summation of dp[i - 1] * dp[n - i] where 1 <= i <= n\\n        for (int nn = 1; nn <= n; ++nn) {\\n            for (int i = 1; i <= nn; ++i) {\\n                dp[nn] += dp[i - 1] * dp[nn - i];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```js\\nvar numTrees = function(n) {\\n  // state: dp[i] => number of different BST can be formed using 1...n\\n  // state transfer function:\\n  // take j as the root, where 1 <= j <= i\\n  // the number of different left subtree: dp[j - 1]\\n  // the number of different right subtree: dp[i - j]\\n  // dp[i] = sum(dp[j - 1] * dp[i - j] for 1 <= j <= i)\\n  // base case:\\n  // dp[0] = 1\\n  // dp[1] = 1\\n  const dp = Array(n + 1).fill(0);\\n  dp[0] = 1;\\n  dp[1] = 1;\\n\\n  for (let i = 2; i <= n; ++i) {\\n    for (let j = 1; j <= i; ++j) {\\n      dp[i] += dp[j - 1] * dp[i - j];\\n    }\\n  }\\n  return dp[n];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 31791,
                "title": "simple-java-solution-a-dp-problem",
                "content": "public class Solution {\\n\\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for (int i=1; i<=n; i++) {\\n            int sum = 0;\\n            for (int j=1;j<=i;j++) {\\n                sum += dp[j-1] * dp[i-j];\\n            }\\n            dp[i] = sum;\\n        }\\n        return dp[n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for (int i=1; i<=n; i++) {\\n            int sum = 0;\\n            for (int j=1;j<=i;j++) {\\n                sum += dp[j-1] * dp[i-j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3647145,
                "title": "recursion-memoization-tabulation",
                "content": "# Pls Upvote if it Helps!!!!\\n\\n# Approach\\nThe no of Uniquely structured binary search tree are eqaul to the catalan no of that number...\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Pls Upvote if Helpful \\uD83E\\uDD79\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // SOLUTION 1 : RECURSIVE SOLUTION\\n    int solve(int n){\\n        // base case\\n        if(n==0 || n==1){\\n            return 1;\\n        }\\n\\n        // recursive calls\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            int temp = solve(i) * solve(n-i-1);\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n\\n    // SOLUTION 2 : RECURSION + MEMOIZATION\\n    int solve2(int n, vector<int>&dp){\\n        // base case\\n        if(n <= 1){\\n            return 1;\\n        }\\n\\n        // dp call\\n        if(dp[n-1] != -1){\\n            return dp[n-1];\\n        }\\n\\n        // recursive calls\\n        int ans = 0;\\n        for(int i = 1; i<=n; i++){\\n            int temp = solve2(i-1, dp) * solve2(n-i, dp);\\n            ans += temp;\\n        }\\n\\n        return dp[n-1] = ans;\\n    }\\n\\n    // SOLUTION 3 : TABULATION METHOD\\n    int solveTab(int n){\\n        // creating dp vector\\n        vector<int>dp(n+1, 0);\\n\\n        // base cases handling\\n        dp[0] = dp[1] = 1;\\n\\n        // i --> no of nodes\\n        for(int i = 2; i<=n; i++){\\n            // j --> no of roots\\n            for(int j = 1; j<=i; j++){\\n                int temp = dp[j-1] * dp[i-j];\\n                dp[i] += temp;\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n\\n\\n    int numTrees(int n) {\\n        // recursive solution\\n        // return solve(n);\\n\\n        // recursive + memoization solution\\n        // vector<int>dp(n, -1);\\n        // return solve2(n, dp);\\n\\n        // tabulation method\\n        return solveTab(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // SOLUTION 1 : RECURSIVE SOLUTION\\n    int solve(int n){\\n        // base case\\n        if(n==0 || n==1){\\n            return 1;\\n        }\\n\\n        // recursive calls\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            int temp = solve(i) * solve(n-i-1);\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n\\n    // SOLUTION 2 : RECURSION + MEMOIZATION\\n    int solve2(int n, vector<int>&dp){\\n        // base case\\n        if(n <= 1){\\n            return 1;\\n        }\\n\\n        // dp call\\n        if(dp[n-1] != -1){\\n            return dp[n-1];\\n        }\\n\\n        // recursive calls\\n        int ans = 0;\\n        for(int i = 1; i<=n; i++){\\n            int temp = solve2(i-1, dp) * solve2(n-i, dp);\\n            ans += temp;\\n        }\\n\\n        return dp[n-1] = ans;\\n    }\\n\\n    // SOLUTION 3 : TABULATION METHOD\\n    int solveTab(int n){\\n        // creating dp vector\\n        vector<int>dp(n+1, 0);\\n\\n        // base cases handling\\n        dp[0] = dp[1] = 1;\\n\\n        // i --> no of nodes\\n        for(int i = 2; i<=n; i++){\\n            // j --> no of roots\\n            for(int j = 1; j<=i; j++){\\n                int temp = dp[j-1] * dp[i-j];\\n                dp[i] += temp;\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n\\n\\n    int numTrees(int n) {\\n        // recursive solution\\n        // return solve(n);\\n\\n        // recursive + memoization solution\\n        // vector<int>dp(n, -1);\\n        // return solve2(n, dp);\\n\\n        // tabulation method\\n        return solveTab(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392710,
                "title": "java-dp-beats-100-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int numTrees(int n) {\\n    var dp = new int[n+1];\\n    dp[0] = 1;\\n\\n    for (var i=1; i<=n; i++)\\n      for (var j=0; j<i; j++)\\n        dp[i] += dp[j] * dp[i-1-j];\\n    \\n    return dp[n];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n  public int numTrees(int n) {\\n    var dp = new int[n+1];\\n    dp[0] = 1;\\n\\n    for (var i=1; i<=n; i++)\\n      for (var j=0; j<i; j++)\\n        dp[i] += dp[j] * dp[i-1-j];\\n    \\n    return dp[n];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044439,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            dp[i]+=dp[j]*dp[i-j-1];\\n        }\\n        for(int i:dp)\\n        cout<<i<<\" \";\\n        return dp[n];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> dp(n+1);\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            for(int j=0;j<i;j++)\\n            dp[i]+=dp[j]*dp[i-j-1];\\n        }\\n        for(int i:dp)\\n        cout<<i<<\" \";\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2865654,
                "title": "o-n-solution",
                "content": "\\n\\n# Approach\\nusing formula\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long int abhi1(int n){\\n    long long int ans=n;\\n    for (int  i = n-1; i>20; i--)\\n    {\\n        ans*=i;\\n    }\\n    return ans;\\n    \\n}\\nlong long int abhi2(int n){\\n    long long int ans=n;\\n    for (int  i = n-1; i>30; i--)\\n    {\\n        ans*=i;\\n    }\\n    return ans;\\n    \\n}\\nlong long int fact(long long int n){\\n    if (n==1)\\n    {\\n       return 1;\\n    }\\n    return n*fact(n-1);\\n}\\n\\n    int numTrees(int n) {\\n        long long int x,y,z;\\n        y=fact(n);\\n        z=y*(n+1);\\n        long long int a,b,c;\\n        if (2*n>20)\\n        {\\n            if (2*n>30)\\n            {\\n                x=fact(20);\\n                a=abhi1(30);\\n                b=abhi2(2*n);\\n               \\n                double m1=x/z;\\n               \\n\\n                return (m1*a*b)/y;\\n            }\\n            else\\n            {\\n               \\n            \\n              x=fact(20);\\n                a=abhi1(2*n);\\n                 double m1=x/z;\\n                \\n                return (m1*a)/y;\\n               \\n        }\\n        }\\n         x=fact(2*n);\\n        long long int ans=y*z;\\n        x/=ans;\\n        return x;\\n\\n\\n       \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n  long long int abhi1(int n){\\n    long long int ans=n;\\n    for (int  i = n-1; i>20; i--)\\n    {\\n        ans*=i;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2449867,
                "title": "3-approaches-recursive-memoisation-tabulation",
                "content": "```\\n//<----------------------------------- Recursive ----------------------------------------->\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n)\\n    {\\n        if(n == 0 || n == 1)    \\n            return 1;\\n        \\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            count += (numTrees(i-1)*numTrees(n-i));\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//<---------------------------------- Memoisation ------------------------------------------>\\n\\nclass Solution {\\npublic:\\n    int getCount(int n , vector<int>&dp)\\n    {\\n        if(n == 0 || n == 1)    \\n            return dp[n] = 1;\\n        \\n        int count = 0;\\n        \\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            count += (getCount(i-1 , dp)*getCount(n-i , dp));\\n        }\\n        \\n        return dp[n] = count;\\n    }\\n    \\n    int numTrees(int n)\\n    {\\n        vector<int>dp(n+1,-1);\\n        return getCount(n , dp);\\n    }\\n};\\n\\n//<-------------------------------------- Tabulation ----------------------------------------->\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n)\\n    {\\n       vector<int> dp(n+1,0);\\n        dp[0] = dp[1] = 1;\\n        \\n        // i -> node\\n        for(int i=2;i<=n;i++){\\n            int ans = 0;\\n            for(int j=1;j<=i;j++){\\n                ans += dp[j-1] * dp[i-j];\\n            }\\n            dp[i] = ans;\\n        }\\n        \\n        return dp[n];\\n    }\\n };\\n \\n ```\\n \\n \\n Please Upvote , if you\\'ve found this helpful",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//<----------------------------------- Recursive ----------------------------------------->\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n)\\n    {\\n        if(n == 0 || n == 1)    \\n            return 1;\\n        \\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            count += (numTrees(i-1)*numTrees(n-i));\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n//<---------------------------------- Memoisation ------------------------------------------>\\n\\nclass Solution {\\npublic:\\n    int getCount(int n , vector<int>&dp)\\n    {\\n        if(n == 0 || n == 1)    \\n            return dp[n] = 1;\\n        \\n        int count = 0;\\n        \\n        if(dp[n] != -1)\\n            return dp[n];\\n        \\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            count += (getCount(i-1 , dp)*getCount(n-i , dp));\\n        }\\n        \\n        return dp[n] = count;\\n    }\\n    \\n    int numTrees(int n)\\n    {\\n        vector<int>dp(n+1,-1);\\n        return getCount(n , dp);\\n    }\\n};\\n\\n//<-------------------------------------- Tabulation ----------------------------------------->\\n\\nclass Solution {\\npublic:\\n    int numTrees(int n)\\n    {\\n       vector<int> dp(n+1,0);\\n        dp[0] = dp[1] = 1;\\n        \\n        // i -> node\\n        for(int i=2;i<=n;i++){\\n            int ans = 0;\\n            for(int j=1;j<=i;j++){\\n                ans += dp[j-1] * dp[i-j];\\n            }\\n            dp[i] = ans;\\n        }\\n        \\n        return dp[n];\\n    }\\n };\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2110463,
                "title": "explanation-python-easy",
                "content": "Case 1 : **n = 1** Only one combination is possible.\\n\\nCase 2 : **n = 2** Let fix one node. Two possibilities for second node. It can either be on right or left.\\nHence for n=2 , 2 trees possible\\n\\nCase 3: **n = 3**\\nAgain fix one node, and we are left with two nodes.\\nPossibilities **:**\\n* Both are on right\\n* Both are on left\\n* One on right and other on left\\n\\nAnswer to each above case will be **Combinations on right X Combinations on left**.\\nNow we know answer of **TWO** nodes = 2\\nAnswer for **ONE** node is 1\\nAnswer for  **THREE** nodes : ( ( 2 on right X 0 on left ) + ( 1 on right X 1 on left ) +( 0 on right X 2 on left ) )\\n\\nOther CASES :\\nSIMILARLY a problem with **n nodes** can be broken into for **n - 1** nodes.\\n\\nArray **a** is created for memomization so that repeated recurcive calls for same value of n are prevented.\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        \\n        a = [0]*n\\n        \\n        def solve(n):\\n            \\n            if n <= 1:\\n                return 1\\n            if a[ n - 1 ] != 0:\\n                return a[ n - 1 ]\\n            k = 0\\n            for i in range(n):\\n                k += ( solve(i) * solve( n-i-1 ) )\\n            a[n-1] = k\\n            return k\\n        \\n        return s( n )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        \\n        a = [0]*n\\n        \\n        def solve(n):\\n            \\n            if n <= 1:\\n                return 1\\n            if a[ n - 1 ] != 0:\\n                return a[ n - 1 ]\\n            k = 0\\n            for i in range(n):\\n                k += ( solve(i) * solve( n-i-1 ) )\\n            a[n-1] = k\\n            return k\\n        \\n        return s( n )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806089,
                "title": "c-easy-to-understand-0ms",
                "content": "![image](https://assets.leetcode.com/users/images/87586211-1c8e-463b-be5d-9aa591d89916_1646029967.6867256.jpeg)\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> arr(n+1);\\n        arr[0] = 1, arr[1] = 1;    //If there are 1 or 0 nodes, then we have one unique BST\\n        for (int i = 2; i <= n; i++)\\n            for (int j =0 ; j <i; j++)\\n                arr[i] += arr[j] * arr[i-j-1];\\n        \\n        return arr[n];\\n    }\\n};\\n```\\n\\n* If you have understood the solution, please do up-vote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        vector<int> arr(n+1);\\n        arr[0] = 1, arr[1] = 1;    //If there are 1 or 0 nodes, then we have one unique BST\\n        for (int i = 2; i <= n; i++)\\n            for (int j =0 ; j <i; j++)\\n                arr[i] += arr[j] * arr[i-j-1];\\n        \\n        return arr[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775259,
                "title": "java-dp-memorization-solution-100-faster",
                "content": "//The idea is just like MCM we wil traverse from 0 to n-1 and partition the imaginary array of\\n//n elements(0 to n-1) at each index i in two parts left and right\\n//e.g n=5\\n//[1,2,3,4,5]\\n//we call recursive functions\\n// here we assume cut is the root index\\n// for left tree it is (starting_index,cut-1)\\n// for right tree it is (cut+1,ending_index)\\n//and add the product of both in our final answer.\\n\\n// code \\n\\npublic int helper(int si,int ei,int [][]dp){\\n        if(si>ei) return 1;\\n        if(si == ei) return dp[si][ei] = 1;\\n        \\n        if(dp[si][ei] != 0) return dp[si][ei];\\n        \\n        int count = 0;\\n        for(int cut = si;cut<=ei;cut++){\\n            \\n            int leftTree = helper(si,cut-1,dp);\\n            int rightTree = helper(cut+1,ei,dp);\\n            \\n            count += (leftTree*rightTree);\\n        }\\n        return dp[si][ei] = count;\\n    }\\n    public int numTrees(int n) {\\n        \\n        int [][]dp = new int[n][n];\\n        \\n        return helper(0,n-1,dp);\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Memoization"
                ],
                "code": "//The idea is just like MCM we wil traverse from 0 to n-1 and partition the imaginary array of\\n//n elements(0 to n-1) at each index i in two parts left and right\\n//e.g n=5\\n//[1,2,3,4,5]\\n//we call recursive functions\\n// here we assume cut is the root index\\n// for left tree it is (starting_index,cut-1)\\n// for right tree it is (cut+1,ending_index)\\n//and add the product of both in our final answer.\\n\\n// code \\n\\npublic int helper(int si,int ei,int [][]dp){\\n        if(si>ei) return 1;\\n        if(si == ei) return dp[si][ei] = 1;\\n        \\n        if(dp[si][ei] != 0) return dp[si][ei];\\n        \\n        int count = 0;\\n        for(int cut = si;cut<=ei;cut++){\\n            \\n            int leftTree = helper(si,cut-1,dp);\\n            int rightTree = helper(cut+1,ei,dp);\\n            \\n            count += (leftTree*rightTree);\\n        }\\n        return dp[si][ei] = count;\\n    }\\n    public int numTrees(int n) {\\n        \\n        int [][]dp = new int[n][n];\\n        \\n        return helper(0,n-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1686104,
                "title": "java-solution-recursion-dp-catalan-numbers",
                "content": "So lets start from the most basic solution that is recursion. Now consider we have n nodes and each of these nodes are candidates for root node right. So lets say we have node i as the root what are possible number of structurally unique BSTs? It would be ```numTress(number of nodes on left side) * numTrees(number of nodes on right side)``` right.\\n![image](https://assets.leetcode.com/users/images/2e8a3386-bde7-48e8-9d4c-0dd0ebc78cd6_1642027238.033934.png)\\nwhere ```C(i-1)``` represents number of structurally unique BSTs from i-1 nodes. And for each node we would find the possible number and simply add. So thinking about the base case for this recursion if n<2 we would have no node or one node and for that the number of possible structurally unique BSTs would be 1. So let\\'s recurse:\\n\\nCode:\\n```\\npublic int numTrees(int n) {\\n        return recur( n );\\n    }\\n    public int recur( int n ) {\\n        if ( n<2 ) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for ( int i=n; i>0; i-- ) {\\n            res += recur( i-1 ) * recur( n-i );\\n        }\\n        return res;\\n    }\\n```\\n\\nNow recursion would lead to TLE. What to do now? Did you say \"Memoize it!\". Ok so let\\'s memoize it.\\n\\nCode:\\n```\\nInteger[] dp;\\n    public int numTrees(int n) {\\n        dp = new Integer[n+1];\\n        return recur( n );\\n    }\\n    public int recur( int n ) {\\n        if ( n<2 ) {\\n            return 1;\\n        }\\n        if ( dp[n]!=null ) {\\n            return dp[n];\\n        }\\n        int res = 0;\\n        for ( int i=n-1; i>=0; i-- ) {\\n            res += recur( i ) * recur( n-i-1 );\\n        }\\n        return dp[n] = res;\\n    }\\n```\\n\\nAnother interesting solution is using Catalan numbers. So before diving into that lets first understand catalan numbers.\\n```Catalan(n) = Catalan(0)*Catalan(n-1) + Catalan(1)*Catalan(n-2).....+Catalan(i)*Catalan(n-i-1)....+Catalan(n-1)*Catalan(0)```\\nThis is the basic formula for Catalan numbers that can be found using recursion and then memoizing it which would take time complexity of O(n^2). Can we do better? Yes indeed! This whole complex looking expression evaluates to:\\n![image](https://assets.leetcode.com/users/images/a032554f-72a1-4064-aa1f-10520edfea6b_1642027916.3883116.png)\\nSo we can calculate this expression in O(n) time with O(1) space.\\n\\nOk, so we get what Catalan numbers are, but how does that help???????\\n![image](https://assets.leetcode.com/users/images/e60a16a7-a1f8-4a56-826c-5e1052af290e_1642028210.074719.png)\\nNow look at the expression Catalan(n). Looks the same right? Exactly so counting structurally unique BSTs is an application of Catalan numbers.\\n\\nCode:\\n```\\npublic int numTrees1(int n) {\\n\\treturn (int)(comb(2*n, n)/(n+1));\\n}\\npublic double comb( int n, int k ) {\\n\\tdouble res = 1;\\n\\tif ( k > n-k ) {\\n\\t\\tk = n - k;\\n\\t}\\n\\tfor ( int i=0; i<k; i++ ) {\\n\\t\\tres *= (n - i);\\n\\t\\tres /= (i + 1);\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\nResources: [Wiki](https://en.wikipedia.org/wiki/Catalan_number), [Recursive of catalan numbers taken exponential time complexity](https://stackoverflow.com/questions/27371612/catalan-numbers-recursive-function-time-complexity)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```numTress(number of nodes on left side) * numTrees(number of nodes on right side)```\n```C(i-1)```\n```\\npublic int numTrees(int n) {\\n        return recur( n );\\n    }\\n    public int recur( int n ) {\\n        if ( n<2 ) {\\n            return 1;\\n        }\\n        int res = 0;\\n        for ( int i=n; i>0; i-- ) {\\n            res += recur( i-1 ) * recur( n-i );\\n        }\\n        return res;\\n    }\\n```\n```\\nInteger[] dp;\\n    public int numTrees(int n) {\\n        dp = new Integer[n+1];\\n        return recur( n );\\n    }\\n    public int recur( int n ) {\\n        if ( n<2 ) {\\n            return 1;\\n        }\\n        if ( dp[n]!=null ) {\\n            return dp[n];\\n        }\\n        int res = 0;\\n        for ( int i=n-1; i>=0; i-- ) {\\n            res += recur( i ) * recur( n-i-1 );\\n        }\\n        return dp[n] = res;\\n    }\\n```\n```Catalan(n) = Catalan(0)*Catalan(n-1) + Catalan(1)*Catalan(n-2).....+Catalan(i)*Catalan(n-i-1)....+Catalan(n-1)*Catalan(0)```\n```\\npublic int numTrees1(int n) {\\n\\treturn (int)(comb(2*n, n)/(n+1));\\n}\\npublic double comb( int n, int k ) {\\n\\tdouble res = 1;\\n\\tif ( k > n-k ) {\\n\\t\\tk = n - k;\\n\\t}\\n\\tfor ( int i=0; i<k; i++ ) {\\n\\t\\tres *= (n - i);\\n\\t\\tres /= (i + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1649147,
                "title": "python-catalan-number-one-liner",
                "content": "```\\nimport math\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # Total number of possible Binary Search Trees with n different nodes \\n        \\n        # 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\\n        \\n        # This series is CATALEN NUMBER series \\n            \\n        # Formula = (2n)! / ((n + 1)! * n!) \\n        \\n        \\n        return math.factorial((2*n)) // (math.factorial((n + 1)) * math.factorial(n)) \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # Total number of possible Binary Search Trees with n different nodes \\n        \\n        # 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862\\n        \\n        # This series is CATALEN NUMBER series \\n            \\n        # Formula = (2n)! / ((n + 1)! * n!) \\n        \\n        \\n        return math.factorial((2*n)) // (math.factorial((n + 1)) * math.factorial(n)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574811,
                "title": "easy-detailed-explanation-dp-0ms",
                "content": "dp[i] -> number of BSTs possible for i nodes.\\n1. For every i=[1...n], we take (j=[1...i]) as root in turn and sum up all possible combinations. This gives us the total number of BSTs for i nodes.\\n2. For every j, if j is made the root, (j-1) nodes are in the left subtree and (i-j) nodes are in the right subtree of the BST.\\n3. These (j-1) nodes and (i-j) nodes can arrange among themselves.\\n4. The arrangement of (j-1) and (i-j) nodes among themselves becomes a subproblem similar to when the BST has (j-1) nodes and (i-j) nodes in total respectively.\\n5. So the summation of the products of dp[j-1] and dp[i-j] gives all possible combinations for i nodes in total. \\n\\nTime Complexity: O(n^2)\\nSpace Complexity:O(n)\\n\\n```class Solution {\\n    public int numTrees(int n) {\\n        int dp[]=new int[n+1];\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            int sum=0;\\n            for(int j=1;j<=i;j++){\\n                sum+=dp[j-1]*dp[i-j];\\n            }\\n            dp[i]=sum;\\n        }\\n        return dp[n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int numTrees(int n) {\\n        int dp[]=new int[n+1];\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            int sum=0;\\n            for(int j=1;j<=i;j++){\\n                sum+=dp[j-1]*dp[i-j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1566338,
                "title": "daily-leetcoding-challenge-november-day-8-catalan-number-approach",
                "content": "class Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=(numTrees(i-1)*numTrees(n-i));\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int numTrees(int n) {\\n        if(n==0) return 1;\\n        if(n==1 || n==2) return n;\\n        int res=0;\\n        for(int i=1;i<=n;i++){\\n            res+=(numTrees(i-1)*numTrees(n-i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1440307,
                "title": "dp-c-solution",
                "content": "Idea : \\nFor a node i as a root , all the nodes less than i will be on the left side of ith node and greater than i will be on the right side of ith node.\\nIn this two subtrees, the combinations possible is (i-1)C1 => i-1 , similarly for the other side .... so for node i, the total combinations would become (i-1) x (i+1). \\nBelow code is an implementation using DP.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int dp[n+1];\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=0;\\n            for(int j=0;j<i;j++){\\n                dp[i]+=dp[j]*dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int dp[n+1];\\n        dp[0]=dp[1]=1;\\n        for(int i=2;i<=n;i++){\\n            dp[i]=0;\\n            for(int j=0;j<i;j++){\\n                dp[i]+=dp[j]*dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423877,
                "title": "java-100-beat-memoization-with-comment",
                "content": "```\\nclass Solution {\\n    //use map as the DP cache, store the number of unique BST that the key number can generate\\n    private HashMap<Integer, Integer> map = new HashMap<>();\\n    public int numTrees(int n) {\\n        if (map.containsKey(n)) {\\n            return map.get(n);\\n        }\\n        if (n == 0) {\\n            map.put(0, 1);\\n            return 1;\\n        }\\n        int res = 0;\\n        //loop through n, because of BST, so the left side is numTrees(i - 1), and right side is numTrees(n - i)\\n        for (int i = 1; i <= n; i++) {\\n            res += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        //when we get the res, put it in the map\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```\\n\\ntime complexity will be O(n^2)\\nwhen the case like\\n1\\n\\t3\\n2\\nwe have 3 nodes and also we have 3 levels, so for each node it needs to loop n times(worst case)\\n\\nspace complexity is O(n)",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //use map as the DP cache, store the number of unique BST that the key number can generate\\n    private HashMap<Integer, Integer> map = new HashMap<>();\\n    public int numTrees(int n) {\\n        if (map.containsKey(n)) {\\n            return map.get(n);\\n        }\\n        if (n == 0) {\\n            map.put(0, 1);\\n            return 1;\\n        }\\n        int res = 0;\\n        //loop through n, because of BST, so the left side is numTrees(i - 1), and right side is numTrees(n - i)\\n        for (int i = 1; i <= n; i++) {\\n            res += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        //when we get the res, put it in the map\\n        map.put(n, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322559,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    public int numTrees(int n) {\\n        if(n==0 || n==1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        \\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           c+=numTrees(i-1)*numTrees(n-i);    \\n        }\\n        map.put(n,c);\\n        return map.get(n);\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/d3129d3e-4cb3-4e57-b71d-a051506c2ba2_1625806739.1477046.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Integer> map=new HashMap<>();\\n    public int numTrees(int n) {\\n        if(n==0 || n==1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        \\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           c+=numTrees(i-1)*numTrees(n-i);    \\n        }\\n        map.put(n,c);\\n        return map.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309476,
                "title": "c-very-simple-dp-easy-explaination-with-comments-100-faster",
                "content": "Hi,\\nFor this question we have sorted sequence and we need to make different Binary Search Trees. \\nSo lets discuss,\\nIf we choose any number from the sequence say it has index ```i``` and we have total ```n``` nodes. Now to calculate the  answer for this ```i``` we can observe that answer would be just ```number of ways of left subtree * number of ways of right subtree``` . Hence problem now reduced to a smaller subproblems ``` (i-1)-0```  and  ```n-(i+1)```.\\n\\nLets see an example \\nif ```n=4``` then\\n- for ```i=1``` we have ```left = 0``` and ```right = 3``` so this will add ```ways(0) * ways(3)``` to answer\\n- for ```i=2``` we have ```left = 1``` and ```right = 2``` so this will add ```ways(1) * ways(2)``` to answer\\n- for ```i=3``` we have ```left = 2``` and ```right = 1``` so this will add ```ways(2) * ways(1)``` to answer\\n- for ```i=4``` we have ```left = 3``` and ```right = 0``` so this will add ```ways(3) * ways(0)``` to answer\\n\\n ```ways(0) = 1, ways(1) = 1, ways(2) =2``` are trivial so now we need to calculate only ```ways(3)``` by similar procedure we can find ```ways(3)``` and put it to the final answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n\\t\\n\\t// maximum value of n is 19 so take array of size 20 to be safe\\n        vector<int> dp(20,0);\\n\\t\\t\\n\\t\\t// initialize trivial values to it\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        if(n<3) return dp[n];\\n\\t\\t\\n\\t\\t//calculate smaller values which are less than n which will help us to find final answer\\n        for(int i=3;i<=n;i++){\\n            int temp=0;\\n            for(int j=0;j<i;j++){\\n                temp+= dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=temp;\\n        }\\n\\t\\t// return answer\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```i```\n```n```\n```i```\n```number of ways of left subtree * number of ways of right subtree```\n``` (i-1)-0```\n```n-(i+1)```\n```n=4```\n```i=1```\n```left = 0```\n```right = 3```\n```ways(0) * ways(3)```\n```i=2```\n```left = 1```\n```right = 2```\n```ways(1) * ways(2)```\n```i=3```\n```left = 2```\n```right = 1```\n```ways(2) * ways(1)```\n```i=4```\n```left = 3```\n```right = 0```\n```ways(3) * ways(0)```\n```ways(0) = 1, ways(1) = 1, ways(2) =2```\n```ways(3)```\n```ways(3)```\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n\\t\\n\\t// maximum value of n is 19 so take array of size 20 to be safe\\n        vector<int> dp(20,0);\\n\\t\\t\\n\\t\\t// initialize trivial values to it\\n        dp[0]=1;\\n        dp[1]=1;\\n        dp[2]=2;\\n        if(n<3) return dp[n];\\n\\t\\t\\n\\t\\t//calculate smaller values which are less than n which will help us to find final answer\\n        for(int i=3;i<=n;i++){\\n            int temp=0;\\n            for(int j=0;j<i;j++){\\n                temp+= dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=temp;\\n        }\\n\\t\\t// return answer\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173886,
                "title": "c-100-faster-and-easy-explanation",
                "content": "**Given an integer n, return the number of structurally unique BST\\'s (binary search trees) which has exactly n nodes of unique values from 1 to n.**\\n\\nIf a tree with a root R has 2 unique combinations in LST(left sub-tree) and 3 unique combinations in RST, then the total number of structuraly unique combinations of that tree with root R is 2*3=6\\n\\nSuppose we have a tree with 4 nodes[1,2,3,4] then we can find structurally unique BSTs as follows:\\n* structurally unique BSTs with root 1 are:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t`\\t    1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tNULL   (2,3,4)--------------> 3 combinations on rhs\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcount=c0*c3`\\n* with root 2:[[1],[2],[3,4]]-------------->c1*c2\\n* with root 3:[[1,2],[3],[4]]-------------->c2*c1\\n* with root 4: [[1,2,3],[4]]--------------->c3*c0;\\n\\nTotal number of combinations is :c0c3+c1c2+c2c1+c3c0;\\nwe caqn generalize this math equation as : Cn=summation of(ci*cn-i-1) from i=0 to n\\n\\nUsing this formula we can calculate for each index and return the nth index\\n\\nCode:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int c[n+1];\\n        c[0]=1;c[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            c[i]=0;\\n            for(int j=0;j<i;j++)\\n                c[i]+=c[j]*c[i-j-1];\\n        }\\n        return c[n];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        int c[n+1];\\n        c[0]=1;c[1]=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            c[i]=0;\\n            for(int j=0;j<i;j++)\\n                c[i]+=c[j]*c[i-j-1];\\n        }\\n        return c[n];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881535,
                "title": "java-dp-top-down",
                "content": "```\\nclass Solution {\\n     HashMap<Integer,Integer> map=new HashMap();\\n    public int numTrees(int n) {\\n        \\n         if(n == 0 || n == 1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int count=0;\\n        for(int i = 1; i <= n; i++)\\n            count += numTrees(i - 1) * numTrees(n - i);\\n        map.put(n, count);\\n        \\n        \\n        \\n        return map.get(n);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     HashMap<Integer,Integer> map=new HashMap();\\n    public int numTrees(int n) {\\n        \\n         if(n == 0 || n == 1)\\n            return 1;\\n        if(map.containsKey(n))\\n            return map.get(n);\\n        int count=0;\\n        for(int i = 1; i <= n; i++)\\n            count += numTrees(i - 1) * numTrees(n - i);\\n        map.put(n, count);\\n        \\n        \\n        \\n        return map.get(n);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703914,
                "title": "python-top-down-dp-more-straightforward-from-brute-force-to-dp",
                "content": "I\\'ve gone through many most-votes posts and most of them are about bottom-up DP. If you know DP well, then you can come up with that easily. However, we can derive the top-down approach from the brute force solution in a more straightforward way, so that even you may not be aware of using DP in the first place, you still will find that in the middle.\\n\\nTo build a BST from ```[1...n]```, we only need to divide it into three parts: the left subtree, root, and the right subtree. For both subtrees, similar processing will be applied again. Well, recursions happened.\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # build a BST from [left...right]\\n        def helper(left=1,right=n):\\n            if left >= right:\\n                return 1\\n            ret = 0\\n            for i in range(left,right+1):\\n                l_tree = helper(left,i-1)\\n                r_tree = helper(i+1,right)\\n                ret += l_tree * r_tree\\n            return ret\\n        return helper()\\n```\\nNot surprisingly, we will get ```TLE```. The problem is that, many redundant computations will be made. For example, ```helper(1,2)``` will be computed every time when you want to build a subtree from ```[1...n], n>2```. To optimise it, we can store the ```helper(1,2)``` for further references. There it is, DP~\\nWe can implement a hashmap to store the result, or in Python, we simply add ```@lru_cache(None)```:\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        @lru_cache(None)\\n        def helper(left=1,right=n):\\n            if left >= right:\\n                return 1\\n            ret = 0\\n            for i in range(left,right+1):\\n                l_tree = helper(left,i-1)\\n                r_tree = helper(i+1,right)\\n                ret += l_tree * r_tree\\n            return ret\\n        return helper()\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```[1...n]```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        # build a BST from [left...right]\\n        def helper(left=1,right=n):\\n            if left >= right:\\n                return 1\\n            ret = 0\\n            for i in range(left,right+1):\\n                l_tree = helper(left,i-1)\\n                r_tree = helper(i+1,right)\\n                ret += l_tree * r_tree\\n            return ret\\n        return helper()\\n```\n```TLE```\n```helper(1,2)```\n```[1...n], n>2```\n```helper(1,2)```\n```@lru_cache(None)```\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        @lru_cache(None)\\n        def helper(left=1,right=n):\\n            if left >= right:\\n                return 1\\n            ret = 0\\n            for i in range(left,right+1):\\n                l_tree = helper(left,i-1)\\n                r_tree = helper(i+1,right)\\n                ret += l_tree * r_tree\\n            return ret\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694086,
                "title": "python-one-liner",
                "content": "You can notice that the answer is the *n*^th Catalan number wich is the difference between central element in Pascal triangle and it\\'s adjacent one, so we just use the simplifyed \\n(*2n* choose *n*) - (*2n* choose *n+1*) formula:\\n\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return math.factorial(2*n)//(math.factorial(n)*math.factorial(n+1))\\n\\t\\t",
                "solutionTags": [],
                "code": "You can notice that the answer is the *n*^th Catalan number wich is the difference between central element in Pascal triangle and it\\'s adjacent one, so we just use the simplifyed \\n(*2n* choose *n*) - (*2n* choose *n+1*) formula:\\n\\n\\n```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        return math.factorial(2*n)//(math.factorial(n)*math.factorial(n+1))\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 667777,
                "title": "catalan-number-explained-java",
                "content": "**Note: This solution does not fare that well in memory nor runtime. It\\'s clearly not the best solution (as compared to DP) but I thought it\\'s the easiest to understand and wish to explain the concept behind.**\\n\\nSince we are dealing with BSTs with unique elements, we know that everything in the left sub-tree is less than the root and everything in the right sub-tree is greater than the root. Now, the input given is 1,2,3,...n. So we know there are n nodes and hence when we consider unique BSTs, we know there can be n possible roots. \\n\\nLet\\'s say we pick number i as the root. With the given input, we know that there are i - 1 elements in the left-subtree of the root. (say if I pick 3 as the root, the left subtree can only contain 1 and 2, hence 3 - 1 = 2 elements) As such, in the right-subtree of the chosen root, we know there are n - i elements.\\n\\nSo what is the total number of BSTs with number i as the root? This is given by t(i - 1) * t(n - 1) because the different permutations in the left-subtree and right-subtree are independent events. t is the function of the number of unique BSTs for a given input. \\n\\nNow we know what\\'s the total number of BSTs with number i as the root and we know if the input is n, there can be n possible roots, we thus find the formula to be t(i - 1) * t (n - i) from i = 1 .... to n.\\n\\nLet\\'s convert this to code:\\n```\\n//Recursion using catalan number\\nclass Solution {\\n    public int numTrees(int n) {\\n\\t\\t//this is the base case, when n = 0 we get an empty BST; when n = 1 we get a BST with a root\\n        if (n == 0 || n == 1) return 1;\\n        int toReturn = 0;\\n\\t\\t//the for-loop below is simply t(i - 1) * t (n - i) from i = 1 .... to n in my explanation\\n        for (int i = 1; i <= n; i++) {\\n            toReturn += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        return toReturn;\\n    }\\n}\\n```\\n\\nI hope this explanation helps in the understanding of the formula! :) But do note that there are many better solutions out there!",
                "solutionTags": [],
                "code": "```\\n//Recursion using catalan number\\nclass Solution {\\n    public int numTrees(int n) {\\n\\t\\t//this is the base case, when n = 0 we get an empty BST; when n = 1 we get a BST with a root\\n        if (n == 0 || n == 1) return 1;\\n        int toReturn = 0;\\n\\t\\t//the for-loop below is simply t(i - 1) * t (n - i) from i = 1 .... to n in my explanation\\n        for (int i = 1; i <= n; i++) {\\n            toReturn += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        return toReturn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589578,
                "title": "c-detailed-explanation-simple-code",
                "content": "```C++\\n/*\\nchoose 1 as the root, we have 0 node for the left tree, i-1 for the right;\\nchoose 2 as the root, we have 1 node for the left tree, i-2 for the right;\\n...\\nchoose i as the root, we have i-1 nodes for the left tree, 0 for the right.\\n\\nG[0] = 1\\nG[1] = 1\\nG(n) = G(0)*G(n-1) + G(1)*G(n-2) + \\u2026 + G(n-1)*G(0)\\n*/\\n\\nint numTrees( int n ) {\\n    if( n == 1 || n == 0 ) return 1;\\n    unordered_map<int, int> hash;\\n    hash[0] = 1;\\n    hash[1] = 1;\\n        \\n    int result = 0;\\n    for( int i=0; i < n; i++ ) {\\n        if( hash.find(i) == hash.end() )\\n            hash[i] = numTrees( i );\\n        if( hash.find( n-i-1 ) == hash.end() )\\n            hash[ n-i-1 ] = numTrees( n-i-1 );\\n        result += hash[i] * hash[ n - i - 1 ];   \\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    int numTrees( int n ) {\\n        if( n == 0 ) return 1;\\n        vector<int> trees( n + 1);\\n        trees[0] = 1;\\n        trees[1] = 1;\\n        for( int i=2; i <= n; i++ ) {\\n            for( int j=0; j < i; j++ ) {\\n                trees[i] += trees[j]*trees[i-j-1];   \\n            }\\n        }\\n        return trees[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\n/*\\nchoose 1 as the root, we have 0 node for the left tree, i-1 for the right;\\nchoose 2 as the root, we have 1 node for the left tree, i-2 for the right;\\n...\\nchoose i as the root, we have i-1 nodes for the left tree, 0 for the right.\\n\\nG[0] = 1\\nG[1] = 1\\nG(n) = G(0)*G(n-1) + G(1)*G(n-2) + \\u2026 + G(n-1)*G(0)\\n*/\\n\\nint numTrees( int n ) {\\n    if( n == 1 || n == 0 ) return 1;\\n    unordered_map<int, int> hash;\\n    hash[0] = 1;\\n    hash[1] = 1;\\n        \\n    int result = 0;\\n    for( int i=0; i < n; i++ ) {\\n        if( hash.find(i) == hash.end() )\\n            hash[i] = numTrees( i );\\n        if( hash.find( n-i-1 ) == hash.end() )\\n            hash[ n-i-1 ] = numTrees( n-i-1 );\\n        result += hash[i] * hash[ n - i - 1 ];   \\n    }\\n    return result;\\n}\\n\\nclass Solution {\\npublic:\\n    int numTrees( int n ) {\\n        if( n == 0 ) return 1;\\n        vector<int> trees( n + 1);\\n        trees[0] = 1;\\n        trees[1] = 1;\\n        for( int i=2; i <= n; i++ ) {\\n            for( int j=0; j < i; j++ ) {\\n                trees[i] += trees[j]*trees[i-j-1];   \\n            }\\n        }\\n        return trees[n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428600,
                "title": "golang-dp-solution-with-explanation",
                "content": "```\\n/*\\np from 1 to n, each node use to root, left tree has p-1 nodes, right tree has n-p nodes\\n\\nf(n): numbers of unique BST with n nodes\\nn \\tf(n)\\n0:\\tf(0) = 1\\n1:\\tf(0) * f(0) = 1 (right 0 left 0)\\n2:\\tf(1) * f(0) + f(0) * f(1) = 1 + 1 = 2 (right 1 left 0\\uFF0Cright 0 left 1)\\n3\\uFF1A\\tf(2) * f(0) + f(1) * f(1) + f(0) * f(2) = 2 + 1 + 2 = 5 (right 2 left 0\\uFF0Cright 1 left 1\\uFF0Cright 0 left 2)\\n4\\uFF1A\\tf(3) * f(0) + f(2) * f(1) + f(1) * f(2) + f(0) * f(3) = 5 + 2 + 2 + 5 = 14 (right 3 left 0\\uFF0Cright 2 left 1\\uFF0Cright 1 left 2\\uFF0Cright 0 left 3)\\n5\\uFF1A\\tf(4) * f(0) + f(3) * f(1) + f(2) * f(2) + f(1) * f(3) + f(0) * f(4) = 14 + 5 + 4 + 5 + 14 = 42 (right 4 left 0\\uFF0Cright 3 left 1\\uFF0Cright 2 left 2\\uFF0Cright 1 left 3\\uFF0Cright 0 left 4)\\n......\\nn:\\ti from n-1 to 0, j=n-1-i, f(n) init to 0, f(n) += f(i) * f(j) \\n*/\\n\\nfunc f(n int, pool []int) int {\\n\\tif pool[n] != 0 {\\n\\t\\treturn pool[n]\\n\\t}\\n\\n\\tsum := 0\\n\\tfor i := n-1; i >= 0; i--{\\n\\t\\tsum += f(i, pool) * f(n-1-i, pool)\\n\\t}\\n\\tpool[n] = sum\\n\\treturn sum\\n}\\n\\nfunc numTrees(n int) int {\\n    pool := make([]int, n+1) //save f(i)\\n    pool[0] = 1 //recursive base case, init here\\n    return f(n, pool)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\np from 1 to n, each node use to root, left tree has p-1 nodes, right tree has n-p nodes\\n\\nf(n): numbers of unique BST with n nodes\\nn \\tf(n)\\n0:\\tf(0) = 1\\n1:\\tf(0) * f(0) = 1 (right 0 left 0)\\n2:\\tf(1) * f(0) + f(0) * f(1) = 1 + 1 = 2 (right 1 left 0\\uFF0Cright 0 left 1)\\n3\\uFF1A\\tf(2) * f(0) + f(1) * f(1) + f(0) * f(2) = 2 + 1 + 2 = 5 (right 2 left 0\\uFF0Cright 1 left 1\\uFF0Cright 0 left 2)\\n4\\uFF1A\\tf(3) * f(0) + f(2) * f(1) + f(1) * f(2) + f(0) * f(3) = 5 + 2 + 2 + 5 = 14 (right 3 left 0\\uFF0Cright 2 left 1\\uFF0Cright 1 left 2\\uFF0Cright 0 left 3)\\n5\\uFF1A\\tf(4) * f(0) + f(3) * f(1) + f(2) * f(2) + f(1) * f(3) + f(0) * f(4) = 14 + 5 + 4 + 5 + 14 = 42 (right 4 left 0\\uFF0Cright 3 left 1\\uFF0Cright 2 left 2\\uFF0Cright 1 left 3\\uFF0Cright 0 left 4)\\n......\\nn:\\ti from n-1 to 0, j=n-1-i, f(n) init to 0, f(n) += f(i) * f(j) \\n*/\\n\\nfunc f(n int, pool []int) int {\\n\\tif pool[n] != 0 {\\n\\t\\treturn pool[n]\\n\\t}\\n\\n\\tsum := 0\\n\\tfor i := n-1; i >= 0; i--{\\n\\t\\tsum += f(i, pool) * f(n-1-i, pool)\\n\\t}\\n\\tpool[n] = sum\\n\\treturn sum\\n}\\n\\nfunc numTrees(n int) int {\\n    pool := make([]int, n+1) //save f(i)\\n    pool[0] = 1 //recursive base case, init here\\n    return f(n, pool)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 261505,
                "title": "clean-java-dp-solution-with-detailed-explanation-and-tree-construction",
                "content": "**Explanation**: \\nWe need to define two functions:\\n\\n```G(n)```: the number of unique BST for a sequence of length n.\\n\\n```F(i, n), 1 <= i <= n```: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.\\n\\nAs one can see, G(n) is the actual function we need to calculate in order to solve the problem. And G(n) can be derived from F(i, n), which at the end, would recursively refer to G(n).\\n\\nFirst of all, given the above definitions, we can see that the total number of unique BST G(n), is the sum of BST F(i) using each number i as a root.\\ni.e. ```G(n) = F(1, n) + F(2, n) + ... + F(n, n). ```\\n\\nWhenever we have a tree with only 1 root, then we have a only 1 combination possible. So that\\'s why dp[1] = 1. Also we initialize dp[0] = 1, because we are going to get cases where we are going to need dp[0]\\n```\\n\\t\\t\\t\\t\\t\\t     G(3)\\n\\t\\t\\t\\t\\t/             |            \\\\\\n\\t\\t\\t\\t    F(1,3)            F(2,3)        F(3,3)\\n\\t\\t\\t\\t    /   \\\\              /  \\\\           /  \\\\\\n\\t\\t  \\t        G(0)  G(2)           G(1) G(1)      G(2) G(0)   \\n ```\\nSo the  code is: \\n\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n\\t int[] dp = new int[n + 1];\\n     dp[0] = 1;\\n     dp[1] = 1;\\n        \\n     for (int i = 2; i <= n; ++i) {\\n          for (int j = 1; j <= i; ++j) {\\n                dp[i] += dp[j - 1] * dp[i - j];\\n            } \\n         }\\n \\n\\treturn dp[n];\\n    }\\n}\\n\\nExample: \\n\\nFor n = 3\\nInitial -> dp[0] = 1, dp[1] = 1\\n\\n1. Iteration 1: i = 2, means we have a total of 2 nodes in our BST. \\n    i)  dp[2] = dp[2] + dp[0]*dp[1] = 0 + 1*1 = 1 <-- We have 0 node on left and 1 node on right subtree out of the total 2 nodes, bcoz one node is going to be the root node so that\\'s why 0 nodes on left and 1 node on right.\\n    ii) dp[2] = dp[2] + dp[1]*dp[0] = 1 + 1*1 = 2 <-- We are having 1 node on left and 0 node on the right subtree of 2 nodes.\\n    The cases of the above one are: \\n    i)     1            ii)      2\\n            \\\\                   /\\n             2                 1\\n    \\n2. Iteration 2: i = 3, means we have a total of 3 nodes in our BST.\\n    i)  dp[3] = dp[3] + dp[0]*dp[2] = 0 + 1*2 = 2 <-- We have 0 nodes on the left and 2 nodes on the right. Final answer is 2 which means that we have 2 combinations available for 0 nodes on left and 2 nodes on right. \\n    ii) dp[3] = dp[3] + dp[1]*dp[1] = 2 + 1*1 = 3 <-- We have 1 nodes on the left and 1 nodes on the right. Final answer is 3 which means that we have 1 combinations available for 1 nodes on left and 1 nodes on right, with addition of 2 previous combinations\\n    iii)  dp[3] = dp[3] + dp[2]*dp[0] = 3 + 2*1 = 5 <-- We have 2 nodes on the left and 0 nodes on the right. Final answer is 5 which means that we have total 2 combinations available for 2 nodes on left and 0 nodes on right, with addition of 3 previous combinations\\n    \\n     The cases of the above one are: \\n    i) 0 nodes on the left and 2 nodes on the right = 2 combinations\\n           1                   1\\n            \\\\                   \\\\\\n             2                   3\\n              \\\\                 /\\n               3               2\\n    ii) 1 nodes on the left and 1 nodes on the right = 1 combination\\n                 2\\n                / \\\\\\n               1   3\\n    iii) 2 nodes on the left and 0 nodes on the right = 2 combination\\n              3                   3\\n             /                   /\\n             1                  2\\n              \\\\                /\\n               2              1\\n",
                "solutionTags": [],
                "code": "```G(n)```\n```F(i, n), 1 <= i <= n```\n```G(n) = F(1, n) + F(2, n) + ... + F(n, n). ```\n```\\n\\t\\t\\t\\t\\t\\t     G(3)\\n\\t\\t\\t\\t\\t/             |            \\\\\\n\\t\\t\\t\\t    F(1,3)            F(2,3)        F(3,3)\\n\\t\\t\\t\\t    /   \\\\              /  \\\\           /  \\\\\\n\\t\\t  \\t        G(0)  G(2)           G(1) G(1)      G(2) G(0)   \\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 31747,
                "title": "my-simple-dp-solution-with-explanation",
                "content": "   \\n\\n       basic idea is the recursion relationship between dps\\n       eg. n=4 \\n       1 is the root: left 0 node right 3 nodes :temp[1]=dp[0]*dp[3]=5\\n       2 is the root: left 1 node right 2 nodes :temp[2]=dp[1]*dp[2]=2\\n       3 is the root: left 2 node right 1 nodes :temp[3]=dp[2]*dp[1]=2\\n       4 is the root: left 3 node right 0 nodes :temp[4]=dp[3]*dp[0]=5\\n       dp[4]=temp[1]+...temp[4]=14\\n\\n     public int numTrees(int n) {\\n        \\tif(n==0) return 0;\\n        \\tif(n==1) return 1;\\n            int[] dp=new int[n+1];\\n            dp[0]=1;\\n            dp[1]=1;//n=1\\n            dp[2]=2;//n=2\\n            for(int i=3;i<=n;i++){\\n            \\tfor(int j=1;j<=i;j++){\\n            \\t\\tdp[i]+=dp[j-1]*dp[i-j];\\n            \\t}\\n            }\\n            return dp[n];\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "   \\n\\n       basic idea is the recursion relationship between dps\\n       eg. n=4 \\n       1 is the root: left 0 node right 3 nodes :temp[1]=dp[0]*dp[3]=5\\n       2 is the root: left 1 node right 2 nodes :temp[2]=dp[1]*dp[2]=2\\n       3 is the root: left 2 node right 1 nodes :temp[3]=dp[2]*dp[1]=2\\n       4 is the root: left 3 node right 0 nodes :temp[4]=dp[3]*dp[0]=5\\n       dp[4]=temp[1]+...temp[4]=14\\n\\n     public int numTrees(int n) {\\n        \\tif(n==0) return 0;\\n        \\tif(n==1) return 1;\\n            int[] dp=new int[n+1];\\n            dp[0]=1;\\n            dp[1]=1;//n=1\\n            dp[2]=2;//n=2\\n            for(int i=3;i<=n;i++){\\n            \\tfor(int j=1;j<=i;j++){\\n            \\t\\tdp[i]+=dp[j-1]*dp[i-j];\\n            \\t}\\n            }\\n            return dp[n];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 31765,
                "title": "dp-solution-java",
                "content": "      public int numTrees(int n) {\\n           \\n            int[] tree = new int[n+1];\\n            tree[0]=1;\\n            tree[1]=1;\\n            for(int i=2; i<=n; i++){\\n                int sum=0;\\n                for(int j=1; j<=i; j++){\\n                    sum=sum+tree[j-1]*tree[i-j];\\n                }\\n                tree[i]=sum;\\n            }\\n            return tree[n];\\n        }",
                "solutionTags": [],
                "code": "      public int numTrees(int n) {\\n           \\n            int[] tree = new int[n+1];\\n            tree[0]=1;\\n            tree[1]=1;\\n            for(int i=2; i<=n; i++){\\n                int sum=0;\\n                for(int j=1; j<=i; j++){\\n                    sum=sum+tree[j-1]*tree[i-j];\\n                }\\n                tree[i]=sum;\\n            }\\n            return tree[n];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 31762,
                "title": "math-solution",
                "content": "    public class Solution {\\n        public int numTrees(int n) {\\n            long k =1;\\n            for (int i = 2; i <= n; i++) \\n            {\\n                k = 2*(2*i-1)*k/(i+1);\\n            }\\n            int res = Math.toIntExact(k);\\n            return res;\\n        }\\n    }\\nbased on [WIKI Catalan Number][1]\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Catalan_number",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n        public int numTrees(int n) {\\n            long k =1;\\n            for (int i = 2; i <= n; i++) \\n            {\\n                k = 2*(2*i-1)*k/(i+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 31785,
                "title": "catalan-numbers-4-lines-java-solution",
                "content": "  public int numTrees(int n) {\\n\\n        double count = 1.0;\\n        for (double i = 1.0; i <= n; i = i + 1.0) \\n            count *= ((i + n) / i);\\n        return (int) Math.round(count / (n+1));\\n  }",
                "solutionTags": [],
                "code": "  public int numTrees(int n) {\\n\\n        double count = 1.0;\\n        for (double i = 1.0; i <= n; i = i + 1.0) \\n            count *= ((i + n) / i);\\n        return (int) Math.round(count / (n+1));\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 31805,
                "title": "easy-to-read-dp-solution-though-not-the-first-to-the-party",
                "content": "    // DP solution based upon the idea that the number of trees with \"n\" elements is\\n    // related to the number of left and right subtrees that can be constructed\\n    // using 0 to n-1 elements.\\n\\n    public int numTrees(int n) {\\n    \\n        int[] trees = new int[n+1];\\n        trees[0] = 1;\\n        trees[1] = 1;\\n\\n        for (int tree=2; tree <= n; tree++) {\\n            int numTrees = 0;\\n            for (int i=1; i <= tree; i++) {\\n                int numLTrees = trees[i-1];\\n                int numRTrees = trees[tree-i];\\n                numTrees += numLTrees * numRTrees;\\n            }\\n            trees[tree] = numTrees;\\n        }\\n        \\n        return trees[n];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    // DP solution based upon the idea that the number of trees with \"n\" elements is\\n    // related to the number of left and right subtrees that can be constructed\\n    // using 0 to n-1 elements.\\n\\n    public int numTrees(int n) {\\n    \\n        int[] trees = new int[n+1];\\n        trees[0] = 1;\\n        trees[1] = 1;\\n\\n        for (int tree=2; tree <= n; tree++) {\\n            int numTrees = 0;\\n            for (int i=1; i <= tree; i++) {\\n                int numLTrees = trees[i-1];\\n                int numRTrees = trees[tree-i];\\n                numTrees += numLTrees * numRTrees;\\n            }\\n            trees[tree] = numTrees;\\n        }\\n        \\n        return trees[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31833,
                "title": "0ms-10line-dp-c-solution-with-explain",
                "content": "when ask f(n),the root of possible tree can be 1,2...n,if the root is i,the possible number  f(n,i) is the possible number of the left tree multiply by the right;the elements of left child tree is 1...i-1, number is i-1; the right is i+1...n,number is n-i;so f(n,i)=f(i-1)*f(n-i),f(n)=sum( f(n,i) ) \\n\\n    int numTrees(int n) {\\n        int dp[10000];\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            dp[i]=0;\\n            for(int j=1;j<=i;j++){\\n                dp[i]+=dp[j-1]*dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "solutionTags": [],
                "code": "when ask f(n),the root of possible tree can be 1,2...n,if the root is i,the possible number  f(n,i) is the possible number of the left tree multiply by the right;the elements of left child tree is 1...i-1, number is i-1; the right is i+1...n,number is n-i;so f(n,i)=f(i-1)*f(n-i),f(n)=sum( f(n,i) ) \\n\\n    int numTrees(int n) {\\n        int dp[10000];\\n        dp[0]=1;\\n        for(int i=1;i<=n;i++){\\n            dp[i]=0;\\n            for(int j=1;j<=i;j++){\\n                dp[i]+=dp[j-1]*dp[i-j];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31841,
                "title": "shorter-solution-in-java-with-a-minor-issue",
                "content": "    class UniqueBSTs {\\n     public int numTrees(int n){\\n        int sum = 0;\\n        if(n == 0) return 1;\\n        for(int i = 1; i <= n; i++)\\n           sum += numTress(n -i) * numTrees(i - 1);\\n      }\\n      return sum;\\n    }  \\n\\nThe solution is accepted at time cost 205ms;\\nOne minor issue is when n = 0, then this solution would give 1. But actually 0 nodes should generate 0 trees.\\nOr this issue is acceptable?",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "    class UniqueBSTs {\\n     public int numTrees(int n){\\n        int sum = 0;\\n        if(n == 0) return 1;\\n        for(int i = 1; i <= n; i++)\\n           sum += numTress(n -i) * numTrees(i - 1);\\n      }\\n      return sum;\\n    }  \\n\\nThe solution is accepted at time cost 205ms;\\nOne minor issue is when n = 0, then this solution would give 1. But actually 0 nodes should generate 0 trees.\\nOr this issue is acceptable?",
                "codeTag": "Java"
            },
            {
                "id": 3607964,
                "title": "c-dp",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int f(int n){\\n         if(n<=1) return 1;\\n         if(dp[n]!=-1) return dp[n];\\n         int ans=0;\\n         for(int i=1 ; i<=n ; i++){\\n             int left = f(i-1);\\n             int right = f(n-i);                 \\n             ans+=left*right;\\n         }\\n        \\n        return dp[n] = ans;\\n         \\n    }\\n    int numTrees(int n) {\\n        \\n        dp = vector<int>(n+1,-1);\\n        return f(n);\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> dp;\\n    int f(int n){\\n         if(n<=1) return 1;\\n         if(dp[n]!=-1) return dp[n];\\n         int ans=0;\\n         for(int i=1 ; i<=n ; i++){\\n             int left = f(i-1);\\n             int right = f(n-i);                 \\n             ans+=left*right;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3105865,
                "title": "beats-100-easiest-solution-using-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n  int exe(int n , vector<int> &dp){\\nif(n==0 || n==1)\\nreturn 1;\\n\\nif(dp[n]!=-1)\\nreturn dp[n];\\n\\nint ans=0;\\nfor(int i=1; i<=n; i++){\\n    ans+=exe(i-1,dp)*exe(n-i,dp);\\n}\\nreturn dp[n]=ans;\\n  }\\n\\n int numTrees(int n) {\\n    vector<int>dp(n+1,-1);\\n    return exe(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  int exe(int n , vector<int> &dp){\\nif(n==0 || n==1)\\nreturn 1;\\n\\nif(dp[n]!=-1)\\nreturn dp[n];\\n\\nint ans=0;\\nfor(int i=1; i<=n; i++){\\n    ans+=exe(i-1,dp)*exe(n-i,dp);\\n}\\nreturn dp[n]=ans;\\n  }\\n\\n int numTrees(int n) {\\n    vector<int>dp(n+1,-1);\\n    return exe(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967513,
                "title": "c-detailed-explanation-of-recursion-fourmula-used-of-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Total number of binary search tree is sum of number of subtree with each root\\n- Total = bst(root1) + bst(root2) + bst(root3) \\nF(x) -> gives number of unique bst with x number of nodes \\nG(y) -> gives number of BST with root elemnt y \\n\\nRecursive Define G(Y) : \\nG(y) = number of left subtree with y root * number of right subtree of y as root\\n\\nx1 = number of nodes in left subtree \\nHence F(x1) = number of left subtree with root y \\nx2 = number of nodes in right subtree\\nHence F(x2) = number of right subtree with root y \\n\\nG(y)= F(x1)*F(x2)\\n\\nIn this Quesition n nodew with value 1 ,2 ,3 , 4 \\n \\nF(n) = G(1) + G(2) + G(3) + G(4) + G(5) +.....+ G(n)\\nG(1) = F(0) * F(n-1-0)\\nG(2) = F(1) * F(n-2)\\nG(3) = F(2) * F(n-3) \\n\\nF(n)\\n{\\n    for( int j = 0 ; j < n ; ++j)\\n    {\\n        res += F(j) * F(n-1-j);  \\n    }\\n}\\n \\n- Number of Subtree is only depend on number of nodes \\ndoes not depend on wiche are they numbers \\ne.g 2 node 1,2 or 3,4\\nnumber of bst : \\n1        2        3       4            \\n \\\\     /           \\\\     /\\n  2   1             4   3 \\n\\nwe can replace by 1,2 by 3,4  \\nBST : one rule to follow \\nnodes on left subtree are < root->val\\nnodes on right subtree are > root->val \\n\\n# Recusion is Solved Using Dp memo & iterative\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int i )\\n    {\\n        if( i ==0 ) return 1; // Number of bst 1 nodes present in tree -> 1 \\n         if(i ==1) return 1; // Number of BST conting 1 node ->1\\n         \\n         int res = 0 ; \\n          for( int j = 0 ; j < i ; ++j ) \\n          res += rec(j)*rec(i-j-1);  // adding number of subtree with root i+1 \\n          returnres;\\n    }\\n    int numTrees(int n) {\\n\\n        vector<int> dp(n+1,-1);  \\n        dp[0]=1;\\n        dp[1]=1;\\n        for (int i = 2 ;i <= n ; ++i )\\n        {\\n            int res = 0;\\n            for (int j = 0 ; j < i ; ++j ) // adding number of subtree with root 0 to n-1 \\n            {\\n                res += dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=res;\\n        }  \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(int i )\\n    {\\n        if( i ==0 ) return 1; // Number of bst 1 nodes present in tree -> 1 \\n         if(i ==1) return 1; // Number of BST conting 1 node ->1\\n         \\n         int res = 0 ; \\n          for( int j = 0 ; j < i ; ++j ) \\n          res += rec(j)*rec(i-j-1);  // adding number of subtree with root i+1 \\n          returnres;\\n    }\\n    int numTrees(int n) {\\n\\n        vector<int> dp(n+1,-1);  \\n        dp[0]=1;\\n        dp[1]=1;\\n        for (int i = 2 ;i <= n ; ++i )\\n        {\\n            int res = 0;\\n            for (int j = 0 ; j < i ; ++j ) // adding number of subtree with root 0 to n-1 \\n            {\\n                res += dp[j]*dp[i-j-1];\\n            }\\n            dp[i]=res;\\n        }  \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723339,
                "title": "simple-approach-solved-without-catalan-numbers-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolving the problem using recursion considering each node as root each time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMentioned as Comments\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) --> auxilliary stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrange(int i, int j, int n, vector<int>& dp){\\n        // base case\\n        if(i > j) return 1;\\n        if(i == j) return 1;\\n\\n        // dp check\\n        if(dp[j-i+1]!=-1) return dp[j-i+1];\\n\\n        // approach: arrange(i, j, n, dp) --> function which returns no. of bst from [i...j]\\n        // we iterate through the entire [i...j] and take each element as root and generate no. of\\n        // possibilities for its left and right subtrees.\\n        \\n        // Note: 1D DP optimized version\\n\\n        int ans = 0;\\n        for(int k=i; k<=j; k++){\\n            ans += arrange(i, k-1, n, dp) * arrange(k+1, j, n, dp);\\n        }\\n        return dp[j-i+1] = ans;\\n    }\\n    int numTrees(int n) {\\n        // memoization:\\n        // vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        // we can further optimize it to 1D DP, as i and j need not to be unique, since we are not given\\n        // an array, only the no. of elements b/w i and j matters to us.\\n        vector<int> dp(n+1, -1);\\n        return arrange(0, n-1, n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrange(int i, int j, int n, vector<int>& dp){\\n        // base case\\n        if(i > j) return 1;\\n        if(i == j) return 1;\\n\\n        // dp check\\n        if(dp[j-i+1]!=-1) return dp[j-i+1];\\n\\n        // approach: arrange(i, j, n, dp) --> function which returns no. of bst from [i...j]\\n        // we iterate through the entire [i...j] and take each element as root and generate no. of\\n        // possibilities for its left and right subtrees.\\n        \\n        // Note: 1D DP optimized version\\n\\n        int ans = 0;\\n        for(int k=i; k<=j; k++){\\n            ans += arrange(i, k-1, n, dp) * arrange(k+1, j, n, dp);\\n        }\\n        return dp[j-i+1] = ans;\\n    }\\n    int numTrees(int n) {\\n        // memoization:\\n        // vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        // we can further optimize it to 1D DP, as i and j need not to be unique, since we are not given\\n        // an array, only the no. of elements b/w i and j matters to us.\\n        vector<int> dp(n+1, -1);\\n        return arrange(0, n-1, n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663540,
                "title": "java-catalan-number-pattern",
                "content": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int dp[]=new int[n+1];\\n         dp[0]=1;\\n         dp[1]=1;\\n    for(int i=2;i<dp.length;i++)\\n    {\\n        int l=0; int r=i-1;\\n        while(l<=(i-1))\\n        {\\n            dp[i]+=dp[l]*dp[r];\\n            l++;\\n            r--;\\n        }\\n    }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int dp[]=new int[n+1];\\n         dp[0]=1;\\n         dp[1]=1;\\n    for(int i=2;i<dp.length;i++)\\n    {\\n        int l=0; int r=i-1;\\n        while(l<=(i-1))\\n        {\\n            dp[i]+=dp[l]*dp[r];\\n            l++;\\n            r--;\\n        }\\n    }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416401,
                "title": "simple-c-solution-recursion-memoization-easy-understanding",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    long long int catalan(long int n,vector<long long int>& memo) \\n    { \\n        // Base case \\n        if (n <= 1) return 1; \\n        if(memo[n]!=-1)return memo[n];\\n        \\n        // catalan(n) is sum of catalan(i)*catalan(n-i-1) \\n        long long int res = 0; \\n        for (int i=0; i<n; i++) \\n            res += catalan(i,memo)*catalan(n-i-1,memo); \\n        memo[n]=res;\\n        return res; \\n    } \\n    int numTrees(int n) {\\n        vector<long long int> memo(n+1,-1);\\n        return catalan(n,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int catalan(long int n,vector<long long int>& memo) \\n    { \\n        // Base case \\n        if (n <= 1) return 1; \\n        if(memo[n]!=-1)return memo[n];\\n        \\n        // catalan(n) is sum of catalan(i)*catalan(n-i-1) \\n        long long int res = 0; \\n        for (int i=0; i<n; i++) \\n            res += catalan(i,memo)*catalan(n-i-1,memo); \\n        memo[n]=res;\\n        return res; \\n    } \\n    int numTrees(int n) {\\n        vector<long long int> memo(n+1,-1);\\n        return catalan(n,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238815,
                "title": "java-in-depth-explanation",
                "content": "**Intuition**\\nThe idea is we place the root in different places, then we could use previous result to solve the problem. See the notes below. Also refer to [NeetCode\\'s YouTube](https://www.youtube.com/watch?v=Ox0TenN3Zpg).\\n\\n```\\n/*    \\nHope it will help you to understand :\\n    \\n    n = 0;     null   \\n    \\n    count[0] = 1\\n    \\n    \\n    n = 1;      1       \\n    \\n    count[1] = 1 \\n    \\n    \\n    n = 2;    1__       \\t\\t\\t __2     \\n    \\t\\t      \\\\\\t\\t\\t\\t\\t/                 \\n    \\t\\t     count[1]\\t   \\tcount[1]\\t\\n    \\n    count[2] = 1 + 1 = 2\\n    \\n    \\n    \\n    n = 3;    1__\\t\\t\\t\\t      __2__\\t                   __3\\n    \\t\\t      \\\\\\t\\t            /       \\\\\\t\\t\\t      /\\t\\t\\n    \\t\\t  count[2]\\t\\t  count[1]    count[1]\\t\\tcount[2]\\n    \\n    count[3] = 2 + 1 + 2  = 5\\n    \\n    \\n    \\n    n = 4;    1__  \\t\\t\\t\\t\\t__2__\\t\\t\\t\\t\\t   ___3___                  \\n    \\t\\t      \\\\\\t\\t\\t\\t /        \\\\\\t\\t\\t\\t\\t  /\\t\\t  \\\\\\t\\t\\t\\n    \\t\\t  count[3]\\t\\t count[1]    count[2]\\t\\t  count[2]   count[1]\\n    \\n                 __4\\t\\t\\t\\t\\n               /\\n           count[3]   \\n    \\n    count[4] = 5 + 2 + 2 + 5 = 14     \\n    \\n\\nAnd  so on...\\n*/\\n```\\n\\n\\n\\n  ```\\n  class Solution\\n{\\n    public int numTrees(int n)\\n    {\\n        // O(n^2) time | O(n) space\\n        int[] tree = new int[n+1];\\n        \\n        // 0 node = empty tree  = 1 tree\\n        // 1 node = 1 root-tree = 1 tree\\n        tree[0] = 1;\\n        tree[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++)\\n        {         \\n            for(int j = 1; j <= i; j++)\\n            {\\n                int left = j - 1;\\n                int right = i - j;\\n                tree[i] += tree[left] * tree[right];\\n            }        \\n        }\\n        return tree[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*    \\nHope it will help you to understand :\\n    \\n    n = 0;     null   \\n    \\n    count[0] = 1\\n    \\n    \\n    n = 1;      1       \\n    \\n    count[1] = 1 \\n    \\n    \\n    n = 2;    1__       \\t\\t\\t __2     \\n    \\t\\t      \\\\\\t\\t\\t\\t\\t/                 \\n    \\t\\t     count[1]\\t   \\tcount[1]\\t\\n    \\n    count[2] = 1 + 1 = 2\\n    \\n    \\n    \\n    n = 3;    1__\\t\\t\\t\\t      __2__\\t                   __3\\n    \\t\\t      \\\\\\t\\t            /       \\\\\\t\\t\\t      /\\t\\t\\n    \\t\\t  count[2]\\t\\t  count[1]    count[1]\\t\\tcount[2]\\n    \\n    count[3] = 2 + 1 + 2  = 5\\n    \\n    \\n    \\n    n = 4;    1__  \\t\\t\\t\\t\\t__2__\\t\\t\\t\\t\\t   ___3___                  \\n    \\t\\t      \\\\\\t\\t\\t\\t /        \\\\\\t\\t\\t\\t\\t  /\\t\\t  \\\\\\t\\t\\t\\n    \\t\\t  count[3]\\t\\t count[1]    count[2]\\t\\t  count[2]   count[1]\\n    \\n                 __4\\t\\t\\t\\t\\n               /\\n           count[3]   \\n    \\n    count[4] = 5 + 2 + 2 + 5 = 14     \\n    \\n\\nAnd  so on...\\n*/\\n```\n```\\n  class Solution\\n{\\n    public int numTrees(int n)\\n    {\\n        // O(n^2) time | O(n) space\\n        int[] tree = new int[n+1];\\n        \\n        // 0 node = empty tree  = 1 tree\\n        // 1 node = 1 root-tree = 1 tree\\n        tree[0] = 1;\\n        tree[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++)\\n        {         \\n            for(int j = 1; j <= i; j++)\\n            {\\n                int left = j - 1;\\n                int right = i - j;\\n                tree[i] += tree[left] * tree[right];\\n            }        \\n        }\\n        return tree[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171720,
                "title": "python-dp-calculate-combination-ways-of-forming-left-and-right-subtrees",
                "content": "combination ways = ways to form left subtree * ways to form right subtree\\n   ways to form left subtree -> select values less than root value\\n   ways to form right subtree -> select values larger than root value\\n        \\n     n = 0 -> 1 way to form a tree, the tree is an empty tree\\n     n = 1 -> 1 way to form a tree, the tree only has one node\\n     n = 2\\n        select root: 1 or 2, then select the rest nodes to form their subtrees, so two nodes have two form ways\\n        1                  2\\n          \\\\              /\\n            2           1\\n        \\n     n = 3\\n        select root: 1, 2, 3\\n        1              1                           2                  3                3\\n          \\\\              \\\\                        / \\\\                /                /\\n            2             3                      1   3              1                2\\n             \\\\            /                                          \\\\              /\\n              3          2                                            2            1\\n        \\n        select 1 as root: no value less than 1, left subtree is always empty, right subtree has two nodes to form -> 2 nodes have 2 ways\\n        select 2 as root: left subtree should take 1, right subtree should take 3 -> one node have one way \\n        select 3 as root: no value larger than 3, left subtree is always empty, right subtree has two nodes to form -> 2 nodes have 2 ways\\n        \\n        answer = 1*2+1*1+2*1\\n\\n```python\\ndef numTrees(self, n: int) -> int:\\n\\t\\t# index of dp i represents the number of nodes to form a tree -> range is [0, n], length is n+1\\n        # when 0 or 1 node, there\\'s only one way to form a tree\\n        dp = [0]*(n+1)\\n        dp[0] = dp[1] = 1\\n        for i in range(2, len(dp)):\\n            # number of (current root + left nodes) is from 1 to j\\n            for j in range(1, i+1):\\n                # left subtree has j-1 nodes, 1 is current root, then the number of right subtree\\'s nodes is i-j\\n                dp[i] += dp[j-1]*dp[i-j]\\n        return dp[n] # when there are n nodes\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef numTrees(self, n: int) -> int:\\n\\t\\t# index of dp i represents the number of nodes to form a tree -> range is [0, n], length is n+1\\n        # when 0 or 1 node, there\\'s only one way to form a tree\\n        dp = [0]*(n+1)\\n        dp[0] = dp[1] = 1\\n        for i in range(2, len(dp)):\\n            # number of (current root + left nodes) is from 1 to j\\n            for j in range(1, i+1):\\n                # left subtree has j-1 nodes, 1 is current root, then the number of right subtree\\'s nodes is i-j\\n                dp[i] += dp[j-1]*dp[i-j]\\n        return dp[n] # when there are n nodes\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2059297,
                "title": "o-n-28-ms-faster-than-94-46-of-python3-online-submissions-for-unique-binary-search-trees",
                "content": "28 ms, faster than 94.46% of Python3 online submissions for Unique Binary Search Trees.\\n\\t\\n\\t\\tcat_ = 1\\n\\n        for i in range(1, n+1):\\n            cat_ *= (4 * i - 2);\\n            cat_ //= (i + 1);\\n        \\n        return cat_",
                "solutionTags": [
                    "Python3"
                ],
                "code": "28 ms, faster than 94.46% of Python3 online submissions for Unique Binary Search Trees.\\n\\t\\n\\t\\tcat_ = 1\\n\\n        for i in range(1, n+1):\\n            cat_ *= (4 * i - 2);\\n            cat_ //= (i + 1);\\n        \\n        return cat_",
                "codeTag": "Unknown"
            },
            {
                "id": 2041389,
                "title": "java-recursion-solution-with-explain",
                "content": "Assume i is root, every integer less than i locate at left tree and larger than i is right tree\\n\\nThe number of combination is\\n```\\nall possible left tree * all possible right tree\\n```\\n\\nAnd for left tree and right tree, they are just the recursion of using another i as root.\\n\\n```\\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\\n\\n    public int numTrees(int n) {\\n        if(n == 0 || n == 1){\\n            return 1;\\n        }\\n\\n        if(hashMap.containsKey(n)){\\n            return hashMap.get(n);\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++){\\n            sum += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        hashMap.put(n, sum);\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nall possible left tree * all possible right tree\\n```\n```\\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\\n\\n    public int numTrees(int n) {\\n        if(n == 0 || n == 1){\\n            return 1;\\n        }\\n\\n        if(hashMap.containsKey(n)){\\n            return hashMap.get(n);\\n        }\\n\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++){\\n            sum += numTrees(i - 1) * numTrees(n - i);\\n        }\\n        hashMap.put(n, sum);\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592963,
                "title": "dp-explanation-without-the-need-to-know-catalan-forumla",
                "content": "To solve this problem with DP, we don\\'t need to know the Catalan numbers in advance.\\nWe don\\'t even have to know this is a DP problem in advance. (But you need to know DP for sure)\\nAll we need is to think about the process of how the tree is constructed.\\nWe can always start with the most simple case, then extend from it.\\n\\nFor n = 1, [1], the number is 1. It should be very intuitive to know this without any difficulty.\\n\\nFor n = 2, [1,2] the number is 2. It may take you a few seconds to draw the possible on the paper, but you will get it.\\n\\nFor n = 3, [1,2,3]. Again we try to figure it out by drawing the possible tree on paper. \\nLet\\'s start by making 1 as the root node, and continue to construct possible trees from [2,3].\\nBut then you come to realize isn\\'t it the same as [1,2] if we consider they are unique numbers and the actual tree does not matter because we only need to know the number of possible trees. So the number of unique trees of [2,3] is the same as the number of [1,2].\\nSo by far, it may remind you it\\'s very similar to the structure of Fibonacci number, that we can get the latter number by adding the previous number. Only in this problem, it is to multiply the number of possible left trees with the number of possible right trees. \\nSo just for [1,2,3], let start with a simple loop to see how to put the things together\\n\\n```\\n// For n = 3\\nint count = 0;\\nfor(int i=1; i<=3; i++) {\\n\\xA0 \\xA0// let i be the root node, then the possible number of trees with i being the root is\\n\\xA0 \\xA0int i_count = number of trees from (i-1 nodes) * number of trees from (3-i nodes)\\n\\xA0 \\xA0// add the possible number of trees with i begin the root to count\\n\\xA0 \\xA0count += i_count;\\n\\n}\\n```\\n\\nI believe you\\'ve got the idea of how to extend the simple case of 3 to any number n.\\nThis is also a very classic DP problem that we can\\n1. find the optimal substructure for the problem\\n2. find recurrence between the problem and subproblem\\n\\nThe final solution\\n\\n```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int numTrees(int n) {\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> dp(n+1, 0);\\n\\xA0 \\xA0 \\xA0 \\xA0 dp[0] = 1; \\xA0 // for null tree, it is counted as 1\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=1; i<=n; i++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(int j=1; j<=i; j++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // for every j as the root node\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // the number is dp[left]*dp[right]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 dp[i] += dp[j-1]*dp[i-j];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 return dp[n];\\n\\xA0 \\xA0 }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// For n = 3\\nint count = 0;\\nfor(int i=1; i<=3; i++) {\\n\\xA0 \\xA0// let i be the root node, then the possible number of trees with i being the root is\\n\\xA0 \\xA0int i_count = number of trees from (i-1 nodes) * number of trees from (3-i nodes)\\n\\xA0 \\xA0// add the possible number of trees with i begin the root to count\\n\\xA0 \\xA0count += i_count;\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int numTrees(int n) {\\n\\xA0 \\xA0 \\xA0 \\xA0 vector<int> dp(n+1, 0);\\n\\xA0 \\xA0 \\xA0 \\xA0 dp[0] = 1; \\xA0 // for null tree, it is counted as 1\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=1; i<=n; i++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 for(int j=1; j<=i; j++) {\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // for every j as the root node\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 // the number is dp[left]*dp[right]\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 dp[i] += dp[j-1]*dp[i-j];\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 \\xA0 \\xA0 return dp[n];\\n\\xA0 \\xA0 }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566949,
                "title": "python3-catalan-s-number-simple-solution-beats-99-97-on-time",
                "content": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        def catalan(n):\\n            temp = [0] * (n + 1)\\n\\n            temp[0], temp[1] = 1, 1\\n\\n            for i in range(2, n + 1):\\n                for j in range(i):\\n                    temp[i] += (temp[j] * temp[i - 1 - j])\\n\\n            return temp[n]\\n        \\n        return catalan(n)\\n```\\n\\nPlease upvote if you like the solution. Comment for any questions.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n==1:\\n            return 1\\n        def catalan(n):\\n            temp = [0] * (n + 1)\\n\\n            temp[0], temp[1] = 1, 1\\n\\n            for i in range(2, n + 1):\\n                for j in range(i):\\n                    temp[i] += (temp[j] * temp[i - 1 - j])\\n\\n            return temp[n]\\n        \\n        return catalan(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566578,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        def factorial(num):\\n            if n == 1:\\n                return 1\\n            else:\\n                tot = 1\\n                for i in range(1, num + 1):\\n                    tot = tot * i\\n                \\n                return tot\\n        \\n        if n == 1:\\n            return 1\\n        elif n == 2:\\n            return 2\\n        else:\\n            first = 1\\n            for i in range(n+2, (n*2) + 1):\\n                first = first * i\\n            second = factorial(n)\\n            \\n            total = first//second\\n            return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        def factorial(num):\\n            if n == 1:\\n                return 1\\n            else:\\n                tot = 1\\n                for i in range(1, num + 1):\\n                    tot = tot * i\\n                \\n                return tot\\n        \\n        if n == 1:\\n            return 1\\n        elif n == 2:\\n            return 2\\n        else:\\n            first = 1\\n            for i in range(n+2, (n*2) + 1):\\n                first = first * i\\n            second = factorial(n)\\n            \\n            total = first//second\\n            return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550466,
                "title": "c-resursive-to-optimzed-explained-0ms-beats-100",
                "content": "### catalans number series : 1, 1, 2, 3, 5, 14, ...\\nC(0) = 1\\nC(1) = 1\\nC(2) = 2 , so on.....\\n\\n#### Total unique BST for n keys equals to nth catalan number.\\n#### So, I have just shown here on how to find nth catalan number.\\n\\n### Recursive solution\\n**Time: O(2^n)** // for recursion tree with two choices and depth \\'n\\'\\n**space: O(n)** \\n\\ncatalan(n) = (C0 * Cn-1) + (C1 * Cn-2) + .... + (Cn-1 * C0 )\\nex: Catalan(3) = C0C1 + C1C1 + C2C0 ==> 2 + 1 + 2 ==> 5\\n```\\nint catalan(int n)\\n{\\n    if (n <= 1)\\n    {\\n        return 1;\\n    }\\n\\n    int result = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        result += (catalan(i) * catalan(n - i - 1));\\n    }\\n\\n    return result;\\n}\\n```\\n\\n### Memoization\\n**Time: O(n * m)**\\n**Space: O(n)** \\n```\\nint catalan(int n, vector<int> &memo)\\n{\\n    if (memo.at(n) != 0)\\n    {\\n        return memo.at(n);\\n    }\\n    if (n <= 1)\\n    {\\n        return 1;\\n    }\\n\\n    int result = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        result += (catalan(i, memo) * catalan(n - i - 1, memo));\\n    }\\n    memo.at(n) = result;\\n    // for (int i = 0; i < n; i++)\\n    // result += catalan(i) * catalan(n - i - 1);\\n\\n    return memo.at(n);\\n}\\n```\\n\\n### DP \\n**Time: O(n^2)** \\n**space: O(n)** \\n- multily with mirror index element ranging from [0 --> i -1 ]\\n```\\nint catalanDP(int n)\\n{\\n    vector<int> catalans(n + 1, 0);\\n    catalans.at(0) = 1;\\n    catalans.at(1) = 1;\\n\\n    for (int i = 2; i <= n; i++)\\n    {\\n        for (int j = 0; j < i; ++j)\\n        {\\n            catalans.at(i) += (catalans.at(j) * catalans.at(i - j - 1));\\n        }\\n    }\\n    return catalans.at(n);\\n}\\n```\\n\\n### Binomial Coefficient\\n**Time: O(n)** // time taken for calculating binomial coefficient \\n```\\n    unsigned long int binomialCoeff(int n, int r){\\n        if(r>n-r){\\n            r = n-r;\\n        }\\n        \\n        unsigned long int res = 1;\\n        \\n        for(int i=0; i<r; ++i){\\n            res = res * (n-i);\\n            res = res / (i+1);\\n        }\\n        return res;\\n    }\\n    int numTrees(int n) {\\n        unsigned long int result = binomialCoeff(2*n, n);\\n        \\n        return result/(n+1);\\n    }\\n```\\n\\n\\t\\n#### Learning resource click this link: [Click here](program-nth-catalan-number)\\n#### Upvote if it has helped you. Thanks:)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nint catalan(int n)\\n{\\n    if (n <= 1)\\n    {\\n        return 1;\\n    }\\n\\n    int result = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        result += (catalan(i) * catalan(n - i - 1));\\n    }\\n\\n    return result;\\n}\\n```\n```\\nint catalan(int n, vector<int> &memo)\\n{\\n    if (memo.at(n) != 0)\\n    {\\n        return memo.at(n);\\n    }\\n    if (n <= 1)\\n    {\\n        return 1;\\n    }\\n\\n    int result = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        result += (catalan(i, memo) * catalan(n - i - 1, memo));\\n    }\\n    memo.at(n) = result;\\n    // for (int i = 0; i < n; i++)\\n    // result += catalan(i) * catalan(n - i - 1);\\n\\n    return memo.at(n);\\n}\\n```\n```\\nint catalanDP(int n)\\n{\\n    vector<int> catalans(n + 1, 0);\\n    catalans.at(0) = 1;\\n    catalans.at(1) = 1;\\n\\n    for (int i = 2; i <= n; i++)\\n    {\\n        for (int j = 0; j < i; ++j)\\n        {\\n            catalans.at(i) += (catalans.at(j) * catalans.at(i - j - 1));\\n        }\\n    }\\n    return catalans.at(n);\\n}\\n```\n```\\n    unsigned long int binomialCoeff(int n, int r){\\n        if(r>n-r){\\n            r = n-r;\\n        }\\n        \\n        unsigned long int res = 1;\\n        \\n        for(int i=0; i<r; ++i){\\n            res = res * (n-i);\\n            res = res / (i+1);\\n        }\\n        return res;\\n    }\\n    int numTrees(int n) {\\n        unsigned long int result = binomialCoeff(2*n, n);\\n        \\n        return result/(n+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441283,
                "title": "c-easy-to-understand-3-methods",
                "content": "**Using Dynamic programming ( Time complexity O(nxn) and space complexity O(n) )**\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n    int c[n+1];\\n    c[0]=c[1]=1;    \\n    for(int i=2;i<=n;i++)\\n    {\\n        c[i]=0;\\n        for(int j=0;j<i;j++)\\n        {\\n            c[i]+=c[j]*c[i-j-1];\\n        }\\n    }\\n        return c[n];\\n    }\\n};\\n```\\n**Using Binomial formula for catalan number\\nTime complexity O(n) and space complexity O(1)**\\n```\\nclass Solution {\\n    public:\\n    int numTrees(int n) {\\n        long long ans=1;\\n        for(int i=n+1;i<=2*n;i++)\\n        {\\n            ans=(ans*i)/(i-n);\\n        }\\n        return ans/(n+1);\\n    }\\n};\\n```\\n**Exponential time complexity (gives TLE)**\\n```\\nclass Solution {\\npublic:\\n    int catalan(int n)\\n    {\\n        if(n==0||n==1)\\n        return 1;\\n        int result=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            result+=catalan(i)*catalan(n-i-1);\\n        }   \\n        return result;\\n    }\\n    int numTrees(int n) {\\n     return catalan(n);   \\n    }\\n};\\n```\\n**Please upvote if you like\\nHappy Coding :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n    int c[n+1];\\n    c[0]=c[1]=1;    \\n    for(int i=2;i<=n;i++)\\n    {\\n        c[i]=0;\\n        for(int j=0;j<i;j++)\\n        {\\n            c[i]+=c[j]*c[i-j-1];\\n        }\\n    }\\n        return c[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n    int numTrees(int n) {\\n        long long ans=1;\\n        for(int i=n+1;i<=2*n;i++)\\n        {\\n            ans=(ans*i)/(i-n);\\n        }\\n        return ans/(n+1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int catalan(int n)\\n    {\\n        if(n==0||n==1)\\n        return 1;\\n        int result=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            result+=catalan(i)*catalan(n-i-1);\\n        }   \\n        return result;\\n    }\\n    int numTrees(int n) {\\n     return catalan(n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418455,
                "title": "java-2-methods-1-liner-idea",
                "content": "**Idea:** Solve [LC 108. Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/1418449/Java-or-Recursive) before this problem to understand the concept\\n\\n**Method 1:** Memoization/Top Down DP gets TLE but AC if memoization is removed.\\n**T/S:** O(n\\xB2)/O(n)\\n```\\npublic int numTrees(int n) {\\n\\treturn numTrees(n, new HashMap<>());\\n}\\n\\nprivate int numTrees(int n, Map<Integer, Integer> map) {\\n\\tif (n <= 1)\\n\\t\\treturn 1;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar numTrees = 0;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t\\tnumTrees += numTrees(i - 1) * numTrees(n - i);\\n\\n\\tmap.put(n, numTrees);\\n\\treturn numTrees;\\n}\\n```\\n*Same as above, using streams, but without memoization.* TLE\\n```\\npublic int numTrees(int n) {\\n\\treturn n <= 1 ? 1 : IntStream.rangeClosed(1, n)\\n\\t\\t\\t\\t\\t\\t\\t\\t .map(i -> numTrees(i - 1) * numTrees(n - i))\\n\\t\\t\\t\\t\\t\\t\\t\\t .sum();\\n}\\n```\\n\\n**Method 2:** Tabulation. Same idea, just bottom-up DP.\\n**T/S:** O(n\\xB2)/O(n)\\n```\\npublic int numTrees(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tdp[0] = dp[1] = 1;\\n\\n\\tfor (var i = 2; i <= n; i++)\\n\\t\\tfor (var j = 1; j <= i; j++)\\n\\t\\t\\tdp[i] += dp[j - 1] * dp[i - j];\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic int numTrees(int n) {\\n\\treturn numTrees(n, new HashMap<>());\\n}\\n\\nprivate int numTrees(int n, Map<Integer, Integer> map) {\\n\\tif (n <= 1)\\n\\t\\treturn 1;\\n\\tif (map.containsKey(n))\\n\\t\\treturn map.get(n);\\n\\n\\tvar numTrees = 0;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t\\tnumTrees += numTrees(i - 1) * numTrees(n - i);\\n\\n\\tmap.put(n, numTrees);\\n\\treturn numTrees;\\n}\\n```\n```\\npublic int numTrees(int n) {\\n\\treturn n <= 1 ? 1 : IntStream.rangeClosed(1, n)\\n\\t\\t\\t\\t\\t\\t\\t\\t .map(i -> numTrees(i - 1) * numTrees(n - i))\\n\\t\\t\\t\\t\\t\\t\\t\\t .sum();\\n}\\n```\n```\\npublic int numTrees(int n) {\\n\\tvar dp = new int[n + 1];\\n\\tdp[0] = dp[1] = 1;\\n\\n\\tfor (var i = 2; i <= n; i++)\\n\\t\\tfor (var j = 1; j <= i; j++)\\n\\t\\t\\tdp[i] += dp[j - 1] * dp[i - j];\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388269,
                "title": "c-dp-solution",
                "content": "**Complexity**\\n- time: O(n^2)\\n- space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int NumTrees(int n) {\\n       \\n        if(n <= 1)\\n            return 1;\\n        \\n        // dp[i]: # of unique BST formed by i nodes\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        // build dp array for 2 nodes, 3 nodes, ..., n nodes\\n        for(int i = 2; i <= n; i++)\\n        {\\n            // there j number of nodes in the left subtree\\n            for(int j = 0; j < i; j++)\\n            {\\n\\t\\t\\t\\t// number of BST constructed by i nodes = # of left sub-BST * # of righ sub-BST\\n                dp[i] += dp[j] * dp[i-1-j];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Note**\\n![image](https://assets.leetcode.com/users/images/81455de5-8ee5-4daf-985b-79e7c9280df8_1630648865.3709857.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumTrees(int n) {\\n       \\n        if(n <= 1)\\n            return 1;\\n        \\n        // dp[i]: # of unique BST formed by i nodes\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        \\n        // build dp array for 2 nodes, 3 nodes, ..., n nodes\\n        for(int i = 2; i <= n; i++)\\n        {\\n            // there j number of nodes in the left subtree\\n            for(int j = 0; j < i; j++)\\n            {\\n\\t\\t\\t\\t// number of BST constructed by i nodes = # of left sub-BST * # of righ sub-BST\\n                dp[i] += dp[j] * dp[i-1-j];\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278581,
                "title": "java-easy-solution-without-dp",
                "content": "```\\nclass Solution {\\n    \\n    public int numTrees(int n) {\\n        return helper(n);\\n    }\\n    int helper(int n)\\n    {\\n        if(n <= 1)\\n            return 1;\\n        int res = 0;\\n        for(int i=0;i<=n-1;i++)\\n        {\\n            res += (helper(i) * helper(n-i-1));\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease upvote i u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numTrees(int n) {\\n        return helper(n);\\n    }\\n    int helper(int n)\\n    {\\n        if(n <= 1)\\n            return 1;\\n        int res = 0;\\n        for(int i=0;i<=n-1;i++)\\n        {\\n            res += (helper(i) * helper(n-i-1));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190656,
                "title": "solutions-pictures",
                "content": "The solution basically wants us to calculate `n-th` [Catalan number](https://en.wikipedia.org/wiki/Catalan_number). However the first solution could be derived using simple logic without any references to Catalan. By the way [22. Generate Parentheses](https://leetcode.com/problems/generate-parentheses/) is another problem that is connected to Catalan.\\n**Erratum**: In the first recursive relation there is an error: the upper limit in summation should be `n-1` instead of `n`.\\n\\n![image](https://assets.leetcode.com/users/images/2d342865-1162-4286-9946-3d765b352237_1620116536.6667213.png)\\n\\n### Solution 1\\n**Dp with up->bottom memoization/recursion**\\n**time: `O(N^2)`, space: `O(N)`**\\nAs there are `n` nodes we can distribute them in number of ways between left and right subtree:\\n```\\n(0, n-1), (1, n-2), (2, n-3)...(n-1,0)\\n```\\nand we need to consider them all. For each distribution of nodes we delegate the question we are being asked to the left and right subtree. Then we just multiply the answers from the left and right subtree (combinatorically we need to account every combination of left BST and right BST) and add them up.\\nHere `n=3`.\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/feed2bc4-9975-4929-956a-a81b0e6973c4_1620126357.7661562.png)\\n\\n<br>\\n\\nTo avoid recalculations we use `unordered_map` to memoize the result.\\n```\\nint numTrees(int n)\\n{\\n\\tstatic unordered_map<int, int> m{{0,1}};\\n\\tif(m.count(n)) return m[n];\\n\\tfor(auto i{0}; i<n; m[n] += numTrees(i)*numTrees(n-1-i), ++i); \\n\\treturn m[n];\\n}\\n```\\n**Dp with bottom->up recursion**\\n**time: `O(N^2)`, space: `O(N)`**\\n```\\nint numTrees(int n)\\n{\\n    int C[20]{1};\\n    for(auto m{1}; m<=n; m++)\\n        for(auto i{0}; i<m; C[m] += C[i]*C[m-1-i], ++i);\\n\\treturn C[n];\\n}\\n```\\nNote, that \\n``` \\nint C[20]{1}; // = {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\\n### Solution 2\\n**Recursion (Catalan numbers recursion relation)**\\n**time: `O(N)`, space: `O(N)` (if no tail recursion)**\\nIf we know a bit about Catalan we can use tail-recursive relation. Mind overflow for `int` return type for `n==19` (hence I use `int64_t`).\\n```\\nint64_t numTrees(int n)\\n{\\n\\treturn n ? numTrees(n-1)*2*(2*n-1)/(n+1) : 1;\\n}\\n```\\n### Solution 3\\n**Look up [Catalan numbers](https://oeis.org/A000108)**\\n\\nWe have only 19 inputs to consider. Catalans grow fast\\n![image](https://assets.leetcode.com/users/images/c0384506-d7ec-418f-a8d1-98825ee8bd48_1620126652.8174157.png)\\n\\nhence the input range is so small. We can just look them up (or just use someone\\'s solution to tabulate them, ha-ha). This may seem like cheating but look up techniques are quiet useful in practical problems. We should always mind the range of the input anyway.\\n**time: `O(1)`, space: `O(N)`**\\n```\\nconstexpr int numTrees(int n)\\n{\\n\\tconstexpr int C[]{1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190};\\n\\treturn C[n];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n(0, n-1), (1, n-2), (2, n-3)...(n-1,0)\\n```\n```\\nint numTrees(int n)\\n{\\n\\tstatic unordered_map<int, int> m{{0,1}};\\n\\tif(m.count(n)) return m[n];\\n\\tfor(auto i{0}; i<n; m[n] += numTrees(i)*numTrees(n-1-i), ++i); \\n\\treturn m[n];\\n}\\n```\n```\\nint numTrees(int n)\\n{\\n    int C[20]{1};\\n    for(auto m{1}; m<=n; m++)\\n        for(auto i{0}; i<m; C[m] += C[i]*C[m-1-i], ++i);\\n\\treturn C[n];\\n}\\n```\n``` \\nint C[20]{1}; // = {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\\n```\n```\\nint64_t numTrees(int n)\\n{\\n\\treturn n ? numTrees(n-1)*2*(2*n-1)/(n+1) : 1;\\n}\\n```\n```\\nconstexpr int numTrees(int n)\\n{\\n\\tconstexpr int C[]{1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790,477638700,1767263190};\\n\\treturn C[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089283,
                "title": "c-clean-code-very-easy-to-understand-faster-than-100",
                "content": "1. The number of unique trees with 0 and 1 nodes will be 1.\\n2. The number of unique structures of a tree will be product of patterns of its child nodes(left and right)\\n3. Consider if the left subtree has 0 nodes then right subtree will have n-1 , similarly if left has 1 , then right will have n-2 ( sparing one node for root node ).  and the loop continues till left have n-1 and right have 0 nodes.\\n\\n/*    \\nHope it will help you to understand :\\n    \\n    n = 0;     null   \\n    \\n    count[0] = 1\\n    \\n    \\n    n = 1;      1       \\n    \\n    count[1] = 1 \\n    \\n    \\n    n = 2;    1__       \\t\\t\\t __2     \\n    \\t\\t      \\\\\\t\\t\\t\\t\\t/                 \\n    \\t\\t     count[1]\\t   \\tcount[1]\\t\\n    \\n    count[2] = 1 + 1 = 2\\n    \\n    \\n    \\n    n = 3;    1__\\t\\t\\t\\t      __2__\\t                   __3\\n    \\t\\t      \\\\\\t\\t            /       \\\\\\t\\t\\t      /\\t\\t\\n    \\t\\t  count[2]\\t\\t  count[1]    count[1]\\t\\tcount[2]\\n    \\n    count[3] = 2 + 1 + 2  = 5\\n    \\n    \\n    \\n    n = 4;    1__  \\t\\t\\t\\t\\t__2__\\t\\t\\t\\t\\t   ___3___                  \\n    \\t\\t      \\\\\\t\\t\\t\\t /        \\\\\\t\\t\\t\\t\\t  /\\t\\t  \\\\\\t\\t\\t\\n    \\t\\t  count[3]\\t\\t count[1]    count[2]\\t\\t  count[2]   count[1]\\n    \\n                 __4\\t\\t\\t\\t\\n               /\\n           count[3]   \\n    \\n    count[4] = 5 + 2 + 2 + 5 = 14     \\n    \\n\\nAnd  so on...\\n*/\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        \\n        vector<int>dp(n+1,0);\\n        \\n        dp[0]=dp[1]=1;\\n        \\n\\t\\t\\n        for(int i=2 ; i<=n ; i++ ){\\n           \\n            for(int j=0;j<i;j++){\\n           \\n\\t\\t\\t\\t   dp[i] += dp[j] * dp[i-j-1] ;\\n           \\n\\t\\t   }\\n        }\\n\\t\\t\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTrees(int n) {\\n        \\n        vector<int>dp(n+1,0);\\n        \\n        dp[0]=dp[1]=1;\\n        \\n\\t\\t\\n        for(int i=2 ; i<=n ; i++ ){\\n           \\n            for(int j=0;j<i;j++){\\n           \\n\\t\\t\\t\\t   dp[i] += dp[j] * dp[i-j-1] ;\\n           \\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 978929,
                "title": "recursion-memoization-dp-0ms",
                "content": "Here\\'s the super slow recursive solution :\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int res = 0;\\n        if (n <= 1)\\n            return 1;\\n        for (int i = 1; i <=n ; i++)    {\\n            res += numTrees(i-1) * numTrees(n-i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nMemoization makes it super fast : \\n\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> hmap = new HashMap<>();\\n    public int numTrees(int n) {\\n        if (hmap.containsKey(n)) return hmap.get(n);\\n        int res = 0;\\n        if (n <= 1)\\n            return 1;\\n        for (int i = 1; i <=n ; i++)    {\\n            res += numTrees(i-1) * numTrees(n-i);\\n        }\\n        hmap.put(n, res);\\n        return res;\\n    }\\n}\\n```\\nThe DP version: \\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <=n ; i++)    {\\n            for (int j = 0; j < i; j++) {\\n                dp[i]+= dp[j] * dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int res = 0;\\n        if (n <= 1)\\n            return 1;\\n        for (int i = 1; i <=n ; i++)    {\\n            res += numTrees(i-1) * numTrees(n-i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    HashMap<Integer, Integer> hmap = new HashMap<>();\\n    public int numTrees(int n) {\\n        if (hmap.containsKey(n)) return hmap.get(n);\\n        int res = 0;\\n        if (n <= 1)\\n            return 1;\\n        for (int i = 1; i <=n ; i++)    {\\n            res += numTrees(i-1) * numTrees(n-i);\\n        }\\n        hmap.put(n, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = dp[1] = 1;\\n        for (int i = 2; i <=n ; i++)    {\\n            for (int j = 0; j < i; j++) {\\n                dp[i]+= dp[j] * dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875023,
                "title": "java-with-dp-detailed-explanation",
                "content": "I feel this is not an obvious DP problem comparing with [those problems](https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns#DP-on-Strings). Below, I will explain how I find the pattern. \\n\\nAs given, we know when n = 3, total of unique BST is 5. But how is that been resolved? \\nMaybe we can start from n = 1? Okay, let\\'s see. \\n\\n```\\nwhen n = 1, count = 1 (root node is 1, and that\\'s it)\\nwhen n = 2, count = 2 (one tree\\'s root node is 1, and the other\\'s root node is 2)\\n```\\n\\nNow we back to look at `n=3`, so we can explain it as:\\n\\n```\\narray = [1,2,3]\\nwhen 1 is the root node: count = 2, because two nodes count is resolved (n = 2, count = 2)\\nwhen 2 is the root node: count = 1, root is 2, left is 1, right is 2\\nwhen 3 is the root node: count = 2, because two nodes count is resolved (n = 2, count = 2)\\n\\nHence when n = 3, the result is 2 + 1 + 2 = 5\\n```\\n\\nlet\\'s see when `n = 4`: \\n\\n```\\narray = [1,2,3,4]\\nwhen 1 is the root node, 3 nodes become it\\'s children, the count is 5, resolved by n = 3.\\nwhen 4 is the root node, 3 nodes become it\\'s children, the cound is 5, resolved by n = 3.\\n\\nHere is the other observation:\\nwhen 2 is root, total number of left tree is 1, and total number of right tree is 2, (look at result for n=1 and n = 2), so count = 1 * 2\\nwhen 3 is root, total number of right tree is 2, and totoal number of left tree is 1, (look at result for n=1 and n = 2), so count = 1 * 2\\n\\nHence when = 4, the result is 5 + 5 + 1*2 + 1*2 = 14\\n```\\n\\nlet\\'s see when `n=5`:\\n\\n```\\narray = [1,2,3,4,5]\\n\\nwhen 1 is the root node, count = 14, resolved by n = 4\\nwhen 5 is the root node, count = 14, resolved by n = 4\\n\\nwhen 2 is the root node, total number of left tree is 1, and total number of right tree is 3, (resolved by n =3), so count = 1 * 5\\nwhen 3 is the root node, total number of left tree is 2, and total number of right tree is 2, so count = 2 * 2\\nwhen 4 is the root node, total number of left tree is 3, and total number of right tree is 1, so count = 5 * 1\\n\\nHence the result is 14 + 14 + 5 + 4 + 5 = 42\\n```\\n\\nTill now, you should be able to find the pattern, and think of DP. And we can use an array to store the result of each stage.\\n\\nHere is the code:\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nwhen n = 1, count = 1 (root node is 1, and that\\'s it)\\nwhen n = 2, count = 2 (one tree\\'s root node is 1, and the other\\'s root node is 2)\\n```\n```\\narray = [1,2,3]\\nwhen 1 is the root node: count = 2, because two nodes count is resolved (n = 2, count = 2)\\nwhen 2 is the root node: count = 1, root is 2, left is 1, right is 2\\nwhen 3 is the root node: count = 2, because two nodes count is resolved (n = 2, count = 2)\\n\\nHence when n = 3, the result is 2 + 1 + 2 = 5\\n```\n```\\narray = [1,2,3,4]\\nwhen 1 is the root node, 3 nodes become it\\'s children, the count is 5, resolved by n = 3.\\nwhen 4 is the root node, 3 nodes become it\\'s children, the cound is 5, resolved by n = 3.\\n\\nHere is the other observation:\\nwhen 2 is root, total number of left tree is 1, and total number of right tree is 2, (look at result for n=1 and n = 2), so count = 1 * 2\\nwhen 3 is root, total number of right tree is 2, and totoal number of left tree is 1, (look at result for n=1 and n = 2), so count = 1 * 2\\n\\nHence when = 4, the result is 5 + 5 + 1*2 + 1*2 = 14\\n```\n```\\narray = [1,2,3,4,5]\\n\\nwhen 1 is the root node, count = 14, resolved by n = 4\\nwhen 5 is the root node, count = 14, resolved by n = 4\\n\\nwhen 2 is the root node, total number of left tree is 1, and total number of right tree is 3, (resolved by n =3), so count = 1 * 5\\nwhen 3 is the root node, total number of left tree is 2, and total number of right tree is 2, so count = 2 * 2\\nwhen 4 is the root node, total number of left tree is 3, and total number of right tree is 1, so count = 5 * 1\\n\\nHence the result is 14 + 14 + 5 + 4 + 5 = 42\\n```\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779622,
                "title": "python-very-simple-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # Start out by building trees for n = 3, n= 4, n = 5 and observe the pattern of trees that they are forming\\n        # For eg: n = 4\\n        # With root as 1, it can have no left subtree and right subtree will have rest of the 3 elements (2, 3, 4). \\n        # These 3 elements can be constructed uniquely in 5 different ways. Why?\\n        \\n        # consider n = 3 now\\n        # With root as 1, it can have 0 left subtree and 2 elements in right subtree which will have 2 combinations.\\n        # With root as 2, it will have 1 left and 1 right subbtree so just 1 combination\\n        # With root as 3, it will have 2 elements in left subtree and 0 element in right subtree. This will result in 2 combinations.\\n        # So totally with n =3, we have 2 + 1 + 2 = 5 combinations\\n        # That is because F[0]*F[2] + F[1]*F[1] + F[2] * F[0]\\n        \\n        # if you consider n = 2, it will have totally 2 combinations\\n        \\n        # If you consider n = 4, it will have these many combinations\\n        # F[0]*F[3] + F[1]*F[2] + F[2]*F[1] + F[3]*F[0] = 1*5 + 1*2 + 2*1 + 5*1 = 14\\n        \\n        # If you consider n = 5, it will have these many combinations\\n        # F[0]*F[4] + F[1]*F[3] + F[2]*F[2] + F[3]*F[1] + F[4]*F[0]\\n        # = 1*14    + 1*5       + 2*2       +  5*1      + 14*1\\n        # = 42    \\n    \\n        \\n        dp = [0 for _ in range(n + 1)]\\n        dp[0] = 1\\n        for i in range(1, n + 1):\\n            total = 0\\n            for k in range(0, i):\\n                # print k, i - k - 1\\n                total += dp[k] * dp[i - k - 1]\\n            dp[i] = total\\n        # print dp\\n        return dp[n]\\n    \\n        \\n        \"\"\"\\n        def numTreesRecursive(num):\\n            if num == 1:\\n                return 1\\n            elif num < 1:\\n                return 1\\n            else:\\n                ans = 0\\n                for k in range(1, num + 1):\\n                    ans += numTreesRecursive(k - 1) * numTreesRecursive(num - k)\\n                return ans\\n            \\n        def numTreesMemoization(num):\\n            if num == 1:\\n                return 1\\n            elif num < 1:\\n                return 1\\n            elif memoize[num] != None:\\n                return memoize[num]\\n            else:\\n                ans = 0\\n                for k in range(1, num + 1):\\n                    ans += numTreesMemoization(k - 1) * numTreesMemoization(num - k)\\n                memoize[num] = ans\\n                return memoize[num]\\n        \\n        def numTreesTabulation(num):\\n            table = [0 for _ in range(num + 1)]\\n            table[0] = 1\\n            table[1] = 1\\n            for i in range(2, num + 1):\\n                for k in range(1, i + 1):\\n                    table[i] += table[k - 1] * table[i - k]\\n\\n            return table[num]\\n        \\n        # Times out\\n        # return numTreesRecursive(n)\\n        \\n        # memoize = [None for _ in range(n + 1)]\\n        # return numTreesMemoization(n)\\n        \\n        return numTreesTabulation(n)\\n        \"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTrees(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        # Start out by building trees for n = 3, n= 4, n = 5 and observe the pattern of trees that they are forming\\n        # For eg: n = 4\\n        # With root as 1, it can have no left subtree and right subtree will have rest of the 3 elements (2, 3, 4). \\n        # These 3 elements can be constructed uniquely in 5 different ways. Why?\\n        \\n        # consider n = 3 now\\n        # With root as 1, it can have 0 left subtree and 2 elements in right subtree which will have 2 combinations.\\n        # With root as 2, it will have 1 left and 1 right subbtree so just 1 combination\\n        # With root as 3, it will have 2 elements in left subtree and 0 element in right subtree. This will result in 2 combinations.\\n        # So totally with n =3, we have 2 + 1 + 2 = 5 combinations\\n        # That is because F[0]*F[2] + F[1]*F[1] + F[2] * F[0]\\n        \\n        # if you consider n = 2, it will have totally 2 combinations\\n        \\n        # If you consider n = 4, it will have these many combinations\\n        # F[0]*F[3] + F[1]*F[2] + F[2]*F[1] + F[3]*F[0] = 1*5 + 1*2 + 2*1 + 5*1 = 14\\n        \\n        # If you consider n = 5, it will have these many combinations\\n        # F[0]*F[4] + F[1]*F[3] + F[2]*F[2] + F[3]*F[1] + F[4]*F[0]\\n        # = 1*14    + 1*5       + 2*2       +  5*1      + 14*1\\n        # = 42    \\n    \\n        \\n        dp = [0 for _ in range(n + 1)]\\n        dp[0] = 1\\n        for i in range(1, n + 1):\\n            total = 0\\n            for k in range(0, i):\\n                # print k, i - k - 1\\n                total += dp[k] * dp[i - k - 1]\\n            dp[i] = total\\n        # print dp\\n        return dp[n]\\n    \\n        \\n        \"\"\"\\n        def numTreesRecursive(num):\\n            if num == 1:\\n                return 1\\n            elif num < 1:\\n                return 1\\n            else:\\n                ans = 0\\n                for k in range(1, num + 1):\\n                    ans += numTreesRecursive(k - 1) * numTreesRecursive(num - k)\\n                return ans\\n            \\n        def numTreesMemoization(num):\\n            if num == 1:\\n                return 1\\n            elif num < 1:\\n                return 1\\n            elif memoize[num] != None:\\n                return memoize[num]\\n            else:\\n                ans = 0\\n                for k in range(1, num + 1):\\n                    ans += numTreesMemoization(k - 1) * numTreesMemoization(num - k)\\n                memoize[num] = ans\\n                return memoize[num]\\n        \\n        def numTreesTabulation(num):\\n            table = [0 for _ in range(num + 1)]\\n            table[0] = 1\\n            table[1] = 1\\n            for i in range(2, num + 1):\\n                for k in range(1, i + 1):\\n                    table[i] += table[k - 1] * table[i - k]\\n\\n            return table[num]\\n        \\n        # Times out\\n        # return numTreesRecursive(n)\\n        \\n        # memoize = [None for _ in range(n + 1)]\\n        # return numTreesMemoization(n)\\n        \\n        return numTreesTabulation(n)\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754109,
                "title": "c-easy-dp-solution-o-n-2-bottom-up",
                "content": "We can solve the problem using dynamic programming. We will solve for small problem (i<n) then will use this results to find for other. \\n\\nFor n=1, dp[n]=1, since 1 BST can be formed with this.\\nFor n=2, dp[n]=2, since 2 BST can be formed with this.\\nFor n=3, there would be 5 BST as desribed below:\\n\\nNo of BST in which there are 0 left children and 2 right children (dp[0] * dp[2])\\nNo of BST in which there are 1 left children and 1 right children (dp[1] * dp[1])\\nNo of BST in which  there are 2 left children and 0 right children (dp[2] * dp[0])\\n\\nTotal number of BST =2+1+2=5.\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 1;\\n        vector<int> dp(n+1, 1);\\n        int ans=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                dp[i]+=(dp[j]*dp[i-j-1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        if(n==0)\\n            return 1;\\n        if(n==1)\\n            return 1;\\n        vector<int> dp(n+1, 1);\\n        int ans=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            dp[i]=0;\\n            for(int j=0;j<i;j++)\\n            {\\n                dp[i]+=(dp[j]*dp[i-j-1]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727240,
                "title": "faster-than-100-submissions-c",
                "content": "Based on Multinomial theorem.\\nEach binary tree can be represented as an array along with null values. Now, if n=N, then the array consists of numbers 1...N and N+1 ```null``` values, that is array for N=3 will be \\n```[1,2,3,null,null,null,null]```.\\nNow, 1...N must be in order and you can place ```null``` values in the spaces between the numbers. That is,\\n```[some null values],1,[some null values],2,[some null values],3,[some null values]...```\\nNow, let a1,a2,a3,...a(N+1) represent number of null values within gaps.\\nthere are N+1 gaps and a1+a2+...+a(N+1)\\nAfter applying multinomial theorem we obtain result as ```(2N C N)/(N+1)```\\n\\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long long int p = 1;\\n        for(int i=1;i<=n;i++){\\n            p*=(n+i);\\n            p/=i;\\n        }\\n        p/=(n+1);\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```null```\n```[1,2,3,null,null,null,null]```\n```null```\n```[some null values],1,[some null values],2,[some null values],3,[some null values]...```\n```(2N C N)/(N+1)```\n```\\nclass Solution {\\npublic:\\n    int numTrees(int n) {\\n        long long int p = 1;\\n        for(int i=1;i<=n;i++){\\n            p*=(n+i);\\n            p/=i;\\n        }\\n        p/=(n+1);\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703139,
                "title": "c-detailed-explaination-faster-than-100-of-ac-solutions-o-n-runtime-dp-o-n-space",
                "content": "Ok so for any tree, you have a root, a left sub-tree(lets call it LST) and a right sub-tree(RST). \\nIf I give you a BST of n-nodes and ask you to change position of any node in LST OR/AND RST, it will give rise to a new BST. So you have got a new/unique BST.\\nSo by **Fundamental Principle Of Counting**, you need to employ multiplication b/w number of possible permutations on the left and the right.\\nHence the recurrence developes:\\n```\\nT(n) = Summation(k=1 to n){T(k-1)*T(n-k)}\\n```\\nThink of it this way: If you take \\'**k-1**\\' nodes in the LST, how many nodes are left to be picked up for the RST?\\n\\'**n-k**\\', Right? Because 1 node has to be the root.\\n\\nFollowing is the code snippet for it:\\n```\\nclass Solution {\\npublic:\\n    int rec(int n, map<int,int> &dp){\\n        if(n==0){\\n            dp[0] = 1;\\n            return 1;\\n        }\\n        if(dp.find(n)!=dp.end())\\n            return dp[n];\\n        int sum = 0;\\n        for(int k=1;k<=n;k++)\\n            sum += rec(n-k,dp)*rec(k-1,dp);\\n        dp[n] = sum;\\n        return sum;\\n    }\\n    int numTrees(int n) {\\n        map<int,int> dp;\\n        return rec(n,dp);\\n    }\\n};\\n```\\n\\nAlso if you want to have a mathematical formula, its the n-th Catalan Number, \\n```\\nC(2n,n)/(n+1) where C(n,r) is the number of combinations possible for picking up r items from n unique items.\\n```\\n\\nHappy Coding!\\nAlso if you feel like, please Upvote\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nT(n) = Summation(k=1 to n){T(k-1)*T(n-k)}\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(int n, map<int,int> &dp){\\n        if(n==0){\\n            dp[0] = 1;\\n            return 1;\\n        }\\n        if(dp.find(n)!=dp.end())\\n            return dp[n];\\n        int sum = 0;\\n        for(int k=1;k<=n;k++)\\n            sum += rec(n-k,dp)*rec(k-1,dp);\\n        dp[n] = sum;\\n        return sum;\\n    }\\n    int numTrees(int n) {\\n        map<int,int> dp;\\n        return rec(n,dp);\\n    }\\n};\\n```\n```\\nC(2n,n)/(n+1) where C(n,r) is the number of combinations possible for picking up r items from n unique items.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703075,
                "title": "finding-the-nth-catalan-number",
                "content": "```\\nclass Solution {\\npublic:\\n    long long binomialCoeff(int n, int k) {\\n        long long res = 1; \\n        if (k > n - k) {\\n            k = n - k;\\n        }\\n        for (int i = 0; i < k; ++i) { \\n            res *= (n - i); \\n            res /= (i + 1); \\n        } \\n        return res; \\n    }\\n    \\n    int numTrees(int n) {\\n        //Catalan Number (2*n)!/((n+1)! * n!)\\n        long long c = binomialCoeff(2 * n, n);  \\n        return c / (n + 1); \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long binomialCoeff(int n, int k) {\\n        long long res = 1; \\n        if (k > n - k) {\\n            k = n - k;\\n        }\\n        for (int i = 0; i < k; ++i) { \\n            res *= (n - i); \\n            res /= (i + 1); \\n        } \\n        return res; \\n    }\\n    \\n    int numTrees(int n) {\\n        //Catalan Number (2*n)!/((n+1)! * n!)\\n        long long c = binomialCoeff(2 * n, n);  \\n        return c / (n + 1); \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493155,
                "title": "simple-recursion-with-memoization-in-java-with-comments",
                "content": "```java\\nclass Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public int numTrees(int n) {\\n\\t    // Empty tree\\n        if(n == 0){\\n            return 1;\\n        }\\n\\t\\t// One tree with root as 1\\n        if(n == 1){\\n            return 1;\\n        }\\n\\t\\t// Two trees \\n        if(n == 2){\\n            return 2;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int result = 0;\\n        for(int i = 1;i<=n;i++){\\n            int left = numTrees(i-1); // when i is root then we can have as many as i-1 as nodes on the left\\n            int right = numTrees(n-i); // as many as n-i as right subtree nodes\\n            result += (left * right); // take the cartesian product or all the combinations for every left and right subtree\\n        }\\n        map.put(n,result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public int numTrees(int n) {\\n\\t    // Empty tree\\n        if(n == 0){\\n            return 1;\\n        }\\n\\t\\t// One tree with root as 1\\n        if(n == 1){\\n            return 1;\\n        }\\n\\t\\t// Two trees \\n        if(n == 2){\\n            return 2;\\n        }\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        int result = 0;\\n        for(int i = 1;i<=n;i++){\\n            int left = numTrees(i-1); // when i is root then we can have as many as i-1 as nodes on the left\\n            int right = numTrees(n-i); // as many as n-i as right subtree nodes\\n            result += (left * right); // take the cartesian product or all the combinations for every left and right subtree\\n        }\\n        map.put(n,result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467450,
                "title": "java-dynamic-programming-with-detail-explainations",
                "content": "```\\n1. Assume that dp[n] is number of unique BST from 1 -> n\\n2. From 1 -> n we could choose different root 1 or 2 or 3 or ..n\\n3. Ex: dp[3] = (dp[0] * dp[2] /*1 is root*/) + (dp[1] * dp[1] /*2 is root*/) + (dp[2] * dp[0] /*3 is root*/)\\n4. We need to find dp[0], dp[1] and dp[2] before finding dp[3], the result of dp[3] is built from\\ndp[0] and dp[1] and dp[2] ==> This is bottom up dynamic programming\\n    \\nclass Solution {\\n    public int numTrees(int n) {\\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= i; j++) {\\n                dp[i] += dp[j - 1] * dp[i - j];\\n            }\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. Assume that dp[n] is number of unique BST from 1 -> n\\n2. From 1 -> n we could choose different root 1 or 2 or 3 or ..n\\n3. Ex: dp[3] = (dp[0] * dp[2] /*1 is root*/) + (dp[1] * dp[1] /*2 is root*/) + (dp[2] * dp[0] /*3 is root*/)\\n4. We need to find dp[0], dp[1] and dp[2] before finding dp[3], the result of dp[3] is built from\\ndp[0] and dp[1] and dp[2] ==> This is bottom up dynamic programming\\n    \\nclass Solution {\\n    public int numTrees(int n) {\\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= i; j++) {\\n                dp[i] += dp[j - 1] * dp[i - j];\\n            }\\n        }\\n        \\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433872,
                "title": "java-dp-with-memoization-easy-to-understand-beats-100",
                "content": "Think about an array [1, 2, 3, ... n]. If we choose k as the root, then \\n- Its left subtree can only contain numbers from 1 to k-1.\\n- Its right subtree can only contain numbers from k+1 to n.\\n- The total combination for unqiue binary trees with k being the root would be count_left * count_right.\\n- Each number in the array can either be picked as the root or not.\\n\\nUse memoization to store the number of unique trees we\\'ve computed.\\n```\\nclass Solution {\\n    public int numTrees(int n) {\\n        // memoization table\\n        Integer[] memo = new Integer[n + 1];\\n        // subtree is null or just one node\\n        memo[0] = 1;\\n        memo[1] = 1;\\n\\n        return numTrees(n, memo);\\n    }\\n\\n    private int numTrees(int n, Integer[] memo) {\\n        if (memo[n] != null) return memo[n];\\n\\n        // pick each node as the root node\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // number of possibilities of left subtree\\n            int left = numTrees(i - 1, memo);\\n            int right = numTrees(n - i, memo);\\n            count += (left * right);\\n        }\\n\\n        memo[n] = count;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numTrees(int n) {\\n        // memoization table\\n        Integer[] memo = new Integer[n + 1];\\n        // subtree is null or just one node\\n        memo[0] = 1;\\n        memo[1] = 1;\\n\\n        return numTrees(n, memo);\\n    }\\n\\n    private int numTrees(int n, Integer[] memo) {\\n        if (memo[n] != null) return memo[n];\\n\\n        // pick each node as the root node\\n        int count = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // number of possibilities of left subtree\\n            int left = numTrees(i - 1, memo);\\n            int right = numTrees(n - i, memo);\\n            count += (left * right);\\n        }\\n\\n        memo[n] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429967,
                "title": "simple-dp-solution-with-explanation",
                "content": "**\\u672C\\u9898\\u7684\\u6838\\u5FC3\\u601D\\u60F3\\u5728\\u4E8E\\u5982\\u4F55\\u6784\\u9020BST \\u8FDB\\u800C \\u63A8\\u65AD\\u51FA\\u6211\\u4EEC\\u7684\\u72B6\\u6001\\u65B9\\u7A0B\\n\\u5229\\u7528bst\\u7684\\u6027\\u8D28\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u91CD\\u590D\\u5229\\u7528smaller bst \\u6784\\u9020 bigger bst**\\n    \\ndynamic programming method\\nlet f(k) be the total num of unique bsts formed by 1 to k\\nwhat\\'s the relation bewteen f(n) & f(n-1)? \\n    \\neg.   \\nwhen n = 4\\nroot node can be 1,2,3,4\\nfor root = 1\\ncan only be f(3) cuz all rest numbers must be in its right sub trees\\nf(0) * f(3)\\nfor root = 2\\nleft subtree only has 1 and right subtree has 3,4\\nthat is f(1) * f(2)\\nfor root = 3\\nleft tree has node 1,2 and right subtree only has 4\\nthat is f(2) * f(1)\\nfor root = 4\\nno right sub tree and left subtree has 1,2,3\\nthat is f(3) * f(0) \\n\\nthrough this analysis we can have the following logic induction\\nfor root value = k and range n\\nnum of its bsts is f(k-1)f(n-k) \\nf(k) = sum of  f(k-1)f(n-k)  (k  is [1,n])\\nbase case : f(0) = 1; f(1) = 1;\\n\\t\\n    public int numTrees(int n) {    // time O(n ^ 2) space O(n)\\n        int[] f = new int[n+1];\\n        f[0] = 1; \\n        f[1] = 1;\\n        if(n <= 1) return 1; // corner case\\n        for(int r = 2; r<= n; r++){\\n            for(int k = 1; k <= r; k++){\\n                f[r] += f[k-1]*f[r-k];\\n            }\\n        }        \\n        return f[n];        \\n    }\\n",
                "solutionTags": [],
                "code": "**\\u672C\\u9898\\u7684\\u6838\\u5FC3\\u601D\\u60F3\\u5728\\u4E8E\\u5982\\u4F55\\u6784\\u9020BST \\u8FDB\\u800C \\u63A8\\u65AD\\u51FA\\u6211\\u4EEC\\u7684\\u72B6\\u6001\\u65B9\\u7A0B\\n\\u5229\\u7528bst\\u7684\\u6027\\u8D28\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u91CD\\u590D\\u5229\\u7528smaller bst \\u6784\\u9020 bigger bst**\\n    \\ndynamic programming method\\nlet f(k) be the total num of unique bsts formed by 1 to k\\nwhat\\'s the relation bewteen f(n) & f(n-1)? \\n    \\neg.   \\nwhen n = 4\\nroot node can be 1,2,3,4\\nfor root = 1\\ncan only be f(3) cuz all rest numbers must be in its right sub trees\\nf(0) * f(3)\\nfor root = 2\\nleft subtree only has 1 and right subtree has 3,4\\nthat is f(1) * f(2)\\nfor root = 3\\nleft tree has node 1,2 and right subtree only has 4\\nthat is f(2) * f(1)\\nfor root = 4\\nno right sub tree and left subtree has 1,2,3\\nthat is f(3) * f(0) \\n\\nthrough this analysis we can have the following logic induction\\nfor root value = k and range n\\nnum of its bsts is f(k-1)f(n-k) \\nf(k) = sum of  f(k-1)f(n-k)  (k  is [1,n])\\nbase case : f(0) = 1; f(1) = 1;\\n\\t\\n    public int numTrees(int n) {    // time O(n ^ 2) space O(n)\\n        int[] f = new int[n+1];\\n        f[0] = 1; \\n        f[1] = 1;\\n        if(n <= 1) return 1; // corner case\\n        for(int r = 2; r<= n; r++){\\n            for(int k = 1; k <= r; k++){\\n                f[r] += f[k-1]*f[r-k];\\n            }\\n        }        \\n        return f[n];        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 394282,
                "title": "c-recursion-w-memo-100",
                "content": "Idea:\\n\\teach time pick a number from 1 to n to be the root of current tree, and divide the whole tree into two subtrees and solve the question recursively. To avoid duplicate calculation, using a hashmap to record completed results.\\n```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> m{{0,1},{1,1}};\\npublic:\\n    int numTrees(int n) {\\n        if (m.count(n)) return m[n];\\n        int sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum += numTrees(i - 1) * numTrees(n - i);\\n        m[n] = sum;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> m{{0,1},{1,1}};\\npublic:\\n    int numTrees(int n) {\\n        if (m.count(n)) return m[n];\\n        int sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum += numTrees(i - 1) * numTrees(n - i);\\n        m[n] = sum;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178999,
                "title": "use-the-power-of-discrete-math-java-5-line-100-0ms-no-dp-needed",
                "content": "Discrete Mathematics by Richard Johnsonbaugh (7th edition)\\nPage 491\\nTheorem 9.8.12: \"There are Cn nonisomorphic binary trees with n vertices where Cn = C(2n, n)/(n+1) is the nth Catalan number.\"\\n\\n```\\npublic int numTrees(int n) {\\n\\t//formula is C(2n,n)/(n+1)\\n\\tdouble answer = 1;\\n\\tfor(double i = n+2; i<=2*n; i++) {\\n\\t\\tanswer*=i;\\n\\t\\tanswer/=i-n;\\n\\t}\\n\\treturn (int)Math.round(answer);\\n}\\n```\\nO(n) time\\nO(1) memory",
                "solutionTags": [],
                "code": "```\\npublic int numTrees(int n) {\\n\\t//formula is C(2n,n)/(n+1)\\n\\tdouble answer = 1;\\n\\tfor(double i = n+2; i<=2*n; i++) {\\n\\t\\tanswer*=i;\\n\\t\\tanswer/=i-n;\\n\\t}\\n\\treturn (int)Math.round(answer);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 31758,
                "title": "java-dp-solution",
                "content": "        \\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                dp[i] += dp[j] * dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "        \\n    public int numTrees(int n) {\\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                dp[i] += dp[j] * dp[i-j-1];\\n            }\\n        }\\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31790,
                "title": "c-explained-44ms-dp-solution",
                "content": "    public int NumTrees(int n) {\\n        if(n <= 2){\\n            return n;\\n        }\\n        \\n        var arr = new int[n+1];\\n        \\n        arr[0] = 1; \\n        arr[1] = 1; \\n        \\n        for(int i = 2; i <= n; i++){\\n            for(int j=0; j<i ; j++){\\n                arr[i] += arr[i-j-1]* arr[j];\\n            }\\n        }\\n        \\n        return arr[n];\\n    }\\n\\nExplanation:\\nThey key is to find out that the maximum number in a BST is always the right most one : \\nLet NT be a tree made of N element\\nTo get an N+1 element trees from NT, I need to find out where can I insert element N+1 in NT\\n=> I can replace every element of the right most branch.\\n\\neg: if I have \\n\\n    1\\n      \\\\\\n        3\\n       /\\n     2\\n\\nI can insert 4 these ways : \\n\\n     position    0              1                   2                  3\\n\\n              4                   1                  1                    1\\n            /                      \\\\                 \\\\                     \\\\\\n          1                         4                 3                     3\\n            \\\\                      /                   \\\\                  /   \\\\\\n              3                 3                        4               2      4\\n             /                  /                       /\\n           2                 2                        2\\n\\n\\nThen we need to find the DP recurrence : \\nLet N(i) be the number of possible tree made of i element.\\nto get N(i+1) we to need to take every tree of N(i) and insert i+1 on every possible location on the rightmost branch.\\nwe can use the previous result to do so : \\n\\n - when i+1 is in position 0, there are N(i) * N(0) results : every tree\\n   made of 1 element below, and every tree made of 0 element above \\n - when i+1 is in position 1, there are N(i-1) * N(1) results : every tree\\n   made of i-1 element below, and every tree made of 1 element above\\n - when i+1 is in position 1, there are N(i-2) * N(2) results : every\\n   tree made of i-2 elements below, an every tree made of 2 elements\\n   above .\\n - etc\\n\\ntherefore we have \\n\\n       for(int i = 2; i <= n; i++){\\n           for(int j=0; j<i ; j++){\\n                arr[i] += arr[i-j-1]* arr[j];\\n            }\\n        }\\n\\nNow we just need to fill the initial cases : \\n\\n        arr[0] = 1; \\n        arr[1] = 1; \\n\\nSpace complexity : O(n)\\nTime Complexity : O(n^2)",
                "solutionTags": [],
                "code": "    public int NumTrees(int n) {\\n        if(n <= 2){\\n            return n;\\n        }\\n        \\n        var arr = new int[n+1];\\n        \\n        arr[0] = 1; \\n        arr[1] = 1; \\n        \\n        for(int i = 2; i <= n; i++){\\n            for(int j=0; j<i ; j++){\\n                arr[i] += arr[i-j-1]* arr[j];\\n            }\\n        }\\n        \\n        return arr[n];\\n    }\\n\\nExplanation:\\nThey key is to find out that the maximum number in a BST is always the right most one : \\nLet NT be a tree made of N element\\nTo get an N+1 element trees from NT, I need to find out where can I insert element N+1 in NT\\n=> I can replace every element of the right most branch.\\n\\neg: if I have \\n\\n    1\\n      \\\\\\n        3\\n       /\\n     2\\n\\nI can insert 4 these ways : \\n\\n     position    0              1                   2                  3\\n\\n              4                   1                  1                    1\\n            /                      \\\\                 \\\\                     \\\\\\n          1                         4                 3                     3\\n            \\\\                      /                   \\\\                  /   \\\\\\n              3                 3                        4               2      4\\n             /                  /                       /\\n           2                 2                        2\\n\\n\\nThen we need to find the DP recurrence : \\nLet N(i) be the number of possible tree made of i element.\\nto get N(i+1) we to need to take every tree of N(i) and insert i+1 on every possible location on the rightmost branch.\\nwe can use the previous result to do so : \\n\\n - when i+1 is in position 0, there are N(i) * N(0) results : every tree\\n   made of 1 element below, and every tree made of 0 element above \\n - when i+1 is in position 1, there are N(i-1) * N(1) results : every tree\\n   made of i-1 element below, and every tree made of 1 element above\\n - when i+1 is in position 1, there are N(i-2) * N(2) results : every\\n   tree made of i-2 elements below, an every tree made of 2 elements\\n   above .\\n - etc\\n\\ntherefore we have \\n\\n       for(int i = 2; i <= n; i++){\\n           for(int j=0; j<i ; j++){\\n                arr[i] += arr[i-j-1]* arr[j];\\n            }\\n        }\\n\\nNow we just need to fill the initial cases : \\n\\n        arr[0] = 1; \\n        arr[1] = 1; \\n\\nSpace complexity : O(n)\\nTime Complexity : O(n^2)",
                "codeTag": "Unknown"
            },
            {
                "id": 31807,
                "title": "ac-clean-java-dp-solution",
                "content": "    public int numTrees(int n) {\\n        // base case\\n        if (n == 0) return 0;\\n        \\n        // dp(i) represents the no. of unique BSTs till i\\n        // dp(0) = 1, means there's a null node\\n        int[] dp = new int[n + 1]; dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; i++)\\n            // use j as root\\n            for (int j = 1; j <= i; j++)\\n                dp[i] += dp[j - 1] * dp[i - j];\\n        \\n        return dp[n];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int numTrees(int n) {\\n        // base case\\n        if (n == 0) return 0;\\n        \\n        // dp(i) represents the no. of unique BSTs till i\\n        // dp(0) = 1, means there's a null node\\n        int[] dp = new int[n + 1]; dp[0] = 1;\\n        \\n        for (int i = 1; i <= n; i++)\\n            // use j as root\\n            for (int j = 1; j <= i; j++)\\n                dp[i] += dp[j - 1] * dp[i - j];\\n        \\n        return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31817,
                "title": "non-recursive-c-solution-with-comments",
                "content": "    int numTrees(int n)\\n    {\\n      /*  if (n<=0) return 0; */\\n      int dp[n+1]; /* dp[i] meaning total # of BST tree with i consecutive nodes */\\n      memset(dp, 0, sizeof(int)*(n+1));\\n      dp[0] = 1; /* NULL is one tree */\\n    \\n      for(int i = 1; i<=n; i++)\\n         /* the idea is for 1....i,  each node can be the root and count the full combination of \\n             left sub BST and right sub BST*/\\n        for(int j = 0; j<i ; j++) \\n            dp[i]+= dp[j] * dp[i-j-1];\\n      \\n      return dp[n];\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "    int numTrees(int n)\\n    {\\n      /*  if (n<=0) return 0; */\\n      int dp[n+1]; /* dp[i] meaning total # of BST tree with i consecutive nodes */\\n      memset(dp, 0, sizeof(int)*(n+1));\\n      dp[0] = 1; /* NULL is one tree */\\n    \\n      for(int i = 1; i<=n; i++)\\n         /* the idea is for 1....i,  each node can be the root and count the full combination of \\n             left sub BST and right sub BST*/\\n        for(int j = 0; j<i ; j++) \\n            dp[i]+= dp[j] * dp[i-j-1];\\n      \\n      return dp[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31813,
                "title": "0ms-easy-to-understand-solution-in-c",
                "content": "I used the formula discussed in: \\nhttp://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there\\n\\n    class Solution {\\n    public:\\n        int numTrees(int n) \\n        {\\n            if(n == 0)\\n                return 0;\\n                \\n            vector<int> nums(n + 1, 0);\\n            nums[0] = 1;\\n            \\n            for(int i = 1; i <= n; i++)\\n            {\\n                int num = 0;\\n                for(int k = 1; k <= i; k++)\\n                {\\n                    num += nums[k - 1] * nums[i - k];\\n                }\\n                \\n                nums[i] = num;\\n            }\\n            \\n            return nums.back();\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int numTrees(int n) \\n        {\\n            if(n == 0)\\n                return 0;\\n                \\n            vector<int> nums(n + 1, 0);\\n            nums[0] = 1;\\n            \\n            for(int i = 1; i <= n; i++)\\n            {\\n                int num = 0;\\n                for(int k = 1; k <= i; k++)\\n                {\\n                    num += nums[k - 1] * nums[i - k];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 31837,
                "title": "o-n2-java-solution",
                "content": "    public int numTrees(int n) {\\n        int ret[] = new int[n + 1];\\n\\t\\n\\t\\tfor (int i = 0; i <= n; i ++) {\\n\\t\\t\\tret[i] = 0;\\n\\t\\t}\\n\\t\\tret[0] = 1;\\n\\t\\tfor (int i = 1; i < n + 1; i ++) {\\n\\t\\t\\tfor (int j = 1; j <= i; j ++) {\\n\\t\\t\\t\\tret[i] += ret[j - 1] * ret[i - j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret[n];\\n    }",
                "solutionTags": [],
                "code": "    public int numTrees(int n) {\\n        int ret[] = new int[n + 1];\\n\\t\\n\\t\\tfor (int i = 0; i <= n; i ++) {\\n\\t\\t\\tret[i] = 0;\\n\\t\\t}\\n\\t\\tret[0] = 1;\\n\\t\\tfor (int i = 1; i < n + 1; i ++) {\\n\\t\\t\\tfor (int j = 1; j <= i; j ++) {\\n\\t\\t\\t\\tret[i] += ret[j - 1] * ret[i - j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 31854,
                "title": "python-dp-solution",
                "content": "    class Solution:\\n        # @return an integer]\\n        # 1:05\\n        def numTrees(self, n):\\n            count = [0] * (n + 1)\\n            count[0] = 1\\n    \\n            for i in range(1, n + 1):\\n                for j in range(0, i):\\n                    count[i] += count[j] * count[i - j - 1]\\n    \\n            return count[n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return an integer]\\n        # 1:05\\n        def numTrees(self, n):\\n            count = [0] * (n + 1)\\n            count[0] = 1\\n    \\n            for i in range(1, n + 1):\\n                for j in range(0, i):\\n                    count[i] += count[j] * count[i - j - 1]\\n    \\n            return count[n]",
                "codeTag": "Java"
            },
            {
                "id": 31867,
                "title": "10-line-java-solution-explanation-given",
                "content": "The main point of the problem is to **recognize how to build up the solution to the bigger problem( n ) using the\\nsolution to smaller problems( 0 , 1, .... n - 1 )**\\nThe best way to understand would be **draw out the possible combination for cases when n = 0, 1, 2, 3 and 4**\\nYou should be able to see how to build the answer for higher values once you know the result for lower values of n. I got this relation... let's say that t(n) be the number of trees, then \\nt(n) = *Summation over i from 0 to n - 1 of* ( t ( i ) * t ( n - 1 - i ) )\\n\\n    public class Solution {\\n        public int numTrees(int n) {\\n            int[] a = new int[n+1];\\n            a[0] = a[1] = 1;\\n            for(int i = 2; i <= n; i++)\\n                for(int j = 0; j < i; j++)  \\n                    a[i] += a[j]*a[i - 1 - j];\\n            return a[n];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int numTrees(int n) {\\n            int[] a = new int[n+1];\\n            a[0] = a[1] = 1;\\n            for(int i = 2; i <= n; i++)\\n                for(int j = 0; j < i; j++)  \\n                    a[i] += a[j]*a[i - 1 - j];\\n            return a[n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 31871,
                "title": "dfs-memory-search-4ms",
                "content": "Algo: dfs + memory search\\n\\nThe following code is for your reference. But there are still a lot of improvement we can do. Like, integer overflow, private data member, ...\\nHow many ones can you find out? :)\\n\\n    class Solution {\\n    public:\\n        int numTrees(int n) {\\n    \\t\\tif (n <= 1)\\n    \\t\\t\\treturn 1;\\n    \\t\\tif (dic.find(n) != dic.end())\\n    \\t\\t\\treturn dic[n];\\n    \\t\\tint ans = 0;\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint left = i;\\n    \\t\\t\\tint right = n - i - 1;\\n    \\t\\t\\tans += numTrees(left) * numTrees(right);\\n    \\t\\t}\\n    \\t\\treturn dic[n] = ans;\\n        }\\n    \\tunordered_map<int, int> dic;\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int numTrees(int n) {\\n    \\t\\tif (n <= 1)\\n    \\t\\t\\treturn 1;\\n    \\t\\tif (dic.find(n) != dic.end())\\n    \\t\\t\\treturn dic[n];\\n    \\t\\tint ans = 0;\\n    \\t\\tfor (int i = 0; i < n; ++i) {\\n    \\t\\t\\tint left = i;\\n    \\t\\t\\tint right = n - i - 1;\\n    \\t\\t\\tans += numTrees(left) * numTrees(right);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3794929,
                "title": "solution-using-dp",
                "content": "# Homework for you\\nSolve using catalan number and comment the code \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main function numTrees(n) takes an integer n as input and returns the total number of unique binary search trees that can be formed with n nodes.\\n\\nThe helper function solve(n) takes an integer n (representing the number of nodes to form a binary search tree) and returns the number of unique binary search trees that can be formed with n nodes.\\n\\nIn the helper function solve, it initializes a vector dp of size n + 1 with all elements set to 0. The vector dp will be used to store the number of unique binary search trees for i nodes.\\n\\nInitialize dp[0] and dp[1] to 1 since there is only one way to form binary search trees with 0 and 1 nodes (empty tree and single-node tree).\\n\\nIterate from i = 2 up to n. For each i, calculate the number of unique binary search trees using the Catalan number formula: dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[i - 1] * dp[0]. This calculation is done by considering each element j as the root and multiplying the number of unique binary search trees for the left subtree (with j - 1 nodes) and the right subtree (with i - j nodes).\\n\\nReturn dp[n], which represents the total number of unique binary search trees with n nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int n)\\n{\\n    vector<int>dp(n+1,0);    \\n    dp[0]=dp[1]=1;\\n    for(int i=2;i<=n;i++)\\n    {\\n        for(int j= 1;j<=i;j++)\\n        {\\n            dp[i]+= dp[j-1]*dp[i-j];\\n        }\\n    }\\n        return dp[n];\\n}\\n    int numTrees(int n) {\\n    return solve(n); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int n)\\n{\\n    vector<int>dp(n+1,0);    \\n    dp[0]=dp[1]=1;\\n    for(int i=2;i<=n;i++)\\n    {\\n        for(int j= 1;j<=i;j++)\\n        {\\n            dp[i]+= dp[j-1]*dp[i-j];\\n        }\\n    }\\n        return dp[n];\\n}\\n    int numTrees(int n) {\\n    return solve(n); \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568543,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565075,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565512,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1564998,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565252,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1708614,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1568195,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1567856,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1570808,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1570205,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1568543,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565075,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565512,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1564998,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1565252,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1708614,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1568195,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1567856,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1570808,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1570205,
                "content": [
                    {
                        "username": "aives",
                        "content": "This is just a helpful hint to think about the problem, it does not give away the solution, but might help guide someone who is looking for it in the right direction.\\n\\nSuppose I want to know how many distinct BST there are with `n` nodes from `0` to `n-1`.\\n\\nIf my BST has `n-1` at the head, how many nodes will be on the left side? How many nodes will be on\\nthe right side?\\n\\nIf my BST has `n-2` at the head, how many nodes will be on the left side? How many nodes will be on \\nthe right side?"
                    },
                    {
                        "username": "poundppx",
                        "content": "this is so binary!"
                    },
                    {
                        "username": "n_209",
                        "content": "\\uD83D\\uDC4D\\uD83C\\uDFFB"
                    },
                    {
                        "username": "Prajju22",
                        "content": "you dropped this crown.... you are king "
                    },
                    {
                        "username": "blazeVortex",
                        "content": "This hint helped me solve this question without looking up the solution.. Thanks!!"
                    },
                    {
                        "username": "robertointerview",
                        "content": "nice hint!!"
                    },
                    {
                        "username": "bumate90",
                        "content": "King!"
                    },
                    {
                        "username": "bengol",
                        "content": "[http://en.wikipedia.org/wiki/Catalan_number][1]\\n\\n![enter image description here][2]\\n\\n\\n  [1]: http://en.wikipedia.org/wiki/Catalan_number\\n  [2]: http://i.imgur.com/hVkEdbp.png"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Bout to whip this out during an interview can\\'t wait to see their face \\uD83D\\uDE06\\n![x](https://assets.leetcode.com/users/images/04095cb9-f81e-4df1-a580-e7c4c05284fe_1675746700.6865969.png)"
                    },
                    {
                        "username": "ytliang97",
                        "content": "great video [10 Questions, 1 concept - Catalan Numbers Applications | Dynamic Programming!](https://www.youtube.com/watch?v=0pTN0qzpt-Y)"
                    },
                    {
                        "username": "johnny411",
                        "content": "Because we have to combine left subtree & right subtrees together.\\nTake `G(5)` \\'s `F(3,5)` as example (I\\'ll skip F(1,5), F(2,5), F(4,5), F(5,5))\\nHope this visualization helps.\\n\\n![image](https://assets.leetcode.com/users/images/173eb88a-2756-4770-8358-ee775d0061af_1629901999.2974467.png)\\n\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-binary-search-trees/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n**Approach 2:** Mathematical Deduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nithanaroy",
                        "content": "https://www.quora.com/Given-n-how-many-structurally-unique-BSTs-binary-search-trees-that-store-values-1-to-n-are-there"
                    },
                    {
                        "username": "erickaky",
                        "content": "If someone has already checked the solution, but still wonders **why there are TWO FOR loops**, while the formula only suggests ONE (at first glance)\\n\\n$$\\\\mathrm{G(n)} = \\\\sum_{i=1}^n G(i - 1) * G(n - i) $$\\n\\nHere is my attempt to explain.\\n\\nImagine we want to find G(3), it can be expressed as:\\n$$\\\\mathrm{G(3)} = G(0) * G(2) + G(1) * G(1) + G(2) * G(0) $$\\n\\nNow we don\\'t know what is G(2), but we can calculate it like this:\\n$$\\\\mathrm{G(2)} = G(0) * G(1) + G(1) * G(0) $$\\n\\nWe can clealy see that to calculate G(3), we need to know all previous G(2), G(1), and etc.\\n\\nThat\\'s why it actually makes sense to start calculating from smaller number. eg: G(2), G(3), G(4) ..\\n\\nWe don\\'t need to calculate G(0) and G(1) they are both 1.\\n1 node tree is 1 combination\\n0 node (empty tree) is 1 combination\\n\\nSo, now back to the original question.\\n\\n```\\npublic class Solution {\\n  public int numTrees(int n) {\\n    int[] G = new int[n + 1];\\n    G[0] = 1;\\n    G[1] = 1;\\n\\n    for (int i = 2; i <= n; ++i) {\\n      for (int j = 1; j <= i; ++j) {\\n        G[i] += G[j - 1] * G[i - j];\\n      }\\n    }\\n    return G[n];\\n  }\\n}\\n```\\n\\nSo, we have 2 loops because to find `G(n)`, we first need to find all previous G(n-1), G(n-2) ... G(2).\\nSo, we essentially first compute G(2) then G(3), G(4) and etc till G(n)\\n\\nThe outer loop `for (int i = 2; i <= n; ++i) {` is where we point which `G` we want to compute, so we start with G(2), then G(3) ... G(n)\\n\\nThe inner loop `for (int j = 1; j <= i; ++j) {` is actually the place where we compute the pointed G[i] using the formula:\\n$$\\\\mathrm{G(i)} = \\\\sum_{j=1}^n G(j - 1) * G(i - j) $$\\n\\nIn other words, due to recursive nature of the formula we have 2 for loops.\\n\\nIt took me a while to realise that.\\nHope it will help someone else!\\n\\n"
                    },
                    {
                        "username": "erickaky",
                        "content": "[@ucancallmex](/ucancallmex) happy to help :)"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "You explained exactly what I am wondering. Thank you."
                    },
                    {
                        "username": "huiqing18",
                        "content": "http://www.cs.cmu.edu/afs/cs/academic/class/15750-s17/ScribeNotes/lecture7.pdf\\nIt is the clearest and detailed with proof steps for the unique binary search tree problems.\\nThere are a lot of great codes in the discussion. So I just share the lecture. It is great!"
                    },
                    {
                        "username": "ben",
                        "content": "i simulate a BST generation, and got TLE."
                    },
                    {
                        "username": "aumo",
                        "content": "memo"
                    },
                    {
                        "username": "oka96",
                        "content": "The tricky part of this question is how to break the problem into subproblem without any duplicate combination.\\n\\nLet\\'s say we have N nodes to form the BST.\\nWe easily to know \\nbst[0] = 1;\\nbst[1] = 1;\\n\\nTo break into subproblem, we can remove the ``root`` node of the BST.\\nThen the single bst will break into two separate bst (left and right bst).\\n\\nThe total nodes to form left and right bst will be (N-1) nodes.\\nIf left bst have 0 node, then right bst will have (N-1)-0 nodes.\\nIf left bst have 1 node, then right bst will have (N-1)-1 nodes.\\n\\nWe can notice that left bst and right bst are separate, so if bst[N] with left bst have 0 node, then the number of way to form will be bst[0] multiply bst[N-1-0]\\n\\nThe sum up of the possible numbers of nodes for left bst.\\nbst[N] = bst[0]*bst[N-1] + bst[1]*bst[N-2] + ... + bst[N-1]*bst[0];\\n\\nTo understand more about this, you can search about Catalan number too.\\n"
                    },
                    {
                        "username": "impwork8053",
                        "content": "ain\\'t getting run code and submit button idk what\\'s the problem.\\ncan anyone help me with this?"
                    }
                ]
            },
            {
                "id": 1736630,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 2000986,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1986285,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1641997,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1575151,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1572038,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1575940,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 2001281,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 2001159,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            },
            {
                "id": 1991903,
                "content": [
                    {
                        "username": "rahulseith",
                        "content": "what is the meaning of structurally unique BST ?  "
                    },
                    {
                        "username": "sunny8080",
                        "content": "Came here after today\\'s Daily LeetCode Challenges "
                    },
                    {
                        "username": "speye_21",
                        "content": "I think the solution is wrong.  It claims there are 14 possible unique BSTs for n=4.  But if you draw a perfect tree of height 4 and trace all possible paths of 4 nodes, there are only 12 possibilities:  8 paths from the root to all the leaves, plus 4 subtree paths from the root to the h-1 nodes (with 1 node spilling over to the opposite side of the root).  There are no paths at higher subtrees because they contain less than 4 nodes, or will repeat paths we have already traced.  So where are the other 2 paths the expected solution claims exist?"
                    },
                    {
                        "username": "coding_menance",
                        "content": "in the dynamic programming solutions, why do we define the vector [where we store the already calculated numbers] outside of the function? What is the difference when we initialize it within the function? Some of the test cases\\' time were exceeding when I initialized vector within the function while it was extremely efficient if done outside.\\n"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/96-unique-binary-search-trees.html"
                    },
                    {
                        "username": "srini_lee",
                        "content": "How did we derive that the solution is the Catalan Number sequence?"
                    },
                    {
                        "username": "kushidhar_ch",
                        "content": "The following pattren is similar to catalan series \\n![image](https://assets.leetcode.com/users/images/17ddb341-6836-4251-8762-63ce2b6682a6_1636350253.4083447.jpeg)\\n\\n<hr>\\n<h1>CODE</h1>\\n\\n![image](https://assets.leetcode.com/users/images/2d90369e-1a1b-431c-99bb-de6312ec4309_1636350273.8615704.png)\\n"
                    },
                    {
                        "username": "trashw1n",
                        "content": "baffling how catalan numbers are behind some seemingly different problems involving dyck paths, binary trees, balanced parantheses, etc."
                    },
                    {
                        "username": "Jeya_Mathesh_Ganesh",
                        "content": "This is similar to different binary trees possible with n nodes."
                    },
                    {
                        "username": "mishra_shashank",
                        "content": "For those who does not need any solution and just need some direction in this question they can refer to any article related to catalan number.I am providing wikipedia link for the same --> https://en.wikipedia.org/wiki/Catalan_number#:~:text=In%20combinatorial%20mathematics%2C%20the%20Catalan,Belgian%20mathematician%20Eug%C3%A8ne%20Charles%20Catalan."
                    }
                ]
            }
        ]
    }
]