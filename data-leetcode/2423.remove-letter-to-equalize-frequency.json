[
    {
        "title": "Remove Letter To Equalize Frequency",
        "question_content": "You are given a 0-indexed string word, consisting of lowercase English letters. You need to select one index and remove the letter at that index from word so that the frequency of every letter present in word is equal.\nReturn true if it is possible to remove one letter so that the frequency of all letters in word are equal, and false otherwise.\nNote:\n\n\tThe frequency of a letter x is the number of times it occurs in the string.\n\tYou must remove exactly one letter and cannot chose to do nothing.\n\n&nbsp;\nExample 1:\n\nInput: word = \"abcc\"\nOutput: true\nExplanation: Select index 3 and delete it: word becomes \"abc\" and each character has a frequency of 1.\n\nExample 2:\n\nInput: word = \"aazz\"\nOutput: false\nExplanation: We must delete a character, so either the frequency of \"a\" is 1 and the frequency of \"z\" is 2, or vice versa. It is impossible to make all present letters have equal frequency.\n\n&nbsp;\nConstraints:\n\n\t2 <= word.length <= 100\n\tword consists of lowercase English letters only.",
        "solutions": [
            {
                "id": 2646539,
                "title": "this-problem-wasn-t-easy",
                "content": "The edge cases were too annoying .",
                "solutionTags": [
                    "C"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2646851,
                "title": "easy-to-understand-python",
                "content": "**Problem Description :**  Return True for the word only if you are able to find an index & by removing that particular index your frequency of word becoming equal and false otherwise.\\n\\nWhy this approach(Not the damn problem) is easy...??\\n\\nAs here i am not focusing on where the case will be false instead am returning the case when the condition can only become true. \\n\\nhence it\\'s easy to understand...\\n\\nWhat we need to do here is... just check whether you are able to make frequency in corresponding char as 1 or not . for this you can take help of set. Now iterate in a for a loop and check this condition if yes return true and false otherwise.\\n\\n\\n**for eg.,**   \\n\\nword =  mmkkkrrtt\\n\\nnow as we can see each word is having frequency 2 except k which is having freq 3 and we need to find 1 index for which we can make freq equal for all other char by removing it.\\n\\nNice, now dry run on this example:\\n\\nfor loop will run till length of 9:\\n\\nthen for each char from starting char till that char and from next char to end of the word we will find its frequency and store them in a set (Why Set...) and check whether frequency is one or not. If for any index it is coming 1 means we can have such index and we will return True. \\n\\nWhy Set... As we are looking on frequency of each char from starting to that index and after that index to end hence all the char will have some frequency and in a set we will focus on unique frequency basically set will contain frequency of each char so here it will look like this [1,2,3] at index other than 3,4 and 4,5. It will look like [2] at index 3,4 and 4,5 but when we take length it will give 3 (for index other than 3,4 and 4,5) and finally we compare it with 1.\\n\\nSo, \\n\\nfor starting from i=0   to i=9 you will get\\n> x=len(set(Counter(word[:0] + word[1:]).values()))   will give 3\\n> x=len(set(Counter(word[:1] + word[2:]).values()))   will give 3\\n> x=len(set(Counter(word[:2] + word[3:]).values()))   will give 3\\n> x=len(set(Counter(word[:3] + word[4:]).values()))   will give 1\\n> x=len(set(Counter(word[:4] + word[5:]).values()))   will give 1\\n> x=len(set(Counter(word[:5] + word[6:]).values()))   will give 3\\n> x=len(set(Counter(word[:6] + word[7:]).values()))   will give 3\\n> x=len(set(Counter(word[:7] + word[8:]).values()))   will give 3\\n> x=len(set(Counter(word[:8] + word[9:]).values()))   will give 3\\n\\nHence, here it will give True for an index as we are getting length of set 1 by removing that index and we are getting all other char freq as equal to 2.\\n\\nAlso we are getting 1 twice as freq of each char is 2 means we can remove 1 index from 2 char and same is happening here. either index 3,4 or 4,5.  But its not a concern for us as we will return True as soon as we will get 1.\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if len(set(Counter(word[0:i] + word[i+1:]).values())) == 1:\\n                return True\\n        return False\\n```\\n\\n\\nAnother approach suggested by @cheupei  : (Reduce TC from O(n2) -> O(n)\\n\\nInstead of checking length of set elements everytime just check when it should be i.e., keep checking the freq of each char by removing 1 from it and also if it is zero. \\n\\n\\n```\\nclass Solution(object):\\n    def equalFrequency(self, word):\\n\\t\\n        counter = Counter(word)\\n        for c in word:\\n            counter[c] -= 1\\n            \\n            if counter[c] == 0:\\n                counter.pop(c)\\n            \\n            if len(set(counter.values())) == 1:\\n                return True\\n\\n            counter[c] += 1\\n        return False\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if len(set(Counter(word[0:i] + word[i+1:]).values())) == 1:\\n                return True\\n        return False\\n```\n```\\nclass Solution(object):\\n    def equalFrequency(self, word):\\n\\t\\n        counter = Counter(word)\\n        for c in word:\\n            counter[c] -= 1\\n            \\n            if counter[c] == 0:\\n                counter.pop(c)\\n            \\n            if len(set(counter.values())) == 1:\\n                return True\\n\\n            counter[c] += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647047,
                "title": "just-watch-my-solution-if-u-find-this-problem-hard-c-no-edge-case",
                "content": "**I think Code is self explanatory**\\n\\nlet me ask u one ques what if the u have been given a problem in which u have to tell whether freq of all letter is equal or not ?\\n\\n\\n->you can do this problem by taking two map one for calculating freq of letter and other for calculating freq of freq\\n\\nfor ex s=\"aabcbbacc\"\\nmp[a]=3\\nmp[b]=3\\nmp[c]=3\\n\\nnow freq of freq is freq[3]=3\\nhere freq map have only one key so our ans will be true\\n\\nnow in this problem we gonna try all possible ways of deleting element \\n\\n\\n\\n\\n**please upvote if u find this helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n      \\n        for(int i=0;i<word.size();i++) //this is for selecting element we want to delete\\n        {\\n            unordered_map<char,int>mp;\\n            unordered_map<int,int>freq;\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(j!=i)  //means we have not taken ith element\\n                    mp[word[j]]++;\\n            }\\n            \\n            for(auto it:mp)\\n                freq[it.second]++;\\n            \\n            if(freq.size()==1)  \\n                return true;\\n            \\n           \\n         }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nTC:O(N^2)\\nSC:O(26)\\n\\nNow Let me share best solution for this problem\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       map<char,int>mp;\\n        for(auto it:word)\\n            mp[it]++;\\n        \\n        map<int,int>freq;\\n        \\n        for(auto it:mp)\\n            freq[it.second]++;\\n        \\n        if(freq.size()>2)\\n            return false;\\n        \\n        if(freq.size()==1)\\n        {\\n            auto it=freq.begin();\\n           \\n            if(it->second==1||it->first==1)\\n                return true;\\n            \\n            return false;\\n        }\\n        \\n        auto it=freq.begin();\\n        auto it2=it++;\\n        \\n         if(it2->first==1&&it2->second==1)\\n             return true;\\n        \\n        \\n        if(abs(it->first-it2->first)!=1)\\n            return false;\\n        \\n        \\n        if(it->second==1)\\n            return true;\\n       \\n                \\n        return false;\\n    }\\n};\\n```\\nTC:O(N)\\nSC:O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n      \\n        for(int i=0;i<word.size();i++) //this is for selecting element we want to delete\\n        {\\n            unordered_map<char,int>mp;\\n            unordered_map<int,int>freq;\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(j!=i)  //means we have not taken ith element\\n                    mp[word[j]]++;\\n            }\\n            \\n            for(auto it:mp)\\n                freq[it.second]++;\\n            \\n            if(freq.size()==1)  \\n                return true;\\n            \\n           \\n         }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       map<char,int>mp;\\n        for(auto it:word)\\n            mp[it]++;\\n        \\n        map<int,int>freq;\\n        \\n        for(auto it:mp)\\n            freq[it.second]++;\\n        \\n        if(freq.size()>2)\\n            return false;\\n        \\n        if(freq.size()==1)\\n        {\\n            auto it=freq.begin();\\n           \\n            if(it->second==1||it->first==1)\\n                return true;\\n            \\n            return false;\\n        }\\n        \\n        auto it=freq.begin();\\n        auto it2=it++;\\n        \\n         if(it2->first==1&&it2->second==1)\\n             return true;\\n        \\n        \\n        if(abs(it->first-it2->first)!=1)\\n            return false;\\n        \\n        \\n        if(it->second==1)\\n            return true;\\n       \\n                \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646524,
                "title": "c-easy-to-understand-using-two-map",
                "content": "<b>Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> mp;\\n        map<int, int> mp2;\\n        for(auto c: word)  mp[c]++;\\n        \\n        for(auto m: mp)  mp2[m.second]++;\\n        \\n        \\n        if(mp2.size() > 2) return false;\\n        map<int, int>::iterator it1 = mp2.begin();\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        \\n        if(mp2.size() == 1){\\n            if(mp.size() == 1 || it1->first == 1) return true;\\n            return false;\\n        }\\n       \\n        \\n        if(it1->first == 1 && it1->second == 1) return true;\\n        if(it1->first == it2->first-1 && it2->second == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> mp;\\n        map<int, int> mp2;\\n        for(auto c: word)  mp[c]++;\\n        \\n        for(auto m: mp)  mp2[m.second]++;\\n        \\n        \\n        if(mp2.size() > 2) return false;\\n        map<int, int>::iterator it1 = mp2.begin();\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        \\n        if(mp2.size() == 1){\\n            if(mp.size() == 1 || it1->first == 1) return true;\\n            return false;\\n        }\\n       \\n        \\n        if(it1->first == 1 && it1->second == 1) return true;\\n        if(it1->first == it2->first-1 && it2->second == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646998,
                "title": "java-faster-than-100-tc-o-n-sc-o-1-easy-to-understand",
                "content": "**Approach**\\n\\n* Calculate count of all characters of a string.\\n* remove each character once anad check if all counts are equal.\\n\\n**Solution**\\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int len = word.length();\\n        int[] count = new int[26];\\n        for (int i = 0; i < len; ++ i) {\\n            char c = word.charAt(i);\\n            count[c - \\'a\\'] ++;\\n        }\\n        for (int i = 0; i < len; ++ i) {\\n            char c = word.charAt(i);\\n            count[c - \\'a\\'] --;\\n            if (equalCount(count)) {\\n                return true;\\n            }\\n            count[c - \\'a\\'] ++;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean equalCount(int[] count) {\\n        int c = 0;\\n        \\n        for (int i: count) {\\n            if (i == 0) {\\n                continue;\\n            } else if (c == 0) {\\n                c = i;\\n            } else if (c == i) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nTC: O(N * 26) = O(N)\\nSC: O(26) = O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int len = word.length();\\n        int[] count = new int[26];\\n        for (int i = 0; i < len; ++ i) {\\n            char c = word.charAt(i);\\n            count[c - \\'a\\'] ++;\\n        }\\n        for (int i = 0; i < len; ++ i) {\\n            char c = word.charAt(i);\\n            count[c - \\'a\\'] --;\\n            if (equalCount(count)) {\\n                return true;\\n            }\\n            count[c - \\'a\\'] ++;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public boolean equalCount(int[] count) {\\n        int c = 0;\\n        \\n        for (int i: count) {\\n            if (i == 0) {\\n                continue;\\n            } else if (c == 0) {\\n                c = i;\\n            } else if (c == i) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647230,
                "title": "c-code-with-complete-case-work-o-n-time-o-1-space",
                "content": "``` \\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> freq(26); // maintain frequency of every character\\n        \\n        for(char ch : word) {\\n            freq[ch - \\'a\\'] += 1;\\n        }\\n        \\n        int mx_freq = 0, mn_freq = word.size(), cnt_mx = 0, cnt_mn = 0;\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            mx_freq = max(mx_freq, freq[i]);                  // maintain max frequency\\n            if(freq[i] > 0) mn_freq = min(mn_freq, freq[i]);  // maintain min frequency\\n        }\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            if(freq[i] == mx_freq)\\n                ++cnt_mx;         // increment count of characters with max frequency\\n            else if(freq[i] == mn_freq)\\n                ++cnt_mn;        // increment count of characters with min frequency\\n            else if(freq[i] > 0) \\n                return false;   // distinct frequencies is greater than 2\\n        }\\n        \\n        if(mx_freq == mn_freq)\\n            return cnt_mx == 1 || mx_freq == 1;\\n        \\n        if(cnt_mn == 1 && mn_freq == 1)\\n            return true;\\n        \\n        if(mx_freq != mn_freq + 1 || cnt_mx != 1)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n   **Case Work:**\\n  \\n   Let\\'s maintain frequency of every character.\\n  \\n*    If count of distinct frequencies > 2, return false.\\n   e.g. : abbccc\\n  \\n*    The count of frequencies can atmost be 2, \\n   so to maintain O(1) space, let\\'s maintain these two frequencies by mx_freq and mn_freq;\\n  \\n   mx_freq ~ highest frequency of a character in word.\\n   cnt_mx ~ count of characters (\\'a\\' - \\'z\\') that have their frequency as mx_freq\\n  \\n   mn_freq ~ lowest frequency of a character in word.\\n   cnt_mn ~ count of characters (\\'a\\' - \\'z\\') that have their frequency as mn_freq\\n   \\n*    if mx_freq == mn_freq: (all characters have same frequency)\\n     -> if mx_freq == 1, there is only character repeating multiple times (e.g.: abcdf), return true\\n     ->    if cnt_mx == 1, word is made of single character (e.g.: bbbbb), return true\\n      ->   otherwise, return false (e.g.: ccddee)\\n  \\n*    Now, we have to handle case of two distinct frequencies.\\n        if mn_freq == 1 and cnt_mn == 1, we have a single occuring character which we can remove and others will have same frequency\\n           return true \\n           e.g. (abbbcccddd, bbccdde)\\n  \\n*    Now, this condition must hold true. (Little exercise, think why \\uD83E\\uDD14)\\n   mx_freq == mn_freq + 1 and cnt_mx == 1. (e.g.: abcc)\\n   \\n**Please consider giving a upvote if it helped!**",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> freq(26); // maintain frequency of every character\\n        \\n        for(char ch : word) {\\n            freq[ch - \\'a\\'] += 1;\\n        }\\n        \\n        int mx_freq = 0, mn_freq = word.size(), cnt_mx = 0, cnt_mn = 0;\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            mx_freq = max(mx_freq, freq[i]);                  // maintain max frequency\\n            if(freq[i] > 0) mn_freq = min(mn_freq, freq[i]);  // maintain min frequency\\n        }\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            if(freq[i] == mx_freq)\\n                ++cnt_mx;         // increment count of characters with max frequency\\n            else if(freq[i] == mn_freq)\\n                ++cnt_mn;        // increment count of characters with min frequency\\n            else if(freq[i] > 0) \\n                return false;   // distinct frequencies is greater than 2\\n        }\\n        \\n        if(mx_freq == mn_freq)\\n            return cnt_mx == 1 || mx_freq == 1;\\n        \\n        if(cnt_mn == 1 && mn_freq == 1)\\n            return true;\\n        \\n        if(mx_freq != mn_freq + 1 || cnt_mx != 1)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646507,
                "title": "c-simple-approach",
                "content": "**Please upvote if it helps :)**\\n\\n**Approach:** Calculate frequency of each char then just decrease frequency of each char by 1 and check whether we get equal frequency or not.\\n\\n```\\nclass Solution \\n{\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n        vector<int> mp(26, 0); \\n        \\n        for(auto it:word) //storing frequency\\n            mp[it-\\'a\\']++;\\n\\n        for(int i=0; i<26; i++) \\n        {\\n            if(mp[i]==0) continue;  //if no char available then check for next char\\n            \\n\\t\\t\\t//if char present then decrease its frequency by 1\\n            mp[i]--;\\n            \\n            int fl=0, cnt=0, fl2=0; //fl for storing frequency 1st time, fl2 assures whether we get equal frequency or not\\n            for(int i=0; i<26; i++) //check whether frequency is equal for other char\\n            {\\n                if(mp[i]==0) continue;\\n                \\n                if(fl==0)  //storing frequency of 1st char in cnt\\n                {\\n                    cnt = mp[i];\\n                    fl=1;\\n                }\\n                \\n                if(mp[i]!=cnt) \\n                {\\n                    fl2=1; \\n                    break;\\n                }\\n            }\\n            if(fl2==0) return true; \\n            \\n            mp[i]++; //restoring frequency of char in mp \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n        vector<int> mp(26, 0); \\n        \\n        for(auto it:word) //storing frequency\\n            mp[it-\\'a\\']++;\\n\\n        for(int i=0; i<26; i++) \\n        {\\n            if(mp[i]==0) continue;  //if no char available then check for next char\\n            \\n\\t\\t\\t//if char present then decrease its frequency by 1\\n            mp[i]--;\\n            \\n            int fl=0, cnt=0, fl2=0; //fl for storing frequency 1st time, fl2 assures whether we get equal frequency or not\\n            for(int i=0; i<26; i++) //check whether frequency is equal for other char\\n            {\\n                if(mp[i]==0) continue;\\n                \\n                if(fl==0)  //storing frequency of 1st char in cnt\\n                {\\n                    cnt = mp[i];\\n                    fl=1;\\n                }\\n                \\n                if(mp[i]!=cnt) \\n                {\\n                    fl2=1; \\n                    break;\\n                }\\n            }\\n            if(fl2==0) return true; \\n            \\n            mp[i]++; //restoring frequency of char in mp \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660629,
                "title": "counter-of-counter",
                "content": "Harder than it looks.\\n\\nWe count characters, and then count the frequency of each count. \\n\\nFor example, for the string \"abcc\", the character count is `{\\'c\\': 2, \\'a\\': 1, \\'b\\': 1}`, and frequency of each count is `{1: 2, 2: 1}` (one letters appear two times, and two letters appear one time each).\\n\\nWe can equalize the string if the frequency counter contains one or two elements, and there are four cases:\\n1. \"abcde\"  `{1: 5}`\\n2. \"aaaaa\" `{5: 1}`\\n3. \"abbcc\" `{1: 1, 2: 2}`\\n4. \"aaabbcc\" `{3: 1, 2: 2}`\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        cnt = Counter(Counter(word).values())\\n        if (len(cnt) == 1):\\n            return list(cnt.keys())[0] == 1 or list(cnt.values())[0] == 1\\n        if (len(cnt) == 2):\\n            f1, f2 = min(cnt.keys()), max(cnt.keys())\\n            return (f1 + 1 == f2 and cnt[f2] == 1) or (f1 == 1 and cnt[f1] == 1)\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        cnt = Counter(Counter(word).values())\\n        if (len(cnt) == 1):\\n            return list(cnt.keys())[0] == 1 or list(cnt.values())[0] == 1\\n        if (len(cnt) == 2):\\n            f1, f2 = min(cnt.keys()), max(cnt.keys())\\n            return (f1 + 1 == f2 and cnt[f2] == 1) or (f1 == 1 and cnt[f1] == 1)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788300,
                "title": "js-very-easy-solution-with-hashmap-and-set",
                "content": "# Code\\n```\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        const character = word[i];\\n        if (hashmap.has(character)) {\\n            hashmap.set(character, hashmap.get(character) + 1);\\n        } else {\\n            hashmap.set(character, 1);\\n        }\\n    }\\n    let output = false;\\n    hashmap.forEach((value, key) => {\\n        const newMap = new Map(hashmap);\\n        if (value === 1) {\\n            newMap.delete(key)\\n        } else {\\n            newMap.set(key, newMap.get(key) - 1);\\n        }\\n        if (new Set([...newMap.values()]).size === 1) output = true;\\n    })\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n    const hashmap = new Map();\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        const character = word[i];\\n        if (hashmap.has(character)) {\\n            hashmap.set(character, hashmap.get(character) + 1);\\n        } else {\\n            hashmap.set(character, 1);\\n        }\\n    }\\n    let output = false;\\n    hashmap.forEach((value, key) => {\\n        const newMap = new Map(hashmap);\\n        if (value === 1) {\\n            newMap.delete(key)\\n        } else {\\n            newMap.set(key, newMap.get(key) - 1);\\n        }\\n        if (new Set([...newMap.values()]).size === 1) output = true;\\n    })\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647447,
                "title": "python-3-4-lines-counter-t-m-38ms-13-8mb",
                "content": "I think the important fact here is that  2 <= word.length <= 100. Brute force is simple, and it passes. I think worst case is O(n^2)/O(n^2), so a different solution would be needed for, say, 2 <= word.length < 2^31.\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n\\n        for i in range(len(word)):\\n            \\n            if len(set(Counter(word[:i]+word[i+1:]).values()))==1:\\n                return True\\n        \\n        return False\\n```\\t\\t\\n\\t\\t\\n\\n[https://leetcode.com/submissions/detail/812908329/](http://)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n\\n        for i in range(len(word)):\\n            \\n            if len(set(Counter(word[:i]+word[i+1:]).values()))==1:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647382,
                "title": "easy-to-understand-100-solution-python",
                "content": "We check and sort the frequency of all the letters - ex ddaccb => [1 1 2 2]\\n\\nIn order to make them all equal, we have two valid cases\\n1. The lowest frequency is 1 - so we can remove this letter completely - if all the rest have the same frequency we\\'re good.\\n2. We have one letter with a frequency that is one higher than the rest, (i.e. the last frequency in the sorted array) if we reduce this, and are left with only one frequency, we have succeeded\\n \\nany other cases are false\\n\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        letter_counts = list(sorted(Counter(word).values()))\\n\\n        # if we only have one (of one letter) - remove it (a.k.a reduce the count to zero)\\n        # and see if all our letters have the same count\\n        if letter_counts[0] == 1 and len(set(letter_counts[1:])) == 1:\\n            return True\\n\\n        # otherwise - let\\'s see if the last one is the only \"odd one out\"\\n        # reduce the count of this letter\\n        letter_counts[-1] -= 1\\n\\n        # if all the letters now have the same count, we are good\\n        return len(set(letter_counts)) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        letter_counts = list(sorted(Counter(word).values()))\\n\\n        # if we only have one (of one letter) - remove it (a.k.a reduce the count to zero)\\n        # and see if all our letters have the same count\\n        if letter_counts[0] == 1 and len(set(letter_counts[1:])) == 1:\\n            return True\\n\\n        # otherwise - let\\'s see if the last one is the only \"odd one out\"\\n        # reduce the count of this letter\\n        letter_counts[-1] -= 1\\n\\n        # if all the letters now have the same count, we are good\\n        return len(set(letter_counts)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647297,
                "title": "simplest-c-code-o-n-traversal",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    bool equalFrequency(string word) {\\n        \\n        //set will store all unique charactes...\\n        unordered_set<char> s;           \\n        \\n        for(int i=0; i<word.length();i++)\\n        {\\n            s.insert(word[i]);\\n        }\\n        \\n        \\n        int sum=word.length();           //it will give total frequecy of all words\\n         \\n        int n = s.size();               //total unique words\\n        \\n        \\n        //first case when all letters come 1 time, then we can delete so return true\\n        if(sum==n) \\n            return true;\\n    \\n        //second case when (n-1) letter come one time and 1 letter come two time so sum % n will give remainder 1, like abcdde\\n        //third case when (n-1) letter come more than 1 time and 1 letter comes 1 time so (sum % n) will give remainder n-1, like aaabbbc\\n        \\n        else if(sum%n==1 || sum%n==(n-1))\\n            return true;\\n        \\n        //remaining are false\\n\\n        return false;\\n        \\n  \\n\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool equalFrequency(string word) {\\n        \\n        //set will store all unique charactes...\\n        unordered_set<char> s;           \\n        \\n        for(int i=0; i<word.length();i++)\\n        {\\n            s.insert(word[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2646700,
                "title": "c-map-sorting-easy",
                "content": "```\\nbool equalFrequency(string word) {\\n        \\n        if(word.size() == 1 || word.size() == 2)  return true ;\\n        \\n        unordered_map<char , int> mp;\\n        \\n        for(auto it : word)  mp[it]++ ;\\n        vector<int> x ;\\n        \\n        for(auto it : mp)    x.push_back(it.second) ;\\n        \\n        int n=x.size() , c=1 ;\\n        sort(x.begin() , x.end()) ;\\n        \\n        if(n == 1)  return true ;\\n        else if(x[0]==x[n-2] && x[n-2]==x[n-1] && x[0]==1)  return true ;\\n        else if(x[0]==x[n-2] && x[n-1]-x[0] == 1)   return true ;\\n        else if(x[0] == 1 && x[1]==x[n-1])  return true ;\\n        else return false ;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nbool equalFrequency(string word) {\\n        \\n        if(word.size() == 1 || word.size() == 2)  return true ;\\n        \\n        unordered_map<char , int> mp;\\n        \\n        for(auto it : word)  mp[it]++ ;\\n        vector<int> x ;\\n        \\n        for(auto it : mp)    x.push_back(it.second) ;\\n        \\n        int n=x.size() , c=1 ;\\n        sort(x.begin() , x.end()) ;\\n        \\n        if(n == 1)  return true ;\\n        else if(x[0]==x[n-2] && x[n-2]==x[n-1] && x[0]==1)  return true ;\\n        else if(x[0]==x[n-2] && x[n-1]-x[0] == 1)   return true ;\\n        else if(x[0] == 1 && x[1]==x[n-1])  return true ;\\n        else return false ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646497,
                "title": "java-explaination",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String str) {\\n        int l = str.length();\\n \\n        // fill frequency array\\n        int[] freq = new int[26];\\n \\n        for (int i = 0; i < l; i++)\\n            freq[str.charAt(i)-\\'a\\']++;\\n \\n        /*  Try decreasing frequency of all character\\n            by one and then check all equality of all\\n            non-zero frequencies */\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int i = c-\\'a\\';\\n \\n            // Check character only if it occurs in str\\n            if (freq[i] > 0) {\\n                freq[i]--;\\n \\n                if (allSame(freq, 26))\\n                    return true;\\n                freq[i]++;\\n            }\\n        }\\n \\n        return false;\\n    }\\n    \\n     private boolean allSame(int freq[], int N)\\n    {\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String str) {\\n        int l = str.length();\\n \\n        // fill frequency array\\n        int[] freq = new int[26];\\n \\n        for (int i = 0; i < l; i++)\\n            freq[str.charAt(i)-\\'a\\']++;\\n \\n        /*  Try decreasing frequency of all character\\n            by one and then check all equality of all\\n            non-zero frequencies */\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int i = c-\\'a\\';\\n \\n            // Check character only if it occurs in str\\n            if (freq[i] > 0) {\\n                freq[i]--;\\n \\n                if (allSame(freq, 26))\\n                    return true;\\n                freq[i]++;\\n            }\\n        }\\n \\n        return false;\\n    }\\n    \\n     private boolean allSame(int freq[], int N)\\n    {\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647533,
                "title": "three-python-solutions-explained",
                "content": "This problem was not so easy as I thought initially. Spent the whole hour without any success and failed in the contest completely. Luckily got the idea from the [straightforward solution](https://leetcode.com/problems/remove-letter-to-equalize-frequency/discuss/2646851/Easy-to-understand-PYTHON) by [nomadac_coder](https://leetcode.com/nomadac_coder).\\n\\nFor each new word that can be constructed by removing one character from initial `word` the `collections.Counter` is used to get remaining characters\\' frequencies. If all frequencies are equal (i.e., `len(set(frequencies)) == 1`) `True` is returned.\\n\\n<ins>Time complexity</ins>: `O(n`<sup>`2`</sup>)<br>\\n\\n```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    for i in range(len(word)):\\n        if len(set(Counter(word[:i] + word[i+1:]).values())) == 1:\\n            return True\\n    return False\\n# end equalFrequency(...)\\n```\\n\\nSimilar idea can be applied to the frequencies of characters in the original `word`. We create the list `freq` of character frequencies, and then for each `freq[i]`:\\n- decrement i-th frequency:  `freq[i] -= 1`;\\n- determine the number of unique `freq` elements (i.e., use `set(freq)` to remove duplicates);\\n- if `len(freq) == 1` then `True` is returned. Another possible solution is `len(freq) == 2 and freq[i] == 0`;\\n- otherwise i-th frequency is restored (`freq[i] += 1`)\\n\\nAt the beginning we may also check if `len(set(freq)) > 2` and return `False`, since it is not possible to equalize more than 2 frequencies by removing single char from `word`\\n\\n```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    freq = list(Counter(word).values())\\n    if len(set(freq)) > 2: return False\\n    for i in range(len(freq)):\\n        freq[i] -= 1\\n        len_ = len(set(freq))\\n        if len_ == 1 or (len_ == 2 and freq[i] == 0):\\n            return True\\n        freq[i] += 1\\n    return False\\n# end equalFrequency(...)\\n```\\n\\nThe second approach gives slightly better runtime\\n\\nIn the solution above we noted that in order to equalize the chars\\' frequencies by removing a signle char the number of the frequencies shall not be greater than 2. Thus, we have three possible cases that have to return `True:\\n1. decrementing the largest frequency by `1` allows to equalize the frequencies\\n2. the smallest frequency minus `1` is `0`, and all other frequencies are equal\\n3. decrementing the smallest frequency allows to equalize the frequencies\\n\\n<ins>Time complexity</ins>: `O(n + k`&times;`log k)`, where `k` as a maximum is `26`\\n\\n```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    freq = sorted(list(Counter(word).values()), reverse = True)\\n    if len(set(freq)) > 2: return False\\n\\n    # check if decrementing the largest frequency allows to equalize char frequencies\\n    freq[0] -= 1\\n    if len(set(freq)) == 1:\\n        return True\\n    freq[0] += 1\\n\\n    # check if decrementing the smallest frequency either gives frequency 0 with all other\\n    # frequencies equal or allows to equalize char frequencies\\n    freq[-1] -= 1\\n    if freq[-1] == 0:\\n        freq.pop()\\n    if len(set(freq)) == 1:\\n        return True\\n    return False\\n# end equalFrequency(...)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    for i in range(len(word)):\\n        if len(set(Counter(word[:i] + word[i+1:]).values())) == 1:\\n            return True\\n    return False\\n# end equalFrequency(...)\\n```\n```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    freq = list(Counter(word).values())\\n    if len(set(freq)) > 2: return False\\n    for i in range(len(freq)):\\n        freq[i] -= 1\\n        len_ = len(set(freq))\\n        if len_ == 1 or (len_ == 2 and freq[i] == 0):\\n            return True\\n        freq[i] += 1\\n    return False\\n# end equalFrequency(...)\\n```\n```python\\ndef equalFrequency(word: str) -> bool:\\n\\n    freq = sorted(list(Counter(word).values()), reverse = True)\\n    if len(set(freq)) > 2: return False\\n\\n    # check if decrementing the largest frequency allows to equalize char frequencies\\n    freq[0] -= 1\\n    if len(set(freq)) == 1:\\n        return True\\n    freq[0] += 1\\n\\n    # check if decrementing the smallest frequency either gives frequency 0 with all other\\n    # frequencies equal or allows to equalize char frequencies\\n    freq[-1] -= 1\\n    if freq[-1] == 0:\\n        freq.pop()\\n    if len(set(freq)) == 1:\\n        return True\\n    return False\\n# end equalFrequency(...)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2647006,
                "title": "c-brute-force-well-explained",
                "content": "Just do what is asked in the question\\nKeep removing every index and find the answer corresponding to that.\\nAt the end take the OR of all the answers\\n\\nC++ code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        bool ans = false;\\n        for(int i=0;i<word.size();i++) // going to every index\\n        {\\n\\t\\t\\tif(ans) // if at any point ans becomes true we return true\\n\\t\\t\\treturn true;\\n            unordered_map<char,int> mp;\\n            int total = 0;\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(j==i) // skipping the current index\\n                    continue;\\n                mp[word[j]]++;\\n                total++;\\n            }\\n            int x = total/mp.size(); // every characters freq should be equal\\n            bool flag = true;\\n            for(auto m:mp)\\n            {\\n                if(m.second!=x) // if the condition is violated then the result is false for this case\\n                {\\n                    flag = false;\\n                    break;\\n                }    \\n            }\\n            if(flag) // if the condition was not violated then it is our ans\\n                ans = ans || true;\\n        }\\n        return ans;           \\n    }\\n};\\n```\\n\\nPlease upvote if you liked the solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        bool ans = false;\\n        for(int i=0;i<word.size();i++) // going to every index\\n        {\\n\\t\\t\\tif(ans) // if at any point ans becomes true we return true\\n\\t\\t\\treturn true;\\n            unordered_map<char,int> mp;\\n            int total = 0;\\n            for(int j=0;j<word.size();j++)\\n            {\\n                if(j==i) // skipping the current index\\n                    continue;\\n                mp[word[j]]++;\\n                total++;\\n            }\\n            int x = total/mp.size(); // every characters freq should be equal\\n            bool flag = true;\\n            for(auto m:mp)\\n            {\\n                if(m.second!=x) // if the condition is violated then the result is false for this case\\n                {\\n                    flag = false;\\n                    break;\\n                }    \\n            }\\n            if(flag) // if the condition was not violated then it is our ans\\n                ans = ans || true;\\n        }\\n        return ans;           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646868,
                "title": "brute-force-remove-each-character-and-check-c",
                "content": "\\n\\n```\\nclass Solution {\\n    vector<int> freq;\\npublic:\\n    bool isEqual(string s, int i){\\n        freq[s[i] - \\'a\\'] = 1;\\n        s.erase(i,1);\\n        map<char,int> mp;\\n        for(auto &c : s){\\n            mp[c]++;\\n            \\n        }\\n        \\n        for(int i = 1;i<s.size();i++){\\n            if(mp[s[i-1]] != mp[s[i]]) return false;\\n           \\n        }\\n         return true;\\n    }\\n    bool equalFrequency(string word) {\\n        freq.resize(26);\\n        for(int i = 0;i<word.size();i++){\\n            if(!freq[word[i] - \\'a\\'] && isEqual(word,i)) return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> freq;\\npublic:\\n    bool isEqual(string s, int i){\\n        freq[s[i] - \\'a\\'] = 1;\\n        s.erase(i,1);\\n        map<char,int> mp;\\n        for(auto &c : s){\\n            mp[c]++;\\n            \\n        }\\n        \\n        for(int i = 1;i<s.size();i++){\\n            if(mp[s[i-1]] != mp[s[i]]) return false;\\n           \\n        }\\n         return true;\\n    }\\n    bool equalFrequency(string word) {\\n        freq.resize(26);\\n        for(int i = 0;i<word.size();i++){\\n            if(!freq[word[i] - \\'a\\'] && isEqual(word,i)) return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179406,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n         vector<int> f(26,0);\\n        for(auto c:word)\\n            f[c-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            vector<int> temp=f;\\n            if(f[i]<=0){\\n                continue;\\n            }\\n            temp[i]--;\\n            set<int> s;\\n            \\n            for(auto x:temp){\\n                if(x>0){\\n                    s.insert(x);\\n                }\\n            }\\n            if(s.size()==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n         vector<int> f(26,0);\\n        for(auto c:word)\\n            f[c-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            vector<int> temp=f;\\n            if(f[i]<=0){\\n                continue;\\n            }\\n            temp[i]--;\\n            set<int> s;\\n            \\n            for(auto x:temp){\\n                if(x>0){\\n                    s.insert(x);\\n                }\\n            }\\n            if(s.size()==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018668,
                "title": "8-line-fast-js-easy-to-read",
                "content": "# Some BS\\nWell, this is definetly a medium+ problem. :)\\nI\\'ve seen many medium and hard ones are much easier than this.\\n\\n# Intuition\\nBrute force, reduce(or remove if it became 0) each element.\\nSee if all the rest are with equal frequency.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar equalFrequency = function (word, cnt = {}) {\\n  for (let w of word) {cnt[w] = (cnt[w] || 0) + 1;}\\n  for (let k in cnt) {\\n    const newCnt = Object.assign({}, cnt);\\n    if (--newCnt[k] === 0) delete newCnt[k];\\n    if (new Set([...Object.values(newCnt)]).size === 1) return true;}\\n  return false;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar equalFrequency = function (word, cnt = {}) {\\n  for (let w of word) {cnt[w] = (cnt[w] || 0) + 1;}\\n  for (let k in cnt) {\\n    const newCnt = Object.assign({}, cnt);\\n    if (--newCnt[k] === 0) delete newCnt[k];\\n    if (new Set([...Object.values(newCnt)]).size === 1) return true;}\\n  return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647687,
                "title": "rust-0-ms-hashmap-based-counter-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/812949562/) employs a *HashMap*-based counter with subsequent checking of 4 frequency conditions. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution \\n{\\n    pub fn equal_frequency(word: String) -> bool \\n    {\\n        // [1] count letter frequencies\\n        let freq_map: HashMap<char,i32> = \\n            word\\n                .chars()\\n                .fold(HashMap::new(), |mut freq, ch|\\n                {\\n                    freq.entry(ch)\\n                        .and_modify(|item| *item += 1)\\n                        .or_insert(1);\\n                    freq\\n                });\\n        \\n        // [2] sort frequencies\\n        let mut freq_vec: Vec<i32> = freq_map.into_values().collect();\\n        freq_vec.sort_unstable();\\n        \\n        // [3] check several frequency conditions\\n\\n        //     - for a single unique letter in the word\\n        if freq_vec.len() == 1  { return true; }\\n        \\n        //     - for all frequencies being equal to 1\\n        if freq_vec[freq_vec.len()-1] == 1     { return true; }\\n\\n        //     - for one less frequent element\\n        if freq_vec[1] - freq_vec[0] == 1 \\n           && freq_vec[1] == freq_vec[freq_vec.len()-1]  { return true; }\\n\\n        //     - for one most frequent element\\n        if freq_vec[freq_vec.len()-1] - freq_vec[freq_vec.len()-2] == 1 \\n           && freq_vec[0] == freq_vec[freq_vec.len()-2]  { return true; }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution \\n{\\n    pub fn equal_frequency(word: String) -> bool \\n    {\\n        // [1] count letter frequencies\\n        let freq_map: HashMap<char,i32> = \\n            word\\n                .chars()\\n                .fold(HashMap::new(), |mut freq, ch|\\n                {\\n                    freq.entry(ch)\\n                        .and_modify(|item| *item += 1)\\n                        .or_insert(1);\\n                    freq\\n                });\\n        \\n        // [2] sort frequencies\\n        let mut freq_vec: Vec<i32> = freq_map.into_values().collect();\\n        freq_vec.sort_unstable();\\n        \\n        // [3] check several frequency conditions\\n\\n        //     - for a single unique letter in the word\\n        if freq_vec.len() == 1  { return true; }\\n        \\n        //     - for all frequencies being equal to 1\\n        if freq_vec[freq_vec.len()-1] == 1     { return true; }\\n\\n        //     - for one less frequent element\\n        if freq_vec[1] - freq_vec[0] == 1 \\n           && freq_vec[1] == freq_vec[freq_vec.len()-1]  { return true; }\\n\\n        //     - for one most frequent element\\n        if freq_vec[freq_vec.len()-1] - freq_vec[freq_vec.len()-2] == 1 \\n           && freq_vec[0] == freq_vec[freq_vec.len()-2]  { return true; }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647545,
                "title": "java-two-solutions",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n##### Approach 1:\\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            StringBuilder temp = new StringBuilder(word);\\n            temp.deleteCharAt(i);\\n            String str = temp.toString();\\n\\n            int[] freq = new int[26];\\n\\n            for (char c : str.toCharArray()) {\\n                freq[c - \\'a\\']++;\\n            }\\n\\n            Set<Integer> set = new HashSet<>();\\n            for (int f : freq) {\\n                if (f > 0) set.add(f);\\n            }\\n\\n            if (set.size() == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * (2 * 26)) => O(n)\\n// SC: O(1)\\n```\\n##### Approach 2:\\nCredit: **[vishesht27](https://leetcode.com/vishesht27/)**\\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (char c : word.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        int[] freq = new int[map.size()];\\n\\n        int i = 0;\\n        for (int f : map.values()) {\\n            freq[i++] = f;\\n        }\\n\\n        Arrays.sort(freq);\\n        int n = freq.length;\\n\\n        if (n == 1) return true;\\n\\n        if (freq[0] == 1 && freq[1] == freq[n - 1]) {\\n            return true;\\n        }\\n\\n        if (freq[0] == freq[n - 2] && freq[n - 1] - freq[n - 2] == 1) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        for (int i = 0; i < word.length(); i++) {\\n            StringBuilder temp = new StringBuilder(word);\\n            temp.deleteCharAt(i);\\n            String str = temp.toString();\\n\\n            int[] freq = new int[26];\\n\\n            for (char c : str.toCharArray()) {\\n                freq[c - \\'a\\']++;\\n            }\\n\\n            Set<Integer> set = new HashSet<>();\\n            for (int f : freq) {\\n                if (f > 0) set.add(f);\\n            }\\n\\n            if (set.size() == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * (2 * 26)) => O(n)\\n// SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        for (char c : word.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n\\n        int[] freq = new int[map.size()];\\n\\n        int i = 0;\\n        for (int f : map.values()) {\\n            freq[i++] = f;\\n        }\\n\\n        Arrays.sort(freq);\\n        int n = freq.length;\\n\\n        if (n == 1) return true;\\n\\n        if (freq[0] == 1 && freq[1] == freq[n - 1]) {\\n            return true;\\n        }\\n\\n        if (freq[0] == freq[n - 2] && freq[n - 1] - freq[n - 2] == 1) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647259,
                "title": "o-n-time-java-solution-with-explanation-of-corner-cases",
                "content": "To solve the problem with O(n) we can count the number of unique characters having first max frequency and number of unique character having second max frequency\\n\\n\\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] charMap = new int[26];\\n        \\n        // counting frequency\\n        for(char c : word.toCharArray()){\\n            charMap[c-\\'a\\']++;\\n        }\\n        \\n        // finding first max frequency and second max frequency (not same as first)\\n        int firstMax=0, secondMax=0;\\n        for(int i=0; i<charMap.length; i++){\\n            if(charMap[i]>firstMax){\\n                secondMax = firstMax;\\n                firstMax = charMap[i];\\n            }\\n            else if(charMap[i]!=firstMax && charMap[i]>secondMax)secondMax = charMap[i];\\n        }\\n        \\n        // counting how many times first max frequency and second max frequency occurs\\n        // return false if any other third value occurs except 0\\n        int firstCount=0, secondCount=0;\\n        for(int i=0; i<charMap.length; i++){\\n            int val = charMap[i];\\n            if(val==0)continue;\\n            if(val==firstMax)firstCount++;\\n            else if(val==secondMax)secondCount++;\\n            else return false;\\n        }\\n        \\n        // we may delete from characters having first max frequency or second max frequency\\n        // 1. if no second max freq that means either first max frequency should be 1 \\n        //     or only 1 character with first max frequency\\n        // 2. if deleting characters having second max frequency then only one case where \\n        //     second max frequency is 1 and also number of characters having that frequency is 1\\n        // 3. if deleting characters having first max frequency then there can only be 1 character \\n        //     having first max frequency and after deleting it should match second max frequency\\n        return (secondMax==0 && (firstMax==1 || firstCount==1)) || (secondMax==1 && secondCount==1) || (firstCount==1 && firstMax-1==secondMax);\\n    }\\n}\\n```\\n\\n\\nIf the code can be further optimized or if I am missing anything please leave a comment.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] charMap = new int[26];\\n        \\n        // counting frequency\\n        for(char c : word.toCharArray()){\\n            charMap[c-\\'a\\']++;\\n        }\\n        \\n        // finding first max frequency and second max frequency (not same as first)\\n        int firstMax=0, secondMax=0;\\n        for(int i=0; i<charMap.length; i++){\\n            if(charMap[i]>firstMax){\\n                secondMax = firstMax;\\n                firstMax = charMap[i];\\n            }\\n            else if(charMap[i]!=firstMax && charMap[i]>secondMax)secondMax = charMap[i];\\n        }\\n        \\n        // counting how many times first max frequency and second max frequency occurs\\n        // return false if any other third value occurs except 0\\n        int firstCount=0, secondCount=0;\\n        for(int i=0; i<charMap.length; i++){\\n            int val = charMap[i];\\n            if(val==0)continue;\\n            if(val==firstMax)firstCount++;\\n            else if(val==secondMax)secondCount++;\\n            else return false;\\n        }\\n        \\n        // we may delete from characters having first max frequency or second max frequency\\n        // 1. if no second max freq that means either first max frequency should be 1 \\n        //     or only 1 character with first max frequency\\n        // 2. if deleting characters having second max frequency then only one case where \\n        //     second max frequency is 1 and also number of characters having that frequency is 1\\n        // 3. if deleting characters having first max frequency then there can only be 1 character \\n        //     having first max frequency and after deleting it should match second max frequency\\n        return (secondMax==0 && (firstMax==1 || firstCount==1)) || (secondMax==1 && secondCount==1) || (firstCount==1 && firstMax-1==secondMax);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647213,
                "title": "long-but-easy-to-understand-100-faster-cpp-o-n-logn",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\tbool equalFrequency(string word) {\\n\\t\\t\\t\\n\\t\\t\\tunordered_map<char,int>vec;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tvec[word[i]]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<int> freq;\\n\\t\\t\\t\\tfor(auto &i: vec){\\n\\t\\t\\t\\t\\tfreq.push_back(i.second);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint n = freq.size();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//all the character in the string occurs only 1 time or not\\n\\t\\t\\t\\tif(n == word.size()) return true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsort(freq.begin(),freq.end());\\n\\t\\t\\t\\t// after sorting we will get the freq like 1,2,2,2,2,2 or 1,1,1,1,1,2 or .......\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(n==1) return true; // only one character is present in given string\\n\\t\\t\\t\\telse if(n>2){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(freq[0]+1 == freq[1]){\\n\\t\\t\\t\\t\\t// for this ->1,2,2,2,2,2  type freq\\n\\t\\t\\t\\t\\t\\tfor(int i=1;i<n-1; i++){\\n\\t\\t\\t\\t\\t\\t\\tif(freq[i] != freq[i+1]){\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(freq[n-1]-1 == freq[n-2]){\\n\\t\\t\\t\\t\\t// for this -> 1,1,1,1,1,2 type freq\\n\\t\\t\\t\\t\\t\\tfor(int i=1;i<n-1; i++){\\n\\t\\t\\t\\t\\t\\t\\tif(freq[i] != freq[i-1]){\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t// if neither of the condition satisfied means ::\\n\\t\\t\\t\\t\\t\\t//we have this type of freq array 1,1,1,2,2,2,2,3,3,3,4\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t// present only two different types of character in the given string (#word)\\n\\t\\t\\t\\t\\tif(freq[0]+1 != freq[1]){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'\\n: ) : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\tbool equalFrequency(string word) {\\n\\t\\t\\t\\n\\t\\t\\tunordered_map<char,int>vec;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tvec[word[i]]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2646977,
                "title": "javascript-simple-solution-with-set",
                "content": "Sorry, my english is not good.\\n\\n1. count characters in word with Array\\n2. loop ( A - Z )\\n\\t3. deep-copy Array in a local variable\\n\\t4. remove a character\\n\\t5. make a Set with array values\\n\\t6. if, size is 1, then frequency of every characters are same -> true\\n\\t7. if size is 2, and then it contains 0 ( 0 means that never reveal in string ) -> true\\n\\t\\t- this one has edge cases, like when the word has A-Z over twice like below\\n\\t\\t- \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\" -> Set { 1 , 2 }\\n\\t\\t- \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzaa\" -> Set { 2 ,  3}\\n8. we can\\'t equalize frequency -> false\\n\\n```\\nconst charcode = (c) => c.charCodeAt() - \\'a\\'.charCodeAt();\\n\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n    const absDiff = (a,b) => Math.abs(a - b);\\n    \\n    const counter = [...word].reduce((a,c) => {\\n        a[charcode(c)]++;\\n        return a;\\n    }, Array(26).fill(0));\\n    \\n    for(let i = 0; i < 26; i++) {\\n        if(!counter[i]) continue;\\n        const copiedCounter = [...counter];\\n        copiedCounter[i]--;\\n        const set = new Set(copiedCounter);\\n        \\n        if(set.size === 1) return true;\\n        if(set.size === 2 && set.has(0)) return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst charcode = (c) => c.charCodeAt() - \\'a\\'.charCodeAt();\\n\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n    const absDiff = (a,b) => Math.abs(a - b);\\n    \\n    const counter = [...word].reduce((a,c) => {\\n        a[charcode(c)]++;\\n        return a;\\n    }, Array(26).fill(0));\\n    \\n    for(let i = 0; i < 26; i++) {\\n        if(!counter[i]) continue;\\n        const copiedCounter = [...counter];\\n        copiedCounter[i]--;\\n        const set = new Set(copiedCounter);\\n        \\n        if(set.size === 1) return true;\\n        if(set.size === 2 && set.has(0)) return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646949,
                "title": "python3-easy",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        dct = collections.Counter(word)\\n        for el in word:\\n            dct[el]-=1\\n            if not dct[el]: del dct[el]\\n            if len(set(dct.values())) == 1: return True\\n            dct[el]+=1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        dct = collections.Counter(word)\\n        for el in word:\\n            dct[el]-=1\\n            if not dct[el]: del dct[el]\\n            if len(set(dct.values())) == 1: return True\\n            dct[el]+=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646944,
                "title": "c-frequency-map-solution-100-time-0ms-100-space-6-1mb",
                "content": "This was a deceptively tricky, cute one.\\n\\nIn order to solve it, I decided to work with a frequency map and to keep track of the overall frequency of all the characters.\\n\\nTo do so, let\\'s start creating a few support variables:\\n* `freqs` will be our frequency table, with `123` cells (ie: up to the ASCII code for `\\'z\\'`) all set to `0`;\\n* `maxFreq` and `minFreq` will store the value of the maximum frequency we will meet, initially set to `0` and `INT_MAX`;\\n* `maxCount` and `minCount` will store respectively the amounts of time we found a value equal to `maxFreq` and `maxFreq - 1` (the lower allowed frequency), both again preset to be `0`.\\n\\nIn order to get our frequencies, we will loop and for each character `c` in `word`, we will:\\n* increase `freqs[c]` by `1`;\\n* update `maxFreq` to be the maximim between its current value and `freqs[c]`.\\n\\nWe will then loop with `i` from each value from `\\'a\\'` to `\\'z\\'` and, if `freqs[i] != 0` (ie: if we found at least an occurrence of that character), we will have three cases:\\n* if `freqs[i] == maxFreq`, we will increase `maxCount` by `1`;\\n* else if `freqs[i] > maxFreq`, we will\\n    * update `maxFreq` to this new value;\\n    * reset `maxCount` to `1`;\\n* if `freqs[i] == minFreq`, we will increase `minCount` by `1`;\\n* else if `freqs[i] < minFreq`, we will\\n    * update `minFreq` to this new value;\\n    * reset `minCount` to `1`.\\n\\nIf we come out of the loop, we have three valid cases left to ponder, in which we can `return` `true`:\\n*  all the characters in `words` are all either identical or different (ie: `maxFreq == minFreq && (maxCount == 1 || maxFreq == 1)`);\\n* only one element is above the rest and only by `+ 1` (ie: `maxCount == 1 && maxFreq - minFreq == 1`);\\n* there is an character with freq `1` and all the rest is the same (ie: `minCount == 1 && maxFreq * maxCount == word.size() - 1`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        // support variables\\n        int freqs[123] = {}, maxFreq = 0, minFreq = INT_MAX, maxCount = 0, minCount = 0;\\n        // populating freqs and getting the higher one\\n        for (char c: word) maxFreq = max(maxFreq, ++freqs[c]);\\n        // checking all the characters we found\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            if (freqs[i]) {\\n                if (freqs[i] == maxFreq) maxCount++;\\n                else if (freqs[i] > maxFreq) maxFreq = freqs[i], maxCount = 1;\\n                if (freqs[i] == minFreq) minCount++;\\n                else if (freqs[i] < minFreq) minFreq = freqs[i], minCount = 1;\\n            }\\n        }\\n        return\\n            // first case: the characters are either all identical or all different\\n            maxFreq == minFreq && (maxCount == 1 || maxFreq == 1) ||\\n            // second case: only one outlier and it is + 1 above the rest\\n            maxCount == 1 && maxFreq - minFreq == 1 ||\\n            // third case: there is an character with freq 1 and all the rest is the same\\n            minCount == 1 && maxFreq * maxCount == word.size() - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        // support variables\\n        int freqs[123] = {}, maxFreq = 0, minFreq = INT_MAX, maxCount = 0, minCount = 0;\\n        // populating freqs and getting the higher one\\n        for (char c: word) maxFreq = max(maxFreq, ++freqs[c]);\\n        // checking all the characters we found\\n        for (int i = \\'a\\'; i <= \\'z\\'; i++) {\\n            if (freqs[i]) {\\n                if (freqs[i] == maxFreq) maxCount++;\\n                else if (freqs[i] > maxFreq) maxFreq = freqs[i], maxCount = 1;\\n                if (freqs[i] == minFreq) minCount++;\\n                else if (freqs[i] < minFreq) minFreq = freqs[i], minCount = 1;\\n            }\\n        }\\n        return\\n            // first case: the characters are either all identical or all different\\n            maxFreq == minFreq && (maxCount == 1 || maxFreq == 1) ||\\n            // second case: only one outlier and it is + 1 above the rest\\n            maxCount == 1 && maxFreq - minFreq == 1 ||\\n            // third case: there is an character with freq 1 and all the rest is the same\\n            minCount == 1 && maxFreq * maxCount == word.size() - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182326,
                "title": "without-any-nested-loop-better-than-most-voted-solution-with-explanation",
                "content": "# Intuition & Approach\\n\\nWe can observe that we can be greedy here, and try removing one letter from the least frequency, and one letter from the most frequency.\\nEqualizing frequencies can only and only be possible by removing either of those, try some examples to see.\\n\\n## Now\\nDo you know why is this solution better (faster) than the most voted one?\\nComment below if you know, else I\\'ll update it here.\\n\\n\\n# Complexity\\n\\nn == len(word)\\nk == len(set(word)), but as \"word consists of lowercase English letters only\", max(k) == 26\\n\\n- Time complexity: $$O(n + k*log(k)) = O(n + 26*log(26)) = O(n)$$\\n\\n- Space complexity: $$O(k) = O(26) = O(1)$$\\n\\n\\n# Code\\n\\n```py\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n\\n        from collections import Counter\\n\\n        # Sort the frequencies of (unique) letters:\\n        freq = sorted(Counter(word).values())  # O(n + k*log(k))\\n        # print(freq)  #debugging\\n\\n        freq[0] -= 1  # remove a letter from the least freq\\n        if len(set(filter(None, freq))) == 1:  # O(k)\\n            return True\\n\\n        freq[0] += 1  # add back for following\\n        freq[-1] -= 1  # remove a letter from the most freq\\n        return len(set(filter(None, freq))) == 1  # O(k)\\n\\n```\\n\\nFeel free to ask any doubt below!\\nCheers \\uD83E\\uDD42\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```py\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n\\n        from collections import Counter\\n\\n        # Sort the frequencies of (unique) letters:\\n        freq = sorted(Counter(word).values())  # O(n + k*log(k))\\n        # print(freq)  #debugging\\n\\n        freq[0] -= 1  # remove a letter from the least freq\\n        if len(set(filter(None, freq))) == 1:  # O(k)\\n            return True\\n\\n        freq[0] += 1  # add back for following\\n        freq[-1] -= 1  # remove a letter from the most freq\\n        return len(set(filter(None, freq))) == 1  # O(k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080552,
                "title": "o-nlogn-solution-step-wise-explanation",
                "content": "## UPVOTE MY SOLUTION\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n### FIRTS OF ALL IT\\'S NOT EASY PROBLEM DUE TO EDGE CASES IT SHOULD BE   ATLEAST MEDIUM\\n**As soon as I read the question it seems easy but it\\'s not My logic is simple I have checked only for true cases\\nI have used a map  to count the frequency  and used a vector to store a frequency**\\n\\n# Approach\\n### Case I\\n**if map size is one it means the word have only one element so vector will also have size one so in this case I have retured true**\\n #### ```aaaaaaaaaa``` there is only one element DELETE ```a```\\n #### so every elements frequency is same after deletion\\n\\n### CASE II\\n**If all elements are unique means all occuring only once**\\n ##### ```abcdefghi``` we can delete any element DELETE ```i``` \\n#### so every elements frequency is same after deletion\\n\\n\\n### CASE III\\n **If there is one element whose frequency is two and all others are    distinct occuring only once**\\n### i.e ```abcdefmm```  we can DELETE ```m``` so it becomes true\\n#### so every elements frequency is same after deletion\\n\\n\\n***###### THESE THREE  CASE STATEMENTS IS COMBINED INTO ONE***\\n\\n```if(one==n||(one==n-1&&two==1)||n==1)return true;```\\n\\n#### CASE IV\\n```if(one==1&&similar==n-2)return true;```\\n\\n**If there are n-1 elements in the word  whose frequency is same   and one element which  occuring  only once** \\n#### i.e ```abbbcccddd```    we can DELETE ```a``` so it becomes true\\n#### so every elements frequency is same after deletion\\n\\n\\n#### CASE V\\n```if(similar==n-2&&v[n-1]-v[n-2]==1)return true;```\\n\\n**if there are n-1  elements whose frequency is same and one      element whose frequency difference is 1**   \\n####  i.e ```aaabbbcccdddeeee``` DELETE ```e``` so every elements frequency is same after deletion\\n\\n\\n**vector will have 3,3,3,3,4 so n-1 element has same frequency  and last element have difference 1 with each frequency**\\n\\n\\nFor every other case answer will be false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(nlogn)$ Due to sort\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        map<char,int>mp;\\n        int n=w.size();\\n        vector<int>v;\\n        int one=0,two=0;\\n        for(int i=0; i<n; i++){mp[w[i]]++;}\\n        \\n        for(auto i: mp){\\n            v.push_back(i.second);\\n            if(i.second==1)one++;\\n            if(i.second==2)two++;\\n        }\\n        n=v.size();\\n        if(one==n||(one==n-1&&two==1)||n==1)return true;\\n        \\n       \\n        int similar=0;\\n         two=0;\\n        sort(v.begin(),v.end());\\n        \\n        for(int i=1; i<n; i++)if(v[i-1]==v[i])similar++;\\n        \\n        if(one==1&&similar==n-2)return true;\\n      \\n        if(similar==n-2&&v[n-1]-v[n-2]==1)return true;\\n     \\n\\n     return false; \\n\\n    }         \\n};\\n```\\n### UPVOTE IF YOU WANT MORE EXPLANATION LIKE THIS \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```aaaaaaaaaa```\n```a```\n```abcdefghi```\n```i```\n```abcdefmm```\n```m```\n```if(one==n||(one==n-1&&two==1)||n==1)return true;```\n```if(one==1&&similar==n-2)return true;```\n```abbbcccddd```\n```a```\n```if(similar==n-2&&v[n-1]-v[n-2]==1)return true;```\n```aaabbbcccdddeeee```\n```e```\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        map<char,int>mp;\\n        int n=w.size();\\n        vector<int>v;\\n        int one=0,two=0;\\n        for(int i=0; i<n; i++){mp[w[i]]++;}\\n        \\n        for(auto i: mp){\\n            v.push_back(i.second);\\n            if(i.second==1)one++;\\n            if(i.second==2)two++;\\n        }\\n        n=v.size();\\n        if(one==n||(one==n-1&&two==1)||n==1)return true;\\n        \\n       \\n        int similar=0;\\n         two=0;\\n        sort(v.begin(),v.end());\\n        \\n        for(int i=1; i<n; i++)if(v[i-1]==v[i])similar++;\\n        \\n        if(one==1&&similar==n-2)return true;\\n      \\n        if(similar==n-2&&v[n-1]-v[n-2]==1)return true;\\n     \\n\\n     return false; \\n\\n    }         \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010067,
                "title": "not-brute-force-solution",
                "content": "# Approach\\nSolution consideres all possible cases\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        cntr1 = Counter(word)\\n\\n        # Case 1 example: aaaa\\n        if len(cntr1.values()) == 1:\\n            return True\\n\\n        # Case 2 example: abcd\\n        if all(val == 1 for val in cntr1.values()):\\n            return True\\n        \\n        cntr2 = Counter(cntr1.values())\\n        if len(cntr2.values()) != 2:\\n            return False\\n        \\n        # Case 3 example: aaaabbbbcccccdddd\\n        item1, item2 = cntr2.items()\\n        if item1 > item2:\\n            item1, item2 = item2, item1\\n        if item2[0] - item1[0] == 1 and item2[1] == 1:\\n            return True\\n        \\n        # Case 4 example: aaaabbbbcdddd\\n        if item1 == (1, 1):\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        cntr1 = Counter(word)\\n\\n        # Case 1 example: aaaa\\n        if len(cntr1.values()) == 1:\\n            return True\\n\\n        # Case 2 example: abcd\\n        if all(val == 1 for val in cntr1.values()):\\n            return True\\n        \\n        cntr2 = Counter(cntr1.values())\\n        if len(cntr2.values()) != 2:\\n            return False\\n        \\n        # Case 3 example: aaaabbbbcccccdddd\\n        item1, item2 = cntr2.items()\\n        if item1 > item2:\\n            item1, item2 = item2, item1\\n        if item2[0] - item1[0] == 1 and item2[1] == 1:\\n            return True\\n        \\n        # Case 4 example: aaaabbbbcdddd\\n        if item1 == (1, 1):\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876727,
                "title": "not-brute-force-solution",
                "content": "# Approach\\nSolution consideres all possible cases\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == 0:\\n            return False\\n        \\n        cntrs = Counter(word)\\n        if len(cntrs) == 1:\\n            return True\\n\\n        cntrsSet = set(cntrs.values())\\n\\n        minn = math.inf\\n        maxx = -math.inf\\n        for cntr in cntrs.values():\\n            minn = min(minn, cntr)\\n            maxx = max(maxx, cntr)\\n        \\n        numOfMin = 0\\n        numOfMax = 0\\n        for cntr in cntrs.values():\\n            if cntr == minn:\\n                numOfMin += 1\\n            if cntr == maxx:\\n                numOfMax += 1\\n\\n        if maxx - minn == 1 and numOfMax == 1 and len(cntrsSet) == 2:\\n            return True\\n        \\n        if minn == 1 and numOfMin == 1 and len(cntrsSet) == 2:\\n            return True\\n        \\n        if minn == maxx == 1:\\n            return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == 0:\\n            return False\\n        \\n        cntrs = Counter(word)\\n        if len(cntrs) == 1:\\n            return True\\n\\n        cntrsSet = set(cntrs.values())\\n\\n        minn = math.inf\\n        maxx = -math.inf\\n        for cntr in cntrs.values():\\n            minn = min(minn, cntr)\\n            maxx = max(maxx, cntr)\\n        \\n        numOfMin = 0\\n        numOfMax = 0\\n        for cntr in cntrs.values():\\n            if cntr == minn:\\n                numOfMin += 1\\n            if cntr == maxx:\\n                numOfMax += 1\\n\\n        if maxx - minn == 1 and numOfMax == 1 and len(cntrsSet) == 2:\\n            return True\\n        \\n        if minn == 1 and numOfMin == 1 and len(cntrsSet) == 2:\\n            return True\\n        \\n        if minn == maxx == 1:\\n            return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725340,
                "title": "easy-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n       int[] freq= new int[26];\\n        for(char c : word.toCharArray()) freq[c - \\'a\\']++;\\n        \\n        for(char c : word.toCharArray()){\\n            freq[c - \\'a\\']--; //as we have asked to delete exactly one char, so we will decrease freq by one for all\\n                             //chars and will check if after decreasing, the freqs of all chars are same or not, If\\n                             //not return false otherwise true;\\n            \\n            if(check(freq)){ // freqs are same no need to check further return true;\\n                return true;\\n            }\\n            freq[c - \\'a\\']++; // we are here cause the earlier char freq is not same to other freqs. restore that char freq and check for next char.\\n        }\\n        return false;\\n    }\\n    \\n    public boolean check(int[] freq){\\n        int count = 0;\\n        \\n        for(int f : freq){\\n            if(f == 0) continue;\\n            else if(count == 0){\\n                count = f;\\n            }else if(count == f) continue;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n       int[] freq= new int[26];\\n        for(char c : word.toCharArray()) freq[c - \\'a\\']++;\\n        \\n        for(char c : word.toCharArray()){\\n            freq[c - \\'a\\']--; //as we have asked to delete exactly one char, so we will decrease freq by one for all\\n                             //chars and will check if after decreasing, the freqs of all chars are same or not, If\\n                             //not return false otherwise true;\\n            \\n            if(check(freq)){ // freqs are same no need to check further return true;\\n                return true;\\n            }\\n            freq[c - \\'a\\']++; // we are here cause the earlier char freq is not same to other freqs. restore that char freq and check for next char.\\n        }\\n        return false;\\n    }\\n    \\n    public boolean check(int[] freq){\\n        int count = 0;\\n        \\n        for(int f : freq){\\n            if(f == 0) continue;\\n            else if(count == 0){\\n                count = f;\\n            }else if(count == f) continue;\\n            else return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651688,
                "title": "c-easy-solution-using-map-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> v;\\n        unordered_map<char,int> m;\\n        for(auto& i : word){\\n            m[i]++;\\n        }\\n        for(auto& itr : m){\\n            v.push_back(itr.second);\\n        }\\n        int l=v.size();\\n        for(int i=0; i<l; ++i){\\n            v[i] -= 1;\\n            unordered_set<int> s;\\n            for(auto& itr : v){\\n                if(itr>0) s.insert(itr);\\n            }\\n            if(s.size() == 1) return true;\\n            v[i] += 1;\\n            s.clear();\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> v;\\n        unordered_map<char,int> m;\\n        for(auto& i : word){\\n            m[i]++;\\n        }\\n        for(auto& itr : m){\\n            v.push_back(itr.second);\\n        }\\n        int l=v.size();\\n        for(int i=0; i<l; ++i){\\n            v[i] -= 1;\\n            unordered_set<int> s;\\n            for(auto& itr : v){\\n                if(itr>0) s.insert(itr);\\n            }\\n            if(s.size() == 1) return true;\\n            v[i] += 1;\\n            s.clear();\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649443,
                "title": "1ms-easy-java-solution-using-frequency-array",
                "content": "Here, we are using frequency array to map the frequency and after that we are checking by deleting each character one by one.\\n\\n**Please upvoat if you find this useful**\\n\\n```\\nclass Solution {\\n    public boolean equalFrequency(String str) {\\n        int l = str.length();\\n        // fill frequency array\\n        int[] freq = new int[26];\\n \\n        for (int i = 0; i < l; i++)\\n            freq[getIdx(str.charAt(i))]++;\\n\\n \\n        /*  Try decreasing frequency of all character\\n            by one and then check all equality of all\\n            non-zero frequencies */\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int i = getIdx(c);\\n \\n            // Check character only if it occurs in str\\n            if (freq[i] > 0) {\\n                freq[i]--;\\n \\n                if (allSame(freq, 26))\\n                    return true;\\n                freq[i]++;\\n            }\\n        }\\n \\n        return false;\\n    }\\n    \\n    // in lower alphabet characters\\n    static int getIdx(char ch)\\n    {\\n        return (ch - \\'a\\');\\n    }\\n    static boolean allSame(int freq[], int N)\\n    {\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n}\\n```\\n\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String str) {\\n        int l = str.length();\\n        // fill frequency array\\n        int[] freq = new int[26];\\n \\n        for (int i = 0; i < l; i++)\\n            freq[getIdx(str.charAt(i))]++;\\n\\n \\n        /*  Try decreasing frequency of all character\\n            by one and then check all equality of all\\n            non-zero frequencies */\\n        for (char c = \\'a\\'; c <= \\'z\\'; c++) {\\n            int i = getIdx(c);\\n \\n            // Check character only if it occurs in str\\n            if (freq[i] > 0) {\\n                freq[i]--;\\n \\n                if (allSame(freq, 26))\\n                    return true;\\n                freq[i]++;\\n            }\\n        }\\n \\n        return false;\\n    }\\n    \\n    // in lower alphabet characters\\n    static int getIdx(char ch)\\n    {\\n        return (ch - \\'a\\');\\n    }\\n    static boolean allSame(int freq[], int N)\\n    {\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648446,
                "title": "javascript-time-memory-100-time-o-n-space-o-1",
                "content": "```// for this solution, we will\\n// 1. log each letter into a map with the [letter, occurance]\\n// 2. use the map to find the average of the occurance of each letter\\n// 3. check for edge cases where each letter only occurs once or there is only one letter in the map.\\n// 4. compare the average to the occurances. if there is more than one that does not equal the average, return false.\\n\\nvar equalFrequency = function(word) {\\n    let map = new Map();\\n    \\n    // 1.\\n    for (const c of word){\\n        map.set(c, map.has(c) ? map.get(c) + 1 : 1);\\n    }\\n    \\n    // 2.\\n    let avg = 0;\\n    for (const entry of map) avg += entry[1];\\n    \\n    // 3.\\n    if (avg / map.size === 1 || map.size === 1) return true;\\n    avg = Math.round(avg / map.size);\\n    \\n    // 4.\\n    let oneOff = false;\\n    for (const entry of map){\\n        if (Math.abs(entry[1] - avg) > 1) return false;\\n        else if(Math.abs(entry[1] - avg) === 1){\\n            if(oneOff === false) oneOff = true;\\n            else return false;\\n        }   \\n    }\\n    return oneOff;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```// for this solution, we will\\n// 1. log each letter into a map with the [letter, occurance]\\n// 2. use the map to find the average of the occurance of each letter\\n// 3. check for edge cases where each letter only occurs once or there is only one letter in the map.\\n// 4. compare the average to the occurances. if there is more than one that does not equal the average, return false.\\n\\nvar equalFrequency = function(word) {\\n    let map = new Map();\\n    \\n    // 1.\\n    for (const c of word){\\n        map.set(c, map.has(c) ? map.get(c) + 1 : 1);\\n    }\\n    \\n    // 2.\\n    let avg = 0;\\n    for (const entry of map) avg += entry[1];\\n    \\n    // 3.\\n    if (avg / map.size === 1 || map.size === 1) return true;\\n    avg = Math.round(avg / map.size);\\n    \\n    // 4.\\n    let oneOff = false;\\n    for (const entry of map){\\n        if (Math.abs(entry[1] - avg) > 1) return false;\\n        else if(Math.abs(entry[1] - avg) === 1){\\n            if(oneOff === false) oneOff = true;\\n            else return false;\\n        }   \\n    }\\n    return oneOff;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2648059,
                "title": "java-fast-100-o-n-short-and-simple-solution-easy-to-understand",
                "content": "\\n\\n```java\\n    public boolean equalFrequency(String word) {\\n        int[] c = new int[26];\\n        int n = word.length();\\n\\t\\t// count freq of each char\\n        for (int i = 0; i < n; i++) {\\n            c[word.charAt(i)-\\'a\\']++;\\n        }\\n\\t\\t// delete of every appeared character, check if any operation works.\\n        for (int i = 0; i < 26; i++) {\\n            if (c[i] == 0) continue;\\n            c[i]--;\\n            if (isEqual(c)) return true;\\n            c[i]++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t// check the count number of each character frequency using hashset.\\n\\t// If all characters in processed string has same frequency (set.size() == 1), \\n\\t// or the processed string becomes empty (set.size() == 0),  return true;\\n\\t\\n    private boolean isEqual(int[] c) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (c[i]!=0) {\\n                set.add(c[i]);\\n            }\\n        }\\n        return set.size() < 2;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n```java\\n    public boolean equalFrequency(String word) {\\n        int[] c = new int[26];\\n        int n = word.length();\\n\\t\\t// count freq of each char\\n        for (int i = 0; i < n; i++) {\\n            c[word.charAt(i)-\\'a\\']++;\\n        }\\n\\t\\t// delete of every appeared character, check if any operation works.\\n        for (int i = 0; i < 26; i++) {\\n            if (c[i] == 0) continue;\\n            c[i]--;\\n            if (isEqual(c)) return true;\\n            c[i]++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t// check the count number of each character frequency using hashset.\\n\\t// If all characters in processed string has same frequency (set.size() == 1), \\n\\t// or the processed string becomes empty (set.size() == 0),  return true;\\n\\t\\n    private boolean isEqual(int[] c) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < 26; i++) {\\n            if (c[i]!=0) {\\n                set.add(c[i]);\\n            }\\n        }\\n        return set.size() < 2;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2647632,
                "title": "c-just-solved-each-general-edge-case-with-explanation",
                "content": "CASE 1 : when string has single character. \\n\\t\\t\\t\\texample - \"a\"\\n\\t\\t\\t\\t\\nCASE 2 : when one character occurs once and all other characters with same frequency. \\n\\t\\t\\t\\texample - \"abbccdd\"\\n\\t\\t\\t\\t\\nCASE 3 : When most frequent character only once with 1 extra count with rest of character\\'s frequency.\\n\\t\\t\\t\\texample - \"aabbccddd\"\\n\\t\\t\\t\\t\\nCASE 4 : When each characters occurs only once.\\n\\t\\t\\t\\texample - \"abcd\"\\n\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<int,int> ump;\\n        for(auto x : word)\\n            ump[x-\\'a\\']++;\\n        \\n        vector<int> v;\\n        for(auto [x,t]:ump) \\n            v.push_back(t);\\n        \\n        sort(begin(v), end(v));\\n        int n = v.size();\\n\\t\\t\\n        if(n==1) return true;  //case 1\\n        if(v[0] == 1 and v[1]==v[n-1]) return true;  //case 2\\n        else if(v[0] == v[n-2] and v[n-1] == v[n-2]+1) return true; //case 3\\n        else if(v[0] == v[n-1] and v[0] == 1) return true;  //case 4\\n\\t\\t\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<int,int> ump;\\n        for(auto x : word)\\n            ump[x-\\'a\\']++;\\n        \\n        vector<int> v;\\n        for(auto [x,t]:ump) \\n            v.push_back(t);\\n        \\n        sort(begin(v), end(v));\\n        int n = v.size();\\n\\t\\t\\n        if(n==1) return true;  //case 1\\n        if(v[0] == 1 and v[1]==v[n-1]) return true;  //case 2\\n        else if(v[0] == v[n-2] and v[n-1] == v[n-2]+1) return true; //case 3\\n        else if(v[0] == v[n-1] and v[0] == 1) return true;  //case 4\\n\\t\\t\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647474,
                "title": "simple-c-solution",
                "content": "```\\nbool equalFrequency(string word) {\\n        map<char,int>mp;\\n        for(auto it:word)\\n        {\\n            mp[it]++;\\n        }\\n        vector<int>arr;\\n        for(auto it:mp)\\n        {\\n            arr.push_back(it.second);\\n        }\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        if(n==1)\\n            return true;\\n        else if(arr[n-1]==1)\\n            return true;\\n        else if(arr[0]==arr[n-2] && arr[n-1]-arr[n-2]==1)\\n            return true;\\n        else if(arr[0]==1 && arr[1]==arr[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool equalFrequency(string word) {\\n        map<char,int>mp;\\n        for(auto it:word)\\n        {\\n            mp[it]++;\\n        }\\n        vector<int>arr;\\n        for(auto it:mp)\\n        {\\n            arr.push_back(it.second);\\n        }\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        if(n==1)\\n            return true;\\n        else if(arr[n-1]==1)\\n            return true;\\n        else if(arr[0]==arr[n-2] && arr[n-1]-arr[n-2]==1)\\n            return true;\\n        else if(arr[0]==1 && arr[1]==arr[n-1])\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647227,
                "title": "c-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isEqualFreq(unordered_map<char, int> &m)\\n    {\\n        int f1; \\n        for(auto &it : m) \\n        {\\n            if(it.second > 0) \\n            {\\n                f1 = it.second;\\n                break;\\n            }\\n        }\\n        for(auto &it : m)\\n        {\\n            if (it.second > 0 && it.second != f1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) \\n    {\\n        unordered_map<char, int> m;\\n        \\n        for(auto it : word)\\n            m[it]++;\\n        \\n        for(auto &it : m) \\n        {\\n            if(it.second > 0) \\n            {\\n\\t\\t\\t    it.second--; //removing one character\\n\\t\\t\\t\\n                if (isEqualFreq(m)) //checking frequency of all characters same or not after removing\\n                    return true;\\n                \\n                it.second++;\\n            }\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqualFreq(unordered_map<char, int> &m)\\n    {\\n        int f1; \\n        for(auto &it : m) \\n        {\\n            if(it.second > 0) \\n            {\\n                f1 = it.second;\\n                break;\\n            }\\n        }\\n        for(auto &it : m)\\n        {\\n            if (it.second > 0 && it.second != f1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) \\n    {\\n        unordered_map<char, int> m;\\n        \\n        for(auto it : word)\\n            m[it]++;\\n        \\n        for(auto &it : m) \\n        {\\n            if(it.second > 0) \\n            {\\n\\t\\t\\t    it.second--; //removing one character\\n\\t\\t\\t\\n                if (isEqualFreq(m)) //checking frequency of all characters same or not after removing\\n                    return true;\\n                \\n                it.second++;\\n            }\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646847,
                "title": "bruteforce-solution",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n   bool doable(unordered_map<char, int> &mp) {\\n        unordered_set<int> st;\\n        for (auto &[key, val] : mp) {\\n            if (val > 0) {\\n                st.insert(val);\\n            }\\n        }\\n        return st.size() == 1;\\n    }\\npublic:\\n    bool equalFrequency(string &word) {\\n        unordered_map<char, int> mp;\\n        for (char &c : word) mp[c]++;\\n        for (auto &[key, val] : mp) {\\n            mp[key]--;\\n            if (doable(mp)) return true;\\n            mp[key]++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nDo consider upvoting and sharing.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n   bool doable(unordered_map<char, int> &mp) {\\n        unordered_set<int> st;\\n        for (auto &[key, val] : mp) {\\n            if (val > 0) {\\n                st.insert(val);\\n            }\\n        }\\n        return st.size() == 1;\\n    }\\npublic:\\n    bool equalFrequency(string &word) {\\n        unordered_map<char, int> mp;\\n        for (char &c : word) mp[c]++;\\n        for (auto &[key, val] : mp) {\\n            mp[key]--;\\n            if (doable(mp)) return true;\\n            mp[key]++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646737,
                "title": "java-easy-to-understand-o-n-time-o-1-space-0-ms",
                "content": "```\\n    int[] f = new int[26];\\n        int maxFreq = 0;\\n        for(char c : word.toCharArray()){\\n            f[c - \\'a\\']++;\\n            maxFreq = Math.max(maxFreq, f[c - \\'a\\']);\\n        }\\n        int maxCount = 0;\\n        int maxMinusOneCount = 0;\\n        int everyThingElse = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            if(f[i] == 0) continue;\\n            if(f[i] == maxFreq) maxCount++;\\n            if((f[i] == maxFreq - 1)) maxMinusOneCount += f[i];\\n            if(f[i] < maxFreq - 1) everyThingElse++;\\n\\n        }\\n        return (maxMinusOneCount == 0 && everyThingElse == 1 && maxFreq >= 2)  || \\n            (maxMinusOneCount == 1 && everyThingElse ==0 && maxFreq >= 2) || \\n            (maxCount == 1 &&  everyThingElse ==0) || \\n            (maxMinusOneCount == 0 && maxFreq == 1);\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    int[] f = new int[26];\\n        int maxFreq = 0;\\n        for(char c : word.toCharArray()){\\n            f[c - \\'a\\']++;\\n            maxFreq = Math.max(maxFreq, f[c - \\'a\\']);\\n        }\\n        int maxCount = 0;\\n        int maxMinusOneCount = 0;\\n        int everyThingElse = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            if(f[i] == 0) continue;\\n            if(f[i] == maxFreq) maxCount++;\\n            if((f[i] == maxFreq - 1)) maxMinusOneCount += f[i];\\n            if(f[i] < maxFreq - 1) everyThingElse++;\\n\\n        }\\n        return (maxMinusOneCount == 0 && everyThingElse == 1 && maxFreq >= 2)  || \\n            (maxMinusOneCount == 1 && everyThingElse ==0 && maxFreq >= 2) || \\n            (maxCount == 1 &&  everyThingElse ==0) || \\n            (maxMinusOneCount == 0 && maxFreq == 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646718,
                "title": "java-easy-to-understand-fixed",
                "content": "fixed\\n\\n```\\npublic boolean equalFrequency(String word) {\\n        int[] data = new int[26];\\n        for (char c: word.toCharArray()) data[c -\\'a\\']++;\\n        for (int i = 0; i< 26; i++){\\n            data[i]--;\\n            if (isEqual(data)) return true;\\n            data[i]++;\\n        }\\n        return false;\\n    }\\n    private boolean isEqual(int[] data){\\n        int lastCount = 0;\\n        for (int count: data){\\n            if (count == 0) continue;\\n            if (lastCount != 0 && count != lastCount) return false;\\n            lastCount = count;\\n        }\\n        return true;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean equalFrequency(String word) {\\n        int[] data = new int[26];\\n        for (char c: word.toCharArray()) data[c -\\'a\\']++;\\n        for (int i = 0; i< 26; i++){\\n            data[i]--;\\n            if (isEqual(data)) return true;\\n            data[i]++;\\n        }\\n        return false;\\n    }\\n    private boolean isEqual(int[] data){\\n        int lastCount = 0;\\n        for (int count: data){\\n            if (count == 0) continue;\\n            if (lastCount != 0 && count != lastCount) return false;\\n            lastCount = count;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646602,
                "title": "after-thousand-attempts-c",
                "content": "God bless anyone who can understand my solution.\\n```c++\\nbool equalFrequency(string word) {\\n        int n=word.length();\\n        //counting frequency of every character\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)    mp[word[i]]++;\\n        //counting frequency of frequency\\n        unordered_map<int,int> mp2;\\n        for(auto it:mp) mp2[it.second]++;\\n        //considering different cases\\n        if(mp2.size()>2)    return false;\\n        else if(mp2.size()==1)\\n        {\\n            if(mp2.begin()->second==1)  return true;\\n            return  (mp2.begin()->first==1);\\n        }\\n        vector<int> temp;\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(auto it:mp2)\\n        {\\n            temp.push_back(it.first);\\n            if(it.first==1&&it.second==1) return true;\\n            mini=min(mini,it.second);\\n            maxi=max(maxi,it.second);\\n        }\\n        int diff=abs(temp[0]-temp[1]);\\n        if(diff==1&&(mini==1||maxi==1)) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nbool equalFrequency(string word) {\\n        int n=word.length();\\n        //counting frequency of every character\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<n;i++)    mp[word[i]]++;\\n        //counting frequency of frequency\\n        unordered_map<int,int> mp2;\\n        for(auto it:mp) mp2[it.second]++;\\n        //considering different cases\\n        if(mp2.size()>2)    return false;\\n        else if(mp2.size()==1)\\n        {\\n            if(mp2.begin()->second==1)  return true;\\n            return  (mp2.begin()->first==1);\\n        }\\n        vector<int> temp;\\n        int mini=INT_MAX,maxi=INT_MIN;\\n        for(auto it:mp2)\\n        {\\n            temp.push_back(it.first);\\n            if(it.first==1&&it.second==1) return true;\\n            mini=min(mini,it.second);\\n            maxi=max(maxi,it.second);\\n        }\\n        int diff=abs(temp[0]-temp[1]);\\n        if(diff==1&&(mini==1||maxi==1)) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073615,
                "title": "noob-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: **o(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **o(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        c=0\\n        n=0\\n        k=[]\\n        se=0\\n        cl=[]\\n        l1=[]\\n        c2=[]\\n        ck=0\\n        o=False\\n        if len(word)>2:\\n            for j in range (0,len(word)):\\n                l1.append(word[j])\\n            for j in range (0,len(word)):\\n                c=l1.count(word[j])\\n                if (c!=1):\\n                    cl.append(c)\\n                if (c==1):\\n                    c2.append(c)\\n                    ck=len(c2)\\n            temp=cl.count(3)\\n            temp2=cl.count(4)\\n            if len(cl)>0:\\n                se=cl[0]\\n                if(ck>1):\\n                    print(len(cl))\\n                    if(len(cl)>2):\\n                        o=False\\n                    else:\\n                        o=True\\n                else:\\n                    for j in cl:\\n                        if se!=j:\\n                            o=False\\n                            if (temp==3 and temp2==0):\\n                                if (len(c2)==0):\\n                                    o=True\\n                                else:\\n                                    o=False\\n                        else:\\n                            if (ck>=1):\\n                                o=True\\n            else:\\n                o=True   \\n        else:\\n            o=True\\n        if(len(word)==word.count(word[0])):\\n            o=True         \\n        return(o)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        c=0\\n        n=0\\n        k=[]\\n        se=0\\n        cl=[]\\n        l1=[]\\n        c2=[]\\n        ck=0\\n        o=False\\n        if len(word)>2:\\n            for j in range (0,len(word)):\\n                l1.append(word[j])\\n            for j in range (0,len(word)):\\n                c=l1.count(word[j])\\n                if (c!=1):\\n                    cl.append(c)\\n                if (c==1):\\n                    c2.append(c)\\n                    ck=len(c2)\\n            temp=cl.count(3)\\n            temp2=cl.count(4)\\n            if len(cl)>0:\\n                se=cl[0]\\n                if(ck>1):\\n                    print(len(cl))\\n                    if(len(cl)>2):\\n                        o=False\\n                    else:\\n                        o=True\\n                else:\\n                    for j in cl:\\n                        if se!=j:\\n                            o=False\\n                            if (temp==3 and temp2==0):\\n                                if (len(c2)==0):\\n                                    o=True\\n                                else:\\n                                    o=False\\n                        else:\\n                            if (ck>=1):\\n                                o=True\\n            else:\\n                o=True   \\n        else:\\n            o=True\\n        if(len(word)==word.count(word[0])):\\n            o=True         \\n        return(o)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785436,
                "title": "unnecessarily-long-c-solution-if-you-hate-yourself-beats-100-time-and-88-memory",
                "content": "# Intuition\\nMonday left me broken\\nTuesday, I was through with hoping\\nWednesday, my empty arms were open\\nThursday, waiting for love, waiting for love\\nThank the stars, it\\'s Friday\\nI\\'m burning like a fire gone wild on Saturday\\nGuess I won\\'t be coming to church on Sunday\\nI\\'ll be waiting for love, waiting for love to come around\\n\\n# Approach\\nKeep submitting and adding a new if statement whenever a testcase fails\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int freq[26] = {0};\\n        char last = word[word.length()-1];\\n        for(auto l: word){\\n            freq[l-\\'a\\']++;\\n        }\\n        char last2;\\n        int i = word.length()-2;\\n        for(;i>=0;i--){\\n            if(word[i] != last){\\n                last2 = word[i];break;\\n            }\\n        }\\n        if(i == -1)return true;\\n        int mode, nonmode;\\n        if(freq[last-\\'a\\'] == freq[last2-\\'a\\']){\\n            mode = freq[last-\\'a\\'];\\n            for (;i>=0;--i){\\n                if (freq[word[i]-\\'a\\']==mode)continue;\\n                else if(abs(freq[word[i]-\\'a\\']-mode) == 1 || freq[word[i]-\\'a\\'] == 1){nonmode = word[i]-\\'a\\';break;}\\n                else if (abs(freq[word[i]-\\'a\\']-mode)>1)return false;\\n            }\\n            if(i==-1)return mode == 1;\\n        }\\n        else if(abs(freq[last-\\'a\\']-freq[last2-\\'a\\']) != 1 && freq[last-\\'a\\'] != 1&& freq[last2-\\'a\\'] != 1)return false;\\n        else{\\n            char last3;\\n            for(;i>=0;i--){\\n                if(word[i] != last && word[i]!=last2){\\n                    last3 = word[i];break;\\n                }\\n            }\\n            if (i == -1)return true;\\n            if(freq[last3-\\'a\\'] == freq[last-\\'a\\']){mode = freq[last-\\'a\\'];nonmode = last2-\\'a\\';}\\n            else if(freq[last3-\\'a\\'] == freq[last2-\\'a\\']){mode = freq[last2-\\'a\\'];nonmode = last-\\'a\\';}\\n            else return false;\\n            if (mode == 1 && freq[nonmode] - mode > 1)return false;\\n        }\\n        if (freq[nonmode]<mode && freq[nonmode]!=1)return false;\\n        cout << mode << \\' \\' << nonmode << \\'\\\\n\\';\\n        for(i = 0; i < 26;++i){\\n            if(freq[i]>0 && i !=nonmode){\\n                if(freq[i]!=mode)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int freq[26] = {0};\\n        char last = word[word.length()-1];\\n        for(auto l: word){\\n            freq[l-\\'a\\']++;\\n        }\\n        char last2;\\n        int i = word.length()-2;\\n        for(;i>=0;i--){\\n            if(word[i] != last){\\n                last2 = word[i];break;\\n            }\\n        }\\n        if(i == -1)return true;\\n        int mode, nonmode;\\n        if(freq[last-\\'a\\'] == freq[last2-\\'a\\']){\\n            mode = freq[last-\\'a\\'];\\n            for (;i>=0;--i){\\n                if (freq[word[i]-\\'a\\']==mode)continue;\\n                else if(abs(freq[word[i]-\\'a\\']-mode) == 1 || freq[word[i]-\\'a\\'] == 1){nonmode = word[i]-\\'a\\';break;}\\n                else if (abs(freq[word[i]-\\'a\\']-mode)>1)return false;\\n            }\\n            if(i==-1)return mode == 1;\\n        }\\n        else if(abs(freq[last-\\'a\\']-freq[last2-\\'a\\']) != 1 && freq[last-\\'a\\'] != 1&& freq[last2-\\'a\\'] != 1)return false;\\n        else{\\n            char last3;\\n            for(;i>=0;i--){\\n                if(word[i] != last && word[i]!=last2){\\n                    last3 = word[i];break;\\n                }\\n            }\\n            if (i == -1)return true;\\n            if(freq[last3-\\'a\\'] == freq[last-\\'a\\']){mode = freq[last-\\'a\\'];nonmode = last2-\\'a\\';}\\n            else if(freq[last3-\\'a\\'] == freq[last2-\\'a\\']){mode = freq[last2-\\'a\\'];nonmode = last-\\'a\\';}\\n            else return false;\\n            if (mode == 1 && freq[nonmode] - mode > 1)return false;\\n        }\\n        if (freq[nonmode]<mode && freq[nonmode]!=1)return false;\\n        cout << mode << \\' \\' << nonmode << \\'\\\\n\\';\\n        for(i = 0; i < 26;++i){\\n            if(freq[i]>0 && i !=nonmode){\\n                if(freq[i]!=mode)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3661151,
                "title": "the-clearest-3-line-solution",
                "content": "# Intuition\\nUse $$Counter$$\\n\\n# Approach\\nConsiderate each of 4 cases\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(26)$$\\n\\n# Code\\n``` Python []\\nclass Solution:\\n  def equalFrequency(self, word: str) -> bool:\\n    freq = Counter(word).values()\\n    mi, ma, le, wle = min(freq), max(freq), len(freq), len(word)\\n    return (\\n      le == 1 or  # one char any times\\n      ma == 1 or  # each char once\\n      mi == ma - 1 and wle == mi * le + 1 or  # one char extra\\n      mi == 1 and wle == ma * (le - 1) + 1  # single extra char\\n    )\\n```\\n``` Python []\\nclass Solution:\\n  def equalFrequency(self, word: str) -> bool:\\n    freq = [*Counter(word).values()]\\n    mi, ma, le, wle = min(freq), max(freq), len(freq), len(word)\\n    return le == 1 or ma == 1 or mi == ma - 1 and wle == mi * le + 1 or mi == 1 and freq.count(ma) == le - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "``` Python []\\nclass Solution:\\n  def equalFrequency(self, word: str) -> bool:\\n    freq = Counter(word).values()\\n    mi, ma, le, wle = min(freq), max(freq), len(freq), len(word)\\n    return (\\n      le == 1 or  # one char any times\\n      ma == 1 or  # each char once\\n      mi == ma - 1 and wle == mi * le + 1 or  # one char extra\\n      mi == 1 and wle == ma * (le - 1) + 1  # single extra char\\n    )\\n```\n``` Python []\\nclass Solution:\\n  def equalFrequency(self, word: str) -> bool:\\n    freq = [*Counter(word).values()]\\n    mi, ma, le, wle = min(freq), max(freq), len(freq), len(word)\\n    return le == 1 or ma == 1 or mi == ma - 1 and wle == mi * le + 1 or mi == 1 and freq.count(ma) == le - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411581,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        vector<int>v(26,0);\\n        for(auto i:w)    v[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            vector<int>temp=v;\\n            if(temp[i]<=0)  continue;\\n            temp[i]-=1;\\n            set<int>st;\\n            for(int j=0;j<temp.size();j++){  \\n                if(temp[j]>0) st.insert(temp[j]);\\n            }\\n            if(st.size()==1) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        vector<int>v(26,0);\\n        for(auto i:w)    v[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            vector<int>temp=v;\\n            if(temp[i]<=0)  continue;\\n            temp[i]-=1;\\n            set<int>st;\\n            for(int j=0;j<temp.size();j++){  \\n                if(temp[j]>0) st.insert(temp[j]);\\n            }\\n            if(st.size()==1) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332918,
                "title": "python3-beat-91-90-27ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == len(set(word)): return True\\n        word = list(word)\\n        for i in word:\\n            b = (word.index(i))\\n            if word.count(i) > 0:\\n                word.pop(word.index(i))\\n                if len(set(Counter(word).values())) == 1:\\n                    return True\\n                else:\\n                    word.insert(b, i)\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == len(set(word)): return True\\n        word = list(word)\\n        for i in word:\\n            b = (word.index(i))\\n            if word.count(i) > 0:\\n                word.pop(word.index(i))\\n                if len(set(Counter(word).values())) == 1:\\n                    return True\\n                else:\\n                    word.insert(b, i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161695,
                "title": "a-simple-solution-on-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReturn true if it is possible to `remove one letter` so that `the frequency of all letters in word are equal`, and false otherwise.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s create a map in which key = letter, value = number of repetitions in a word.\\nThe algorithm will consist in checking the condition: if you delete one letter, the frequency of letters will become the same. To do this, we need a set that will contain the number of repetitions of letters.\\nSince the set does not contain repetitions, the set for a word with the same frequency of letters will contain only one number equal to the frequency.\\n1. Create a cycle of passing through each letter of the word;\\n2. Reducing the frequency of occurrence of the letter by 1 (it turns out that we removed this letter from the word, For example: the original word = aabbc, after removing the first letter, our word will become = abbc. Or by removing the third letter, our word will become = aabc. When deleting the last one - aabb);\\n3. Create a set that contains the frequency of occurrence of the letter. If there is only one value in the word after deleting the letter under the idex i in the set => then the frequency of occurrence of each letter is the same => we achieve the condition of the problem;\\n4. Do not forget to return the \"stolen\" value of 1 from the letter under the index i.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val counter = word.groupingBy { it }.eachCount().toMutableMap()\\n\\n        for (i in word) {\\n            counter[i] = counter[i]!! - 1\\n\\n            val set = counter.filterNot { it.value == 0 }.values.toHashSet()\\n           \\n            if (set.size == 1) return true\\n\\n            counter[i] = counter[i]!! + 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val counter = word.groupingBy { it }.eachCount().toMutableMap()\\n\\n        for (i in word) {\\n            counter[i] = counter[i]!! - 1\\n\\n            val set = counter.filterNot { it.value == 0 }.values.toHashSet()\\n           \\n            if (set.size == 1) return true\\n\\n            counter[i] = counter[i]!! + 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956376,
                "title": "q2423-accepted-c-using-hashmaps-simple-logic-easy",
                "content": "Idk, should I praise this \\'Easy\\' question or Hate it.\\nVery amazing and tricky test cases \\nTried this Question multiple times before reaching to this solution.\\nPlease Upvote \\uD83D\\uDC4D\\uD83E\\uDEF6\\uD83C\\uDFFB\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map <char,int> mp1;\\n        map <int,int> mp2;\\n        for(auto i:word)\\n            mp1[i]++;\\n\\n        for(auto i:mp1)\\n            mp2[i.second]++;\\n        \\n        if(mp2.size()>2)\\n            return false;\\n        \\n        map<int, int>::iterator it1 = mp2.begin();\\n        if(mp2.size()==1){\\n            if(mp1.size()==1 || it1->first==1) // Ex. aa || abc return true\\n                return true;\\n            return false; // Ex. aabbcc return false\\n        }\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        if(mp2.size()==2){\\n            if(it1->second==1 && it1->first==1) //One Freq and One Item\\n                return true;\\n            if(it1->first==it2->first-1 && it2->second==1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map <char,int> mp1;\\n        map <int,int> mp2;\\n        for(auto i:word)\\n            mp1[i]++;\\n\\n        for(auto i:mp1)\\n            mp2[i.second]++;\\n        \\n        if(mp2.size()>2)\\n            return false;\\n        \\n        map<int, int>::iterator it1 = mp2.begin();\\n        if(mp2.size()==1){\\n            if(mp1.size()==1 || it1->first==1) // Ex. aa || abc return true\\n                return true;\\n            return false; // Ex. aabbcc return false\\n        }\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        if(mp2.size()==2){\\n            if(it1->second==1 && it1->first==1) //One Freq and One Item\\n                return true;\\n            if(it1->first==it2->first-1 && it2->second==1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755353,
                "title": "easy-cpp-with-all-working-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n\\t// Need to store count of frequency of letter\\n\\t    //all working cases\\n        //aaaaa          5:1               --size=1\\n        //abcd           1:4              --size =1\\n        // aabbccc    2:2  3:1             --size=2\\n        //aabbccd    2:3   1:1             --size=2\\n        \\n        unordered_map<int,int>mp;\\n        for(auto ch:word) mp[ch-\\'a\\']++;\\n        int count[1000]={};\\n        unordered_set<int>s;\\n        for(auto p:mp) count[p.second]++,s.insert(p.second);\\n        int size=s.size();\\n        if(size>2) return 0;\\n        int a,b; a=b=-1;\\n         a=*s.begin();\\n        if(size==2) b=*s.begin()+1;\\n        \\n        if(size==1 and (count[a]==1 || a==1)) return 1;\\n        if(size==2 and ((b-a==1 and count[b]==1) ||(  a==1 and count[a]==1))) return 1;\\n          return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n\\t// Need to store count of frequency of letter\\n\\t    //all working cases\\n        //aaaaa          5:1               --size=1\\n        //abcd           1:4              --size =1\\n        // aabbccc    2:2  3:1             --size=2\\n        //aabbccd    2:3   1:1             --size=2\\n        \\n        unordered_map<int,int>mp;\\n        for(auto ch:word) mp[ch-\\'a\\']++;\\n        int count[1000]={}",
                "codeTag": "Java"
            },
            {
                "id": 2736303,
                "title": "python-use-counter-easy-to-follow",
                "content": "\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        def is_uniform(cnt):\\n            return  len(set([c for c in cnt.values()  if c !=0 ])) == 1\\n\\n        cnt = Counter(word)\\n        for c in word:\\n            \\n            cnt[c] -= 1\\n            \\n            if is_uniform(cnt):\\n                \\n                return True\\n            \\n            cnt[c] += 1\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        def is_uniform(cnt):\\n            return  len(set([c for c in cnt.values()  if c !=0 ])) == 1\\n\\n        cnt = Counter(word)\\n        for c in word:\\n            \\n            cnt[c] -= 1\\n            \\n            if is_uniform(cnt):\\n                \\n                return True\\n            \\n            cnt[c] += 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707570,
                "title": "python-simple-solution-using-hashmap-and-set-faster-than-98-56",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        a=[0]*26\\n        for i in word:\\n            a[ord(i)-97]+=1\\n        for i in range(26):\\n            if a[i]>0:\\n                a[i]-=1\\n                b=set(a)\\n                b.discard(0)\\n                if len(b)==1:\\n                    break\\n                else:\\n                    a[i]+=1\\n        if len(b)==1:\\n            return True\\n        return False\\n```\\n            \\n                    \\n                    \\n    \\n    \\n        \\n        \\n            \\n\\n",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        a=[0]*26\\n        for i in word:\\n            a[ord(i)-97]+=1\\n        for i in range(26):\\n            if a[i]>0:\\n                a[i]-=1\\n                b=set(a)\\n                b.discard(0)\\n                if len(b)==1:\\n                    break\\n                else:\\n                    a[i]+=1\\n        if len(b)==1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700561,
                "title": "runtime-0ms-code-along-with-explaination",
                "content": "class Solution {\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n//CREATE VECTOR OF SIZE 26 AND ASSIGN WITH ALL ELEMENT AS 0\\n        vector<int> freq(26,0);\\n        for(int c=0;c<word.size();c++)\\n        {\\n\\t\\t\\tfreq[word[c]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n//IF OCCURENCE OF ELEMENT IS 0 THEN SKIP IT OR ELSE DECREASE ITS FREQUENCY BY 1\\n            if(freq[i]==0)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                freq[i]--;\\n            }\\n\\t\\t\\t\\n//CONSIDER MIN AND MAX VALUE\\n            int max=INT_MIN,min=INT_MAX;\\n//TRAVERSE IN FREQ VECTOR  IF ITS 0 THEN SKIP,IF IT IS GREATER THEN MAX THEN ASSIGN IT TO MAX OR ASSIGN IT TO MIN\\n             for (auto j : freq) {\\n                if (j == 0) continue;\\n                if (j > max) max = j;\\n                if (j < min) min = j;\\n            }\\n//CHECK IF MIN AND MAX VALUE IS EQUAL IF YES THEN RETURN TRUE OR ELSE RETURN FALSE\\n            if(max==min)return true;\\n            freq[i]++;\\n            \\n        }\\n        return false;\\n    }\\n};\\n\\n**UPVOTE IF U FOUND IT HELPFUL  :-) **",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n//CREATE VECTOR OF SIZE 26 AND ASSIGN WITH ALL ELEMENT AS 0\\n        vector<int> freq(26,0);\\n        for(int c=0;c<word.size();c++)\\n        {\\n\\t\\t\\tfreq[word[c]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2686812,
                "title": "cpp-using-stack-easy-to-understand",
                "content": "*using traversal for each character of word*\\n**I hope this solution is work for you **\\n\\n```\\n bool equalFrequency(string word) {\\n      for(int i=0;i<word.size();i++)\\n      {\\n          map<char,int> mp;\\n          for(int j=0;j<word.size();j++)\\n          {\\n              if(j==i)\\n                  continue;\\n              else\\n                  mp[word[j]]++;\\n          }\\n          set<int> s;\\n          for(auto it:mp)\\n              s.insert(it.second);\\n          if(s.size()==1)\\n              return true;\\n          \\n      }\\n        return false;\\n\\t}\\n```\\n**PLEASE UPVOTE**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool equalFrequency(string word) {\\n      for(int i=0;i<word.size();i++)\\n      {\\n          map<char,int> mp;\\n          for(int j=0;j<word.size();j++)\\n          {\\n              if(j==i)\\n                  continue;\\n              else\\n                  mp[word[j]]++;\\n          }\\n          set<int> s;\\n          for(auto it:mp)\\n              s.insert(it.second);\\n          if(s.size()==1)\\n              return true;\\n          \\n      }\\n        return false;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674711,
                "title": "c-hard-solutions-edge-cases",
                "content": "**Please upvote if you like this solution**\\n\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       unordered_map<char, int> mp;\\n        map<int, int> mp2;\\n        for(auto c: word)  mp[c]++;\\n        \\n        for(auto m: mp)  mp2[m.second]++;\\n        \\n        \\n        if(mp2.size() > 2) return false;\\n        map<int, int>::iterator it1 = mp2.begin();\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        \\n        if(mp2.size() == 1){\\n            if(mp.size() == 1 || it1->first == 1) return true;\\n            return false;\\n        }\\n       \\n        \\n        if(it1->first == 1 && it1->second == 1) return true;\\n        if(it1->first == it2->first-1 && it2->second == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       unordered_map<char, int> mp;\\n        map<int, int> mp2;\\n        for(auto c: word)  mp[c]++;\\n        \\n        for(auto m: mp)  mp2[m.second]++;\\n        \\n        \\n        if(mp2.size() > 2) return false;\\n        map<int, int>::iterator it1 = mp2.begin();\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++;\\n        \\n        if(mp2.size() == 1){\\n            if(mp.size() == 1 || it1->first == 1) return true;\\n            return false;\\n        }\\n       \\n        \\n        if(it1->first == 1 && it1->second == 1) return true;\\n        if(it1->first == it2->first-1 && it2->second == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674555,
                "title": "c-easy-to-understand-simple-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> count)\\n    {\\n        sort(count.begin(),count.end());\\n        for(int i=0;i<=24;i++)\\n        {\\n            if(count[i]==0)\\n            {\\n                continue;\\n            }\\n            if(count[i]!=count[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        vector<int> count(26,0);\\n        for(char &ch:word)\\n        {\\n            count[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]==0)\\n            {\\n                continue;\\n            }\\n            count[i]--;\\n            if(check(count))\\n            {\\n                return true;\\n            }\\n            count[i]++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> count)\\n    {\\n        sort(count.begin(),count.end());\\n        for(int i=0;i<=24;i++)\\n        {\\n            if(count[i]==0)\\n            {\\n                continue;\\n            }\\n            if(count[i]!=count[i+1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        vector<int> count(26,0);\\n        for(char &ch:word)\\n        {\\n            count[ch-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(count[i]==0)\\n            {\\n                continue;\\n            }\\n            count[i]--;\\n            if(check(count))\\n            {\\n                return true;\\n            }\\n            count[i]++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667999,
                "title": "there-are-only-3-cases-that-would-return-true-0ms",
                "content": "After we have the frequency distribution, there are only 3 cases that we would return true.\\nAll the other cases would return false.\\nSo we just have to handle these 3 cases.\\n\\n###### Case 1: Only 1 freqency\\nExample: aaa \\nWe get frequency distribution = [3] \\nIt is trivial to return true\\n\\n###### Case 2: Remove the least one and the others are all the same\\nExample: abbcc  /  abc / cccd\\nDistribution would be [1, 2, 2] / [1, 1, 1] / [1,3]\\nBecause the least one is 1, removing it will make it disappear, thus if all the others are the same, we could just return true\\nLogic: if the least frequency is 1, and check if the others are all the same or not\\n\\n###### Case 3: Remove the most one and the others are all the same\\nExample: aabbccc \\nDistribution would be [2, 2, 3]\\nRemoving the most one will not make it disappear, so its frequency must be equal to the least one plus one, and all others are the same.\\nLogic: if the least + 1 == the most, check if the others are all the same or not\\n\\n**Algorithm**\\n1. Get the frequency distribution and sort it\\n2. Check the first and last element\\n3. Check the other elements (because it is sorted, we just need to check the adjacent one of first or last element)\\n\\n##### C++ Solution\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> h;\\n\\n        for (auto &c : word) {\\n            h[c]++;\\n        }\\n\\n        vector<int> freq;\\n        for (auto &p : h) {\\n            freq.push_back(p.second);\\n        }\\n        sort(freq.begin(), freq.end());\\n\\n        int l = 0;\\n        int r = freq.size()-1;\\n\\n\\t\\t// Case 1\\n        if (freq.size() == 1) {\\n            // aaa => 3\\n            return true;\\n        }\\n\\n        // following handle at least 2 freqency\\n        // Case 2: removing the first one\\n        if (freq[l] == 1 && freq[l+1] == freq[r]) {\\n            // first is 1, the others are all the same, eg. 1,1,1 abc or 1,3 cccd\\n            return true;\\n        }\\n        // Case 3: removing the last one\\n        if (freq[l]+1 == freq[r] && freq[l] == freq[r-1]) {\\n            // 2,3 aabbb or 2,2,3 aabbccc\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> h;\\n\\n        for (auto &c : word) {\\n            h[c]++;\\n        }\\n\\n        vector<int> freq;\\n        for (auto &p : h) {\\n            freq.push_back(p.second);\\n        }\\n        sort(freq.begin(), freq.end());\\n\\n        int l = 0;\\n        int r = freq.size()-1;\\n\\n\\t\\t// Case 1\\n        if (freq.size() == 1) {\\n            // aaa => 3\\n            return true;\\n        }\\n\\n        // following handle at least 2 freqency\\n        // Case 2: removing the first one\\n        if (freq[l] == 1 && freq[l+1] == freq[r]) {\\n            // first is 1, the others are all the same, eg. 1,1,1 abc or 1,3 cccd\\n            return true;\\n        }\\n        // Case 3: removing the last one\\n        if (freq[l]+1 == freq[r] && freq[l] == freq[r-1]) {\\n            // 2,3 aabbb or 2,2,3 aabbccc\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660481,
                "title": "java-0-ms-easy-to-understand",
                "content": "```\\n\\tpublic boolean equalFrequency(String word) {\\n        int[] freq = new int[26];\\n        for(char c : word.toCharArray()) freq[c-\\'a\\']++;\\n\\n        Arrays.sort(freq);\\n        int min = 0;\\n        for(int i = 0; i < 26; i++) {\\n            if(freq[i] != 0) {\\n                min = i;\\n                break;\\n            }\\n        }\\n\\n        if(freq[25] == 1 || min == 25) return true;\\n        if(freq[min] == 1 && freq[min+1] == freq[25]) return true;\\n        if(freq[25] - freq[min] == 1 && freq[min] == freq[24]) return true;\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic boolean equalFrequency(String word) {\\n        int[] freq = new int[26];\\n        for(char c : word.toCharArray()) freq[c-\\'a\\']++;\\n\\n        Arrays.sort(freq);\\n        int min = 0;\\n        for(int i = 0; i < 26; i++) {\\n            if(freq[i] != 0) {\\n                min = i;\\n                break;\\n            }\\n        }\\n\\n        if(freq[25] == 1 || min == 25) return true;\\n        if(freq[min] == 1 && freq[min+1] == freq[25]) return true;\\n        if(freq[25] - freq[min] == 1 && freq[min] == freq[24]) return true;\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651978,
                "title": "24-ms-faster-than-100-00-python3",
                "content": "- count number of occurencies of each character\\n- return True if there is only one char in the word or all counts == 1\\n- otherwise there must be exactly 2 numbers in all counts\\n- removal is possible if there is a single char with count == 1\\n- or if there is a single char with count greater by one than counts of other chars\\n\\n```\\ndef equalFrequency(self, word: str) -> bool:\\n\\n\\tcnt = [count for c in ascii_lowercase if (count := word.count(c)) > 0]\\n\\n\\tif len(cnt) == 1 or set(cnt) == {1}:\\n\\t\\treturn True\\n\\n\\tif len(set(cnt)) == 2:\\n\\t\\tvc = Counter(cnt)\\n\\t\\tif vc[1] == 1 or max(vc) == min(vc) + 1 and vc[max(vc)] == 1:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef equalFrequency(self, word: str) -> bool:\\n\\n\\tcnt = [count for c in ascii_lowercase if (count := word.count(c)) > 0]\\n\\n\\tif len(cnt) == 1 or set(cnt) == {1}:\\n\\t\\treturn True\\n\\n\\tif len(set(cnt)) == 2:\\n\\t\\tvc = Counter(cnt)\\n\\t\\tif vc[1] == 1 or max(vc) == min(vc) + 1 and vc[max(vc)] == 1:\\n\\t\\t\\treturn True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2651299,
                "title": "",
                "content": "```\\nclass Solution(object):\\n    def equalFrequency(self, word):\\n        counting=Counter(word)\\n        for i in word:\\n            counting[i]-=1\\n            newlist=[]\\n            for j in counting.values():\\n                if j:\\n                    newlist.append(j)\\n            if len(set(newlist))==1:\\n                return True\\n            counting[i]+=1\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def equalFrequency(self, word):\\n        counting=Counter(word)\\n        for i in word:\\n            counting[i]-=1\\n            newlist=[]\\n            for j in counting.values():\\n                if j:\\n                    newlist.append(j)\\n            if len(set(newlist))==1:\\n                return True\\n            counting[i]+=1\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651246,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) ; n is word length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool EqualFrequency(string word)\\n    {\\n        int[] c = new int[26];\\n        foreach(var x in word)\\n            c[x-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(c[i]>0)\\n            {\\n                c[i]--;\\n                if(IsAllEqual(c))\\n                    return true;\\n                c[i]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public bool IsAllEqual(int[] c)\\n    {\\n        int i=0;\\n        while(c[i] == 0)\\n            i++;\\n        \\n        int last = c[i];\\n        for(i=1;i<26;i++)\\n            if(c[i] != 0 && c[i] != last)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool EqualFrequency(string word)\\n    {\\n        int[] c = new int[26];\\n        foreach(var x in word)\\n            c[x-\\'a\\']++;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(c[i]>0)\\n            {\\n                c[i]--;\\n                if(IsAllEqual(c))\\n                    return true;\\n                c[i]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    public bool IsAllEqual(int[] c)\\n    {\\n        int i=0;\\n        while(c[i] == 0)\\n            i++;\\n        \\n        int last = c[i];\\n        for(i=1;i<26;i++)\\n            if(c[i] != 0 && c[i] != last)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650784,
                "title": "easy-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        \\n        unordered_map<char,int> m;\\n        unordered_set<int> st;\\n        //storing in map to know the freq of char\\n        for(auto c:s){\\n            m[c]++;\\n        \\n        }\\n         \\n         //storing element is set to know the size of stack\\n         for(auto x:m){\\n              st.insert(x.second);\\n             if(st.size()>1) return false;\\n         }\\n        if(st.size()==1) return true;\\n        else \\n            return false;\\n         \\n    }\\n    bool equalFrequency(string word) {\\n        \\n        int n=word.length();\\n        int i=0;\\n        while(i<n){\\n            string s=word;\\n            //deleting char one by one and checking the freq\\n            s.erase(s.begin()+i);\\n            //cout<<s<<\" \"<<endl;\\n             if(check(s)) return true;\\n             else i++;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        \\n        unordered_map<char,int> m;\\n        unordered_set<int> st;\\n        //storing in map to know the freq of char\\n        for(auto c:s){\\n            m[c]++;\\n        \\n        }\\n         \\n         //storing element is set to know the size of stack\\n         for(auto x:m){\\n              st.insert(x.second);\\n             if(st.size()>1) return false;\\n         }\\n        if(st.size()==1) return true;\\n        else \\n            return false;\\n         \\n    }\\n    bool equalFrequency(string word) {\\n        \\n        int n=word.length();\\n        int i=0;\\n        while(i<n){\\n            string s=word;\\n            //deleting char one by one and checking the freq\\n            s.erase(s.begin()+i);\\n            //cout<<s<<\" \"<<endl;\\n             if(check(s)) return true;\\n             else i++;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2649511,
                "title": "java-hashmap-solution-definitely-not-easy",
                "content": "First compute the frequency of each character and store as \"freq\", the compute the frequency of all the values of the FreqMap and store as \"map\". \\nFocus more on the false cases.\\n\\n1. Since we can remove only one character, if the size of map is greater than 2, we can simply return false, because we have more than one character of different frequencies. \\n2. If all characters have same frequencies, they all should occur exactly once. \\n3.  Now we remain with the cases where there are only two values of frequencies in our map. We can extract those values using iterator, or simply extracting the entry set. \\n4.  If the values differ by more than one, we can simply return false. \\n5.  If a character appear only once, we can return true.\\n\\n\\n**Update : Two newly added testcases fail**\\n\\np.s. We can also use frequency array instead of HashMap.\\n\\n```\\nclass Solution \\n{\\n    public boolean equalFrequency(String word) \\n\\t{\\n        HashMap<Character, Integer> freq = new HashMap<>(); \\n        \\n        for(char ch : word.toCharArray())\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>(); \\n        \\n        for(int key : freq.values())\\n            map.put(key, map.getOrDefault(key, 0) + 1); \\n        \\n        if(map.size() > 2)\\n            return false; \\n        \\n        if(map.size() == 1)\\n        {\\n            if(freq.size() == 1)\\n                return true; \\n            \\n            for(int val : freq.values())\\n\\t\\t\\t{\\n                if(val != 1)\\n                    return false;\\n\\t\\t\\t}\\n            return true;\\n        }\\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\\n        Map.Entry<Integer, Integer> temp = it.next();      \\n        int x = temp.getKey(), fx = temp.getValue();\\n        temp = it.next();\\n        int y = temp.getKey(), fy = temp.getValue();\\n        \\n//         List<Map.Entry<Integer, Integer>> temp = new ArrayList<>(map.entrySet());\\n//         int x = temp.get(0).getKey(), fx = temp.get(0).getValue();\\n//         int y = temp.get(1).getKey(), fy = temp.get(1).getValue();\\n        \\n        if((Math.abs(x - y) != 1) && fx != 1)\\n            return false; \\n        \\n        if((fy == 1) || (x==1 && fx == 1))\\n            return true;   \\n        \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean equalFrequency(String word) \\n\\t{\\n        HashMap<Character, Integer> freq = new HashMap<>(); \\n        \\n        for(char ch : word.toCharArray())\\n            freq.put(ch, freq.getOrDefault(ch, 0)+1);\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>(); \\n        \\n        for(int key : freq.values())\\n            map.put(key, map.getOrDefault(key, 0) + 1); \\n        \\n        if(map.size() > 2)\\n            return false; \\n        \\n        if(map.size() == 1)\\n        {\\n            if(freq.size() == 1)\\n                return true; \\n            \\n            for(int val : freq.values())\\n\\t\\t\\t{\\n                if(val != 1)\\n                    return false;\\n\\t\\t\\t}\\n            return true;\\n        }\\n        Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();\\n        Map.Entry<Integer, Integer> temp = it.next();      \\n        int x = temp.getKey(), fx = temp.getValue();\\n        temp = it.next();\\n        int y = temp.getKey(), fy = temp.getValue();\\n        \\n//         List<Map.Entry<Integer, Integer>> temp = new ArrayList<>(map.entrySet());\\n//         int x = temp.get(0).getKey(), fx = temp.get(0).getValue();\\n//         int y = temp.get(1).getKey(), fy = temp.get(1).getValue();\\n        \\n        if((Math.abs(x - y) != 1) && fx != 1)\\n            return false; \\n        \\n        if((fy == 1) || (x==1 && fx == 1))\\n            return true;   \\n        \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649497,
                "title": "rust-swift-0ms-o-n-w-frequency-frequency",
                "content": "# Solution\\n## Rust\\nSubmission link: https://leetcode.com/submissions/detail/813307898/\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_frequency(word: String) -> bool {\\n        let mut c = HashMap::new();\\n        for char in word.chars() {\\n            *c.entry(char).or_insert(0) += 1;\\n        }\\n        let mut counts = HashMap::new();\\n        for count in c.values() {\\n            *counts.entry(count).or_insert(0) += 1;\\n        }\\n        if counts.len() == 1 {\\n            return counts.contains_key(&1) || counts.contains_key(&word.len());\\n        }\\n        if counts.len() == 2 {\\n            let min = counts.iter().min_by_key(|(&k, _)| k).unwrap().0;\\n            return counts.get(&1) == Some(&1) || counts.get(&(*min + 1)) == Some(&1);\\n        }\\n        false\\n    }\\n}\\n```\\n\\n## Swift\\nSubmission link: https://leetcode.com/submissions/detail/813302222/\\n\\n```swift\\nclass Solution {\\n    func equalFrequency(_ word: String) -> Bool {\\n        var c = [Character: Int]()\\n        for char in word {\\n            c[char] = (c[char] ?? 0) + 1\\n        }\\n        var counts = [Int: Int]()\\n        for count in c.values {\\n            counts[count] = (counts[count] ?? 0) + 1\\n        }\\n        if counts.count == 1 {\\n            return counts[1] != nil || counts[word.count] != nil\\n        }\\n        if counts.count == 2 {\\n            return counts[1] == 1 || counts[counts.min(by: { $0.value > $1.value })!.key + 1] == 1\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n# Intution\\n- The problem is about frequencies, so we want a counter, which maps elements to frequencies.\\n- Specifically, all of our cases deal with the frequency of frequencies, so we count the the frequencies.\\n- We can break the problem down case-by-case for a solution\\n\\n# Cases\\nCases below are written like nested if/else statements and operate on assumptions that the cases above them on the tree were False.\\n\\n1. There is one frequency.\\n\\ta. The only frequency is 1, so we can remove an entire occurence of that frequency, making it always **True**. Example: `\"abcd\" => \"abc\"`\\n\\tb. The only frequency occurs only once, so we can convert it to a new frequency, making it always **True**. This is the same as saying the only frequency is the length of the word. Example: `\"aaaa\" => \"aaa\"`\\n\\tc. Otherwise, it is always **False**. Example: `\"aabb\"`.\\n2. There are two frequencies.\\n\\ta. The lower frequency is 1 and occurs once. This will always be **True**. Example: `\"aaabbbc\" => \"aaabbb\"`\\n\\tb. The difference in frequencies is 1, and the larger frequency occurs only once. This will always be **True**. Example: `\"aabbb\" => \"aabb\"`\\n\\tc. The remaining cases will always be **False** because they necessarily have either two frequencies that differ but the larger occurs multiple times or they have a frequency which differs by more than 1. Examples: `\"aabbbccc\"` and `\"aabbbb\"`.\\n3. There are three or more frequencies. This will always be **False**. You can\\'t change the two largest of these with one delete to be equal to the lowest one. Example: `\"abbccc\"`",
                "solutionTags": [
                    "Swift",
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_frequency(word: String) -> bool {\\n        let mut c = HashMap::new();\\n        for char in word.chars() {\\n            *c.entry(char).or_insert(0) += 1;\\n        }\\n        let mut counts = HashMap::new();\\n        for count in c.values() {\\n            *counts.entry(count).or_insert(0) += 1;\\n        }\\n        if counts.len() == 1 {\\n            return counts.contains_key(&1) || counts.contains_key(&word.len());\\n        }\\n        if counts.len() == 2 {\\n            let min = counts.iter().min_by_key(|(&k, _)| k).unwrap().0;\\n            return counts.get(&1) == Some(&1) || counts.get(&(*min + 1)) == Some(&1);\\n        }\\n        false\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func equalFrequency(_ word: String) -> Bool {\\n        var c = [Character: Int]()\\n        for char in word {\\n            c[char] = (c[char] ?? 0) + 1\\n        }\\n        var counts = [Int: Int]()\\n        for count in c.values {\\n            counts[count] = (counts[count] ?? 0) + 1\\n        }\\n        if counts.count == 1 {\\n            return counts[1] != nil || counts[word.count] != nil\\n        }\\n        if counts.count == 2 {\\n            return counts[1] == 1 || counts[counts.min(by: { $0.value > $1.value })!.key + 1] == 1\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648599,
                "title": "python3-explained-problem-destroyed-using-facts-logic",
                "content": "# Solution\\n```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        c = Counter(Counter(word).values())\\n        if len(c) == 1:\\n            return 1 in c or len(word) in c\\n        if len(c) == 2:\\n            return c[1] == 1 or c[min(c)+1] == 1\\n        return False\\n```\\n\\n# Intution\\n- The problem is about frequencies, so we want a counter, which maps elements to frequencies.\\n- Specifically, all of our cases deal with the frequency of frequencies, so we count the the frequencies.\\n- We can break the problem down case-by-case for a solution\\n\\n# Cases\\nCases below are written like nested if/else statements and operate on assumptions that the cases above them on the tree were False.\\n\\n1. There is one frequency.\\n\\ta. The only frequency is 1, so we can remove an entire occurence of that frequency, making it always **True**. Example: `\"abcd\" => \"abc\"`\\n\\tb. The only frequency occurs only once, so we can convert it to a new frequency, making it always **True**. This is the same as saying the only frequency is the length of the word. Example: `\"aaaa\" => \"aaa\"`\\n\\tc. Otherwise, it is always **False**. Example: `\"aabb\"`.\\n2. There are two frequencies.\\n\\ta. The lower frequency is 1 and occurs once. This will always be **True**. Example: `\"aaabbbc\" => \"aaabbb\"`\\n\\tb. The difference in frequencies is 1, and the larger frequency occurs only once. This will always be **True**. Example: `\"aabbb\" => \"aabb\"`\\n\\tc. The remaining cases will always be **False** because they necessarily have either two frequencies that differ but the larger occurs multiple times or they have a frequency which differs by more than 1. Examples: `\"aabbbccc\"` and `\"aabbbb\"`.\\n3. There are three or more frequencies. This will always be **False**. You can\\'t change the two largest of these with one delete to be equal to the lowest one. Example: `\"abbccc\"`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        c = Counter(Counter(word).values())\\n        if len(c) == 1:\\n            return 1 in c or len(word) in c\\n        if len(c) == 2:\\n            return c[1] == 1 or c[min(c)+1] == 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647933,
                "title": "c-best-solution-unordered-map-of-frequencies",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n      unordered_map<char,int> mp1;\\n        unordered_map<char,int>::iterator itr;\\n        // create a map for frequency of characters\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        // create a map to know the frequency of occurrence of characters\\n        unordered_map<int,int> mp2;\\n        for(itr=mp1.begin();itr!=mp1.end();itr++){\\n            mp2[itr->second]++;\\n        }\\n        // if there are more than two frequencies the answer is false\\n        if(mp2.size()>2) return false;\\n        \\n        unordered_map<int,int>::iterator itr1;\\n        unordered_map<int,int>::iterator itr2;\\n        \\n        itr1=mp2.begin();\\n        if(mp2.size()==1){\\n            \\n            // here check if one char occus multiple times or multiple char occur once\\n            if(itr1->first==1 || itr1->second==1)return true;\\n            else return false;\\n        }\\n        itr2=mp2.begin();\\n        itr2++;\\n        if((itr1->first-itr2->first==1 && itr1->second==1)||//if the diff b/w freq is 1 and the no. of char comes once \\n           (itr2->first-itr1->first==1 && itr2->second==1)||\\n           (itr1->first==1&&itr1->second==1)||// if any char occurs once with 1 freq\\n           (itr2->first==1&&itr2->second==1))return true;\\n        \\n        return false;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n      unordered_map<char,int> mp1;\\n        unordered_map<char,int>::iterator itr;\\n        // create a map for frequency of characters\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        // create a map to know the frequency of occurrence of characters\\n        unordered_map<int,int> mp2;\\n        for(itr=mp1.begin();itr!=mp1.end();itr++){\\n            mp2[itr->second]++;\\n        }\\n        // if there are more than two frequencies the answer is false\\n        if(mp2.size()>2) return false;\\n        \\n        unordered_map<int,int>::iterator itr1;\\n        unordered_map<int,int>::iterator itr2;\\n        \\n        itr1=mp2.begin();\\n        if(mp2.size()==1){\\n            \\n            // here check if one char occus multiple times or multiple char occur once\\n            if(itr1->first==1 || itr1->second==1)return true;\\n            else return false;\\n        }\\n        itr2=mp2.begin();\\n        itr2++;\\n        if((itr1->first-itr2->first==1 && itr1->second==1)||//if the diff b/w freq is 1 and the no. of char comes once \\n           (itr2->first-itr1->first==1 && itr2->second==1)||\\n           (itr1->first==1&&itr1->second==1)||// if any char occurs once with 1 freq\\n           (itr2->first==1&&itr2->second==1))return true;\\n        \\n        return false;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647798,
                "title": "python3-oneline-bruteforce",
                "content": "# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        return any(len(set(Counter(word[:i]+word[i+1:]).values()))==1 for i in range(len(word)))\\n```\\n# Explanation in Python3\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            z=word[:i]+word[i+1:]\\n            if len(set(Counter(z).values()))==1:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        return any(len(set(Counter(word[:i]+word[i+1:]).values()))==1 for i in range(len(word)))\\n```\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            z=word[:i]+word[i+1:]\\n            if len(set(Counter(z).values()))==1:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647489,
                "title": "c-simple-approach-tc-max-n-26-26",
                "content": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n\\t\\n         int fre[26] = { } ;\\n         for(auto x : word)\\n               fre[x - \\'a\\'] ++ ;\\n        \\n         for(int i= 0 ; i < 26 ; i ++ ){\\n             \\n              if(fre[i]){\\n                  \\n                   fre[i] -- ;                                       /// decreasing ith char frequency by one\\n                   int mn = 1e9 , mx = 0 ;\\n                  \\n                   for(int j = 0 ; j < 26 ; j ++){\\n                       if(fre[j] ){\\n                           mx  = max(mx , fre[j]) ;\\n                           mn = min(mn , fre[j]) ;\\n                        }\\n                   }\\n                  \\n                   if(mx == mn)                                     /// menas all fre has occuing same times\\n                       return true ;\\'\\n                   fre[i] ++ ;                                           /// adding ith char frequency by one (backtracking)\\n                  \\n              }\\n         }\\n         return false;\\n        \\n    }\\n    \\n    \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n\\t\\n         int fre[26] = { }",
                "codeTag": "Java"
            },
            {
                "id": 2647317,
                "title": "python3-brutal-frequency-counter-solution",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        char_freq = Counter(word)\\n        freq_counter = Counter(char_freq.values())\\n        freqs = list(freq_counter.keys())\\n        # Cases for one character difference, e.g. abcc\\n        if len(freqs) == 2:\\n            if abs(freqs[0] - freqs[1]) == 1 and (1 in freq_counter.values()):\\n                return True\\n        # Edge cases for same frequencies or same characters, e.g. abcde or aaaaa\\n        if len(freqs) == 1: \\n            if 1 in freqs or 1 in freq_counter.values():\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        char_freq = Counter(word)\\n        freq_counter = Counter(char_freq.values())\\n        freqs = list(freq_counter.keys())\\n        # Cases for one character difference, e.g. abcc\\n        if len(freqs) == 2:\\n            if abs(freqs[0] - freqs[1]) == 1 and (1 in freq_counter.values()):\\n                return True\\n        # Edge cases for same frequencies or same characters, e.g. abcde or aaaaa\\n        if len(freqs) == 1: \\n            if 1 in freqs or 1 in freq_counter.values():\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647185,
                "title": "c-map-set-solution-easy-to-understand",
                "content": "\\tbool solve(unordered_map<char,int> &m){\\n\\t\\t\\tset<int>st;\\n\\t\\t\\tfor(auto it:m){\\n\\t\\t\\t\\tif(it.second) st.insert(it.second);\\n\\t\\t\\t}\\n\\t\\t\\tif(st.size()>1) return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool equalFrequency(string word) {\\n\\t\\t\\tunordered_map<char,int>mpp;\\n\\n\\t\\t\\tfor(char c:word) mpp[c]++;\\n\\n\\t\\t\\tfor(char c:word){\\n\\t\\t\\t\\tmpp[c]--;\\n\\t\\t\\t\\tif(solve(mpp)) return true;\\n\\t\\t\\t\\tmpp[c]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tbool solve(unordered_map<char,int> &m){\\n\\t\\t\\tset<int>st;\\n\\t\\t\\tfor(auto it:m){\\n\\t\\t\\t\\tif(it.second) st.insert(it.second);\\n\\t\\t\\t}\\n\\t\\t\\tif(st.size()>1) return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool equalFrequency(string word) {\\n\\t\\t\\tunordered_map<char,int>mpp;\\n\\n\\t\\t\\tfor(char c:word) mpp[c]++;\\n\\n\\t\\t\\tfor(char c:word){\\n\\t\\t\\t\\tmpp[c]--;\\n\\t\\t\\t\\tif(solve(mpp)) return true;\\n\\t\\t\\t\\tmpp[c]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2647159,
                "title": "java-solution-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n  \\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char ch: word.toCharArray()){\\n           map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: map.entrySet()){\\n            char key=entry.getKey();\\n            int value=entry.getValue();\\n            map.put(key,value-1);\\n            Set<Integer> set = new HashSet<>(map.values());\\n            set.remove(0);\\n            if(set.size()==1) return true;\\n            // else return false;\\n\\n            map.put(key,value);\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n  \\n        Map<Character,Integer> map=new HashMap<>();\\n        for(char ch: word.toCharArray()){\\n           map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> entry: map.entrySet()){\\n            char key=entry.getKey();\\n            int value=entry.getValue();\\n            map.put(key,value-1);\\n            Set<Integer> set = new HashSet<>(map.values());\\n            set.remove(0);\\n            if(set.size()==1) return true;\\n            // else return false;\\n\\n            map.put(key,value);\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647147,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(unordered_map<char, int> mp, char ch, int count)\\n    {\\n        // edge case\\n        \\n        if(count == 0)\\n        {\\n            unordered_set<int> s;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x.first != ch)\\n                {\\n                    s.insert(x.second);\\n                }\\n            }\\n            \\n            if(s.size() == 1)\\n            {\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        // general\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.first != ch)\\n            {\\n                if(x.second != count)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string str) {\\n        \\n        int n = str.size();\\n        \\n        unordered_map<char, int> mp;\\n        \\n        // store the frequency of each character in map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i]]++;\\n        }\\n        \\n        // decrement the frequecy of each character each time, and check is all the frequency are equal\\n        \\n        for(auto x : mp)\\n        {\\n            int count = x.second;\\n            \\n            count--;\\n            \\n            if(is_possible(mp, x.first, count))\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(unordered_map<char, int> mp, char ch, int count)\\n    {\\n        // edge case\\n        \\n        if(count == 0)\\n        {\\n            unordered_set<int> s;\\n            \\n            for(auto x : mp)\\n            {\\n                if(x.first != ch)\\n                {\\n                    s.insert(x.second);\\n                }\\n            }\\n            \\n            if(s.size() == 1)\\n            {\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        // general\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.first != ch)\\n            {\\n                if(x.second != count)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string str) {\\n        \\n        int n = str.size();\\n        \\n        unordered_map<char, int> mp;\\n        \\n        // store the frequency of each character in map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[str[i]]++;\\n        }\\n        \\n        // decrement the frequecy of each character each time, and check is all the frequency are equal\\n        \\n        for(auto x : mp)\\n        {\\n            int count = x.second;\\n            \\n            count--;\\n            \\n            if(is_possible(mp, x.first, count))\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646995,
                "title": "javascript-hashmap-and-set",
                "content": "```\\nvar equalFrequency = function(word) {\\n    let map = {};\\n\\n    for(let i = 0; i < word.length; i++) {\\n        if(!map[word[i]]) {\\n            map[word[i]] = 1;\\n        } else {\\n            map[word[i]]++;\\n        }\\n    }\\n    \\n    const arr = Object.values(map);\\n     \\n    for(let i = 0; i < arr.length; i++) {\\n        const newArr = Array.from(arr);\\n        \\n        if(newArr[i] == 1) {\\n            newArr.splice(i, 1);\\n        } else {\\n            newArr[i]--;   \\n        }\\n        \\n        if(new Set(newArr).size == 1) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar equalFrequency = function(word) {\\n    let map = {};\\n\\n    for(let i = 0; i < word.length; i++) {\\n        if(!map[word[i]]) {\\n            map[word[i]] = 1;\\n        } else {\\n            map[word[i]]++;\\n        }\\n    }\\n    \\n    const arr = Object.values(map);\\n     \\n    for(let i = 0; i < arr.length; i++) {\\n        const newArr = Array.from(arr);\\n        \\n        if(newArr[i] == 1) {\\n            newArr.splice(i, 1);\\n        } else {\\n            newArr[i]--;   \\n        }\\n        \\n        if(new Set(newArr).size == 1) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646978,
                "title": "four-conditions-hard-problem",
                "content": "My approach is to:\\n\\n1. generate the frequency list in order\\n2. identify four conditions\\n\\t1. `ddddd` where only one letter exists in the string\\n\\t2. `abcd`, where all letter occurs once only\\n\\t3. `deeefff`, where by deleting the letter occurs only once, this letter become non-existent.\\n\\t4. `ddeefff`, where by deleting the letter occurs the most, all frequencies equal.\\n\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        counter = Counter(word)\\n        \\n        list = []\\n        for _, v in counter.items():\\n            if v:\\n                list.append(v)\\n        list.sort()\\n        \\n        if len(list) == 1: # example: \\'ddddd\\'\\n            return True\\n        \\n        if list[-1] == 1: # example: \\'abcdefg\\'\\n            return True\\n        \\n        if list[0] == 1 and list[1] == list[-1]: # example: \\'bdddfff\\'\\n            return True\\n        \\n        if list[-1] == list[-2] + 1 and list[0] == list[-2]: # example: \\'bbbdddgggg\\'\\n            return True\\n        \\n\\t\\t# all other cases are bad conditions\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        counter = Counter(word)\\n        \\n        list = []\\n        for _, v in counter.items():\\n            if v:\\n                list.append(v)\\n        list.sort()\\n        \\n        if len(list) == 1: # example: \\'ddddd\\'\\n            return True\\n        \\n        if list[-1] == 1: # example: \\'abcdefg\\'\\n            return True\\n        \\n        if list[0] == 1 and list[1] == list[-1]: # example: \\'bdddfff\\'\\n            return True\\n        \\n        if list[-1] == list[-2] + 1 and list[0] == list[-2]: # example: \\'bbbdddgggg\\'\\n            return True\\n        \\n\\t\\t# all other cases are bad conditions\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646956,
                "title": "c-clean-solution-and-very-easy-approach-in-o-n",
                "content": "# Intuition\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_map<char,int> mpp;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            mpp[word[i]]++;\\n        }\\n        set<int> st;\\n        for(auto it:mpp)\\n        {\\n            st.insert(it.second);\\n        }\\n        int f;\\n        int s;\\n        \\n        vector<int> ans;\\n        for(auto it:mpp)\\n        {\\n            ans.push_back(it.second);\\n        }\\n        \\n        sort(ans.begin(),ans.end());\\n        if(ans.size()==1)\\n            return true;\\n        f=ans[0];\\n        s=ans[ans.size()-1];\\n        if(f==s && f==1)\\n        {\\n            return true;\\n        }\\n        int a=count(ans.begin(),ans.end(),f);\\n        int b=count(ans.begin(),ans.end(),s);\\n        \\n        if(( a-1==0 || b-1==0 ) && st.size()==2 && abs(f-s)==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646880,
                "title": "java-100-faster",
                "content": "Hi Family,\\n\\nI put the proper comment in the code for your understanding\\n\\n```\\n\\tpublic boolean equalFrequency(String word) {\\n        int n = word.length();\\n        int freq[] = new int[26];\\n        \\n        // make the frequency array for the characters\\n        for (char ch:word.toCharArray()) freq[ch - \\'a\\']++;\\n        \\n        for (char ch:word.toCharArray()){\\n            \\n            int i = ch - \\'a\\';\\n            /*\\n            * delete the every character one by one and check freq is equal or not\\n            * After removing the character,if we didn\\'t find the equal Freq string then again add the deleted element in the freq\\n            * do it again n again till last character\\n            */\\n            \\n            freq[i]--;\\n            if (check_allSame(freq)) return true;\\n            freq[i]++;\\n            \\n        }\\n        return false;\\n        \\n        \\n    }\\n    private boolean check_allSame(int freq[])\\n    {\\n        int N = freq.length;\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n   \\n```\\n\\nTHanks !!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic boolean equalFrequency(String word) {\\n        int n = word.length();\\n        int freq[] = new int[26];\\n        \\n        // make the frequency array for the characters\\n        for (char ch:word.toCharArray()) freq[ch - \\'a\\']++;\\n        \\n        for (char ch:word.toCharArray()){\\n            \\n            int i = ch - \\'a\\';\\n            /*\\n            * delete the every character one by one and check freq is equal or not\\n            * After removing the character,if we didn\\'t find the equal Freq string then again add the deleted element in the freq\\n            * do it again n again till last character\\n            */\\n            \\n            freq[i]--;\\n            if (check_allSame(freq)) return true;\\n            freq[i]++;\\n            \\n        }\\n        return false;\\n        \\n        \\n    }\\n    private boolean check_allSame(int freq[])\\n    {\\n        int N = freq.length;\\n        int same = 0;\\n \\n        // get first non-zero element\\n        int i;\\n        for (i = 0; i < N; i++) {\\n            if (freq[i] > 0) {\\n                same = freq[i];\\n                break;\\n            }\\n        }\\n \\n        // check equality of each element with\\n        // variable same\\n        for (int j = i + 1; j < N; j++)\\n            if (freq[j] > 0 && freq[j] != same)\\n                return false;\\n \\n        return true;\\n    }\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646679,
                "title": "easy-approach-optimized-c-map-min-max-freq",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n                                         //firstly trying to check by removing letter with minimum frequency\\n        unordered_map<char,int>mp;\\n        for(auto i:word)\\n        {\\n            mp[i]++;\\n        }\\n    \\n        int mini = 1000000 ;\\n        char l=\\'#\\';\\n        for(auto i:mp){\\n                      if(i.second<mini)\\n                      {\\n                          mini = min(mini,i.second);l=i.first;\\n                      }}\\n        int y = mp.size();\\n        unordered_map<int,int>mp2;\\n                unordered_map<char,int>mp3;\\n        mp[l]--;\\n        for(auto i:mp)\\n        {\\n            if(i.second>0){\\n            mp2[i.second]++;}\\n        }\\n        if(mp2.size()==1){return true;}\\n                                            // then trying to check by removing letter with maximum frequency\\n        int maxi = -1 ;\\n        char ll=\\'#\\';\\n        for(auto i:word)\\n        {\\n            mp3[i]++;\\n        }\\n        for(auto i:mp3){\\n                      if(i.second>maxi)\\n                      {\\n                          maxi = max(maxi,i.second);ll=i.first;\\n                      }}\\n        \\n        unordered_map<int,int>mp4;\\n        \\n        mp3[ll]--;\\n        for(auto i:mp3)\\n        {\\n            if(i.second>0){\\n            mp4[i.second]++;}\\n        }\\n        if(mp4.size()==1){return true;}\\n        return false;                          // else returning false\\n       \\n    }\\n};```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n                                         //firstly trying to check by removing letter with minimum frequency\\n        unordered_map<char,int>mp;\\n        for(auto i:word)\\n        {\\n            mp[i]++;\\n        }\\n    \\n        int mini = 1000000 ;\\n        char l=\\'#\\';\\n        for(auto i:mp){\\n                      if(i.second<mini)\\n                      {\\n                          mini = min(mini,i.second);l=i.first;\\n                      }}\\n        int y = mp.size();\\n        unordered_map<int,int>mp2;\\n                unordered_map<char,int>mp3;\\n        mp[l]--;\\n        for(auto i:mp)\\n        {\\n            if(i.second>0){\\n            mp2[i.second]++;}\\n        }\\n        if(mp2.size()==1){return true;}\\n                                            // then trying to check by removing letter with maximum frequency\\n        int maxi = -1 ;\\n        char ll=\\'#\\';\\n        for(auto i:word)\\n        {\\n            mp3[i]++;\\n        }\\n        for(auto i:mp3){\\n                      if(i.second>maxi)\\n                      {\\n                          maxi = max(maxi,i.second);ll=i.first;\\n                      }}\\n        \\n        unordered_map<int,int>mp4;\\n        \\n        mp3[ll]--;\\n        for(auto i:mp3)\\n        {\\n            if(i.second>0){\\n            mp4[i.second]++;}\\n        }\\n        if(mp4.size()==1){return true;}\\n        return false;                          // else returning false\\n       \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2646676,
                "title": "try-removing-every-char-to-find-the-answer-c-easy-one",
                "content": "**Approach**: store frequency of each element in hashmap, since we have to remove 1 char at a time so iterate over the string and remove the current char and see if frequencies of all char are same or not. \\n\\n```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<char, int> &mpp, int freq){\\n        for(auto it: mpp){\\n            if(it.second>=1 && it.second != freq)\\n                return false;\\n        }\\n            \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(auto it: word)\\n            mpp[it]++;\\n        \\n\\n        //try removing every char\\n        for(int i=0; i<word.size(); i++){\\n            mpp[word[i]]--;      //remove word\\n            int freq = (i<word.size()-1) ? mpp[word[i+1]]: mpp[word[i-1]];\\n            // cout<<freq;\\n            \\n            if(check(mpp, freq))        //return true if by removing current char frequencies will equal\\n                return true;\\n            \\n            mpp[word[i]]++;     //backtrack\\n        }\\n        \\n        return false;\\n    }   \\n};\\n```\\n\\nPlease upvote if u like the approach:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<char, int> &mpp, int freq){\\n        for(auto it: mpp){\\n            if(it.second>=1 && it.second != freq)\\n                return false;\\n        }\\n            \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(auto it: word)\\n            mpp[it]++;\\n        \\n\\n        //try removing every char\\n        for(int i=0; i<word.size(); i++){\\n            mpp[word[i]]--;      //remove word\\n            int freq = (i<word.size()-1) ? mpp[word[i+1]]: mpp[word[i-1]];\\n            // cout<<freq;\\n            \\n            if(check(mpp, freq))        //return true if by removing current char frequencies will equal\\n                return true;\\n            \\n            mpp[word[i]]++;     //backtrack\\n        }\\n        \\n        return false;\\n    }   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2646597,
                "title": "easy-approach-explained-map",
                "content": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n                                         //firstly trying to check by removing letter with minimum frequency\\n        unordered_map<char,int>mp;\\n        for(auto i:word)\\n        {\\n            mp[i]++;\\n        }\\n    \\n        int mini = 1000000 ;\\n        char l=\\'#\\';\\n        for(auto i:mp){\\n                      if(i.second<mini)\\n                      {\\n                          mini = min(mini,i.second);l=i.first;\\n                      }}\\n        int y = mp.size();\\n        unordered_map<int,int>mp2;\\n                unordered_map<char,int>mp3;\\n        mp[l]--;\\n        for(auto i:mp)\\n        {\\n            if(i.second>0){\\n            mp2[i.second]++;}\\n        }\\n        if(mp2.size()==1){return true;}\\n                                            // then trying to check by removing letter with maximum frequency\\n        int maxi = -1 ;\\n        char ll=\\'#\\';\\n        for(auto i:word)\\n        {\\n            mp3[i]++;\\n        }\\n        for(auto i:mp3){\\n                      if(i.second>maxi)\\n                      {\\n                          maxi = max(maxi,i.second);ll=i.first;\\n                      }}\\n        \\n        unordered_map<int,int>mp4;\\n        \\n        mp3[ll]--;\\n        for(auto i:mp3)\\n        {\\n            if(i.second>0){\\n            mp4[i.second]++;}\\n        }\\n        if(mp4.size()==1){return true;}\\n        return false;                          // else returning false\\n       \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n                                         //firstly trying to check by removing letter with minimum frequency\\n        unordered_map<char,int>mp;\\n        for(auto i:word)\\n        {\\n            mp[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2646578,
                "title": "check-all-removals",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        n = len(word)\\n        for i in range(n):\\n            ctr = Counter(word[:i] + word[i+1:])\\n            if len(set(ctr.values())) == 1:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        n = len(word)\\n        for i in range(n):\\n            ctr = Counter(word[:i] + word[i+1:])\\n            if len(set(ctr.values())) == 1:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646534,
                "title": "its-seems-to-be-easy-but-omg-it-is-not-beginner-friendly",
                "content": "Not a easy one",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2646513,
                "title": "python-java-brute-force",
                "content": "\\tclass Solution:\\n\\t\\tdef equalFrequency(self, word: str) -> bool:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tnewWord = word[:i] + word[i + 1:]\\n\\t\\t\\t\\tfreq = collections.Counter(newWord)\\n\\t\\t\\t\\tif max(freq.values()) == min(freq.values()):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean equalFrequency(String word) {\\n\\t\\t\\tint n = word.length();\\n\\t\\t\\tfor (int i = 0; i < word.length(); i ++) {\\n\\t\\t\\t\\tString newWord = word.substring(0, i) + word.substring(i + 1, n);\\n\\t\\t\\t\\tMap<Character, Integer> map = new HashMap<>();\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (char c: newWord.toCharArray()) {\\n\\t\\t\\t\\t\\tmap.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (char c: map.keySet()) {\\n\\t\\t\\t\\t\\tmin = Math.min(min, map.get(c));\\n\\t\\t\\t\\t\\tmax = Math.max(max, map.get(c));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (max == min) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef equalFrequency(self, word: str) -> bool:\\n\\t\\t\\tfor i in range(len(word)):\\n\\t\\t\\t\\tnewWord = word[:i] + word[i + 1:]\\n\\t\\t\\t\\tfreq = collections.Counter(newWord)\\n\\t\\t\\t\\tif max(freq.values()) == min(freq.values()):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic boolean equalFrequency(String word) {\\n\\t\\t\\tint n = word.length();\\n\\t\\t\\tfor (int i = 0; i < word.length(); i ++) {\\n\\t\\t\\t\\tString newWord = word.substring(0, i) + word.substring(i + 1, n);\\n\\t\\t\\t\\tMap<Character, Integer> map = new HashMap<>();\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tint max = 0;\\n\\t\\t\\t\\tfor (char c: newWord.toCharArray()) {\\n\\t\\t\\t\\t\\tmap.put(c, map.getOrDefault(c, 0) + 1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2646488,
                "title": "c-i-must-be-overrated-brute-force",
                "content": "I kept getting an edge case wrong when using a map and couldn\\'t figure out where I was going wrong. So I just gave up and used brute force because the constraint is <= 100.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        for(int i = 0; i < word.length(); i++){\\n            bool ok = true;\\n            map<int, int> freq;\\n            string temp = word;\\n            temp.erase(i, 1);\\n            for(auto i : temp) freq[i]++;\\n            int last = freq[temp[0]];\\n            for(auto i : freq) if(i.second != last) ok = false;\\n            if(ok == true) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        for(int i = 0; i < word.length(); i++){\\n            bool ok = true;\\n            map<int, int> freq;\\n            string temp = word;\\n            temp.erase(i, 1);\\n            for(auto i : temp) freq[i]++;\\n            int last = freq[temp[0]];\\n            for(auto i : freq) if(i.second != last) ok = false;\\n            if(ok == true) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3926333,
                "title": "easy-c-solution-using-map-and-letter-frequency-0ms",
                "content": "\\n# Approach\\nWith a map of frequencies you can figure out what is the most frequent frequency, if you multiply it with the number of letters with that frequency you know how many letters are \"good\" and then with the numbers of remaining letters you know if you can equalize the word or not (if its 1 you can remove the letter, if its 1+max_frequency you can remove the extra letter. In every other cases you can not equalize the word).\\n\\n## Example :\\nabccadd -> size=7\\n\\'a\\' -> 2\\n\\'b\\' -> 1\\n\\'c\\' -> 2\\n\\'d\\' -> 2\\n\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a &nbsp;c &nbsp;d\\n2\\\\*(1+1+1)=6\\n7-6=1 we can just get rid of the remaining letter\\n\\nif we had 9 letters &nbsp;(3\\\\*2 + 1\\\\*3)\\n9-6 = 3 != 1 but lets try addind one to the most common frequency (which is 2)\\n(3+1)*2=8\\n9-8=1 we can just get rid of the remaining letter\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        if (word.empty()) return false;\\n        unordered_map<char,int> mp; // frequencies of letters\\n        for (auto x:word) mp[x]++;\\n\\n        int number_of_letters=0;\\n        unordered_map<int,int> mp2; // frequencies of frequencies\\n        for (auto x:mp) {\\n            number_of_letters++;\\n            mp2[x.second]++;\\n        }\\n        int max=0, max_element=0;\\n        // max_element = most common frequency\\n        // max = frequency of max_element\\n        for (auto x:mp2) {\\n            if (x.second>max) {max=x.second; max_element=x.first;}\\n            else if (x.second==max&&x.first>max_element) max_element=x.first;\\n        }\\n        if (number_of_letters==2&&(max_element*2-1==word.size())) return true; // edge case\\n        if (number_of_letters==word.size()||number_of_letters==1) return true; // edge case\\n        return (max_element*(max+1)==word.size()-1)||(max_element*max==word.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        if (word.empty()) return false;\\n        unordered_map<char,int> mp; // frequencies of letters\\n        for (auto x:word) mp[x]++;\\n\\n        int number_of_letters=0;\\n        unordered_map<int,int> mp2; // frequencies of frequencies\\n        for (auto x:mp) {\\n            number_of_letters++;\\n            mp2[x.second]++;\\n        }\\n        int max=0, max_element=0;\\n        // max_element = most common frequency\\n        // max = frequency of max_element\\n        for (auto x:mp2) {\\n            if (x.second>max) {max=x.second; max_element=x.first;}\\n            else if (x.second==max&&x.first>max_element) max_element=x.first;\\n        }\\n        if (number_of_letters==2&&(max_element*2-1==word.size())) return true; // edge case\\n        if (number_of_letters==word.size()||number_of_letters==1) return true; // edge case\\n        return (max_element*(max+1)==word.size()-1)||(max_element*max==word.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907967,
                "title": "easy-solution-with-43ms-runtime-beats-97-44",
                "content": "I know the solotion is not optimal in terms of complexity but the idea is very simple i have 2 tables which are identical with the occurrence of every letter in the word variable.\\nSo for the word \"abcc\" the table is [1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] and then I search for the minimum and the maximum of the table and stock them in \"min\" and \"max\" variables, after that in tab I decrement the min value by 1. So tab becomes [0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] and in the tab2 I decrement the max value by 1 so it becomes [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] and then I loop in both of the tables and check if they all have the same numbers ( 0 is ignored ) and stock the tests in testmin and testmax variables. And finally I return (testmin || testmax) which means if any of the tables has the same number of letters the word is accepted. In this case the testmin is equal to false because of the appearence of [1,2] and testmax is equal to true because it only contains [1]s. \\n\\n\\n# Code\\n```\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n  let test = false;\\n  let tab=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let tab2=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n  let min = -1;\\n  let max = -1;\\n  let x=0;\\n  let y=0;\\n\\n  let testmin = true;\\n  let testmax = true;\\n\\n\\n\\n  for(let i=0 ; i<alpha.length;i++)\\n  {\\n    tab[i] = word.split(alpha[i]).length - 1\\n    tab2[i] = word.split(alpha[i]).length - 1\\n    if (tab[i] != 0)\\n    {\\nmin=tab[i];\\nmax = tab[i];\\n    }\\n  }\\n\\n\\n  for(let i=0 ; i<tab.length;i++)\\n  {\\n     \\n   if (min>tab[i] && tab[i]>0)\\n   {\\n     min = tab[i]\\n   }\\n    if (max<tab[i] && tab[i]>0)\\n   {\\n     max = tab[i]\\n   }\\n  }\\n\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]==min)\\n    {\\n      tab[i]--\\n      \\n      break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==max)\\n    {\\n      tab2[i]--\\n     \\n      break;\\n    }\\n  }\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]!=0)\\n    {\\n     x=tab[i]\\n     \\n     break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==min)\\n    {\\n     y=tab2[i];\\n    \\n     break;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n\\n    \\n    if(tab[i]!=x && tab[i]!=0)\\n    {\\n      \\n     testmin = false;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab2.length;i++)\\n  {\\n    \\n    if(tab2[i]!=y  && tab2[i]!=0)\\n    {\\n     \\n     testmax = false;\\n    }\\n  }\\n\\n\\nreturn testmin || testmax\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar equalFrequency = function(word) {\\n  let test = false;\\n  let tab=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let tab2=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\\n  let alpha = \"abcdefghijklmnopqrstuvwxyz\"\\n  let min = -1;\\n  let max = -1;\\n  let x=0;\\n  let y=0;\\n\\n  let testmin = true;\\n  let testmax = true;\\n\\n\\n\\n  for(let i=0 ; i<alpha.length;i++)\\n  {\\n    tab[i] = word.split(alpha[i]).length - 1\\n    tab2[i] = word.split(alpha[i]).length - 1\\n    if (tab[i] != 0)\\n    {\\nmin=tab[i];\\nmax = tab[i];\\n    }\\n  }\\n\\n\\n  for(let i=0 ; i<tab.length;i++)\\n  {\\n     \\n   if (min>tab[i] && tab[i]>0)\\n   {\\n     min = tab[i]\\n   }\\n    if (max<tab[i] && tab[i]>0)\\n   {\\n     max = tab[i]\\n   }\\n  }\\n\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]==min)\\n    {\\n      tab[i]--\\n      \\n      break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==max)\\n    {\\n      tab2[i]--\\n     \\n      break;\\n    }\\n  }\\n\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n    if(tab[i]!=0)\\n    {\\n     x=tab[i]\\n     \\n     break;\\n    }\\n  }\\n\\n  for(let i=0 ; i<tab2.length;i++)\\n  {\\n    if(tab2[i]==min)\\n    {\\n     y=tab2[i];\\n    \\n     break;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab.length;i++)\\n  {\\n\\n    \\n    if(tab[i]!=x && tab[i]!=0)\\n    {\\n      \\n     testmin = false;\\n    }\\n  }\\n\\nfor(let i=0 ; i<tab2.length;i++)\\n  {\\n    \\n    if(tab2[i]!=y  && tab2[i]!=0)\\n    {\\n     \\n     testmax = false;\\n    }\\n  }\\n\\n\\nreturn testmin || testmax\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745109,
                "title": "solution-nice-solution-like-you",
                "content": "- ## ***Intuition***\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n\\n---\\n\\n- ```\\n```\\n``Code block\\n```\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        freq = [0] * 26\\n        for i in word:\\n            index = ord(i) - 97\\n            freq[index] += 1\\n        while 0 in freq:\\n            freq.remove(0)\\n        for j in range(len(freq)):\\n            if len(set(freq)) == 1 and freq[j]<2 or len(freq)==1:\\n                return True\\n        if len(set(freq)) > 2:\\n            return False\\n        min_freq = min(freq)\\n        max_freq = max(freq)\\n        if freq.count(max_freq) == 1 and max_freq - min_freq == 1:\\n            return True\\n        if freq.count(min_freq) == 1 and min_freq == 1:\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n```\n```\\n```\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        freq = [0] * 26\\n        for i in word:\\n            index = ord(i) - 97\\n            freq[index] += 1\\n        while 0 in freq:\\n            freq.remove(0)\\n        for j in range(len(freq)):\\n            if len(set(freq)) == 1 and freq[j]<2 or len(freq)==1:\\n                return True\\n        if len(set(freq)) > 2:\\n            return False\\n        min_freq = min(freq)\\n        max_freq = max(freq)\\n        if freq.count(max_freq) == 1 and max_freq - min_freq == 1:\\n            return True\\n        if freq.count(min_freq) == 1 and min_freq == 1:\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713449,
                "title": "remove-letter-to-equalize-frequency-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int n=word.size();\\n        map<char,int> mp;\\n        for(auto it:word)\\n        {\\n            mp[it]++;\\n        }\\n        vector<int> freq(256,0);\\n        for(auto it: word)\\n        {\\n            freq[it]++;\\n        }\\n        set<char> st;\\n        for(auto it: word)\\n        {\\n            st.insert(it);\\n        }\\n        \\n        \\n        for(auto it: mp)\\n        {\\n            set<char> temp;\\n            freq[it.first]--;\\n            for(auto i:st)\\n            {\\n                if(freq[i]!=0)\\n                temp.insert(freq[i]);\\n            }\\n            if(temp.size()==1)\\n            {\\n                return true;\\n            }\\n            freq[it.first]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int n=word.size();\\n        map<char,int> mp;\\n        for(auto it:word)\\n        {\\n            mp[it]++;\\n        }\\n        vector<int> freq(256,0);\\n        for(auto it: word)\\n        {\\n            freq[it]++;\\n        }\\n        set<char> st;\\n        for(auto it: word)\\n        {\\n            st.insert(it);\\n        }\\n        \\n        \\n        for(auto it: mp)\\n        {\\n            set<char> temp;\\n            freq[it.first]--;\\n            for(auto i:st)\\n            {\\n                if(freq[i]!=0)\\n                temp.insert(freq[i]);\\n            }\\n            if(temp.size()==1)\\n            {\\n                return true;\\n            }\\n            freq[it.first]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224521,
                "title": "clean-brute-force",
                "content": "# Code\\n```\\n# @param {String} word\\n# @return {Boolean}\\ndef equal_frequency(word)\\n  chars = word.chars\\n  chars.each_with_index do |_, i|\\n    return true if valid? chars.reject.with_index { |_, ci| ci == i}\\n  end\\n  false\\nend\\n\\ndef valid?(arr)\\n  arr.tally.values.uniq.size == 1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} word\\n# @return {Boolean}\\ndef equal_frequency(word)\\n  chars = word.chars\\n  chars.each_with_index do |_, i|\\n    return true if valid? chars.reject.with_index { |_, ci| ci == i}\\n  end\\n  false\\nend\\n\\ndef valid?(arr)\\n  arr.tally.values.uniq.size == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3205545,
                "title": "easy-python-solution-hashmaps",
                "content": "# Code\\n```\\nclass Solution:\\n    def equalFrequency(self, s: str) -> bool:\\n        arr = list(s)\\n        for i in range(len(arr)):\\n            hashmap = {}\\n            temp = Counter(arr[0:i]+arr[i+1:])\\n            for k in temp:\\n                if temp[k] not in hashmap:\\n                    hashmap[temp[k]] = [k]\\n                else:\\n                    hashmap[temp[k]].append(k)\\n            maxx = max(hashmap)\\n            minn = min(hashmap)\\n            if maxx == minn:\\n                return True\\n        return False\\n\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, s: str) -> bool:\\n        arr = list(s)\\n        for i in range(len(arr)):\\n            hashmap = {}\\n            temp = Counter(arr[0:i]+arr[i+1:])\\n            for k in temp:\\n                if temp[k] not in hashmap:\\n                    hashmap[temp[k]] = [k]\\n                else:\\n                    hashmap[temp[k]].append(k)\\n            maxx = max(hashmap)\\n            minn = min(hashmap)\\n            if maxx == minn:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952018,
                "title": "c-beginner-friendly-0ms-runtime-6-1mb-memory",
                "content": "\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  ~ O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find(int * freq,int n){\\n        int i,is_equal;// \"\"is_equal\" is to check whether all frequencies are equal\\n        for(i=0;i<26;i++){\\n            if(freq[i]>0){\\n                is_equal=freq[i];\\n                break;\\n            }\\n        }\\n\\n        for(int j=i+1;j<26;j++){\\n            if(freq[j]>0 && is_equal!=freq[j])\\n               return false;\\n            }        \\n\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        int freq[26]={0};//initialise every element with 0\\n        for(auto a:word)\\n            freq[a-\\'a\\']++; // increase the frequency if encountered\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            int i=ch-\\'a\\'; \\n            if(freq[i]>0){\\n             freq[i]--; /* decreasing the frequency to check whether removing it will\\n               equalize the frequencies */\\n             if(find(freq,26))\\n              return true;\\n             freq[i]++;// increasing it back as doesn\\'t give the result\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(int * freq,int n){\\n        int i,is_equal;// \"\"is_equal\" is to check whether all frequencies are equal\\n        for(i=0;i<26;i++){\\n            if(freq[i]>0){\\n                is_equal=freq[i];\\n                break;\\n            }\\n        }\\n\\n        for(int j=i+1;j<26;j++){\\n            if(freq[j]>0 && is_equal!=freq[j])\\n               return false;\\n            }        \\n\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        int freq[26]={0};//initialise every element with 0\\n        for(auto a:word)\\n            freq[a-\\'a\\']++; // increase the frequency if encountered\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n            int i=ch-\\'a\\'; \\n            if(freq[i]>0){\\n             freq[i]--; /* decreasing the frequency to check whether removing it will\\n               equalize the frequencies */\\n             if(find(freq,26))\\n              return true;\\n             freq[i]++;// increasing it back as doesn\\'t give the result\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847601,
                "title": "cpp-easy-to-understand-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\tvector<int>v;\\n    bool equalFrequency(string word) \\n    {   \\n        //getting the mapping of all the char of the string\\'s\\n        v.resize(26,0);\\n\\t    for(int i=0;i<word.length();i++)\\n\\t\\t{\\n\\t\\t    v[word[i] - \\'a\\']++;\\t\\n        }\\n        //checking for the the every possible char if the removeal of that can meke freq equal\\n        for(int i=0;i<word.length();i++)\\n\\t\\t{\\t\\n\\t        v[word[i] - \\'a\\']--;\\n\\t\\t    if(fun()  ==  true)\\n\\t\\t\\t{\\n \\t\\t         return true;\\n\\t\\t\\t}\\t\\n\\t\\t\\tv[word[i] - \\'a\\']++;\\n\\t\\t}        \\n\\t\\treturn false;\\n    }\\n    bool fun()\\n    {\\n    \\t//checking if all the alive freq are equal or not\\n  \\t    set<int>st;\\n    \\tfor(int i=0;i<26;i++)\\n    \\t{\\n    \\t\\tif(v[i] == 0)\\n    \\t\\tcontinue;\\n    \\t\\t\\n    \\t\\tif(v[i] > 0)\\n    \\t\\tst.insert(v[i]);\\n    \\t\\t\\n    \\t\\tif(st.size() > 1)\\n    \\t\\treturn false;\\n    \\t\\t\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int>v;\\n    bool equalFrequency(string word) \\n    {   \\n        //getting the mapping of all the char of the string\\'s\\n        v.resize(26,0);\\n\\t    for(int i=0;i<word.length();i++)\\n\\t\\t{\\n\\t\\t    v[word[i] - \\'a\\']++;\\t\\n        }\\n        //checking for the the every possible char if the removeal of that can meke freq equal\\n        for(int i=0;i<word.length();i++)\\n\\t\\t{\\t\\n\\t        v[word[i] - \\'a\\']--;\\n\\t\\t    if(fun()  ==  true)\\n\\t\\t\\t{\\n \\t\\t         return true;\\n\\t\\t\\t}\\t\\n\\t\\t\\tv[word[i] - \\'a\\']++;\\n\\t\\t}        \\n\\t\\treturn false;\\n    }\\n    bool fun()\\n    {\\n    \\t//checking if all the alive freq are equal or not\\n  \\t    set<int>st;\\n    \\tfor(int i=0;i<26;i++)\\n    \\t{\\n    \\t\\tif(v[i] == 0)\\n    \\t\\tcontinue;\\n    \\t\\t\\n    \\t\\tif(v[i] > 0)\\n    \\t\\tst.insert(v[i]);\\n    \\t\\t\\n    \\t\\tif(st.size() > 1)\\n    \\t\\treturn false;\\n    \\t\\t\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677873,
                "title": "easy-to-understand-and-implement-o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s just a simulation of the problem statement.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to one by one decrease the frequency of every character present in the given word and check if frequncy of all the charcter present in the given word is equal or not. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // function to check if frequency of all characters present is equal or not.\\n    bool check(map<char,int> mp)\\n    {   // create a set to store frequency\\n        set<char> s;\\n\\n      for (auto x:mp)\\n      { // if the character is present in the string\\n          if (x.second!=0)\\n          s.insert(x.second);\\n      }\\n        // if frequency of al the characters is equal\\n      return s.size()==1;\\n    }\\n    bool equalFrequency(string word) {\\n        // create a map to store character and it\\'s frequncy\\n        map<char,int> mp;\\n        for (auto x:word)\\n        mp[x]++;\\n    \\n        for (char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            if (mp[ch]!=0)\\n            {   // decrese it\\'s frequncy\\n                --mp[ch];\\n\\n                if (check(mp))\\n                return true;\\n                // again add it to the map\\n                ++mp[ch];\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to check if frequency of all characters present is equal or not.\\n    bool check(map<char,int> mp)\\n    {   // create a set to store frequency\\n        set<char> s;\\n\\n      for (auto x:mp)\\n      { // if the character is present in the string\\n          if (x.second!=0)\\n          s.insert(x.second);\\n      }\\n        // if frequency of al the characters is equal\\n      return s.size()==1;\\n    }\\n    bool equalFrequency(string word) {\\n        // create a map to store character and it\\'s frequncy\\n        map<char,int> mp;\\n        for (auto x:word)\\n        mp[x]++;\\n    \\n        for (char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            if (mp[ch]!=0)\\n            {   // decrese it\\'s frequncy\\n                --mp[ch];\\n\\n                if (check(mp))\\n                return true;\\n                // again add it to the map\\n                ++mp[ch];\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675344,
                "title": "fully-commented-solution",
                "content": "```\\n/* explanation: \\n-> check function will check whether we can make all the frequencies of the array equal\\n   by decreasing the ith frequency?\\n   \\n-> if we cant then, we will restore the frequency of the ith character and check for another\\n\\n-> sorting helps in making all the zero freq. come at front so that it can be neglected at    starting of loop\\n*/\\n\\nclass Solution {\\npublic:\\n    bool check(vector<int>freq)\\n    {\\n        sort(freq.begin(),freq.end());\\n        \\n        for(int i = 0; i < 25; ++i)\\n        {\\n            if(freq[i] == 0) //neglecting zero freq.\\n                continue;\\n            if(freq[i] != freq[i + 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        vector<int>freq(26,0);\\n        for(auto it:word)\\n            ++freq[it - \\'a\\'];\\n        for(int i = 0; i < 26; ++i)\\n        {\\n            if(freq[i] == 0)\\n                continue;\\n            \\n            --freq[i];\\n            if(check(freq))\\n                return true;\\n            ++freq[i];\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n// if liked please upvote :)",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/* explanation: \\n-> check function will check whether we can make all the frequencies of the array equal\\n   by decreasing the ith frequency?\\n   \\n-> if we cant then, we will restore the frequency of the ith character and check for another\\n\\n-> sorting helps in making all the zero freq. come at front so that it can be neglected at    starting of loop\\n*/\\n\\nclass Solution {\\npublic:\\n    bool check(vector<int>freq)\\n    {\\n        sort(freq.begin(),freq.end());\\n        \\n        for(int i = 0; i < 25; ++i)\\n        {\\n            if(freq[i] == 0) //neglecting zero freq.\\n                continue;\\n            if(freq[i] != freq[i + 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool equalFrequency(string word) {\\n        vector<int>freq(26,0);\\n        for(auto it:word)\\n            ++freq[it - \\'a\\'];\\n        for(int i = 0; i < 26; ++i)\\n        {\\n            if(freq[i] == 0)\\n                continue;\\n            \\n            --freq[i];\\n            if(check(freq))\\n                return true;\\n            ++freq[i];\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670878,
                "title": "python3-o-n-with-comments",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        mp1 = collections.Counter(word)\\n        # All character only occur once or there is only 1 character.\\n        if len(mp1) == len(word) or len(mp1) == 1:\\n            return True\\n        mp2 = collections.Counter(mp1.values())\\n        if len(mp2) != 2:\\n            return False\\n        lst = list(mp2.keys())\\n        k1, k2 = lst[0], lst[1]\\n        v1, v2 = mp2[k1], mp2[k2]\\n        # One character only occurs once.\\n        if v1 == 1 and k1 == 1 or v2 == 1 and k2 == 1:\\n            return True\\n        # There is only one high frequency character. \\n        if k1 == k2 + 1 and v1 == 1 or k1 == k2 - 1 and v2 == 1:\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        mp1 = collections.Counter(word)\\n        # All character only occur once or there is only 1 character.\\n        if len(mp1) == len(word) or len(mp1) == 1:\\n            return True\\n        mp2 = collections.Counter(mp1.values())\\n        if len(mp2) != 2:\\n            return False\\n        lst = list(mp2.keys())\\n        k1, k2 = lst[0], lst[1]\\n        v1, v2 = mp2[k1], mp2[k2]\\n        # One character only occurs once.\\n        if v1 == 1 and k1 == 1 or v2 == 1 and k2 == 1:\\n            return True\\n        # There is only one high frequency character. \\n        if k1 == k2 + 1 and v1 == 1 or k1 == k2 - 1 and v2 == 1:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665134,
                "title": "a-few-solutions",
                "content": "**Concise solutions:**\\n\\nReturn `true` if-and-only-if we have the same frequency of the characters remaining without each `i`<sup>th</sup> character of the input string `s`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var equalFrequency = { s: String -> IntArray(s.length){ it }.any{ i -> 1 == \"${s.substring(0, i)}${s.substring(i + 1)}\".groupingBy{ it }.eachCount().values.toSet().size } }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet equalFrequency = s => [...Array(s.length).keys()].some(i => 1 == new Set(Object.values(_.countBy(`${s.substr(0, i)}${s.substr(i + 1)}`.split(\\'\\')))).size);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    equalFrequency = lambda self, s: any(1 == len(set(Counter(s[:i] + s[i + 1:]).values())) for i in range(len(s)))\\n```\\n\\n*Rust*\\n```\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn equal_frequency(s: String) -> bool {\\n        fn ok(s: String) -> bool {\\n            let mut m = HashMap::new();\\n            for c in s.chars() {\\n                *m.entry(c.clone()).or_insert(0) += 1;\\n            }\\n            let mut seen = HashSet::new();\\n            for cnt in m.values() {\\n                seen.insert(cnt);\\n            }\\n            1 == seen.len()\\n        }\\n        (0..s.len()).into_iter().any(|i| ok(String::from(format!(\"{}{}\", &s[0..i], &s[i + 1..]))))\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    bool equalFrequency(string s) {\\n        auto ok = [](auto&& s) {\\n            Counter cnt; Set seen;\\n            for_each(s.begin(), s.end(), [&](auto c) { ++cnt[c]; });\\n            transform(cnt.begin(), cnt.end(), inserter(seen, seen.end()), [](auto& pair) { return pair.second; });\\n            return 1 == seen.size();\\n        };\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (ok(s.substr(0, i).append(s.substr(i + 1))))\\n                return true;\\n        return false;\\n    }\\n};\\n```\\n\\n---\\n\\n**Verbose solutions:**\\n\\nThere are 2 use cases to consider:\\n\\n1. decrement the frequency of the minimum frequency value to zero, ie. delete it\\n2. decrement the frequency of the maximum frequency value to the frequency of all other characters\\n\\nSo let\\'s try them both by decrementing the frequency of each unique character `c` in `s` and see in the remaining frequency values are all equal.\\n\\n* Note: this is less efficient than cherry-picking the characters with min/max frequency value, but the code is more concise.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun equalFrequency(s: String): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        for (c in s) {\\n            m[c] = 1 + (m[c] ?: 0)\\n        }\\n        for (c in s.toSet()) {\\n            m[c] = -1 + m[c]!!\\n            if (m[c]!! == 0)\\n                m.remove(c)\\n            if (1 == m.values.toSet().size)\\n                return true\\n            m[c] = 1 + (m[c] ?: 0)\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet equalFrequency = (s, m = new Map()) => {\\n    for (let c of s.split(\\'\\'))\\n        m.set(c, 1 + (m.get(c) || 0));\\n    for (let c of new Set(s.split(\\'\\'))) {\\n        m.set(c, -1 + m.get(c));\\n        if (!m.get(c))\\n            m.delete(c);\\n        if (1 == new Set([...m].map(([_, val]) => val)).size)\\n            return true;\\n        m.set(c, 1 + (m.get(c) || 0));\\n    };\\n    return false;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def equalFrequency(self, s: str) -> bool:\\n        m = Counter(s)\\n        for c in set(s):\\n            m[c] -= 1\\n            if not m[c]:\\n                del m[c]\\n            if 1 == len(set(m.values())):\\n                return True\\n            m[c] += 1\\n        return False\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<int>;\\n    bool equalFrequency(string s, Map m = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto c: Set{s.begin(), s.end()}) {\\n            if (!--m[c])\\n                m.erase(c);\\n            auto target = m.begin()->second;\\n            if (all_of(m.begin(), m.end(), [=](auto& pair) { return pair.second == target; }))\\n                return true;\\n            ++m[c];\\n        };\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var equalFrequency = { s: String -> IntArray(s.length){ it }.any{ i -> 1 == \"${s.substring(0, i)}${s.substring(i + 1)}\".groupingBy{ it }.eachCount().values.toSet().size } }\\n}\\n```\n```\\nlet equalFrequency = s => [...Array(s.length).keys()].some(i => 1 == new Set(Object.values(_.countBy(`${s.substr(0, i)}${s.substr(i + 1)}`.split(\\'\\')))).size);\\n```\n```\\nclass Solution:\\n    equalFrequency = lambda self, s: any(1 == len(set(Counter(s[:i] + s[i + 1:]).values())) for i in range(len(s)))\\n```\n```\\nuse std::collections::{HashMap, HashSet};\\nimpl Solution {\\n    pub fn equal_frequency(s: String) -> bool {\\n        fn ok(s: String) -> bool {\\n            let mut m = HashMap::new();\\n            for c in s.chars() {\\n                *m.entry(c.clone()).or_insert(0) += 1;\\n            }\\n            let mut seen = HashSet::new();\\n            for cnt in m.values() {\\n                seen.insert(cnt);\\n            }\\n            1 == seen.len()\\n        }\\n        (0..s.len()).into_iter().any(|i| ok(String::from(format!(\"{}{}\", &s[0..i], &s[i + 1..]))))\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using Counter = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    bool equalFrequency(string s) {\\n        auto ok = [](auto&& s) {\\n            Counter cnt; Set seen;\\n            for_each(s.begin(), s.end(), [&](auto c) { ++cnt[c]; });\\n            transform(cnt.begin(), cnt.end(), inserter(seen, seen.end()), [](auto& pair) { return pair.second; });\\n            return 1 == seen.size();\\n        };\\n        for (auto i{ 0 }; i < s.size(); ++i)\\n            if (ok(s.substr(0, i).append(s.substr(i + 1))))\\n                return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun equalFrequency(s: String): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        for (c in s) {\\n            m[c] = 1 + (m[c] ?: 0)\\n        }\\n        for (c in s.toSet()) {\\n            m[c] = -1 + m[c]!!\\n            if (m[c]!! == 0)\\n                m.remove(c)\\n            if (1 == m.values.toSet().size)\\n                return true\\n            m[c] = 1 + (m[c] ?: 0)\\n        }\\n        return false\\n    }\\n}\\n```\n```\\nlet equalFrequency = (s, m = new Map()) => {\\n    for (let c of s.split(\\'\\'))\\n        m.set(c, 1 + (m.get(c) || 0));\\n    for (let c of new Set(s.split(\\'\\'))) {\\n        m.set(c, -1 + m.get(c));\\n        if (!m.get(c))\\n            m.delete(c);\\n        if (1 == new Set([...m].map(([_, val]) => val)).size)\\n            return true;\\n        m.set(c, 1 + (m.get(c) || 0));\\n    };\\n    return false;\\n};\\n```\n```\\nclass Solution:\\n    def equalFrequency(self, s: str) -> bool:\\n        m = Counter(s)\\n        for c in set(s):\\n            m[c] -= 1\\n            if not m[c]:\\n                del m[c]\\n            if 1 == len(set(m.values())):\\n                return True\\n            m[c] += 1\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    using Set = unordered_set<int>;\\n    bool equalFrequency(string s, Map m = {}) {\\n        for (auto c: s)\\n            ++m[c];\\n        for (auto c: Set{s.begin(), s.end()}) {\\n            if (!--m[c])\\n                m.erase(c);\\n            auto target = m.begin()->second;\\n            if (all_of(m.begin(), m.end(), [=](auto& pair) { return pair.second == target; }))\\n                return true;\\n            ++m[c];\\n        };\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664233,
                "title": "ok",
                "content": "**straightforward**\\n```\\nbool equalFrequency(string w)\\n{\\n\\tint d[26]{};\\n\\tfor(const auto & c : w) ++d[c-\\'a\\'];\\n\\n\\tint im{w[0]-\\'a\\'}, iM{w[0]-\\'a\\'};\\n\\tfor(int i{}; i<26; ++i)\\n\\t{\\n\\t\\tif(d[i] and d[i]<d[im]) im=i;\\n\\t\\tif(d[i] and d[i]>d[iM]) iM=i;\\n\\t}    \\n\\n\\tint M=d[iM];\\n\\t--d[iM];\\n\\tauto f1 = all_of(begin(d), end(d), [&](auto & x){ return !x or x==M-1; });   \\n\\t++d[iM];\\n\\t--d[im];      \\n\\tauto f2 = all_of(begin(d), end(d), [&](auto & x){ return !x or x==M; });\\n\\treturn f1 or f2;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool equalFrequency(string w)\\n{\\n\\tint d[26]{};\\n\\tfor(const auto & c : w) ++d[c-\\'a\\'];\\n\\n\\tint im{w[0]-\\'a\\'}, iM{w[0]-\\'a\\'};\\n\\tfor(int i{}; i<26; ++i)\\n\\t{\\n\\t\\tif(d[i] and d[i]<d[im]) im=i;\\n\\t\\tif(d[i] and d[i]>d[iM]) iM=i;\\n\\t}    \\n\\n\\tint M=d[iM];\\n\\t--d[iM];\\n\\tauto f1 = all_of(begin(d), end(d), [&](auto & x){ return !x or x==M-1; });   \\n\\t++d[iM];\\n\\t--d[im];      \\n\\tauto f2 = all_of(begin(d), end(d), [&](auto & x){ return !x or x==M; });\\n\\treturn f1 or f2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656815,
                "title": "c-100-faster",
                "content": "1. bool equalFrequency(string word) {\\n1.     vector<int>v(26,0);\\n1.         for(int i=0;i<word.size();i++)\\n1.         {\\n1.             v[word[i]-\\'a\\']++;\\n1.         }\\n1.         for(int i=0;i<26;i++)\\n1.         {\\n1.             vector<int>temp=v;\\n1.             if(v[i]<=0)\\n1.             {\\n1.                 continue;\\n1.             }\\n1.             temp[i]--;\\n1.             set<int>s;\\n1.             for(auto z:temp)\\n1.             {  if(z>0)\\n1.                 s.insert(z);\\n1.             }\\n1.             if(s.size()==1)\\n1.                 return true;\\n1.         }\\n1.         return false;\\n1.     }",
                "solutionTags": [],
                "code": "1. bool equalFrequency(string word) {\\n1.     vector<int>v(26,0);\\n1.         for(int i=0;i<word.size();i++)\\n1.         {\\n1.             v[word[i]-\\'a\\']++;\\n1.         }\\n1.         for(int i=0;i<26;i++)\\n1.         {\\n1.             vector<int>temp=v;\\n1.             if(v[i]<=0)\\n1.             {\\n1.                 continue;\\n1.             }\\n1.             temp[i]--;\\n1.             set<int>s;\\n1.             for(auto z:temp)\\n1.             {  if(z>0)\\n1.                 s.insert(z);\\n1.             }\\n1.             if(s.size()==1)\\n1.                 return true;\\n1.         }\\n1.         return false;\\n1.     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2656314,
                "title": "python-counter-of-counters",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == 1:\\n            return True\\n        cnt = Counter(word)\\n        if len(cnt) == 1:\\n            return True\\n        cnt_cnt = Counter(cnt.values())\\n        \\n        if len(cnt_cnt) == 1 and next(iter(cnt_cnt)) == 1:\\n            return True\\n        if len(cnt_cnt) == 2:\\n            (f1, c1), (f2, c2) = cnt_cnt.items()\\n            if c1 == 1 and (f1 == 1 or (f1 - f2) == 1):\\n                return True\\n            if c2 == 1 and (f2 == 1 or (f2 - f1) == 1):\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        if len(word) == 1:\\n            return True\\n        cnt = Counter(word)\\n        if len(cnt) == 1:\\n            return True\\n        cnt_cnt = Counter(cnt.values())\\n        \\n        if len(cnt_cnt) == 1 and next(iter(cnt_cnt)) == 1:\\n            return True\\n        if len(cnt_cnt) == 2:\\n            (f1, c1), (f2, c2) = cnt_cnt.items()\\n            if c1 == 1 and (f1 == 1 or (f1 - f2) == 1):\\n                return True\\n            if c2 == 1 and (f2 == 1 or (f2 - f1) == 1):\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654324,
                "title": "golang-solution-0ms-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Remove Letter To Equalize Frequency.\\nMemory Usage: 1.9 MB, less than 100.00% of Go online submissions for Remove Letter To Equalize Frequency.\\n\\n```\\nfunc equalFrequency(word string) bool {\\n    m := make(map[rune]int)\\n    for _, r := range word {\\n        if v, ok := m[r]; ok {\\n            m[r] = v + 1 \\n        } else {\\n            m[r] = 1\\n        }\\n    }\\n    m2 := make(map[int]int)\\n    for _, c := range m {\\n        if v, ok := m2[c]; ok {\\n            m2[c] = v + 1 \\n        } else {\\n            m2[c] = 1\\n        }        \\n    }\\n    if len(m2) == 1 {\\n        var k, v int\\n        for k, v = range m2 {}\\n        if k == 1 || v == 1 {\\n            return true\\n        }\\n        return false\\n    } else if len(m2) > 2 {\\n        return false\\n    }\\n    s := make([]int, 0, 2)\\n    for k, _ := range m2 {\\n        s = append(s, k)\\n    }\\n    sort.Ints(s)\\n    if v, _ := m2[s[1]]; v == 1 && s[1] - s[0] == 1 {\\n        return true\\n    }\\n    if v, _ := m2[s[0]]; v == 1 && s[0] == 1{\\n        return true\\n    } \\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc equalFrequency(word string) bool {\\n    m := make(map[rune]int)\\n    for _, r := range word {\\n        if v, ok := m[r]; ok {\\n            m[r] = v + 1 \\n        } else {\\n            m[r] = 1\\n        }\\n    }\\n    m2 := make(map[int]int)\\n    for _, c := range m {\\n        if v, ok := m2[c]; ok {\\n            m2[c] = v + 1 \\n        } else {\\n            m2[c] = 1\\n        }        \\n    }\\n    if len(m2) == 1 {\\n        var k, v int\\n        for k, v = range m2 {}\\n        if k == 1 || v == 1 {\\n            return true\\n        }\\n        return false\\n    } else if len(m2) > 2 {\\n        return false\\n    }\\n    s := make([]int, 0, 2)\\n    for k, _ := range m2 {\\n        s = append(s, k)\\n    }\\n    sort.Ints(s)\\n    if v, _ := m2[s[1]]; v == 1 && s[1] - s[0] == 1 {\\n        return true\\n    }\\n    if v, _ := m2[s[0]]; v == 1 && s[0] == 1{\\n        return true\\n    } \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654117,
                "title": "c-concept-explained-faster-than-100-00-of-c-solution",
                "content": "\\n        vector<int>  ans(26);\\n        for(auto i: word) ans[i-\\'a\\']++;    // stored all the frequency of elements \\n        for(int i=0; i<26; i++){ \\n\\t\\t\\t//then we will decrerase that frequency ;\\n            if(ans[i]) {\\n                ans[i]--; // decrease the frequency of the char ;\\n                bool chk = true;\\n                int maxi = *max_element(ans.begin(),ans.end()); // this will return the max element into the vector arr;\\n                for(int j=0; j<26;j++){\\n                    if(ans[j] && ans[j] != maxi)    // means if all element\\'s frequeny is equal or not  if not equel then chek is false; and move on..\\n\\t\\t\\t\\t\\t\\tchk = false;\\n                }\\n                if(chk) return true;  // this means after deleting that elemet frequency will be equal of all other element into that arr; so return true; \\n                ans[i]++;    // if not true \\n            }\\n        }\\n        return false;  \\n\\n\\t\\t\\n**Runtime**: 0 ms, faster than **100.00% of C++** online submissions for Remove Letter To Equalize Frequency.\\n**Memory Usage**: 6.2 MB, less than **100.00% of C++** online submissions for Remove Letter To Equalize Frequency.\\n\\n\\n**upvote the solution if you find this helpfull and feel free to ask doubt**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "\\n        vector<int>  ans(26);\\n        for(auto i: word) ans[i-\\'a\\']++;    // stored all the frequency of elements \\n        for(int i=0; i<26; i++){ \\n\\t\\t\\t//then we will decrerase that frequency ;\\n            if(ans[i]) {\\n                ans[i]--; // decrease the frequency of the char ;\\n                bool chk = true;\\n                int maxi = *max_element(ans.begin(),ans.end()); // this will return the max element into the vector arr;\\n                for(int j=0; j<26;j++){\\n                    if(ans[j] && ans[j] != maxi)    // means if all element\\'s frequeny is equal or not  if not equel then chek is false; and move on..\\n\\t\\t\\t\\t\\t\\tchk = false;\\n                }\\n                if(chk) return true;  // this means after deleting that elemet frequency will be equal of all other element into that arr; so return true; \\n                ans[i]++;    // if not true \\n            }\\n        }\\n        return false;  \\n\\n\\t\\t\\n**Runtime**: 0 ms, faster than **100.00% of C++** online submissions for Remove Letter To Equalize Frequency.\\n**Memory Usage**: 6.2 MB, less than **100.00% of C++** online submissions for Remove Letter To Equalize Frequency.\\n\\n\\n**upvote the solution if you find this helpfull and feel free to ask doubt**",
                "codeTag": "Unknown"
            },
            {
                "id": 2653312,
                "title": "the-easiest-way",
                "content": "Remove each letter\\'s occurence and check if the remaining string has equal characters.\\nTime  Complexity : O(26^2)\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n        vector<int> cnt(26);\\n\\t\\t\\n        for(char c : s) cnt[c - \\'a\\']++;\\n        \\n        for(int i=0; i<26; ++i)\\n        {\\n            if(cnt[i] == 0) continue;\\n            \\n\\t\\t\\t// removing letter\\'s occurence\\n            --cnt[i];\\n            \\n\\t\\t\\t// checking if the rest of character\\'s are same\\n            bool same = true;\\n            int num = -1;\\n            for(int j=0; j<26; ++j)\\n            {\\n                if(cnt[j] == 0) continue;\\n                \\n                if(num == -1) num = cnt[j];\\n                \\n                if(num != cnt[j]) \\n                {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(same) return true;\\n\\t\\t\\t// adding the letter back\\n            ++cnt[i];\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n        vector<int> cnt(26);\\n\\t\\t\\n        for(char c : s) cnt[c - \\'a\\']++;\\n        \\n        for(int i=0; i<26; ++i)\\n        {\\n            if(cnt[i] == 0) continue;\\n            \\n\\t\\t\\t// removing letter\\'s occurence\\n            --cnt[i];\\n            \\n\\t\\t\\t// checking if the rest of character\\'s are same\\n            bool same = true;\\n            int num = -1;\\n            for(int j=0; j<26; ++j)\\n            {\\n                if(cnt[j] == 0) continue;\\n                \\n                if(num == -1) num = cnt[j];\\n                \\n                if(num != cnt[j]) \\n                {\\n                    same = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(same) return true;\\n\\t\\t\\t// adding the letter back\\n            ++cnt[i];\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652943,
                "title": "scala-one-line-solution",
                "content": "```\\n  def equalFrequency(word: String): Boolean = \\n    (0 until word.length).foldLeft(false)((ans, idx)=>{\\n      ans || (word.substring(0, idx) + word.substring(idx + 1, word.length)).groupBy(identity).mapValues(_.size).map(_._2).groupBy(identity).size == 1\\n    })\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def equalFrequency(word: String): Boolean = \\n    (0 until word.length).foldLeft(false)((ans, idx)=>{\\n      ans || (word.substring(0, idx) + word.substring(idx + 1, word.length)).groupBy(identity).mapValues(_.size).map(_._2).groupBy(identity).size == 1\\n    })\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2652848,
                "title": "c-faster-100-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool equalFrequency(string word) \\n\\t\\t{\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tvector<int> freq(26, 0);\\n\\n\\t\\t\\tfor(int i = 0 ; i < word.size() ; i++)\\n\\t\\t\\t\\td += ++freq[word[i] - \\'a\\'] == 1;\\n\\n\\t\\t\\tset<int>st;\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tst.clear();\\n\\n\\t\\t\\t\\tfor(int j = 0 ; j < 26 ; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(freq[j])\\n\\t\\t\\t\\t\\t\\tst.insert(freq[j]);\\n\\t\\t\\t\\t}    \\n\\n\\t\\t\\t\\tif(st.size() == 1)\\n\\t\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t\\tfreq[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool equalFrequency(string word) \\n\\t\\t{\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tvector<int> freq(26, 0);\\n\\n\\t\\t\\tfor(int i = 0 ; i < word.size() ; i++)\\n\\t\\t\\t\\td += ++freq[word[i] - \\'a\\'] == 1;\\n\\n\\t\\t\\tset<int>st;\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tst.clear();\\n\\n\\t\\t\\t\\tfor(int j = 0 ; j < 26 ; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(freq[j])\\n\\t\\t\\t\\t\\t\\tst.insert(freq[j]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2652584,
                "title": "clean-c-code-100-faster-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        for(int i=0;i<word.size();i++)\\n        {\\n            string s=word;\\n            s.erase(s.begin()+i);\\n            map<char,int>mp;\\n            for(auto it:s)\\n            mp[it]++;\\n            set<int>s1;\\n            for(auto it:mp)\\n            {\\n                s1.insert(it.second);\\n            }\\n            cout<<s1.size()<<endl;\\n            if(s1.size()==1)return true;\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        for(int i=0;i<word.size();i++)\\n        {\\n            string s=word;\\n            s.erase(s.begin()+i);\\n            map<char,int>mp;\\n            for(auto it:s)\\n            mp[it]++;\\n            set<int>s1;\\n            for(auto it:mp)\\n            {\\n                s1.insert(it.second);\\n            }\\n            cout<<s1.size()<<endl;\\n            if(s1.size()==1)return true;\\n\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2652432,
                "title": "python-easy-using-set",
                "content": "\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif len(set(Counter(word[:i]+word[i+1:]).values()))==1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "\\tfor i in range(len(word)):\\n\\t\\t\\t\\tif len(set(Counter(word[:i]+word[i+1:]).values()))==1:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Unknown"
            },
            {
                "id": 2652390,
                "title": "kotlin-solution-should-be-a-medium-problem",
                "content": "```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val map = mutableMapOf<Char,Int>()\\n        \\n        word.forEach {\\n            map[it] = map.getOrDefault(it, 0) + 1\\n        }\\n        \\n        val occurences = map.values.toList()\\n        \\n        if (occurences.size == 1) return true\\n        if (occurences.distinct().size > 2) return false\\n        \\n        var diffCount = 0\\n        var i = 0\\n        \\n        while (i < occurences.size-1) {\\n            if (diffCount > 1) {\\n                return false\\n            }\\n            \\n            if (occurences[i] != occurences[i+1]) {\\n                if (Math.abs(occurences[i] - occurences[i+1]) > 1)\\n                    return false\\n\\n                diffCount++\\n                i++\\n            }\\n            \\n            i++\\n        }\\n        \\n        return diffCount == 1 || occurences[0] == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val map = mutableMapOf<Char,Int>()\\n        \\n        word.forEach {\\n            map[it] = map.getOrDefault(it, 0) + 1\\n        }\\n        \\n        val occurences = map.values.toList()\\n        \\n        if (occurences.size == 1) return true\\n        if (occurences.distinct().size > 2) return false\\n        \\n        var diffCount = 0\\n        var i = 0\\n        \\n        while (i < occurences.size-1) {\\n            if (diffCount > 1) {\\n                return false\\n            }\\n            \\n            if (occurences[i] != occurences[i+1]) {\\n                if (Math.abs(occurences[i] - occurences[i+1]) > 1)\\n                    return false\\n\\n                diffCount++\\n                i++\\n            }\\n            \\n            i++\\n        }\\n        \\n        return diffCount == 1 || occurences[0] == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651864,
                "title": "100-runtime-100-memory-complexity-analysis-easy-code-c",
                "content": "![image](https://assets.leetcode.com/users/images/ac18faea-fad8-4832-90ed-0e59413d918e_1664729630.890346.png)\\n\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> freq(26, 0);\\n        \\n        for (auto c : word) freq[c - \\'a\\']++;\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (freq[i] == 0) continue;\\n            freq[i]--;\\n            int max = INT_MIN, min = INT_MAX;\\n            for (auto j : freq) {\\n                if (j == 0) continue;\\n                if (j > max) max = j;\\n                if (j < min) min = j;\\n            }\\n            if (max == min) return true;\\n            freq[i]++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n## Complexity Analysis\\n##### Time Complexity: O(n)\\n##### Space Complexity: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        vector<int> freq(26, 0);\\n        \\n        for (auto c : word) freq[c - \\'a\\']++;\\n        \\n        for (int i = 0; i < 26; ++i) {\\n            if (freq[i] == 0) continue;\\n            freq[i]--;\\n            int max = INT_MIN, min = INT_MAX;\\n            for (auto j : freq) {\\n                if (j == 0) continue;\\n                if (j > max) max = j;\\n                if (j < min) min = j;\\n            }\\n            if (max == min) return true;\\n            freq[i]++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651843,
                "title": "java-simple-solution-with-map-and-set",
                "content": "```\\npublic boolean equalFrequency(String word) {  \\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n\\n        //Count characters\\n        //define unic characters\\n        for (char ch : word.toCharArray()) {\\n            map.merge(ch, 1, Integer::sum);\\n            set.add(ch);\\n        }\\n\\n        //Iterate through unique characters\\n        for (char ch : set) {\\n            Map<Character, Integer> copyMap = new HashMap<>(map); //Create every time copy of Map\\n            copyMap.merge(ch, -1, Integer::sum); //For every character decreased count\\n\\n            if (copyMap.get(ch) == 0) { //If count of character becames 0, delete it from map\\n                copyMap.remove(ch);\\n            }\\n\\t\\t\\t \\n\\t\\t\\t //Check is frequency unic for all characters when make one deletion\\n            Set<Integer> freq = new HashSet<>(copyMap.values());     \\n            if (freq.size() == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean equalFrequency(String word) {  \\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n\\n        //Count characters\\n        //define unic characters\\n        for (char ch : word.toCharArray()) {\\n            map.merge(ch, 1, Integer::sum);\\n            set.add(ch);\\n        }\\n\\n        //Iterate through unique characters\\n        for (char ch : set) {\\n            Map<Character, Integer> copyMap = new HashMap<>(map); //Create every time copy of Map\\n            copyMap.merge(ch, -1, Integer::sum); //For every character decreased count\\n\\n            if (copyMap.get(ch) == 0) { //If count of character becames 0, delete it from map\\n                copyMap.remove(ch);\\n            }\\n\\t\\t\\t \\n\\t\\t\\t //Check is frequency unic for all characters when make one deletion\\n            Set<Integer> freq = new HashSet<>(copyMap.values());     \\n            if (freq.size() == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651781,
                "title": "java-o-nlogn-faster-than-100-memory-less-than-100-of-java-submissions",
                "content": "class Solution {\\n    public boolean equalFrequency(String word) {\\n        \\n        if(word.length() == 2)\\n            if(word.charAt(0) == word.charAt(1))\\n                return true;\\n        \\n        // put the string into the map easily\\n        \\n        HashMap<Character,Integer> mp = new HashMap<>();\\n        for(int i=0; i<word.length(); i++){\\n            mp.put(word.charAt(i),mp.getOrDefault(word.charAt(i),0)+1);\\n        }\\n        \\n        int[] arr = new int[mp.size()];\\n        int ind = 0;\\n        \\n        // put the values or frequency into an array\\n        for(Map.Entry<Character,Integer> e : mp.entrySet()){\\n            arr[ind++] = e.getValue();\\n        }\\n        \\n\\t\\t// sort the array\\n        Arrays.sort(arr);\\n        \\n        if(arr.length == 1)\\n            return true;\\n        \\n        if(arr[0] == 1 && arr[arr.length-1] == 1)\\n                return true;\\n        if(arr[0] == arr[arr.length-1])\\n            return false;\\n        \\n        if(arr[arr.length -1] - arr[0] > 1)\\n            return false;\\n        else{\\n                for(int i=0; i<arr.length-1; i++){\\n                    if(arr[i] != arr[i+1])\\n                        if((i+1) == arr.length-1 || i ==0)\\n                            return true;\\n                }\\n        }        \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean equalFrequency(String word) {\\n        \\n        if(word.length() == 2)\\n            if(word.charAt(0) == word.charAt(1))\\n                return true;\\n        \\n        // put the string into the map easily\\n        \\n        HashMap<Character,Integer> mp = new HashMap<>();\\n        for(int i=0; i<word.length(); i++){\\n            mp.put(word.charAt(i),mp.getOrDefault(word.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2651706,
                "title": "c-o-n-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_set <char> st;    //store all the unique characters\\n        \\n        for(auto x : word) {\\n            st.insert(x);\\n        }\\n        \\n        int sz = st.size();    //unique words\\n        \\n        int len = word.length();\\n        \\n        if(sz == len)\\n            return true;\\n        \\n        else if(len%sz == 1 || len%sz == (sz-1))\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**Do upvote if the solution helps you**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        unordered_set <char> st;    //store all the unique characters\\n        \\n        for(auto x : word) {\\n            st.insert(x);\\n        }\\n        \\n        int sz = st.size();    //unique words\\n        \\n        int len = word.length();\\n        \\n        if(sz == len)\\n            return true;\\n        \\n        else if(len%sz == 1 || len%sz == (sz-1))\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651094,
                "title": "java-solution-1ms-runtime-o-n-time-100-faster",
                "content": "```java \\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] a = new int[26];\\n        \\n        for(int i=0;i<word.length();i++)\\n            a[word.charAt(i)-\\'a\\']++;\\n        \\n        int max=0;\\n        int min=word.charAt(0)-\\'a\\';\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>a[max])\\n                max=i;\\n            if(a[i]<a[min] && a[i]>0)\\n                min=i;\\n        }\\n        //checking by reducing max freq by 1\\n        a[max]--;\\n        if(check(a))\\n             return true;\\n        a[max]++;\\n        \\n        //checking by reducing min freq by 1\\n        a[min]--;\\n        if(check(a))\\n             return true;\\n        return false;\\n    }\\n    \\n    private boolean check(int[] a)\\n    {\\n        int last=0;\\n        for(int x:a)\\n        {\\n            if(x>0){\\n            if(last==0)\\n                last = x;\\n            else if(last!=x)\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] a = new int[26];\\n        \\n        for(int i=0;i<word.length();i++)\\n            a[word.charAt(i)-\\'a\\']++;\\n        \\n        int max=0;\\n        int min=word.charAt(0)-\\'a\\';\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>a[max])\\n                max=i;\\n            if(a[i]<a[min] && a[i]>0)\\n                min=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2650309,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n           map<char , int> mp;\\n        int cnt = 0;\\n        for(int i = 0 ; i<word.length() ; i++){\\n            mp[word[i]]++;\\n        }\\n        \\n        \\n        \\n        for(auto it: mp){\\n            int val =0;\\n            set<int> st;\\n            for(auto it1: mp){\\n                if(it1.first == it.first){\\n                if(it.second-1 > 0){\\n                    st.insert(it.second-1);\\n                }\\n                    continue;\\n                }\\n                \\n                st.insert(it1.second);\\n                \\n                \\n            }\\n            \\n            if(st.size() == 1){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        for(auto it: mp){\\n            if(it.second == 1){\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt == word.length()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n           map<char , int> mp;\\n        int cnt = 0;\\n        for(int i = 0 ; i<word.length() ; i++){\\n            mp[word[i]]++;\\n        }\\n        \\n        \\n        \\n        for(auto it: mp){\\n            int val =0;\\n            set<int> st;\\n            for(auto it1: mp){\\n                if(it1.first == it.first){\\n                if(it.second-1 > 0){\\n                    st.insert(it.second-1);\\n                }\\n                    continue;\\n                }\\n                \\n                st.insert(it1.second);\\n                \\n                \\n            }\\n            \\n            if(st.size() == 1){\\n                return true;\\n            }\\n        }\\n        \\n        \\n        for(auto it: mp){\\n            if(it.second == 1){\\n                cnt++;\\n            }\\n        }\\n        \\n        if(cnt == word.length()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650198,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n        int l = 0;\\n        int n = s.length();\\n        map<char,int> mp;\\n        for(auto i:s)mp[i]++;\\n        if(mp.size()==n)return 1;\\n        while(l<=n)\\n        {\\n            int cnt = 0;\\n            for(auto &i:mp)\\n            {\\n                if(i.second<l)cnt+=i.second;\\n                else cnt+=(i.second-l);\\n            }\\n            if(cnt==1)return 1;\\n            l++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string s) {\\n        int l = 0;\\n        int n = s.length();\\n        map<char,int> mp;\\n        for(auto i:s)mp[i]++;\\n        if(mp.size()==n)return 1;\\n        while(l<=n)\\n        {\\n            int cnt = 0;\\n            for(auto &i:mp)\\n            {\\n                if(i.second<l)cnt+=i.second;\\n                else cnt+=(i.second-l);\\n            }\\n            if(cnt==1)return 1;\\n            l++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650138,
                "title": "javascript",
                "content": "Use nested for loop and set\\n\\n```\\nconst equalFrequency = function(word) {\\n    for (let i = 0; i < word.length; i++) {\\n        const hash = {}\\n        for (let j = 0; j < word.length; j++) {\\n            if (i !== j) {\\n                const ch = word[j]\\n                hash[ch] = (hash[ch] || 0) + 1\\n            }\\n        }\\n        \\n        const hashSet = new Set()\\n        \\n        for (let prop in hash) {\\n            hashSet.add(hash[prop])\\n        }\\n        \\n        if (hashSet.size === 1) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst equalFrequency = function(word) {\\n    for (let i = 0; i < word.length; i++) {\\n        const hash = {}\\n        for (let j = 0; j < word.length; j++) {\\n            if (i !== j) {\\n                const ch = word[j]\\n                hash[ch] = (hash[ch] || 0) + 1\\n            }\\n        }\\n        \\n        const hashSet = new Set()\\n        \\n        for (let prop in hash) {\\n            hashSet.add(hash[prop])\\n        }\\n        \\n        if (hashSet.size === 1) {\\n            return true\\n        }\\n    }\\n    \\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2649688,
                "title": "c-0ms-faster-than-100-hashmap-easiest-approach-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// Do Upvote if you liked the Solution.\\n\\n    bool equalFrequency(string word) {\\n\\n       unordered_map<char,int>mpp;\\n       for(auto it : word)\\n       {\\n          mpp[it]++;\\n       } \\n       vector<int> v;\\n       for(auto it : mpp)\\n       {\\n           v.push_back(it.second);\\n       }\\n\\n       sort(v.begin(),v.end());\\n       int cnt = count(v.begin(),v.end(),v[0]);\\n      \\n       if(v.size() == 1) return true;\\n\\n       if(cnt == v.size())\\n       {\\n           if(v[0] == 1) return true;\\n           else return false;\\n       }\\n\\n       if(cnt == 1 || cnt == v.size()-1)\\n       {\\n           if(v[v.size()-1]-v[0]==1) return true;\\n           else return false;\\n       }\\n       \\n       return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// Do Upvote if you liked the Solution.\\n\\n    bool equalFrequency(string word) {\\n\\n       unordered_map<char,int>mpp;\\n       for(auto it : word)\\n       {\\n          mpp[it]++;\\n       } \\n       vector<int> v;\\n       for(auto it : mpp)\\n       {\\n           v.push_back(it.second);\\n       }\\n\\n       sort(v.begin(),v.end());\\n       int cnt = count(v.begin(),v.end(),v[0]);\\n      \\n       if(v.size() == 1) return true;\\n\\n       if(cnt == v.size())\\n       {\\n           if(v[0] == 1) return true;\\n           else return false;\\n       }\\n\\n       if(cnt == 1 || cnt == v.size()-1)\\n       {\\n           if(v[v.size()-1]-v[0]==1) return true;\\n           else return false;\\n       }\\n       \\n       return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649489,
                "title": "python-100-fast-and-100-memory",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        dic = Counter(word)\\n        count = Counter(dic.values())\\n        \\n        l1 = count.most_common()\\n        \\n\\t\\t### here are some cases help you understand better  ###\\n        ###  like  abccc   abc ,aabbcc, aaa ###\\n        return (len(l1) == 2 and l1[-1][1] == 1 and abs(l1[0][0] -  l1[1][0]) == 1)\\\\\\n                or (len(l1) == 1 and l1[0][0] == 1) or len(dic) == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        dic = Counter(word)\\n        count = Counter(dic.values())\\n        \\n        l1 = count.most_common()\\n        \\n\\t\\t### here are some cases help you understand better  ###\\n        ###  like  abccc   abc ,aabbcc, aaa ###\\n        return (len(l1) == 2 and l1[-1][1] == 1 and abs(l1[0][0] -  l1[1][0]) == 1)\\\\\\n                or (len(l1) == 1 and l1[0][0] == 1) or len(dic) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649480,
                "title": "easy-c-solution-made-after-20-submission-and-condition-checking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        int a[26]={0};\\n        for(int i=0;i<w.size();i++){\\n            a[w[i]-\\'a\\']++;\\n        }\\n        map<int,int> mp;\\n        for(int i=0;i<26;i++){\\n            if(a[i]!=0){\\n                mp[a[i]]++;\\n            }\\n        }\\n        if(mp.size()==1){\\n            if(mp.begin()->second>1&&mp.begin()->first\\n              >1)return false;\\n            return true;\\n        }else if(mp.size()>2){\\n            return false;\\n        }else{\\n            auto it=mp.begin();\\n            int n1=it->first;\\n            it++;\\n            int n2=it->first;\\n            if((mp.begin()->first==1&&mp.begin()->second==1)||(it->first==1&&it->second==1))return true;\\n            if(n1>n2&&mp.begin()->second>1){\\n                return false;\\n            }\\n            else if(n2>n1&&it->second>1){\\n                return false;\\n            }\\n            if(abs(n1-n2)!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string w) {\\n        int a[26]={0};\\n        for(int i=0;i<w.size();i++){\\n            a[w[i]-\\'a\\']++;\\n        }\\n        map<int,int> mp;\\n        for(int i=0;i<26;i++){\\n            if(a[i]!=0){\\n                mp[a[i]]++;\\n            }\\n        }\\n        if(mp.size()==1){\\n            if(mp.begin()->second>1&&mp.begin()->first\\n              >1)return false;\\n            return true;\\n        }else if(mp.size()>2){\\n            return false;\\n        }else{\\n            auto it=mp.begin();\\n            int n1=it->first;\\n            it++;\\n            int n2=it->first;\\n            if((mp.begin()->first==1&&mp.begin()->second==1)||(it->first==1&&it->second==1))return true;\\n            if(n1>n2&&mp.begin()->second>1){\\n                return false;\\n            }\\n            else if(n2>n1&&it->second>1){\\n                return false;\\n            }\\n            if(abs(n1-n2)!=1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648432,
                "title": "python3-1-liner-counter-solution",
                "content": "Consider all cases where one character is deleted, and check if the frequency of each character of the string is equal.\\n```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        return any(len(set(Counter(word[:i]+word[i+1:]).values()))==1 for i in range(len(word)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        return any(len(set(Counter(word[:i]+word[i+1:]).values()))==1 for i in range(len(word)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648054,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn equal_frequency(word: String) -> bool {\\n        let mut counter = [0; 26];\\n        let (mut min_val, mut max_val) = (i32::MAX, i32::MIN);\\n\\n        word.bytes().for_each(|b| {\\n            let n = &mut counter[(b - b\\'a\\') as usize];\\n            *n += 1;\\n            max_val = max_val.max(*n);\\n        });\\n\\n        let (mut num_max, mut total) = (0, 0);\\n        counter.iter().filter(|n| **n > 0).for_each(|&n| {\\n            if n == max_val {\\n                num_max += 1;\\n            }\\n            min_val = min_val.min(n);\\n            total += 1;\\n        });\\n\\n        // 4 possible options:\\n        // aaaaa || abcde\\n        // abcdd\\n        // aabcc\\n        num_max == total && (total == 1 || max_val == 1)\\n            || num_max == 1 && (max_val - min_val) == 1\\n            || num_max == total - 1 && min_val == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Counting Sort"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn equal_frequency(word: String) -> bool {\\n        let mut counter = [0; 26];\\n        let (mut min_val, mut max_val) = (i32::MAX, i32::MIN);\\n\\n        word.bytes().for_each(|b| {\\n            let n = &mut counter[(b - b\\'a\\') as usize];\\n            *n += 1;\\n            max_val = max_val.max(*n);\\n        });\\n\\n        let (mut num_max, mut total) = (0, 0);\\n        counter.iter().filter(|n| **n > 0).for_each(|&n| {\\n            if n == max_val {\\n                num_max += 1;\\n            }\\n            min_val = min_val.min(n);\\n            total += 1;\\n        });\\n\\n        // 4 possible options:\\n        // aaaaa || abcde\\n        // abcdd\\n        // aabcc\\n        num_max == total && (total == 1 || max_val == 1)\\n            || num_max == 1 && (max_val - min_val) == 1\\n            || num_max == total - 1 && min_val == 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647995,
                "title": "java-array-sort",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        Integer[] map = new Integer[26];\\n        TreeMap<Integer, Integer> countMap = new TreeMap<>();\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n\\n        for (char item : word.toCharArray()) {\\n            int i = item - \\'a\\';\\n            if (map[i] == null)\\n                map[i] = 0;\\n            map[i]++;\\n        }\\n\\n        Arrays.sort(map, (a, b) -> a == null ? -1 : b == null ? 1 : a - b); // sort by min first with null in front \\n        map[25]--; // Most Frequency\\n\\n        if (isAllSame(map))\\n            return true;\\n\\n        map[25]++; // Most Frequency\\n        Arrays.sort(map, (a, b) -> a == null ? -1 : b == null ? 1 : b - a); // sort by max first with null in front \\n        map[25]--; // Less Frequency\\n\\n        return isAllSame(map);\\n    }\\n\\n    boolean isAllSame(Integer[] map) {\\n        int num = 0;\\n        for (int i = 25; i >= 0 && map[i] != null; i--) {\\n            if (map[i] == 0)\\n                continue;\\n\\n            if (num == 0)\\n                num = map[i];\\n            else if (map[i] != num)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        Integer[] map = new Integer[26];\\n        TreeMap<Integer, Integer> countMap = new TreeMap<>();\\n        int minIndex = 0;\\n        int maxIndex = 0;\\n\\n        for (char item : word.toCharArray()) {\\n            int i = item - \\'a\\';\\n            if (map[i] == null)\\n                map[i] = 0;\\n            map[i]++;\\n        }\\n\\n        Arrays.sort(map, (a, b) -> a == null ? -1 : b == null ? 1 : a - b); // sort by min first with null in front \\n        map[25]--; // Most Frequency\\n\\n        if (isAllSame(map))\\n            return true;\\n\\n        map[25]++; // Most Frequency\\n        Arrays.sort(map, (a, b) -> a == null ? -1 : b == null ? 1 : b - a); // sort by max first with null in front \\n        map[25]--; // Less Frequency\\n\\n        return isAllSame(map);\\n    }\\n\\n    boolean isAllSame(Integer[] map) {\\n        int num = 0;\\n        for (int i = 25; i >= 0 && map[i] != null; i--) {\\n            if (map[i] == 0)\\n                continue;\\n\\n            if (num == 0)\\n                num = map[i];\\n            else if (map[i] != num)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647869,
                "title": "python-o-n-simulate-deletion",
                "content": "Try to avoid enumerating all cases (very easy to ignore cases), so I think it would be easier to fully simulate the deletion process.  \\n- use a counter to count char frequency\\n- each step remove the char from the counter and check whether it has a single frequency\\n\\n```py\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        n = len(word)\\n        \\n        counter = Counter([c for c in word])\\n        \\n        \\n        for i in range(26):\\n            c = chr(ord(\\'a\\') + i)\\n            if c not in counter:\\n                continue\\n            \\n            counter[c] -= 1\\n            if counter[c] == 0:\\n                del counter[c]\\n\\n            frequencies = set(counter.values())\\n            if len(frequencies) == 1:\\n                return True\\n\\n            counter[c] += 1\\n                \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        n = len(word)\\n        \\n        counter = Counter([c for c in word])\\n        \\n        \\n        for i in range(26):\\n            c = chr(ord(\\'a\\') + i)\\n            if c not in counter:\\n                continue\\n            \\n            counter[c] -= 1\\n            if counter[c] == 0:\\n                del counter[c]\\n\\n            frequencies = set(counter.values())\\n            if len(frequencies) == 1:\\n                return True\\n\\n            counter[c] += 1\\n                \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647825,
                "title": "java-beat-100-with-freq-count",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] count = new int[26];\\n        for (char c : word.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int num : count) {\\n            if (num == 0) {\\n                continue;\\n            }\\n            int freq = map.getOrDefault(num, 0);\\n            map.put(num, freq + 1);\\n        }\\n        if (map.size() == 2 && map.firstKey() + 1 == map.lastKey() && map.get(map.lastKey()) == 1) {\\n            return true;\\n        }\\n        if (map.size() == 2 && map.firstKey() == 1 && map.get(map.firstKey()) == 1) {\\n            return true;\\n        }\\n        if (map.size() == 1) {\\n             if (map.firstKey() == 1 || map.get(map.firstKey()) == 1) {\\n                 return true;\\n             }\\n        } \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int[] count = new int[26];\\n        for (char c : word.toCharArray()) {\\n            count[c - \\'a\\']++;\\n        }\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int num : count) {\\n            if (num == 0) {\\n                continue;\\n            }\\n            int freq = map.getOrDefault(num, 0);\\n            map.put(num, freq + 1);\\n        }\\n        if (map.size() == 2 && map.firstKey() + 1 == map.lastKey() && map.get(map.lastKey()) == 1) {\\n            return true;\\n        }\\n        if (map.size() == 2 && map.firstKey() == 1 && map.get(map.firstKey()) == 1) {\\n            return true;\\n        }\\n        if (map.size() == 1) {\\n             if (map.firstKey() == 1 || map.get(map.firstKey()) == 1) {\\n                 return true;\\n             }\\n        } \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647800,
                "title": "very-easy-c-intuitive-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       int n=word.length();\\n       map<int,int>m;\\n        unordered_set<int>s;\\n        for(int i=0 ;i<n;i++){\\n            m[word[i]]++;\\n        }\\n        \\n        for(auto i:m){\\n            s.insert(i.second);\\n        }\\n        if(s.size()==1){\\n            for(auto i:s){\\n                if(i==1){\\n                    return true;\\n                }else if(m.size()==1){\\n                        return true;\\n                    }\\n            }\\n        }\\n        \\n       \\n        if(s.size()==1 || s.size()>2){\\n            return false;\\n        }\\n        \\n        \\n        vector<int>v;\\n        for(auto it:s){\\n            v.push_back(it);\\n        }\\n        \\n        int a=v[0];\\n        int b=v[1];\\n        int acnt=0, bcnt=0;\\n        int reqSize=m.size()-1;\\n        for(auto i:m){\\n            if(i.second==a){\\n                acnt++;\\n            }else if(i.second==b){\\n                bcnt++;\\n            }\\n        }\\n        \\n        if(acnt==reqSize){\\n            if(abs(a-b)==1){\\n                return true;\\n            }\\n        }else if(bcnt==reqSize){\\n            if(abs(a-b)==1){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n       int n=word.length();\\n       map<int,int>m;\\n        unordered_set<int>s;\\n        for(int i=0 ;i<n;i++){\\n            m[word[i]]++;\\n        }\\n        \\n        for(auto i:m){\\n            s.insert(i.second);\\n        }\\n        if(s.size()==1){\\n            for(auto i:s){\\n                if(i==1){\\n                    return true;\\n                }else if(m.size()==1){\\n                        return true;\\n                    }\\n            }\\n        }\\n        \\n       \\n        if(s.size()==1 || s.size()>2){\\n            return false;\\n        }\\n        \\n        \\n        vector<int>v;\\n        for(auto it:s){\\n            v.push_back(it);\\n        }\\n        \\n        int a=v[0];\\n        int b=v[1];\\n        int acnt=0, bcnt=0;\\n        int reqSize=m.size()-1;\\n        for(auto i:m){\\n            if(i.second==a){\\n                acnt++;\\n            }else if(i.second==b){\\n                bcnt++;\\n            }\\n        }\\n        \\n        if(acnt==reqSize){\\n            if(abs(a-b)==1){\\n                return true;\\n            }\\n        }else if(bcnt==reqSize){\\n            if(abs(a-b)==1){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647591,
                "title": "python-solution-naive-but-easy-to-understand",
                "content": "```\\nfrom statistics import mode\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        mydict = {}\\n        \\n        \\'\\'\\' Making a dictionary to count frequency \\'\\'\\'\\n        for char in word:\\n            if char not in mydict:\\n                mydict[char] = 1\\n            else:\\n                mydict[char] = mydict[char] + 1\\n        \\n        if len(mydict.keys())==1:  # if we have only one type of element (Ex: \\'aaaaa\\')\\n            return True\\n        \\n        freq = mode(list(mydict.values()))   # most common frequency\\n       \\n        \\'\\'\\' If we have each letter only once \\'\\'\\'\\n        if list(mydict.values()).count(1) == len(word):\\n            return True\\n\\n        \\n        for k,v in mydict.items():\\n            if v != freq:\\n                mydict[k]=mydict[k]-1       # if freq not equal decrease (Ex: aaabbcc)\\n                for k,v in mydict.items():  # it may be we need to increase the frequecy not decrease (Ex: \\'aabcc\\')\\n                    if v!=freq:\\n                        mydict[k]=mydict[k]+2\\n                        break\\n                break\\n                \\n        else:\\n            return False     # if all frequecy are equal and not 1\\n        \\n        for k,v in mydict.items():   # finally check after adjusting frequecy are we able to make all frequecnies equal\\n            if v != freq and v!=0:\\n                return False\\n        return True\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom statistics import mode\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        mydict = {}\\n        \\n        \\'\\'\\' Making a dictionary to count frequency \\'\\'\\'\\n        for char in word:\\n            if char not in mydict:\\n                mydict[char] = 1\\n            else:\\n                mydict[char] = mydict[char] + 1\\n        \\n        if len(mydict.keys())==1:  # if we have only one type of element (Ex: \\'aaaaa\\')\\n            return True\\n        \\n        freq = mode(list(mydict.values()))   # most common frequency\\n       \\n        \\'\\'\\' If we have each letter only once \\'\\'\\'\\n        if list(mydict.values()).count(1) == len(word):\\n            return True\\n\\n        \\n        for k,v in mydict.items():\\n            if v != freq:\\n                mydict[k]=mydict[k]-1       # if freq not equal decrease (Ex: aaabbcc)\\n                for k,v in mydict.items():  # it may be we need to increase the frequecy not decrease (Ex: \\'aabcc\\')\\n                    if v!=freq:\\n                        mydict[k]=mydict[k]+2\\n                        break\\n                break\\n                \\n        else:\\n            return False     # if all frequecy are equal and not 1\\n        \\n        for k,v in mydict.items():   # finally check after adjusting frequecy are we able to make all frequecnies equal\\n            if v != freq and v!=0:\\n                return False\\n        return True\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647503,
                "title": "100-faster-easy-to-understand",
                "content": "In this first we count frequency of all char and after that we are finding maximum and minimum frequency if there is any other frequency than these two then directly we wil print false\\notherwise we will count how many times maximum frequency is occuring and same for minimum frequency \\nNow if our max frequency is equal to min freq than we check that if frequency is ==1 than we can delete any one and if it is occuring only once that we will return true.\\nif min freq is ==1 and it is occuring only once than also we will return true\\nif max freq is not equal to min freq +1 or if occurance of maxi freq is more than 1 we will return false\\notherwise true;\\n```\\n        map<char,int>m;\\n        int maxi=0,l=INT_MAX;\\n        for(auto it:word)\\n        {\\n            m[it]++;\\n        }\\n        for(auto it:m)\\n        {\\n            l=min(l,it.second);\\n            maxi=max(maxi,it.second);\\n        }\\n        int c=0,x=0;\\n        for(auto it:m)\\n        {\\n            if(it.second==maxi)c++;\\n            else if(it.second==l)x++;\\n            else\\n                return false;\\n            \\n        }\\n        if(maxi==l)return l==1||c==1;\\n        if(l==1&&x==1)return true;\\n        if(maxi!=l+1||(c!=1))return false;\\n        \\n        \\n        return true;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        map<char,int>m;\\n        int maxi=0,l=INT_MAX;\\n        for(auto it:word)\\n        {\\n            m[it]++;\\n        }\\n        for(auto it:m)\\n        {\\n            l=min(l,it.second);\\n            maxi=max(maxi,it.second);\\n        }\\n        int c=0,x=0;\\n        for(auto it:m)\\n        {\\n            if(it.second==maxi)c++;\\n            else if(it.second==l)x++;\\n            else\\n                return false;\\n            \\n        }\\n        if(maxi==l)return l==1||c==1;\\n        if(l==1&&x==1)return true;\\n        if(maxi!=l+1||(c!=1))return false;\\n        \\n        \\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647502,
                "title": "o-n-2-using-brute-force-for-deleting-every-position",
                "content": "**Main Idea**:\\n+ Trying to delete every position \\n+ Checking the same occurs of every value \\n\\n**Code**:\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        h = {}\\n        for w in word:\\n            h[w] = h.get(w, 0) + 1\\n        \\n        ans = False\\n        for w in word:\\n            h1 = [h[i] if i!=w else h[i]-1 for i in h if i!=w or h[i]-1>0]\\n            if min(h1)==max(h1):\\n                ans = True\\n                break\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        h = {}\\n        for w in word:\\n            h[w] = h.get(w, 0) + 1\\n        \\n        ans = False\\n        for w in word:\\n            h1 = [h[i] if i!=w else h[i]-1 for i in h if i!=w or h[i]-1>0]\\n            if min(h1)==max(h1):\\n                ans = True\\n                break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647483,
                "title": "python-fastest-100-single-counter-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/812912583/) employs a single counter with subsequent checking of 4 frequency conditions. It demonstrated **37 ms runtime (100.00%)** and used **14.0 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        # [1] count letter frequencies\\n        freq = Counter(word)\\n        \\n        # [2] check several frequency conditions\\n        \\n        #     - for a single unique letter in the word\\n        if  len(freq.most_common()) == 1:\\n            return True\\n\\n        #     - for all frequencies being equal to 1\\n        if  freq.most_common()[0][1] == 1:\\n            return True\\n\\n        #     - for one most frequent element\\n        if  freq.most_common()[0][1] - freq.most_common()[1][1] == 1 \\\\\\n        and freq.most_common()[1][1] == freq.most_common()[-1][1]:\\n                return True\\n\\n        #     - for one less frequent element\\n        if  freq.most_common()[-2][1] - freq.most_common()[-1][1] == 1 \\\\\\n        and freq.most_common()[0][1] == freq.most_common()[-2][1]:\\n                return True\\n                \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        # [1] count letter frequencies\\n        freq = Counter(word)\\n        \\n        # [2] check several frequency conditions\\n        \\n        #     - for a single unique letter in the word\\n        if  len(freq.most_common()) == 1:\\n            return True\\n\\n        #     - for all frequencies being equal to 1\\n        if  freq.most_common()[0][1] == 1:\\n            return True\\n\\n        #     - for one most frequent element\\n        if  freq.most_common()[0][1] - freq.most_common()[1][1] == 1 \\\\\\n        and freq.most_common()[1][1] == freq.most_common()[-1][1]:\\n                return True\\n\\n        #     - for one less frequent element\\n        if  freq.most_common()[-2][1] - freq.most_common()[-1][1] == 1 \\\\\\n        and freq.most_common()[0][1] == freq.most_common()[-2][1]:\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647389,
                "title": "python-solution-an-easy-solution",
                "content": "```\\nclass Solution:\\n    def isequal(self, c):\\n        c = Counter(c)\\n        return len(list(set(list(c.values())))) == 1\\n\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if self.isequal(word[:i] + word[i + 1:]):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isequal(self, c):\\n        c = Counter(c)\\n        return len(list(set(list(c.values())))) == 1\\n\\n    def equalFrequency(self, word: str) -> bool:\\n        for i in range(len(word)):\\n            if self.isequal(word[:i] + word[i + 1:]):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647342,
                "title": "c-easy-to-understand",
                "content": "**PLS UPVOTE IF YOU LIKE , GOD BLESS ALL**\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int maxi=-1,ch=0,maxas=0;\\n        unordered_map<char,int>m;\\n        priority_queue<pair<int,char>>p;\\n        for(auto i : word){\\n        m[i]++;\\n            maxas=max(maxas,m[i]);   //to keep track of the max character.\\n        }\\n        for(auto [i,j]:m){\\n          p.push({j,i});      //priority_queue has been used to get most frequent character first.\\n          if(j==maxas)ch++;         //counting the frequency of max character\\n       }  \\n        if(m.size()-ch==1) return true;     //checking the edge case eg abbcc.\\n      maxi+=p.top().first;\\n        p.pop();\\n        if(maxi==0) maxi=1;\\n        while(!p.empty()){\\n            if(abs(maxi-p.top().first)>0)return false;   \\n            p.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int maxi=-1,ch=0,maxas=0;\\n        unordered_map<char,int>m;\\n        priority_queue<pair<int,char>>p;\\n        for(auto i : word){\\n        m[i]++;\\n            maxas=max(maxas,m[i]);   //to keep track of the max character.\\n        }\\n        for(auto [i,j]:m){\\n          p.push({j,i});      //priority_queue has been used to get most frequent character first.\\n          if(j==maxas)ch++;         //counting the frequency of max character\\n       }  \\n        if(m.size()-ch==1) return true;     //checking the edge case eg abbcc.\\n      maxi+=p.top().first;\\n        p.pop();\\n        if(maxi==0) maxi=1;\\n        while(!p.empty()){\\n            if(abs(maxi-p.top().first)>0)return false;   \\n            p.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647335,
                "title": "c-easy-peasy-lemon-squeezy",
                "content": "It\\'s easier to understand this way!\\nQ.after popping any element, if the frequency of elements in string is equal return 1.\\n-> we\\'ll iterate the string and pop i\\'th element and check if after popping ,the string has equal frequency of characters or not.\\n\\n\\tbool isEqual(string str, int i)\\n\\t{\\n\\t\\tstr.erase(i,1);  //erasing i\\'th element \\n\\t\\tunordered_map<char, int> m; \\n\\t\\t\\n\\t\\t//store frequency of character\\n\\t\\tfor (int i = 0; i < str.size(); i++)  m[str[i]]++;\\n\\t\\t\\n\\t\\t//if the occurence are different we return 0\\n\\t\\tfor (int i = 1; i < str.size(); i++)\\n\\t\\t\\tif (m[str[i]] != m[str[i-1]])  return 0;\\n\\n\\t\\treturn 1;\\n\\t}\\n\\tbool equalFrequency(string word) {\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t\\tif (isEqual(word, i)) return true;\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "It\\'s easier to understand this way!\\nQ.after popping any element, if the frequency of elements in string is equal return 1.\\n-> we\\'ll iterate the string and pop i\\'th element and check if after popping ,the string has equal frequency of characters or not.\\n\\n\\tbool isEqual(string str, int i)\\n\\t{\\n\\t\\tstr.erase(i,1);  //erasing i\\'th element \\n\\t\\tunordered_map<char, int> m; \\n\\t\\t\\n\\t\\t//store frequency of character\\n\\t\\tfor (int i = 0; i < str.size(); i++)  m[str[i]]++;\\n\\t\\t\\n\\t\\t//if the occurence are different we return 0\\n\\t\\tfor (int i = 1; i < str.size(); i++)\\n\\t\\t\\tif (m[str[i]] != m[str[i-1]])  return 0;\\n\\n\\t\\treturn 1;\\n\\t}\\n\\tbool equalFrequency(string word) {\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t\\tif (isEqual(word, i)) return true;\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2647323,
                "title": "kotlin-array-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val freq = IntArray(26)\\n        for (ch in word) {\\n            freq[ch - \\'a\\']++\\n        }\\n        var freq1: Int = -1\\n        var count1: Int = 1\\n        var freq2: Int = -1\\n        var count2: Int = 1\\n        for (item in freq) {\\n            if (item > 0) {\\n                when {\\n                    freq1 == -1 -> freq1 = item\\n                    freq1 == item -> count1++\\n                    freq2 == -1 -> freq2 = item\\n                    freq2 == item -> count2++\\n                    else -> return false\\n                }\\n            }\\n        }\\n        if (freq1 > freq2 && freq2 != -1) {\\n            val temp = freq1\\n            freq1 = freq2\\n            freq2 = temp\\n        }\\n        /**\\n         * 4 scenarios when true:\\n         * 1. n 0 0\\n         * 2. 1 1 1\\n         * 3. 1 n n\\n         * 4. n n n+1\\n         */\\n        return count1 == 1 && freq2 == -1\\n            || freq1 == 1 && freq2 == -1\\n            || freq1 == 1 && count1 == 1 && freq2 != -1\\n            || freq1 + 1 == freq2 && count2 == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun equalFrequency(word: String): Boolean {\\n        val freq = IntArray(26)\\n        for (ch in word) {\\n            freq[ch - \\'a\\']++\\n        }\\n        var freq1: Int = -1\\n        var count1: Int = 1\\n        var freq2: Int = -1\\n        var count2: Int = 1\\n        for (item in freq) {\\n            if (item > 0) {\\n                when {\\n                    freq1 == -1 -> freq1 = item\\n                    freq1 == item -> count1++\\n                    freq2 == -1 -> freq2 = item\\n                    freq2 == item -> count2++\\n                    else -> return false\\n                }\\n            }\\n        }\\n        if (freq1 > freq2 && freq2 != -1) {\\n            val temp = freq1\\n            freq1 = freq2\\n            freq2 = temp\\n        }\\n        /**\\n         * 4 scenarios when true:\\n         * 1. n 0 0\\n         * 2. 1 1 1\\n         * 3. 1 n n\\n         * 4. n n n+1\\n         */\\n        return count1 == 1 && freq2 == -1\\n            || freq1 == 1 && freq2 == -1\\n            || freq1 == 1 && count1 == 1 && freq2 != -1\\n            || freq1 + 1 == freq2 && count2 == 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647293,
                "title": "funny-how-our-brain-works-always-check-constraints",
                "content": "Our brain always try to find the optmial solution. But atleast in the contest it was straightup BRUTE_FORCE just remove 1 char for every character in the given string. Just LOOK AT CONSTRAINTS!!!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2647195,
                "title": "i-tried-it-but-couldn-t-get-it-passed",
                "content": "![image](https://assets.leetcode.com/users/images/86b0290b-fc54-421a-8f71-c5dcfe92ea61_1664644461.092479.png)\\n\\n1.  I mapped char to their No.o occurences in the string word\\n2.  then i calculated the minimum and maximum occurences of the char\\n3.  i also looked if the occurences of all the char is equal to 1 or not \\n4.  if it occurences == 1 for all char OR if differences between maximum and minimum is 1 then return true \\n5. else false\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/86b0290b-fc54-421a-8f71-c5dcfe92ea61_1664644461.092479.png)\\n\\n1.  I mapped char to their No.o occurences in the string word\\n2.  then i calculated the minimum and maximum occurences of the char\\n3.  i also looked if the occurences of all the char is equal to 1 or not \\n4.  if it occurences == 1 for all char OR if differences between maximum and minimum is 1 then return true \\n5. else false\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2647160,
                "title": "c-2-maps-explanation",
                "content": "**Approach:**\\n\\n* we will consider 2 maps\\n* mp1 to store the characters and there respective freq\\n* mp2 to store the freq_value and the number of time this freq occured\\n* now\\n* if ```(mp2.size() > 2) ```\\n\\t* it means there are more than 2 distinct freq\\n\\t* so we will return false\\n\\t* because we can never get a unique freq by just one operation\\n* so we can handle at most 2 different freq\\n* we use ```map``` in mp2 instead of ```unordered_map``` to store the freq in increasing order\\n* if we have a single freq only i.e ```mp2.size()==1```\\n\\t* Then we can get true in two cases\\n\\t\\t* either all the characters are same i.e. ```mp1.size()==1```\\n\\t\\t\\t* \"aaaa\"\\n\\t\\t* or all the characters are different i.e. ```f1==1```\\n\\t\\t\\t* \"abcdefg\"\\n* Now for only 2 different freq,\\n\\t* if we have a the min_freq i.e f1 =1 and it has appeared only 1 time \\n\\t\\t* i.e. word = \"abbbcccdddeee\" of this type, here\\n\\t\\t\\t* f1=1,n1=1, f2=3,n2=4\\n\\t\\t\\t* so we return true as we can delete this char and get a unique freq f2\\n\\t* if we have f2-f1=1\\n\\t\\t* i.e the freq differ by 1 only\\n\\t\\t* so we can dec f2 to f1 by deleting one char\\n\\t\\t* but this is possible if f2 has occured only one time i.e n2 must be 1\\n\\t\\t* why?\\n\\t\\t\\t* for \"aabbbccc\", \\n\\t\\t\\t\\t* f1 = 2, n1=1, f2=3, n2=2\\n\\t\\t\\t\\t* you can\\'t get a unique freq\\n\\t\\t\\t* but for \"aabbb\"\\n\\t\\t\\t\\t* f1=2,n1=1,f2=3,n2=1\\n\\t\\t\\t\\t* you can get \"aabb\" all with freq=2=f1\\n* for every other case you can see that we will get false\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool equalFrequency(string word)\\n    {\\n        unordered_map<char, int> mp1; // {char,freq}\\n        map<int, int> mp2;            //{freq_value,number of times this freq occured}\\n        for (char c : word)\\n            mp1[c]++;\\n\\n        for (auto &x : mp1)\\n            mp2[x.second]++;\\n\\n        if (mp2.size() > 2) // if we have more than 2 diff freq\\n            return false;\\n        map<int, int>::iterator it1 = mp2.begin(); // iterator at 1st freq\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++; // iterator at 2nd freq\\n\\n        int f1 = it1->first;  // 1st freq value\\n        int n1 = it1->second; // number of times 1st freq occured\\n        int f2 = it2->first;  // 2nd freq value\\n        int n2 = it2->second; // number of times 2nd freq occured\\n\\n        if (mp2.size() == 1)\\n        {\\n            if (mp1.size() == 1 || f1 == 1)\\n                return true;\\n            return false;\\n        }\\n\\n        if (f1 == 1 && n1 == 1)\\n            return true;\\n        if ((f1 == f2 - 1) && n2 == 1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```(mp2.size() > 2) ```\n```map```\n```unordered_map```\n```mp2.size()==1```\n```mp1.size()==1```\n```f1==1```\n```\\nclass Solution\\n{\\npublic:\\n    bool equalFrequency(string word)\\n    {\\n        unordered_map<char, int> mp1; // {char,freq}\\n        map<int, int> mp2;            //{freq_value,number of times this freq occured}\\n        for (char c : word)\\n            mp1[c]++;\\n\\n        for (auto &x : mp1)\\n            mp2[x.second]++;\\n\\n        if (mp2.size() > 2) // if we have more than 2 diff freq\\n            return false;\\n        map<int, int>::iterator it1 = mp2.begin(); // iterator at 1st freq\\n        map<int, int>::iterator it2 = mp2.begin();\\n        it2++; // iterator at 2nd freq\\n\\n        int f1 = it1->first;  // 1st freq value\\n        int n1 = it1->second; // number of times 1st freq occured\\n        int f2 = it2->first;  // 2nd freq value\\n        int n2 = it2->second; // number of times 2nd freq occured\\n\\n        if (mp2.size() == 1)\\n        {\\n            if (mp1.size() == 1 || f1 == 1)\\n                return true;\\n            return false;\\n        }\\n\\n        if (f1 == 1 && n1 == 1)\\n            return true;\\n        if ((f1 == f2 - 1) && n2 == 1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647112,
                "title": "c-0ms-solution-100-fast",
                "content": "```\\nbool allSame(vector<int>& feq){\\n        int prev=0;\\n        \\n        for(int i=0; i<26; i++)\\n            if(feq[i] != 0){\\n                prev = feq[i];\\n                break;\\n            }\\n        \\n        for(int i=0; i<26; i++)\\n            if(feq[i] != 0){\\n                if(feq[i] != prev)\\n                    return false;\\n            }\\n        \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) {        \\n        vector<int> feq(26, 0);\\n\\n        for(char &ch: word)\\n            feq[ch-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++){\\n            if(feq[i] > 0){\\n                feq[i]--;\\n                \\n                if(allSame(feq))\\n                    return true;\\n                \\n                feq[i]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool allSame(vector<int>& feq){\\n        int prev=0;\\n        \\n        for(int i=0; i<26; i++)\\n            if(feq[i] != 0){\\n                prev = feq[i];\\n                break;\\n            }\\n        \\n        for(int i=0; i<26; i++)\\n            if(feq[i] != 0){\\n                if(feq[i] != prev)\\n                    return false;\\n            }\\n        \\n        return true;\\n    }\\n    \\n    bool equalFrequency(string word) {        \\n        vector<int> feq(26, 0);\\n\\n        for(char &ch: word)\\n            feq[ch-\\'a\\']++;\\n        \\n        for(int i=0; i<26; i++){\\n            if(feq[i] > 0){\\n                feq[i]--;\\n                \\n                if(allSame(feq))\\n                    return true;\\n                \\n                feq[i]++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2647096,
                "title": "python-100-faster-solution",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        count = { }\\n\\t\\t# if less than 2 is length then answer will be true as we can delete 1 always and keeping frequency same. \\n        if len(word) <= 2 : \\n            return True \\n        #making the count of all the characters using dictionary \\n        for i in word : \\n            if i not in count  : \\n                count[i] = 1 \\n            else : \\n                count[i] += 1\\n        if len(count) == 1 : \\n            return True \\n\\t\\t#list of the count of characters this will tell the varity of count \\'aaaa\\' - 4 and \\'bbb\\' - 3 and \\'cc\\' - 2\\n        val = list(count.values( ) ) \\n        maxi = max(val)\\n        mini = min (val) \\n\\t\\t# taking max and min as to find the difference of characters \\n        if mini == 1 and maxi == 1 :  # if min and max is 1 means we can delete 1 keeping frequency same.\\n            return True \\n        if maxi - mini == 0  :  # means there is no need of deletion \\n            return False\\n        if maxi - mini > 1  :  # if character diff is more than 1 means more than 1 character need to be deleted. \\n            return False \\n        elif maxi - mini == 1 :  \\n            if val.count(mini) > 1 and val.count(maxi) > 1 : # means more element need to be deleted. \\n                return False \\n            return True \\n        else : return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        \\n        count = { }\\n\\t\\t# if less than 2 is length then answer will be true as we can delete 1 always and keeping frequency same. \\n        if len(word) <= 2 : \\n            return True \\n        #making the count of all the characters using dictionary \\n        for i in word : \\n            if i not in count  : \\n                count[i] = 1 \\n            else : \\n                count[i] += 1\\n        if len(count) == 1 : \\n            return True \\n\\t\\t#list of the count of characters this will tell the varity of count \\'aaaa\\' - 4 and \\'bbb\\' - 3 and \\'cc\\' - 2\\n        val = list(count.values( ) ) \\n        maxi = max(val)\\n        mini = min (val) \\n\\t\\t# taking max and min as to find the difference of characters \\n        if mini == 1 and maxi == 1 :  # if min and max is 1 means we can delete 1 keeping frequency same.\\n            return True \\n        if maxi - mini == 0  :  # means there is no need of deletion \\n            return False\\n        if maxi - mini > 1  :  # if character diff is more than 1 means more than 1 character need to be deleted. \\n            return False \\n        elif maxi - mini == 1 :  \\n            if val.count(mini) > 1 and val.count(maxi) > 1 : # means more element need to be deleted. \\n                return False \\n            return True \\n        else : return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647046,
                "title": "c-easiest-100-faster-than-others",
                "content": "![image](https://assets.leetcode.com/users/images/bb0e5718-09b3-46b8-8517-f7b0c3f28682_1664643323.007382.png)\\n\\n\"\"\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        \\n        char C = \\'C\\';\\n        \\n        for(int i = 0;i<word.size(); ++i)\\n        {   \\n            string temp = word;\\n            temp[i] = C;\\n            vector<int> v(26,0);\\n\\n            \\n            for(int j = 0;j<temp.size(); ++j)\\n            {   \\n                if(temp[j]!=C)v[temp[j]-97]++;\\n            }\\n            set<int> s;\\n            \\n            for(int i = 0;i<v.size(); ++i)\\n            if(v[i]!=0)s.insert(v[i]);\\n            \\n            if(s.size()==1)return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n\"\"",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        \\n        char C = \\'C\\';\\n        \\n        for(int i = 0;i<word.size(); ++i)\\n        {   \\n            string temp = word;\\n            temp[i] = C;\\n            vector<int> v(26,0);\\n\\n            \\n            for(int j = 0;j<temp.size(); ++j)\\n            {   \\n                if(temp[j]!=C)v[temp[j]-97]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2647008,
                "title": "c-easy-to-understand",
                "content": "```c++\\nclass Solution\\n{\\npublic:\\n    bool all_same(vector<int> &M)\\n    {\\n        int val;\\n\\n        for (int n : M)\\n            if (n > 0)\\n            {\\n                val = n;\\n                break;\\n            }\\n\\n        for (int i = 0; i < M.size(); i++)\\n            if (M[i] > 0 && M[i] != val)\\n                return false;\\n\\n        return true;\\n    }\\n\\n    bool equalFrequency(string word)\\n    {\\n        vector<int> count(26);\\n\\n        for (char c : word)\\n            count[c - \\'a\\']++;\\n\\n        for (char i = 0; i < count.size(); i++)\\n            if (count[i] > 0)\\n            {\\n                count[i]--;\\n\\n                if (all_same(count))\\n                    return true;\\n\\n                count[i]++;\\n            }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution\\n{\\npublic:\\n    bool all_same(vector<int> &M)\\n    {\\n        int val;\\n\\n        for (int n : M)\\n            if (n > 0)\\n            {\\n                val = n;\\n                break;\\n            }\\n\\n        for (int i = 0; i < M.size(); i++)\\n            if (M[i] > 0 && M[i] != val)\\n                return false;\\n\\n        return true;\\n    }\\n\\n    bool equalFrequency(string word)\\n    {\\n        vector<int> count(26);\\n\\n        for (char c : word)\\n            count[c - \\'a\\']++;\\n\\n        for (char i = 0; i < count.size(); i++)\\n            if (count[i] > 0)\\n            {\\n                count[i]--;\\n\\n                if (all_same(count))\\n                    return true;\\n\\n                count[i]++;\\n            }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646959,
                "title": "very-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n        unordered_map<char,int> map;\\n        for(auto &x: word)\\n        {\\n            map[x]++;\\n        }\\n        for(auto &x: word)\\n        {\\n            map[x]--;\\n            if(map[x] == 0)map.erase(x);\\n            set<int> s;\\n            for(auto &x: map)\\n            {\\n                s.insert(x.second);\\n            }\\n            if(s.size() == 1)return true;\\n            map[x]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) \\n    {\\n        unordered_map<char,int> map;\\n        for(auto &x: word)\\n        {\\n            map[x]++;\\n        }\\n        for(auto &x: word)\\n        {\\n            map[x]--;\\n            if(map[x] == 0)map.erase(x);\\n            set<int> s;\\n            for(auto &x: map)\\n            {\\n                s.insert(x.second);\\n            }\\n            if(s.size() == 1)return true;\\n            map[x]++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646952,
                "title": "easy-btw-simple-and-elegant-c-solution-map",
                "content": "#APPROACH 1: BruteForce\\n\\n//we\\'ll iterate the string and pop i\\'th element, and  check if  after poping the string has equal frequency of characters or not.\\n\\n\\tbool isEqual(string str, int i)\\n\\t{\\n\\t\\tstr.erase(i,1);  //erasing i\\'th element \\n\\t\\tunordered_map<char, int> m; \\n\\t\\t\\n\\t\\t//store frequency of character\\n\\t\\tfor (int i = 0; i < str.size(); i++)  m[str[i]]++;\\n\\t\\t\\n\\t\\t//if the occurence are different we return 0\\n\\t\\tfor (int i = 1; i < str.size(); i++)\\n\\t\\t\\tif (m[str[i]] != m[str[i-1]])  return 0;\\n\\n\\t\\treturn 1;\\n\\t}\\n\\tbool equalFrequency(string word) {\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t\\tif (isEqual(word, i)) return true;\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "#APPROACH 1: BruteForce\\n\\n//we\\'ll iterate the string and pop i\\'th element, and  check if  after poping the string has equal frequency of characters or not.\\n\\n\\tbool isEqual(string str, int i)\\n\\t{\\n\\t\\tstr.erase(i,1);  //erasing i\\'th element \\n\\t\\tunordered_map<char, int> m; \\n\\t\\t\\n\\t\\t//store frequency of character\\n\\t\\tfor (int i = 0; i < str.size(); i++)  m[str[i]]++;\\n\\t\\t\\n\\t\\t//if the occurence are different we return 0\\n\\t\\tfor (int i = 1; i < str.size(); i++)\\n\\t\\t\\tif (m[str[i]] != m[str[i-1]])  return 0;\\n\\n\\t\\treturn 1;\\n\\t}\\n\\tbool equalFrequency(string word) {\\n\\t\\tfor (int i = 0; i < word.size(); i++)\\n\\t\\t\\tif (isEqual(word, i)) return true;\\t\\t\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2646900,
                "title": "o-n-2-works-for-given-constraints-simple-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        \\n              int n = word.size();\\n        bool ans;\\n\\n       \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n             map<char,int>mp;\\n            for(int j=0;j<n;j++)\\n                {\\n                    if(j!=i)\\n                        {\\n                            mp[word[j]]++;\\n                        }\\n                }\\n                \\n                set<int>freq;\\n            \\n                for(auto &i:mp)\\n                {\\n                    freq.insert(i.second);\\n                }\\n            \\n                if(freq.size()==1)\\n                return true;\\n        }\\n        \\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        \\n              int n = word.size();\\n        bool ans;\\n\\n       \\n\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n             map<char,int>mp;\\n            for(int j=0;j<n;j++)\\n                {\\n                    if(j!=i)\\n                        {\\n                            mp[word[j]]++;\\n                        }\\n                }\\n                \\n                set<int>freq;\\n            \\n                for(auto &i:mp)\\n                {\\n                    freq.insert(i.second);\\n                }\\n            \\n                if(freq.size()==1)\\n                return true;\\n        }\\n        \\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646871,
                "title": "python-frequency-counter",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        freq = Counter(word).values()\\n        return (len(freq) == 1 or\\n                min(freq) == max(freq) == 1 or \\n                (min(freq) == max(freq) - 1 and (\\n                 len(word) == min(freq) * len(freq) + 1 or\\n                 len(word) == max(freq) * len(freq) - 1)\\n                )\\n               )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        freq = Counter(word).values()\\n        return (len(freq) == 1 or\\n                min(freq) == max(freq) == 1 or \\n                (min(freq) == max(freq) - 1 and (\\n                 len(word) == min(freq) * len(freq) + 1 or\\n                 len(word) == max(freq) * len(freq) - 1)\\n                )\\n               )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646869,
                "title": "c-understandable-for-beginners-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int freq[26] = {0};\\n        int maxFreq = 0;\\n        for(char c : word){\\n            freq[c - \\'a\\']++;\\n            maxFreq = max(maxFreq, freq[c - \\'a\\']);\\n        }\\n        int maxCount = 0;\\n        int maxMinusOneCount = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            if(freq[i] == 0) continue;\\n            if(freq[i] == maxFreq) maxCount++;\\n            if((freq[i] == maxFreq - 1)) maxMinusOneCount++;\\n            if(freq[i] < maxFreq - 1) return false;\\n\\n        }\\n        return maxMinusOneCount == 1 || maxCount == 1 || (maxMinusOneCount == 0 && maxFreq == 1);\\n    \\n    }\\n\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool equalFrequency(string word) {\\n        int freq[26] = {0};\\n        int maxFreq = 0;\\n        for(char c : word){\\n            freq[c - \\'a\\']++;\\n            maxFreq = max(maxFreq, freq[c - \\'a\\']);\\n        }\\n        int maxCount = 0;\\n        int maxMinusOneCount = 0;\\n\\n        for(int i = 0; i < 26; i++) {\\n            if(freq[i] == 0) continue;\\n            if(freq[i] == maxFreq) maxCount++;\\n            if((freq[i] == maxFreq - 1)) maxMinusOneCount++;\\n            if(freq[i] < maxFreq - 1) return false;\\n\\n        }\\n        return maxMinusOneCount == 1 || maxCount == 1 || (maxMinusOneCount == 0 && maxFreq == 1);\\n    \\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646862,
                "title": "most-ugliest-java-solution-not-easy",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int n = word.length();\\n     HashMap<Character, Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(hm.containsKey(word.charAt(i)))\\n                hm.put(word.charAt(i) , hm.get(word.charAt(i)) +  1);\\n            else\\n                hm.put(word.charAt(i) , 1);\\n        }\\n        if(hm.size() ==1) return true;\\n        ArrayList<Integer> ls = new ArrayList<>();\\n        int min = 0;\\n        Set<Integer> st = new HashSet<>();\\n        for(var v : hm.values())\\n        {   if(v==1) min++; \\n            ls.add(v);\\n         st.add(v);\\n        }\\n        Collections.sort(ls);\\n        System.out.println(ls);\\n        int f  = ls.get(0);\\n        int l = ls.get(ls.size()-1);\\n        if( f == l ){\\n            if(f == 1) return true;\\n            return  false;\\n        }\\n        else if(l-f == 1){\\n            if(f == 1 && (min == 1 || min == n-1)){\\n                 return true;\\n            }else{\\n                if(l != ls.get(ls.size()-2) )return true;\\n                 return false;\\n                \\n            }\\n        }\\n        else{\\n            if(st.size() == 2 && min == 1) return true;\\n            return false;\\n        }\\n        \\n        //return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        int n = word.length();\\n     HashMap<Character, Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(hm.containsKey(word.charAt(i)))\\n                hm.put(word.charAt(i) , hm.get(word.charAt(i)) +  1);\\n            else\\n                hm.put(word.charAt(i) , 1);\\n        }\\n        if(hm.size() ==1) return true;\\n        ArrayList<Integer> ls = new ArrayList<>();\\n        int min = 0;\\n        Set<Integer> st = new HashSet<>();\\n        for(var v : hm.values())\\n        {   if(v==1) min++; \\n            ls.add(v);\\n         st.add(v);\\n        }\\n        Collections.sort(ls);\\n        System.out.println(ls);\\n        int f  = ls.get(0);\\n        int l = ls.get(ls.size()-1);\\n        if( f == l ){\\n            if(f == 1) return true;\\n            return  false;\\n        }\\n        else if(l-f == 1){\\n            if(f == 1 && (min == 1 || min == n-1)){\\n                 return true;\\n            }else{\\n                if(l != ls.get(ls.size()-2) )return true;\\n                 return false;\\n                \\n            }\\n        }\\n        else{\\n            if(st.size() == 2 && min == 1) return true;\\n            return false;\\n        }\\n        \\n        //return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646850,
                "title": "python-sort-counter-values",
                "content": "```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        values = sorted(Counter(word).values())\\n\\n        def test(v, i):\\n            v[i] -= 1\\n            if v[i] == 0:\\n                del v[i]\\n\\n            return len(set(v)) == 1\\n\\n        return test(values[:], 0) or test(values[:], len(values) - 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        values = sorted(Counter(word).values())\\n\\n        def test(v, i):\\n            v[i] -= 1\\n            if v[i] == 0:\\n                del v[i]\\n\\n            return len(set(v)) == 1\\n\\n        return test(values[:], 0) or test(values[:], len(values) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646803,
                "title": "java-remove-each-character-one-by-one",
                "content": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        for(int i = 0; i < word.length(); i++){\\n            Map<Character, Integer> map = new HashMap<>();\\n            for(int j = 0; j < word.length(); j++){\\n\\t\\t\\t\\t// count frequency of all characters in word, skipping the character at the ith index\\n                if(j != i) map.put(word.charAt(j), map.getOrDefault(word.charAt(j), 0) + 1);\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            set.addAll(map.values());\\n            if(set.size() == 1) return true; // if only 1 frequency, exists return true\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean equalFrequency(String word) {\\n        for(int i = 0; i < word.length(); i++){\\n            Map<Character, Integer> map = new HashMap<>();\\n            for(int j = 0; j < word.length(); j++){\\n\\t\\t\\t\\t// count frequency of all characters in word, skipping the character at the ith index\\n                if(j != i) map.put(word.charAt(j), map.getOrDefault(word.charAt(j), 0) + 1);\\n            }\\n            Set<Integer> set = new HashSet<>();\\n            set.addAll(map.values());\\n            if(set.size() == 1) return true; // if only 1 frequency, exists return true\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646791,
                "title": "simple-python-solution-covering-all-edge-cases",
                "content": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        wordcount = Counter(word)\\n        freqcount = Counter(wordcount.values())\\n        \\n        # scenario - aaabbbbccccc\\n        if len(freqcount.keys()) > 2: return False      \\n        \\n        # scenario - abcdef\\n        if len(freqcount.keys()) == 1 and 1 in freqcount: return True   \\n\\n        # scenario - aaaaab\\n        if 1 in freqcount and freqcount[1] == 1: return True\\n        \\n        # scenario - aaaaaaaaa\\n        if len(freqcount.keys()) == 1 and list(freqcount.values())[0] == 1: return True \\n        \\n        # scenario - aabbccc\\n        min_freqcount, max_freqcount = min(freqcount), max(freqcount)\\n        if max_freqcount == min_freqcount + 1 and freqcount[max_freqcount] == 1: return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        wordcount = Counter(word)\\n        freqcount = Counter(wordcount.values())\\n        \\n        # scenario - aaabbbbccccc\\n        if len(freqcount.keys()) > 2: return False      \\n        \\n        # scenario - abcdef\\n        if len(freqcount.keys()) == 1 and 1 in freqcount: return True   \\n\\n        # scenario - aaaaab\\n        if 1 in freqcount and freqcount[1] == 1: return True\\n        \\n        # scenario - aaaaaaaaa\\n        if len(freqcount.keys()) == 1 and list(freqcount.values())[0] == 1: return True \\n        \\n        # scenario - aabbccc\\n        min_freqcount, max_freqcount = min(freqcount), max(freqcount)\\n        if max_freqcount == min_freqcount + 1 and freqcount[max_freqcount] == 1: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646759,
                "title": "felt-so-dumb",
                "content": "Couldn\\'t even solve an easy problem, man feeling so dumb.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2646752,
                "title": "faster-100-c-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool equalFrequency(string word) \\n\\t\\t{\\n\\t\\t\\tint n = word.size();\\n\\t\\t\\tvector<int> freq(26, 0);\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[word[i] - \\'a\\']++;\\n\\t\\t\\t\\tif(freq[word[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\td++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\tbool f = 0;\\n\\t\\t\\tfor(int i = 0 ; i < 26 ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tf = 1;\\n\\t\\t\\t\\tfreq[i]--;\\n\\t\\t\\t\\tset<int>st;\\n\\t\\t\\t\\tfor(int j = 0 ; j < 26 ; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(freq[j])\\n\\t\\t\\t\\t\\t\\tst.insert(freq[j]);    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(st.size() == 1)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t\\tfreq[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool equalFrequency(string word) \\n\\t\\t{\\n\\t\\t\\tint n = word.size();\\n\\t\\t\\tvector<int> freq(26, 0);\\n\\t\\t\\tint d = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfreq[word[i] - \\'a\\']++;\\n\\t\\t\\t\\tif(freq[word[i] - \\'a\\'] == 1)\\n\\t\\t\\t\\t\\td++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2646748,
                "title": "easy-to-understand",
                "content": "First of all store the frequency of every character in m\\nthen store the frequency\\'s frequency(bit tricky) eg: a is occuring 2 times b is occuring 2 times and c is occuring 2 times then store m1[2] = 3;\\nlen(m1) cannot be more than 2\\nstore max frequency and min frequency and check the conditions.\\n```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        m = {}\\n        flag = True\\n        for i in word:\\n            if i in m:\\n                m[i]+=1 \\n            else:\\n                m[i]=1\\n        m1 = {}\\n        for key,val in m.items():\\n            if m[key] in m1:\\n                m1[m[key]]+=1\\n            else:\\n                m1[m[key]] = 1\\n        if len(m1)>2:\\n            return False\\n        maxi = -sys.maxsize\\n        mini = sys.maxsize\\n        for key,val in m1.items():\\n            maxi = max(maxi,key)\\n            mini = min(mini,key)\\n        if len(m1)==1 and maxi==1: #eg: abcd\\n            return True\\n        if (maxi==mini and len(m1)==1 and m1[maxi]==1): #eg: aaaa\\n            return True\\n        if maxi-mini==1 and (m1[maxi]==1 or m1[mini]==1): #remaining all\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalFrequency(self, word: str) -> bool:\\n        m = {}\\n        flag = True\\n        for i in word:\\n            if i in m:\\n                m[i]+=1 \\n            else:\\n                m[i]=1\\n        m1 = {}\\n        for key,val in m.items():\\n            if m[key] in m1:\\n                m1[m[key]]+=1\\n            else:\\n                m1[m[key]] = 1\\n        if len(m1)>2:\\n            return False\\n        maxi = -sys.maxsize\\n        mini = sys.maxsize\\n        for key,val in m1.items():\\n            maxi = max(maxi,key)\\n            mini = min(mini,key)\\n        if len(m1)==1 and maxi==1: #eg: abcd\\n            return True\\n        if (maxi==mini and len(m1)==1 and m1[maxi]==1): #eg: aaaa\\n            return True\\n        if maxi-mini==1 and (m1[maxi]==1 or m1[mini]==1): #remaining all\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1626428,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1783072,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626246,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1694700,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1625852,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1822702,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1627312,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1798676,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1721518,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626101,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626428,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1783072,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626246,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1694700,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1625852,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1822702,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1627312,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1798676,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1721518,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626101,
                "content": [
                    {
                        "username": "Sarthak20574",
                        "content": "yes it is easy, \"easily the most frustrating problem on leetcode\"\nand the test cases"
                    },
                    {
                        "username": "amrit6239",
                        "content": "[@jaiyadav](/jaiyadav) if the letters in the word already have same frequency then remove any letter from the word it would become like this \"ac\" as the letter \"a\" and \"c\" has frequency of 1 so the  output is true"
                    },
                    {
                        "username": "qleoz12",
                        "content": "[@jaiyadav](/jaiyadav) how do you find this becouse for me the response is false not true"
                    },
                    {
                        "username": "not_a_koder",
                        "content": "[@jaiyadav](/jaiyadav) If you see here, by removing any random index ( letter) your word still has equal number of each letter. Hope that answers your questions."
                    },
                    {
                        "username": "CoderN-P",
                        "content": "[@jaiyadav](/jaiyadav) Because if you remove 1 occurrence of any letter in \"bac\" you will get either \"ac\", \"ba\", \"ac\", or \"bc\" which all have even occurrences for all characters."
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Can you please explain this...\\nWhy this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "Sivarama_Krishnan_Venktrayan",
                        "content": "```\\nError : Hard problem is listed as Easy problem.\\n```"
                    },
                    {
                        "username": "jhriverasa",
                        "content": "Not hard, just annoying af xd\\n"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "Not _that_ hard, but an absolute pain in the ass.  It's especially annoying because it _looks_ easy."
                    },
                    {
                        "username": "bobsingh149",
                        "content": "If u brute force then no need to consider any edge cases "
                    },
                    {
                        "username": "Odisseo76",
                        "content": "I don\\'t understand why case \"abbcc\" is expected to be true. For me it\\'s false. Any idea?"
                    },
                    {
                        "username": "user3324vB",
                        "content": "If a is removed  then bb and cc would have equal frequency"
                    },
                    {
                        "username": "nivasreddy",
                        "content": "when we remove a then it becomes \"bbcc\" which is equal and we are deleting only one letter so condition also satisfies.    so it is showing true"
                    },
                    {
                        "username": "Odisseo76",
                        "content": "[@QingjiaTsang](/QingjiaTsang) yes, you are rigth, I also found it. Thank you!"
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "f! I knew it! let\\'s delete the \\'a\\', then it return true..."
                    },
                    {
                        "username": "QingjiaTsang",
                        "content": "same here and  why there\\'s nobody questioning this tho."
                    },
                    {
                        "username": "Woors",
                        "content": "bloody easy"
                    },
                    {
                        "username": "roderik",
                        "content": "I spent most time of the contest trying to solve this one \\uD83D\\uDE02, until I got an error from one of the hidden test cases, bloody easy indeed"
                    },
                    {
                        "username": "CODEX47",
                        "content": "Then please post a solution with explanation man."
                    },
                    {
                        "username": "daring-calf",
                        "content": "I\\'m literally crying while doing this."
                    },
                    {
                        "username": "Vhalen_G",
                        "content": "idk why this problem is easy"
                    },
                    {
                        "username": "Finesse",
                        "content": "Because brute force works very well here"
                    },
                    {
                        "username": "bikcrum",
                        "content": "King of edge cases!"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Why this testcase is giving true?????????\\ninput\\nword =\\n\"bac\"\\nOutput\\nfalse\\nExpected\\ntrue"
                    },
                    {
                        "username": "saibhagyaram",
                        "content": "[@sibinandhan52](/sibinandhan52) even though removal of any random character from the word doesn\\'t effect the frequency of any character. So,that it is true...."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "[@sibinandhan52](/sibinandhan52)  Even after one elimination the frequency remain same."
                    },
                    {
                        "username": "c4lb33",
                        "content": "[@sibinandhan52](/sibinandhan52) [@sibinandhan52](/sibinandhan52) When we remove any one of b,a,c we get either (b,a), (a,c), or (b,c) which are all  strings with letters with same frequency"
                    },
                    {
                        "username": "rumit2k23",
                        "content": "[@_blanker_](/_blanker_)  not understand can you please expline  more about this test case? "
                    },
                    {
                        "username": "_blanker_",
                        "content": "[@sibinandhan52](/sibinandhan52) cause it\\'s gonna be ba, so occurrences will be b:1 and a:1"
                    },
                    {
                        "username": "sibinandhan52",
                        "content": "Can someone explain this....."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey @lee215 please post a concise solution for this problem as well. Thank you."
                    }
                ]
            },
            {
                "id": 1626245,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1994501,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1931681,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1930586,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1905443,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1880749,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1626290,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 2017261,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1898403,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1807994,
                "content": [
                    {
                        "username": "bobsingh149",
                        "content": "It is easy if u just brute force it "
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "You : Easy\\nLeetcode : Let\\'s bring you down"
                    },
                    {
                        "username": "geekyshark",
                        "content": "if you manage to solve this problem in less than 30 mins, you are a legend my friend"
                    },
                    {
                        "username": "ankit_borbora",
                        "content": "This is the worst problem in the whole internet. Would have given 1000 dislikes if i could."
                    },
                    {
                        "username": "baround",
                        "content": "An interesting problem. Most people\\'s mind will probably go to counting frequency of each letter. My hint, if you need one, would be to count the frequency of each frequencies, and see what we can do with those.\\n\\nOf course, another hint would be to look at the solution after you spend like an hour with a problem :). Have fun!"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "problem\\'s got 99999 edge cases"
                    },
                    {
                        "username": "TwilightButcher",
                        "content": "Easy?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "Easy-peasy... 25 mins instead of my usual 2-3 mins spend on an average easy task"
                    },
                    {
                        "username": "java_run",
                        "content": "This problem is ACTUALLY  easy , no joke !\\nJust use a complete brute force and freq array ,\\n\\nBAMM , and it is solved ! \\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2423.%20Remove%20Letter%20To%20Equalize%20Frequency.CPP\\nALL LEETCODE SOLUTION IN C++,\\n if you find it helpful PLEASE LEAVE A STAR."
                    }
                ]
            },
            {
                "id": 1735889,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 2057444,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 2054226,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 2053033,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 2036317,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 2035852,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 1957013,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 1951628,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 1893945,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 1881316,
                "content": [
                    {
                        "username": "user0181Tj",
                        "content": "So, so, so, so many cases.\\nThis is the most frustrating \\'easy\\' I\\'ve done."
                    },
                    {
                        "username": "ajjha7203",
                        "content": "I don\\'t think it was an easy problem!"
                    },
                    {
                        "username": "pk_87",
                        "content": "dam this easy is hardddddd"
                    },
                    {
                        "username": "shaza_0",
                        "content": "I am getting an error for the test case word=\"bac\", the output should be false, but it is giving it as true. Any idea why the test case bac returns true?"
                    },
                    {
                        "username": "rakshapadiyar",
                        "content": "For the testcase \"bac\", the expected output is true.\\nThis is because, if you remove either \\'a\\' or \\'b\\' or \\'c\\' from the String \"bac\", the frequency of all the remaining characters will be 1.\\n\\nIf you remove one character \\'a\\', the String becomes \"bc\" => frequency(b) = 1, frequency(c)=1\\nOr \\nIf you remove one character \\'b\\', the String becomes \"ac\" => frequency(a) = 1, frequency(c)=1\\nOr\\nIf you remove one character \\'c\\', the String becomes \"ba\" =>  frequency(b) = 1, frequency(a)=1\\n\\nTherefore, \\'true\\' is the expected output for the testcase \"bac\"."
                    },
                    {
                        "username": "afprusin",
                        "content": "(\\u251B\\u0CA0_\\u0CA0)\\u251B\\u5F61\\u253B\\u2501\\u253B"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "Fun problem.  I do not why the acceptance rate is so low. \n\nThere are a lot of edge cases to consider so expect to have many if-else statements.\n\nTip: You can only have at most 2 types of frequencies."
                    },
                    {
                        "username": "jyotsnaroychowdhury",
                        "content": "We must not delete a letter if the frequency is equal without deleting it .\\n\\n"
                    },
                    {
                        "username": "Yunuscinar41",
                        "content": "Bro, you stole my solid 80 mins. God damn :D :D"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "The question seem simple once you understand it but when you start implementing with all edge cases, it\\'s not an easy one. it\\'s actually a medium."
                    },
                    {
                        "username": "TasminAfroz",
                        "content": "this question so tricky. I believe it is not an easy question. But yes, brute force process and thinking can help  "
                    }
                ]
            },
            {
                "id": 1861883,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1856943,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1845688,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1815748,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1815394,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1802321,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1802124,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1798505,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1772878,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            },
            {
                "id": 1770549,
                "content": [
                    {
                        "username": "shivu001",
                        "content": "in the testcase \"bac\" i think its output is false because each character have 1 frequency. so , according to the question we only need to check frequency of each letter is equal or not but in this case i seem equal but it give me wrong answer"
                    },
                    {
                        "username": "Burekodmesa",
                        "content": "No, it should be true. When you subtract 1 from either of the frequencies, you get a \\'0\\' for that particular letter, thus what is left is a string of length 2 with all remaining letters having the same frequency."
                    },
                    {
                        "username": "nom3rcy",
                        "content": "it is not easy. It would be though if the description stated clearly that the expected solution should not be optimal but O(n^2)"
                    },
                    {
                        "username": "kiu2022fall_Dachimagaria",
                        "content": "????????????????????????????????????????????????????????????"
                    },
                    {
                        "username": "panksea06",
                        "content": "Mis-Read \"You need to select\" as an *optional* selection, should instead think of it as \"You must select\". \\nBurned way too much time getting additional edge cases of removing zero characters, shoot. "
                    },
                    {
                        "username": "seifsoliman",
                        "content": "this problem have 2 test cases \\n1- count char and check if min ==1 remove and check if set of array == 1\\n2- max count of (char - 1) and check if set of array ==1\\nhint: use hash table to count each char"
                    },
                    {
                        "username": "qleoz12",
                        "content": "why \"bac\" expected value is true if b:1 a:1 c:1 so we could not remove any char because all have same frecuency?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same  if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency "
                    },
                    {
                        "username": "Vol4ica",
                        "content": "Tip: calculate number of occurrences for each character in word, and sort these numbers by ascending. Then examine first and last numbers of occurrences in this list, comparing them with inbetweens. Easier for brain to process."
                    },
                    {
                        "username": "ng-developerJS",
                        "content": "how \\'bac\\' is true if we cannot choose to do nothing ? "
                    },
                    {
                        "username": "phanindra8383",
                        "content": "[@vijay__bhaskar](/vijay__bhaskar)   then why \"aazz\" is false\\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Read the question again they have asked to remove atleast one letter So that the frequency of each character remains same if it is same return true otherwise false.But In any cas we have to perform atleast one deletion.\\nIn your case we can remove any letter a or b or c all other will have equal frequency"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "You can Remove any letter and all other letters have same frequency "
                    },
                    {
                        "username": "vinayaktyagi77",
                        "content": "\\'\\'\\'\\nVERY BRUTE FOURCE SOLUTION:\\n\\n        for i in range(len(word)):\\n            dic = {}\\n            for j in range(len(word)):\\n                if j != i:\\n                    if word[j] in dic:\\n                        dic[word[j]]+= 1\\n                    else:\\n                        dic.update({word[j]: 1})\\n            \\n            if len(set(dic.values())) == 1:\\n                return True\\n        return False\\n\\nTC:- O(N*N)\\nSC:- O(N)\\n\\'\\'\\'"
                    },
                    {
                        "username": "Claviger",
                        "content": "Nice solution in the discussion area.  WoRdS r hArD..."
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Any ideas on how I could get the last 4 hours of my life back?\\n\\nI know there\\'s a way to solve this in O(n) (I was close) but I\\'ll revisit it at a later date I think."
                    }
                ]
            }
        ]
    }
]