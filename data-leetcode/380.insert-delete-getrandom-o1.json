[
    {
        "title": "Remove Duplicates from Sorted Array II",
        "question_content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;k&nbsp;elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.",
        "solutions": [
            {
                "id": 27976,
                "title": "3-6-easy-lines-c-java-python-ruby",
                "content": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "solutionTags": [],
                "code": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27987,
                "title": "short-and-simple-java-solution-easy-to-understand",
                "content": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 967951,
                "title": "python-two-pointers-approach-explained",
                "content": "Let us use two pointers approach here: `slow` pointer and `fast` pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more `2` of them, so we start with `slow` and `fast` equal to `2`.\\n\\nThen we iterate through our data and check if `nums[slow - 2] == nums[fast]`: what does it mean? It means, that in fact `nums[slow-2] = ... = nums[fast]` and that we already have group of `3` or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\n**Complexity**: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not `2` duplicates, but `k`: in this case we just need to change all 3 occurences of `2` to `k`.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748592,
                "title": "0ms-100-faster-c-solution-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28067,
                "title": "o-n-time-and-o-1-java-solution-when-allowed-at-most-k-times-of-duplicates",
                "content": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1329356,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748197,
                "title": "java-simple-any-repetitions-explained",
                "content": "**Idea:** 2 pointers\\n* If array length is less than 3, there\\'s nothing to do so exit\\n* Since the array is sorted, all duplicates will be consecutive. So use 2 pointers, one to point at the 3rd or higher occurence of a num, and another one to find the number that can replace the num at the first pointer\\n* Keep doing this until all 3+ repetitions of nums have been overwritten\\n* Example: `[0, 0, 1, 1, 1, 1, 2, 3, 3]`\\n\\n![image](https://assets.leetcode.com/users/images/ba998bdb-4241-469a-85e7-13f5ab60a97e_1644108233.2912471.png)\\n> **T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\nGeneric solution for when k repetitions are allowed\\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374696,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others**Bold**\\n![download.jfif](https://assets.leetcode.com/users/images/e1f75de3-02bf-44d0-bb86-208e5309d274_1680526945.9427269.jpeg)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28004,
                "title": "my-c-solution-16ms-5-lines",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2415500,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\\n\\t\\t\\tSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. At last return k after placing the final result in the first k slots of nums.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 96.73% of Java online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 41.8 MB, less than 87.33% of Java online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 4 ms, faster than 83.16% of C++ online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 7.7 MB, less than 99.73% of C++ online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 24 ms, faster than 74.03% of Python online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n                    \\n# **JavaScript Solution:**\\nRuntime: 88 ms, faster than 76.14% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 43.5 MB, less than 98.04% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347871,
                "title": "6-lines-c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835835,
                "title": "runtime-faster-than-99-39-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921824,
                "title": "simple-easy-100-beats-java-solution",
                "content": "# Intuition\\nIn this solution, we\\'re iterating through the array once. We maintain an index variable that points to the position where the next unique element should be placed. If the current element is not equal to the element at index - 2, it means we haven\\'t encountered this element twice yet, so we can include it in the result array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach works because we\\'re allowed to keep up to two duplicates. If there are more than two duplicates, the elements that are allowed to remain in the array are those that are not equal to the element at index - 2, ensuring that only two duplicates are present.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062386,
                "title": "0-n-easy-to-understand-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n#### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe goal of this function is to remove duplicates from the nums vector while keeping at most two occurrences of any element. The function returns the length of the modified vector after removing duplicates.\\n\\nHere\\'s the approach implemented in the code:\\n\\n- Initialize an integer variable i to 0. This variable will keep track of the current position in the modified nums vector.\\n\\n- Use a for loop to iterate through each element ele in the nums vector using the range-based for loop.\\n\\n- Inside the loop, check the following conditions:\\n\\n---\\n\\n\\n1. i == 0: This condition ensures that the first element is always included in the modified vector.\\n2. i == 1: This condition ensures that the second element is always included in the modified vector.\\n3. nums[i-2] != ele: This condition checks if the current element ele is not the same as the element two positions before the current position i. This ensures that only two occurrences of any element are included in the modified vector.\\n---\\n-  If any of the above conditions are met, copy the current element ele to the nums[i] position in the modified vector, and increment i by 1 to move to the next position.\\n\\n\\n- Repeat this process for all elements in the nums vector.\\n\\n- Finally, return the value of i, which represents the length of the modified vector with duplicates removed.\\n\\nThis approach effectively modifies the nums vector in place, removing duplicates while keeping at most two occurrences of each element. The function returns the length of the modified vector, which can be used to access the unique elements in the first i positions of the vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote.png](https://assets.leetcode.com/users/images/91a084df-cac4-4805-8bbf-78afd5e22977_1695092464.1321526.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750063,
                "title": "python-implementation-using-two-pointers-o-n-time-space-complexity-95-faster",
                "content": "#### **If You Find This Post Helpful Please Upvote**\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529357,
                "title": "java-tc-o-n-sc-o-1-optimized-two-pointers-solution-followup",
                "content": "**In place, one pass solution using 2 pointers**\\n\\n```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n**Follow-Up: Each unique element should appear at most K times**\\n\\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Remove Element questions on LeetCode:\\n- [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/discuss/1529341/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution)\\n- [27. Remove Element + Follow Up](https://leetcode.com/problems/remove-element/discuss/1529351/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025001,
                "title": "accepted-fast-java-code-beats-100-o-n",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968051,
                "title": "remove-duplicates-o-n-time-o-1-space-complexity",
                "content": "Let us use two pointers approach here: ``slow`` pointer and ``fast ``pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more 2 of them, so we start with slow and fast equal to 2.\\n\\nThen we iterate through our data and check if ``nums[slow - 2] == nums[fast]``: what does it mean? It means, that in fact ``nums[slow-2] = ... = nums[fast]`` and that we already have group of `3 `or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\nComplexity: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not 2 duplicates, but k: in this case we just need to change all `3 `occurences of `2` to` k.`\\n```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\\nOne more easy solution that comes to my mind after attempting above solution\\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```\\n**If you have any questions, feel free to ask. If you like solution and explanations, please Upvote!,It inspires me alot.Happy Coding!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755474,
                "title": "super-simple-concise-cute-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\\n\\nOk, I saw some of your solutions are not getting accepted.\\nThe main reason for this is because you are writing it in another language. Such as C or C++. In this language, the storage management is not properly done as they are legacy languages and there is no garbage collection.\\n\\nIf you are using such languages then I will suggest you write the following line the the return statement. \\n\\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```\\nsuggested by @IILuciferII\\n\\nHope it Helps. Thanks!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599075,
                "title": "javascript-pretty-simple",
                "content": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602362,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499165,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\ntake a map<int, int> which stores the count of each element if the count is less than equal to 2 then insert the element in the required position of the array else skip and go to the next element.\\n> Please see the approach - 2 that is more optimized. no extra space is required for this. We can think about sliding window size 2.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\nhere the given array is sorted. we use this consept here => at index **i** the element **nums[i]** is present more than two times in the array is **nums[i] == nums[i-2]**\\n> let assume nums [0,0,1,1,1,1,2,3,3]\\n> We start from index 2\\n> so nums[2] != nums[0] then the element in 2nd index is not more than 2 times. so we can add nums[2]\\n> but for index 4\\n> nums[4] == nums[2]\\n> sowe can not add the element nums[4]\\n\\nplease dry run the solution for better understanding\\n\\n**One edge case is if the size of nums is less than 2 then simple return the size**\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28114,
                "title": "simple-java-solution-with-explanation",
                "content": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "codeTag": "Unknown"
            },
            {
                "id": 3741215,
                "title": "simple-two-pointer-approach-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf an element has appeared twice already in the array, we ignore the extra appearances of the element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote: assuming 0-based index; extra appearance = additional to 2 appearances\\n1. if the size(nums) <= 2, then there is no chance that an element would have appeared more than twice, so then we can return the size\\n2. we form the resultant array in-place by overriding the extra appearances of elements.\\n3. we have two variable to track indices: $$i$$ for iterating over elements of given array, $$rIndex$$ to track our resultant array.\\n4. we initiate $$rIndex$$ = 1 and start $$i$$ from 2. why? have look at (1.)\\n5. we iterate $$i$$ from 2 to (n - 1)\\n    a) if nums[$$i$$] same as nums[$$rIndex$$] and nums[$$rIndex$$ - 1], then ignore and continue to next iteration. why? the current element has made it\\'s 2 appearances already.\\n    b) else, the current element can be included in the resultant array. so, increment $$rIndex$$ and assign nums[$$rIndex$$] with nums[$$i$$].\\n6. return $$rIndex$$ + 1. why? we return the size, not the last index value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749637,
                "title": "c-with-easy-explanation",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Count of any element shoud not be greater than 2 within the limit or return variable.\\n#### \\u2714\\uFE0F **Solution - I (My Best Approach)**\\n##### **Intuition :-**\\n* Take a variable `prev` and point it with element at 0th index of `vector nums`.\\n* Take a variable count and initialize it with 1 as we are already escaping the 0th index.\\n* Take a variable pos in which we will insert any new element which is not equal to prev and update prev with new and increment the pos and count at same time.\\n* Go through the code for better understanding\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\\nJust have a question would you like a solution that is concise like the above where it will give the correct result but for dry run purposes, you have to make changes like putting brackets or the solution which I am pasting below. Let me know in the comments because I think brackets play a major role when we want to see the dry run of every iteration what changes are going to be done by the code using the print statement.\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity** : `O(N)`, traverse is done only for once.\\n**Space Complexity** : `O(1)`, No extra space is used.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28128,
                "title": "python-9-lines-2-extra-variables-76ms-any-simpler-solution-else",
                "content": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "solutionTags": [
                    "Python"
                ],
                "code": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "codeTag": "Python3"
            },
            {
                "id": 632374,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27967,
                "title": "clean-python-solution",
                "content": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "codeTag": "Java"
            },
            {
                "id": 28120,
                "title": "c-code-quite-standard",
                "content": "You only need to change K to allow K repetitions.\\nOne common mistake one can make is \" if(nums[i] != nums[i-K])\" : it is wrong since nums[i-k] can be overwritten in a previous iteration.\\n\\n    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }\\n            return last;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4006464,
                "title": "simple-beats-100",
                "content": "\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506920,
                "title": "java-solution-for-remove-duplicates-from-sorted-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code removes duplicates from the sorted array \"nums\" and keeps at most two occurrences of each unique element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the length of the array \"nums\" is less than or equal to 2. If true, return the length as there are no duplicates to remove.\\n- Initialize two pointers: \"prev\" points to the position where the next unique element will be placed, and \"curr\" points to the current element being checked.\\n- Iterate through the array starting from the third element (index 2) until the end.\\n- Check if the current element \"nums[curr]\" is equal to the previous two elements \"nums[prev]\" and \"nums[prev - 1]\". If true, it means there are more than two occurrences of this element, so increment \"curr\" to skip it.\\n- If the current element is not a duplicate, move the \"prev\" pointer forward, update \"nums[prev]\" with the current element, and increment both \"prev\" and \"curr\".\\n- Repeat steps 4 and 5 until all elements have been checked.\\n- Return \"prev + 1\" as the new length of the modified array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) since it iterates through the array once, where n is the length of the input array \"nums\".\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the algorithm modifies the input array in-place without using any additional data structures, regardless of the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918873,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654614,
                "title": "super-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740702,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600043,
                "title": "0ms-beats-most-intuitive-java-solution",
                "content": "# Intuition and Approach\\nHey Folks\\uD83D\\uDC4B\\uD83C\\uDFFC,\\nI am back with another **AMAZING** solution to a pretty complex problem (that you might think at this point) but let me give you a little spoiler\\uD83D\\uDE02 I will take the solution of an easy problem and add 3 lines of code (one extra condition) and it will solve this problem.\\n\\nAs always , To solve this problem there is a pre-requisite.\\nYou must first solve/try this problem\\uD83D\\uDC47\\uD83C\\uDFFC\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\\n\\nNow, Assuming that you have solved or at least read the problem description, the question basically asks to group the unique elements in the starting part of the array (in-place) and return the count of unique elements.\\n\\nLogic is a simple Two-pointer Approach\\n\\n**Step 1:** we keep a pointer named $$lastUnique$$ pointing to the last unique element that we processed and another pointer $$current$$ pointing to the current element we are standing at.$$lastUnique$$ will start from 0 as first element is always unique.\\n\\n**Step2:** At each $$current$$, check two conditions\\n- If $$current$$ element is equal to the lastUnique element then we can ignore the $$current$$ element.\\n\\n- Otherwise, swap the $$current$$ element with $$lastUnique + 1$$ index and move $$lastUnique$$ one step ahead. (Now this is my lastUnique element processed)\\n\\n**Step 3:** In the End , return $$lastUnique + 1$$ as we need to return count and $$lastUnique$$ signifies the index.\\n\\nCode(Linked Question):\\n```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\\n\\n\\nNow, Coming back to this problem, if you see carefully this question also asks us to group unique elements in the starting part of array **(problem statement of Linked Question)** but know one extra condition is added that the unique element can appear at most twice.\\n\\nSo , now we simply can\\'t ignore the $$current$$ element if it is equal to $$lastUnique$$, **we need to check if there exists an element to the left of $$lastUnique$$ that is equal to $$current$$ element, if it is then ignore the $$current$$ element (as duplicate already considered) otherwise we need to add the $$current$$ element to $$lastUnique$$. (Read the bold part again to get better clarity)**\\n\\nYou are done. Just copy the code and in place of $$continue$$ add the extra condition check and submit it to beat \\uD83D\\uDCAF%.\\nCongratulations, you have developed a 0ms solution to a complex(not now\\uD83D\\uDE09) problem.\\n\\nI know this solution can be compressed to 5-6 lines of code but \\n**Are those solutions really intuitive..?\\uD83E\\uDD14** **Can you come up with those solutions directly in an interview..?\\uD83E\\uDD14**  Not for an average Coder like me.\\n\\n> **INTUITION COMES FIRST, OPTIMISATIONS COME LATTER**\\n\\n\\uD83D\\uDE4F\\uD83C\\uDFFCPlzz Upvote if you found this solution helpful and interesting\\uD83D\\uDE4F\\uD83C\\uDFFC\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$-> S*ingle Iteration*\\n\\n- Space complexity: $$O(1)$$-> *No extra space used*",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759575,
                "title": "precise-c-two-pointers-o-n-time-o-1-space",
                "content": "# Approach\\nIf the array\\'s length is less than 3, we could safely return the length of the array as any element present in it will either appear once or twice which satisfies the given condition.\\n\\nVariable \\'k\\' stores the length of \\'in-place subarray\\' with unique elements which appears at most twice.\\n\\nWe begin with value of \\'k\\' and \\'i\\' as 2 as the array will have at most twice unique elements till 1.\\nThen we check \\'nums[i]\\' with \\'nums[k-2]\\' i.e current element with second element from length of \\'in-place subarray\\' with unique elements and if they are not equal we store current element at end of in-place subarray\\nand increment k by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n \\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750807,
                "title": "js-really-short-and-simple-solution",
                "content": "**Go through the list backwards and remove the excess numbers**\\n```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28053,
                "title": "share-my-o-n-time-and-o-1-space-short-and-simple-solution-when-duplicates-are-allowed-at-most-k-times",
                "content": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "solutionTags": [],
                "code": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3142015,
                "title": "0-ms-easy-best-solution-brute-force-solution-java",
                "content": "# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n# Code\\n```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n\\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529279,
                "title": "java-o-n-time-100-beats-o-1-space-simple-easy-to-understand-counter",
                "content": "if you like this aproach kindly upvote and comment so that i can share more my solutions and your one upvote will motivate me to post more precise solutions\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749252,
                "title": "two-pointer-approach-in-o-n-time-complexity-with-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we are using ***Two pointer approach.***\\n- We are taking i & j as pointers and count as counter.\\n- if i & j are equal, we\\u2019ll increase count & if count is less then 3 then we\\u2019ll replace j with i. and increase j value.\\n- else we\\u2019ll store next i value to j & make count 1, then increase j.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28051,
                "title": "easy-to-understand-java-solution",
                "content": "Save count for distinct numbers. \\nIf the count is less than 3 we can keep it.\\n\\n\\n----------\\n\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n                if(cnt<3){\\n                    nums[len++] = nums[i];\\n                }\\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27974,
                "title": "c-simple-ac-solution-in-10-lines-21ms",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }\\n            }\\n            return rear+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3958748,
                "title": "simple-python-3-solution-beats-98-7",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183342,
                "title": "80-remove-duplicates-from-sorted-array-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize a variable i to 0.\\n- Loop through each n in nums.\\n- Check if i is less than 2 or n is greater than the nums[i-2].\\n  - If the condition is true, assign n to nums[i] and increment i by 1.\\n- Return i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542066,
                "title": "faster-than-98-66-memory-usage-less-than-100",
                "content": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192080,
                "title": "2-pointers-simplest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749406,
                "title": "short-and-simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230086,
                "title": "java-100-o-1-space-5-lines-of-code-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28175,
                "title": "o-n-in-place-solution",
                "content": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3896472,
                "title": "c-easy-shortest-solution",
                "content": "Just check if the i+2 th element is same or not, if not then use the second pointer to fill the array.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3589635,
                "title": "js-ts-2-simple-solutions-100-explained-and-commented",
                "content": "# Solution #1\\nWorks for at most any number if we change the comparison value in the if block.\\n## Approach\\n- Check if the input array `nums` is empty. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop. For each element:\\n    - Check if we have not yet seen this element (i.e., if `k` is less than `2`), or if the current element is greater than the second-to-last unique element (i.e., `nums[i] > nums[k-2]`). If either of these conditions is `true`, then we have a new unique element.\\n- Assign the current element to the new position indicated by `k` in the array `nums`.\\n- Increment `k` to move the pointer to the next position.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k` as the function output.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\\n\\n# Solution #2\\nWorks only for at most twice\\n## Approach\\n- Check if the input array `nums` is `empty`. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop, starting at index `1` (since the first element is always unique).\\n    - Check if the current element is not equal to the previous unique element (i.e., `nums[i] !== nums[k]`), or if the current element is equal to the previous unique element but the previous two elements are not equal (i.e., `nums[i] === nums[k] && nums[k] !== nums[k - 1`]). If either of these conditions is `true`, then we have a new unique element.\\n    - Increment `k` to move the pointer to the next position.\\n    - Assign the current element to the new position indicated by `k` in the array `nums`.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k + 1` as the function output, since `k` is a zero-based index and we need to add `1` to get the number of unique elements.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141821,
                "title": "0ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420762,
                "title": "3-simple-steps-to-solve-same-types-without-if-else",
                "content": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "codeTag": "Unknown"
            },
            {
                "id": 1752202,
                "title": "python-2-solutions-naive-and-efficient-explained",
                "content": "## The naive approach is using the inbuilt count() method in python, and removing (count-2) instances of the element.\\n## For example the array nums = [1,1,1,1,2,2,2,3,3], it will delete (count of 1 - 2) 1\\'s, that is 4-2 = 2 ones, and so on.\\n## count() method in python returns the frequency of the element, if the frequency is less than 2 skip one place and go ahead if it\\'s more than 2, delete (count-2) elements and then skip 2 places.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```\\n# Efficient 2-pointer approach\\n## This approach has a start and an end pointer which is 2 indices ahead of start, everytime nums[end] == nums[start], it deleted nums[end]. Once 1st element is done, start shifts to end, and end shifts to start+2.\\n\\n```def  removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if length < 2:\\n            return length\\n        start = 0\\n        end = start + 2\\n\\n        while(end <= length-1):\\n            if nums[start+1] == nums[start]:\\n                if nums[end] > nums[start]:\\n                    start = end\\n                    end += 2\\n                else:\\n                    nums.pop(end)\\n                    length -= 1\\n            else:\\n                start += 1\\n                end += 1\\n        \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1750032,
                "title": "java-3ms-solution-leetcode-dc",
                "content": "**please upvote if you like my solution**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749976,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749376,
                "title": "c-simple-and-easy-solution-using-two-pointers-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271806,
                "title": "c-using-unordered-map",
                "content": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 377132,
                "title": "python-solution-upvote-if-you-understood",
                "content": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "codeTag": "Python3"
            },
            {
                "id": 3720279,
                "title": "best-solution-c-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585412,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347800,
                "title": "java-100-faster-two-pointer-method-in-java-simplify-your-code-and-save-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c1be1504-3486-4267-a051-24173837f10d_1679924192.437104.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137326,
                "title": "python3-o-n-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```\\n# **Please upvote guys if you find the solution helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114911,
                "title": "js-ts-easy-solution",
                "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513788,
                "title": "go-o-n",
                "content": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732669,
                "title": "c-easy-to-understand-3-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\\n**Without any extra space and linear time complexity**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193869,
                "title": "c-easy-code",
                "content": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "solutionTags": [],
                "code": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980297,
                "title": "simplest-python-4-lines-solution",
                "content": "* Iterating over the array from last index (i.e. using  for loop reversely ) to eliminate range errors.\\n* Deleting the number that is repeating.\\n\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208796,
                "title": "python-solution",
                "content": "We use the two pointer approach as in 26. Remove Duplicates from Sorted Array, except that we will use an extra `flag` variable to indicate the number of duplicates of `nums[j]` in `nums[:i+1]`. If `flag = False`, then there are `0` or `1` duplicate of `nums[j]` in `nums[:i+1]`, and we should increment `i`, and swap `nums[i]` and `nums[j]`; Else if `flag = True`, there are `2` or more duplicates of `nums[j]` in `nums[:i+1]`, and we should do nothing and continue with the next iteration of `j`. The loop invariant is that `nums[:i+1]` is always the sorted array `nums[:j+1]` with duplicates appear at most twice. Hence when `j` reaches `len(nums)-1`, `nums[:i+1]` is `nums` with duplicates appear at most twice.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28072,
                "title": "share-my-o-n-time-and-o-1-space-solution-with-duplicates-are-allowed-at-most-n-times",
                "content": "    public class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }\\n        int dif = 2;\\n        for(int i=2;i<nums.length;i++){\\n            if(nums[i]!=nums[dif-2]){\\n                nums[dif++]=nums[i];\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n\\n\\nif N duplicates are allowed,you just need to change the nums[dif-2] to nums[dif-N] ,welcome to discuss with me .",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4045552,
                "title": "javascript-easy-and-very-understandable-2-pointers-solution",
                "content": "# Intuition / Approach\\nSince the nums array is already sorted, its actually really easy to see when we have more than 2 duplicates of any given integer. Sounds very simple and stupid, but if you look at 3 numbers at once and you see that they are all the same integer, then we have an obvious extra duplicate. We could drop the right element, and keep incrementing r. As we increment r, if the element reoccurs, then we keep dropping them. However, if we see that our r pointer element breaks from our element at l and mid, then we know that there are no more extra duplicates, and we can start checking the next batch of 3 elements from the first occurance of an integer we havent seen yet (which is at pointer r). Here is where we will fix our pointers, where l = r, mid = l+1, and r = mid+1. And the check from above starts again. In any other situation, we can just move all our pointers by 1 and keep checking the same conditions we listed above.\\n\\nSince I decided to use a placeholder (\"_\") in places where I dropped the integer, for the test cases to pass given the criteria, I need to move all the place holders to the right. \\n\\nI know that I did a lot of extra work with the placeholders and 2nd loop to move the \"_\" to the right, but I wanted to solve this problem clearly as possible and where anyone can see what is happening at any given moment, so I thought that this was the most simplest solution to understand.\\n\\nHope this helps! I thought it was kind of confusing first, but once you realize how the array being sorted works in your favor, its really easy to do. \\n\\n# Complexity\\n- Time complexity:\\n    - First while loop iterates through nums once using 3 pointers. Since the loop passes through the array once-> O(N);\\n    - Second while loop iterates through nums once using 2 pointers. Since the loop passes through the array once -> O(N);\\n    - O(N + N) => O(2N) => (Constants are dropped) O(N); \\n\\n- Space complexity:\\n    - Constant number of extra variables used (k, l, mid, r, i, j)\\n    - No additional data structures used to store inputs with respect to the input size\\n    -  O(1); \\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907328,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointers\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878331,
                "title": "o-n-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompared to \"Remove Elementes From A Sorted Array I\": The key differences are the \">\" symbol and l- 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPlaceholder \\'l\\' stops at the 3rd repeated value while \\'i\\' continues and looks for then next different value. The \">\" symbol prevents cases where 2 == 2 would be true and allows \\'i\\' to continue.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861369,
                "title": "3-line-easy-to-understand-code-beats-86-in-runtime-99-31-in-memory-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859756,
                "title": "simple-2-pointers-solution-speed-94-67-memory-86-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738535,
                "title": "two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717239,
                "title": "the-solution-from-beginner-perspective-easy-to-understand",
                "content": "# Intuition\\nMy program is checking from the first element of the array then it goes one by one until the the 3rd from last element. \\n\\n# Approach\\nif  nums[i]  equals to  nums[i+2]  the program just continue because it means there is more than 2 of this element so we are not going to take it this one.\\nif it\\'s not equal it means this element less than 3 so we take it to our nums array like nums[index] = nums[i] index starting from zero when we arrived to last 3rd element of array we checked last time if it equals to last elemnet of the array we didnt take it but it\\'s not we take this one too. Then we automatically take it last two element of array to our nums array because we checked the last 3rd element then the last 2 elemen either equol or diffrent these two sitsituation is okey for the question.\\n\\nFeetback : I\\'am a beginner for java maybe this code slow which is not i checked :) or maybe it is not suitable for code standards but i think it easy to understand. if you understand that code you can make me understand by upvote my solutions.\\nthanks in advance\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585488,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541541,
                "title": "c-time-o-n-memory-o-1-10-line-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433964,
                "title": "easiest-handwritten-approach-with-dry-run-check-it-out",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/bf2875ee-778b-4ce2-9e02-c140706a3949_1681889805.5851915.png)\\n![image.png](https://assets.leetcode.com/users/images/bea318f3-e9ef-42f2-af88-36157512e861_1681889822.9460862.png)\\n![image.png](https://assets.leetcode.com/users/images/17b032ff-d978-4d80-83a2-4d26c2262a56_1681889851.0495398.png)\\n![image.png](https://assets.leetcode.com/users/images/a19c445f-d6f8-46d0-a039-de5617ef44bd_1681889868.721397.png)\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115163,
                "title": "easy-c-uniform-coding-style-that-works-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that go through all the elements, along with that check if the current element has been included previously or not if included skip it, else add it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep two pointers:\\nWhile moving left will store the position to store the newly found element. At the end it will containt the number of unique elements.\\nRight(r) will move forward till the end of the given array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\nFor [26. Remove Duplicates from Sorted Array\\n](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) Allowed to keep only one instance\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\\n\\nFor [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)   \\nAllowed to keep atmost two instances\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472886,
                "title": "python-elegant-short-99-6-faster-two-variables-one-pass-o-1-memory",
                "content": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1758413,
                "title": "simple-solution-in-python-with-clean-code",
                "content": "\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749926,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "\\n\\nHere, we will keep tab on the current element in the variable \\'now\\'. And we are keeping a counter to count the number of elements with the value \\'now\\'.\\n\\nIf the count becomes more than 2, we will remove that element from the list. \\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749815,
                "title": "python-naive-efficient-approach",
                "content": "Naive approach:\\n\\n- store the count of each number appearing.\\n- if count is greater than 2 then pop and append it to the last of the list \\n- increase the k count by 1 and return length of nums - k as the answer\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\\n\\nEfficient Approach:\\n\\n- As the array is already sorted we know can track the count of each number by going to next second element to it.\\n- And replace it whenever there is count > 2 and increase k value for both appending and traversal.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749743,
                "title": "python3-simple-and-easy-faster-90",
                "content": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749068,
                "title": "easy-to-understand-c-solution-in-linear-time-and-constant-space",
                "content": "Use two pointers i and j, i => to iterate through the array, j => to maintain writing pos for the next element.\\nWhile iterating through the array, keep count of elements having same value as current:\\n-if you encounter same element  and count is less than 2, then store the element in the next position\\n-else if you encounter a different element, then reset the count to 1 and store that element in the next position.\\nreturn j\\n\\nTC: O(n)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708962,
                "title": "java-remove-duplicates-o-n-two-pointer-solution",
                "content": "For reference, a solution from which I will build up on:\\n\\n**Remove Duplicates From Sorted Array**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nSince now two duplicates are allowed, I introduce a boolean flag to indicate duplicates occurring.\\n\\n**Remove Duplicates From Sorted Array II**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nTo see why both 1 and 2 cases should overwrite, consider the example `[0,0,1,1,1,1,2,3,3]`.\\nFor case 2, it is clear that the array index at res should be overwritten: a new unduplicated number has been introduced.\\nFor case 1, without the array index at res overwritten the solution would return `[0,0,1,1,2,3,2,_,_]` not `[0,0,1,1,2,3,3,_,_]`.\\nTo see why, note that at index `i == 8` index `res == 5`. We see a smaller number 2 after the 3 that overwrote index `res`.\\n\\n\\nThis is indicative of a corner case in which the duplicate of the last overwriting number was not reflected properly.\\nTo reflect this corner case the solution faithfully overwrites value at `res` whenever it finds a new duplicate. In the best case, it just redundantly overwrites the duplicate that occurred right before. In the worst case, it properly overwrites the value right next to the duplicate that occurred somewhere much before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356963,
                "title": "most-optimised-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355654,
                "title": "python-simple-two-pointers-with-explanation",
                "content": "`cur_idx` is the current index at which we\\'ll place `nums[i]`\\n\\n`count` is the current count of consecutive elements\\n\\nWe increment `count` if `i` isn\\'t the last index of the array and the next element of the array is equal to the current element of the array. Then, we swap the elements at `i` and `cur_idx`. \\n\\nWe only increment `cur_idx` if the count of duplicate elements is two or less because if the current count is greater than that, we only want to write that element at most two times.\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 744616,
                "title": "nice-and-easy-c-solution-using-two-pointers",
                "content": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "solutionTags": [],
                "code": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "codeTag": "Unknown"
            },
            {
                "id": 618939,
                "title": "generic-solution-o-n-time-and-o-1-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "\\n[Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\n[Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391499,
                "title": "javascript-solution-56ms",
                "content": "\\n>\\u221A Accepted\\n  \\u221A 166/166 cases passed (56 ms)\\n  \\u221A Your runtime beats 98.23 % of javascript submissions\\n  \\u221A Your memory usage beats 100 % of javascript submissions (35.6 MB)\\n  \\n```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/tiokang/image_1569737680.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 174982,
                "title": "python-solution-100-32ms",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28099,
                "title": "java-1ms-solution",
                "content": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "codeTag": "Unknown"
            },
            {
                "id": 3964930,
                "title": "javascript-typescript-efficient-algorithm",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable j to 2. This will keep track of the index where the next non-duplicate element should be placed.\\n\\n2. Iterate over the array nums starting from index 2 (since the first two elements are allowed to appear twice).\\n\\n   a. For each index i starting from 2 and going up to the length of nums:\\n      i. Check if the current element nums[i] is not equal to the element at index j - 2. This condition ensures that we\\'re only allowing duplicates to appear twice.\\n      ii. If the condition is true, assign the value of nums[i] to the position nums[j] (j being the next available index for a non-duplicate element) and increment j by 1.\\n\\n3. After the loop, the variable j now holds the count of unique elements with duplicates allowed at most twice.\\n\\n4. Return the value of j as the new length of the modified array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n# Code\\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933663,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923393,
                "title": "easiest-solution-using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661984,
                "title": "java-solution-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602270,
                "title": "java-4-codes-actually-2-but-the-3rd-one-is-interesting-xd-4th-one-beats-100-time-and-space",
                "content": "# Method 1: Frequency Array\\n\\n## Intuition\\nSo the first intuition on seeing this problem and its constraints was to solve this using frequency array. But the problem is that there are negative numbers also, so had to think of a way to tackle those. Read below to learn how I solved this.\\n\\n## Approach\\nSo the approach is simple:\\n1. There will be an array `freqp[]` for handling the normal positive numbers.\\n\\n2. There will be an array `freqn[]` for handling the negative numbers.\\n\\n3. Next, start filling the `freqp[]` and `freqn[]` arrays (as mentioned in the code given below).\\n\\n4. Now, building of the `freqp[]` is simple, but for `freqn[]`, since we can\\'t have negative array indices, so I will mark the particular negative number at the index `-1*(negative number)` in the `freqn[]` array.\\n\\n5. Next, I run 2 while loops, each with 2 variables, `i` which is used for traversing the frequency arrays, first `freqn[]` (since negative numbers are smaller than the positive numbers), starting with `i=10000` up to `i=0`, because the greater the magnitude the smaller the negative of it (10000>1 but -10000<-1), and later for `freqp[]`, starting with `i=0` up to `i=10000`. And the other variable is `p`, which is used for filling `nums[]`.\\n\\n6. Now, inside each while loop wherever the frequency is greater than `0`, we first check if the frequency is greater than `2`, if so, then replace it with `2`, and fill next 2 positions of nums using `p`, while decrementing the frequency until it becomes `0`.\\n\\n7. After going through both the while loops, `p` will be last index where any value was manually filled, so it is that `k` which is to be returned.\\n\\n## Complexity\\n- **Time complexity:**\\nTime complexity is `O(n+k)`, where `n` is the size of input array, and `k` is the range of numbers (constraints).\\n\\n- **Space complexity:**\\nSpace complexity is also `O(n+k)`.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/ce865d3d-1256-4f85-8d09-047be9d6908a_1685997186.793973.png)\\n\\n\\n---\\n\\n# Method 2: Two Pointers\\n\\n## Intuition\\nI got intuition on seeing that my previous solution had beaten too less of the available JAVA solutions. So, I started thinking in another way. I knew this could be solved by 2 pointers, but the thing was how?\\n\\n## Approach\\nThe approach to this solution needed testing on edges, but rest was easy to think of:\\n1. Have 3 pointers (indexes), `i`, `j`, and `p`. `i` will be used to determine the number which is currently being repeated. `j` is used to traverse the repeated instances of the number at index `i`. And `p` is used to fill the array `nums[]` (in-place). *Yes if it was not mentioned that the solution had to be in-place, then making another `ans[]` array, we could solve the problem with just `i` and `p`.*\\n\\n2. Figuring out 3 pointers were needed was easy but a bit tricky, but the next part is just easy to think of, however slightly complex to implement.\\n\\n3. So, we initialize `i`, `j`, `p` all to `0`, and have a `cnt` variable to count the number of times any particular value has been repeated (however it stops incrementing once it reaches `2`, so it is more sort of a check variable).\\n\\n4. Now, a while loop runs until `j` reaches the end of the `nums[]` array. In each iteration of the while loop:\\n\\n    1. If the value at index `j` is equal to that of `i`, that means, there is a repetition, and the `cnt` variable is incremented until it reaches `2`.\\n\\n        1. If the cnt variable hasn\\'t reached 2, then nums[p] will be filled with the same value at index `i` and `j`. And `p` is also incremented after each fill.\\n\\n        2. If the `cnt` variable has reached `2`, then we won\\'t increment `p`, because we can\\'t have more than 2 occurences in the final array.\\n\\n    2. If the value isn\\'t equal, that means we have found a new value and at this point `nums[i]!=nums[j]`. Hence, we change `i=j`, increment `j`, and set `cnt` to `1` (because the new number itself is also counted). And we also increment `p`, and the rest of the while loop continues.\\n\\n5. After the while loop is terminated, `p` gives the last index at which value was filled, `i` and `j` reach end of the array. So, we return `p`, while our array `nums[]` has been properly modified.\\n\\n\\n\\n## Complexity\\n- **Time complexity:**\\nTime Complexity is `O(n)`, where `n` is the size of the `nums[]` array.\\n\\n- **Space complexity:**\\nSpace Complexity is `O(1)` with in-place operations.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n![image.png](https://assets.leetcode.com/users/images/19e0b885-f997-426c-b7cd-2b236dc3c366_1685998948.7063458.png)\\n\\n\\n\\n---\\n\\n# Method 3 : Method 2 + Garbage Collector (XD)\\n\\n## Intuition\\nSo, it\\'s obvious when you grind 15 minutes (check difference between time stamps of previous 2 solutions), you won\\'t expect your code\\'s space complexity to just beat 47.15% of the other JAVA solutions. Hence, this is the intuition to do something crazy!\\n\\n## Approach\\nThe approach was nothing, but see the best solution that beats 100% space, so I found a solution (by clicking the first bar in the distribution chart).\\n\\nAnd you know what? I got to know an amazing technique to tease the LeetCode Judge, by manually running the Garbage Collector of JAVA before returning the answer to each test case.\\n\\nAnd the answer is `System.gc();`.\\n\\n# Complexity\\n- **Space complexity:**\\nSpace complexity of this new code as expected, did beat all JAVA solutions, (because you literally cleanup everything before returning lol).\\n\\n- **Time complexity:**\\nNow, the time complexity (`O(t*c),` where t is number of tc and c is the time to run the garbage collector in 1 call) was definitely a concern, because running so many test cases, everytime manually clearing up memory, would take more worth of time than it took to cleanup some small space in memory. This solution took less time than method 1, but no signs of beating 100% solutions.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\\n\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/a8f2bf24-97f9-4094-a9b0-dd663b4d3b99_1685999693.956865.png)\\n\\n\\n---\\n\\n# Method 4 : Method 3 (but optimized!)\\n\\n## Intuition\\nSo, by now I had understood the fact that at this point with this 2 pointer solution, it was just space-time tradeoff using the garbage collector. And I just wanted to find some point where it gives the best combination of them.\\n\\n## Approach\\nSo, my approach now was to reduce the number of times that garbage collector was being run. Why not, just run it once in 5 or once in 10 times, and clear up all the space in minimal time?\\n\\nIf it was in my hands (or basically if I knew how the judge worked), I would have called the System.gc() command just before the last return value, but the fact is I don\\'t know how it functions.\\n\\n\\nBut I do have access to the current time in the System clock and how it works, so with different modulo hashes, I tried to get the best performance, and well starting from `%2`, then `%3`, finally `%4` gave me the best result.\\n\\nNow what do I mean by `%4`? It means I added just one line in my code which is of this structure:\\n\\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\\n\\nNow, this `m` can vary for different constraints, while here `m=4` worked for me. And so, finally, below you can see a code that beats 100% of space and 100% time in all JAVA solutions across LeetCode for this problem.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/313d42a3-fbed-4d2b-9a8e-f52bc68a366e_1686000339.0158308.png)\\n\\n\\n\\n\\n---\\n\\n# A Request!\\n\\n***Please upvote this post so that other people can also learn something new, a part of which is logical, and the rest is crazy XD!***\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576995,
                "title": "general-for-k-duplicates-easy-c-understandable-solution-beats-100",
                "content": "# Intuition\\nThe given array is sorted. This means next element will be either same element or bigger one. Store current element in a variable and keep comparing it with next element, also keep an eye that count does not exceed K (Here K is 2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: I come up with the idea that if I swap array for every duplicates, it will be costly, so I thought why not mark that place and swap everything at last.\\nThere will be three cases as you can see in code\\nCase 1: Element of array is same as current element and count is still postive.\\nCase 2: Element of array is same as current element but count is not positive.\\nCase 3: Element of array is not equal to current.\\n\\nStep 2: I sort the array. \\nStep 3: Found the length using loop.\\nStep 4: Check Corner Cases for array size = 1 or 2 or 0;\\nYou are done!!!\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569694,
                "title": "same-approach-as-easy-one-0ms-beats-100-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486377,
                "title": "classical-two-pointer-approach-with-little-tweak-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437027,
                "title": "using-java-beats-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328439,
                "title": "simple-0ms-solution-beats-100-with-explanation-java-c",
                "content": "# Explanation & Example\\nSo from the question we can see **we need to remove duplicates in place and each element can appear atmost twice**.\\n\\nlet\\'s take the below array for **example**\\n**arr = [0,0,1,1,1,1,2,3,3]**\\n\\nSo in the initial observation we can see everything appears in correct count except 1.\\nWe initialize prev with 1st element(0) in array and we start with index 1,as we know the 1st element in array gonna be unique so we also initialize k with 1.as we are doing it in-place **assume our array(arr) has[0,-,-,-,-,-,-,-,-] for better understanding**.\\n\\n\\n- In 1st iteration prev = 0 as it is equal to ith value(0) we\\'ll increase the count to 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(0) and increment k [0,0,-,-,-,-,-,-,-].\\n\\n- In 2nd iteration prev = 0 and arr[i]=1 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,-,-,-,-,-,-]\\n\\n- In 3rd iteration prev = 1 and arr[i]=1 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,1,-,-,-,-,-]\\n\\n- In 4th & 5th iteration prev = 1 and arr[i]=1 so the count becomes 2 & 3 respectively as it does not pass the condition(c<=1) the array remains same[0,0,1,1,-,-,-,-,-]\\n\\n- In 6th iteration prev = 1 and arr[i]=2 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(2) and increment k [0,0,1,1,2,-,-,-,-]\\n\\n- In 7th iteration prev = 2 and arr[i]=3 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,-,-,-]\\n\\n- In 8th iteration prev = 3 and arr[i]=3 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,3,-,-]\\n\\n- In 8th iteration the k will be in 6th index and as usual we\\'ll increment and k becomes 7\\n\\n- so we got the **output as 7** and we can see the array(arr) becomes [0,0,1,1,2,3,3,-,-] and the **first 7 value(0-6 index) in the array has unique elements appears at most twice**.\\n\\n# Complexity\\n- Time complexity : O(N)\\n\\n- Space complexity : O(1)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196900,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090684,
                "title": "remove-duplicates-from-sorted-array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080349,
                "title": "easy-solution-using-maps-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852511,
                "title": "java-o-n-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786407,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427237,
                "title": "a-simple-java-solution-that-beats-100-with-explanation",
                "content": "Since the array is already sorted and we want to keep at most two duplicates, we only need to compare `nums[i]` and `nums[i - 2]` if the original array is not modified. For the array `nums = [1,1,1,2,2,3]`, we saw `nums[2] == nums[0]`, which means there are more than 2 duplicates and we should remove one of them. \\n\\nTo remove the duplicates, we need a pointer `current` that points to the index, where the elements before it has at most 2 duplicates. In this way, we can overwrite it with a valid number later. For example, for the array `nums = [1,1,1,2,2,3]`, `2` would be our index because there are only two numbers before. We noticed `nums[2] == nums[0]`. So we may want to replace `nums[2]` with some value after it. Since `nums[3] != nums[1]`, we can replace `nums[2]` with `nums[3]`. Thus the array becomes `[1,1,2,2,2,3]`. For this new array, we saw that `nums[4] == nums[2]`. But we don\\'t want to remove it since we added the extra `2`. We must add the offset, which is `i - current`, where `i` is the pointer of the original array. So the comparation will be between `nums[i]` and `nums[i - 2 - (i - current)]`, which is `nums[current - 2]`.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195204,
                "title": "o-n-with-o-1-extra-memory-java-c-c",
                "content": "**Algorithm**\\n* If length of nums is less than 2 then simply return length of array\\n* We can solve this question using two pointers i.e., i and count. Count will track the index of array to be sent and i will track the index of next bigger element\\n* If current element is less than next element that means only one element is present, then add the ith element in array at count index, incrementing count for next element.\\n* Else, that means there are more than one elements of that current element. We know that we can add at most two elements, so we will add ith element in the array upto next 2 count pointers. \\n* We need to shift the ith element to the next greater element.\\n* There might be chances that the last element of nums can be remained uncheckd, so once the ith pointer is at second last element then we can add the i+1th element at count place in array.\\n\\nTime Complexity: O(n) with O(1) extra memory\\n**Code in Java**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Code in C**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```\\n\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750932,
                "title": "very-very-easy-java-with-o-1-memory",
                "content": "```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750790,
                "title": "swapping-to-preserve-the-relative-order",
                "content": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "solutionTags": [],
                "code": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1750721,
                "title": "c-simple-solution-easy-to-understand-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749171,
                "title": "cpp-easy-solution-with-time-o-n-space-o-1-and-o-n",
                "content": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1650174,
                "title": "c-using-single-loop",
                "content": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1377370,
                "title": "ez-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271028,
                "title": "c-solution",
                "content": "**intuition**\\nmaintain two pointers ```i``` and ```j```.\\npointer ```i``` is used to traverse the array, pointer ```j``` is used to mark the position where needs a replace.\\nwhen ```nums[i] == nums[j-2]```, then there are 3 duplicates  (```nums[j] = nums[j-1] = nums[j-2]```). ```j``` is pointing at the position where needs a replacement, so we don\\'t move ```j``` until we find the next number that can replace ```nums[j]```.\\nwhen ```nums[i] > nums[j-2]```, we find the number that can be used to replace ```nums[j]```.\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```j```\n```i```\n```j```\n```nums[i] == nums[j-2]```\n```nums[j] = nums[j-1] = nums[j-2]```\n```j```\n```j```\n```nums[j]```\n```nums[i] > nums[j-2]```\n```nums[j]```\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208200,
                "title": "two-pointers-c",
                "content": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 969763,
                "title": "two-pointer-approach-o-n-time-java",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968082,
                "title": "c-4ms-fast-solution-easy-to-understand",
                "content": "simple approach \\nStoring the value of last element in the variable a\\n using k to know whether it has iterated for more than two times \\n erasing the element if it comes for third time \\n ans stores the required size of vector\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }\\n                else\\n                {\\n                    k=1;\\n                    ans++;\\n                }\\n            }\\n            else\\n            {\\n                a=n[i];\\n                k=0;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 968049,
                "title": "c-simple-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968017,
                "title": "python-binary-search-solution-upper-bound-aka-bisect-right",
                "content": "Something like this maybe, wrote linear search first then replaced with upper bound:\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```\\n\\nSolutions in this discussion remind me the Silicon Valley episode about brute search on a sorted list:\\n\\nhttps://www.youtube.com/watch?v=9FzT2I21F3k",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967991,
                "title": "remove-duplicates-from-sorted-array-ii-c",
                "content": "**My Approach** : I used a pointer  --> i, for keeping track of the position I am currently in and a variable --> count, to count the occurence of the same element. Whenever the count exceeds 2 i.e more than 2 same elements, I erase it from the vector using the inbuilt erase() function; otherwise, I increase the pointer and reset the count variable to 1.\\nPls read the code for better clarity.\\nThanks!\\n**Pls upvote if you find this helpful.**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679623,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 4 ms, faster than 90.35% of Go online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 3 MB, less than 75.25% of Go online submissions for Remove Duplicates from Sorted Array II.\\n\\n```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674085,
                "title": "python3-linear-scan",
                "content": "**Algo**\\nSimilar to [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```",
                "codeTag": "Java"
            },
            {
                "id": 533779,
                "title": "simplest-swift-solution",
                "content": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509355,
                "title": "python3-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462841,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{};\\n        for(int i=0;i<n-2;i++){\\n            if(nums[i]==nums[i+1]&& nums[i+1]==nums[i+2]){\\n                nums[i]=INT_MAX;\\n                count++;\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        return n-count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{}",
                "codeTag": "Java"
            },
            {
                "id": 386869,
                "title": "python-2-variables-inplace-popping-easy-to-understand-with-explanation",
                "content": "The approach is quite simple, keep track of the current element in consideration and the count of the element. Initiate the track as the first element in the array and  have the occurence count as the second element, you may use a tuple for this of some simpler structure to save more memory. As you iterate, check if the count of the current element under consideration exceeds that under track, in which case we pop it but do not increment out tracker. While loops are convenient here since the array size changes and the len(nums) si computed prior to every iteration. In case they are different, reinitiate the tracker with the new value and set the second frequency element to 1.\\n \\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352667,
                "title": "java-simplest-approach-for-this-exercise",
                "content": "We can copy the exact same solution from https://leetcode.com/problems/remove-duplicates-from-sorted-array/\\nThe only trick is that we allow j to move forward n times when we find duplicates, where n = 2 for this exercise.\\nMake sure to add +1 to j when you return it because we want the length of the new array and not the last valid index.\\n\\n**Remove Duplicates from Sorted Array (LC #26)**\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\\n\\n**Remove Duplicates from Sorted Array II**\\n\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314125,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27982,
                "title": "6-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28071,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }\\n            \\n            return newSize;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 28098,
                "title": "my-easy-c-solution",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28142,
                "title": "java-solution-generalized-to-maximal-k-time-occurences",
                "content": "This solution is inspired by @tech-wonderland.net\\n\\nIn this solution, I use a **for** loop instead of a **while** since we know for sure the iteration will end after loop through the array one time.\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }\\n        \\n        public int removeDuplicates(int[] nums, int k) {\\n            \\n            int len = nums.length, count = 1;\\n            \\n            // j points the position where the next qualified number \\n            // found by i pointer will be written\\n            for ( int i = 1, j = 1; i < nums.length; i++ ) {\\n    \\n                count = (nums[i] != nums[i-1]) ? 1 : count+1;\\n                \\n                if ( count > k ) {\\n                    len--;\\n                } else {\\n                    nums[j++] = nums[i];\\n                }\\n    \\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 28145,
                "title": "iterative-python-solution-o-n-88ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def removeDuplicates(self, nums):\\n            n = len(nums)\\n            if n < 3:\\n                return n\\n    \\n            start, tail = 0, 2\\n    \\n            for i in range(2, n):\\n                if nums[i] != nums[tail - 1] or nums[i] != nums[tail - 2]:\\n                    nums[tail] = nums[i]\\n                    tail += 1\\n    \\n            return tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 28132,
                "title": "in-place-solution-in-python-for-reference",
                "content": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "codeTag": "Java"
            },
            {
                "id": 3989902,
                "title": "simple-easy-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880642,
                "title": "best-javascript-simple-solution-easy-to-understand-quickly-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659959,
                "title": "java-best-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629267,
                "title": "python-intuitive-optimal-2-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 pointers, one goes first to find the next unique element, the slower one waits until the first one find a new element and fill its current position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate over `nums`, we first set the amount of the number of duplicates for the current element to 2, `cnt_left = 2`. We only do this when we found a new element: `num != nums[j - 1]` or `j == 0`\\n\\nWe then update the slow pointer and reduce the `cnt_left` when:\\n- We need another duplicate: `cnt_left > 0 and num == nums[j - 1]`\\n- New element found: `j == 0` or `num != nums[j - 1]`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627809,
                "title": "simple-solution-java",
                "content": "# Intuition\\nThe given code aims to remove duplicates from an array nums and return the new length of the array.\\n\\n# Approach\\n1) Create a new array n1 with the same length as nums. This array will store the non-duplicate elements.\\n2) Initialize variables c, c1, and n to keep track of counts and the length of the new array.\\n3) Iterate over the elements of nums using the outer for loop.\\n4) Reset c to zero at the beginning of each outer loop iteration. c will count the number of occurrences of the current element.\\n5) Use the inner for loop to iterate over nums and check for occurrences of the current element. Increment c for each occurrence.\\n6) If c is greater than 1, it means the current element is a duplicate.\\n7) Add the current element twice to n1 (to remove duplicates).\\nUpdate c1 and n accordingly.\\n8) If c is 1, it means the current element is not a duplicate.\\nAdd the current element once to n1.\\nUpdate c1 and n accordingly.\\n9) After the loop ends, copy the elements from n1 back to nums.\\nReturn the final count n, representing the new length of the array after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\n**Please upvote if you like my solution!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625795,
                "title": "kotlin-simple-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598061,
                "title": "easy-c-solution-o-n",
                "content": "\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571777,
                "title": "combining-both-versions-easy-and-medium-c-o-1-space",
                "content": "Problem 26. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\\n\\n\\n\\n\\n\\n\\nProblem 80. [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564625,
                "title": "remove-duplicates-from-sorted-array-ii",
                "content": "**Simple** Solution :\\n1. **step1: **pick the first element from the array( hence given minimum length of array is 1).\\n1. step2: count the frequency of element.\\n1. step3: if count==3  remove the element at that index and decrease the count and length of array(because we deleted one element from array). and stay at that index don\\'t increment the index(i) because next element comes to current index when we delete an element at present index).\\n1. \\xA0step4: if new element comes into picture then change pointer(p) to new element and count to 1.\\n1.  step5: return the final length of the array(l).\\n\\n``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545339,
                "title": "simple-two-pointers-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1983237,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1982040,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1929287,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1736627,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2075933,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2073357,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2071883,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2065028,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2064125,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2057740,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2056728,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2055605,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2051670,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050718,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050414,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2029005,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2020620,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2005189,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2003421,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2002773,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 1994697,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1986159,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1958088,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1932780,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1916491,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1767478,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754137,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1741175,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1648709,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709320,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Consecutive Numbers",
        "question_content": "<p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n",
        "solutions": [
            {
                "id": 321205,
                "title": "runtime-299-ms-faster-than-94-39",
                "content": "Runtime: 299 ms, faster than 94.39% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: N/A\\n\\n```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359304,
                "title": "easy-and-simple-solution-using-lead-try-this",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```\\n**If U like the solution, Pls Upvote**\\n\\n![cat.png](https://assets.leetcode.com/users/images/cb4680e8-b410-4c2f-a9f7-914b5be19e87_1680183976.0080035.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53418,
                "title": "simple-solution",
                "content": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "solutionTags": [],
                "code": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 237228,
                "title": "my-version-is-more-flexible-we-can-change-3-to-4-or-5-or-10",
                "content": "#### Question\\n```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\\n#### Answer\\n##### Approach1\\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```\\n\\n##### Approach2\\n```SQL\\nselect distinct num as ConsecutiveNums from\\n(select num, id - row_number() over (order by num, id) rank from logs) a\\ngroup by num,rank\\nhaving count(*) >2\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420941,
                "title": "mysql-2-different-approach-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509769,
                "title": "easy-approach-clear-code-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Easily taking out the distinct num from the table whose occurence >= 3. \\n- To check that consecutively occurence is atleast 3 times, we do it by `creating 3 tables for every other id by +1 increment` & `matching them that they are equal.` \\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/59140048-d0f2-482b-8ec7-28bbf0126f63_1683741800.9033337.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53420,
                "title": "solution-with-user-defined-variables",
                "content": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "solutionTags": [],
                "code": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 3824916,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```\\nIF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/d5520730-3315-4ebe-a865-3a6bd4416173_1690477599.7336297.jpeg)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700299,
                "title": "faster-than-99-simple-self-join",
                "content": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 213003,
                "title": "",
                "content": "\\u5927\\u6982\\u4EE3\\u7801\\u8FD9\\u6837\\n```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```\\n\\u8BB0\\u5F97\\u52A0\\u4E2Adistinct\\uFF0C\\u4E0D\\u52A0\\u5C31\\u4F1A\\u6709\\u91CD\\u590D\\u7684",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214755,
                "title": "180-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we need to identify the rows that have at least two consecutive numbers equal to each other. We can do this by joining the table with itself twice, with the second copy offset by 1 row, and the third copy offset by 2 rows. If the values in the num column match for all three copies, then we have found a row where the number appears at least three times consecutively. We can use the DISTINCT keyword to remove duplicates and the ORDER BY keyword to sort the result table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\\nWe join the table Logs with itself three times, using aliases l1, l2, and l3. We then check that l1.num = l2.num and l2.num = l3.num, meaning that the number in the num column appears at least three times consecutively. We select the num column from the first copy of the table and use the DISTINCT keyword to remove duplicates.\\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```\\nIn this case, the only number that appears at least three times consecutively is 1.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53439,
                "title": "an-ugly-solution",
                "content": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "solutionTags": [],
                "code": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "codeTag": "Unknown"
            },
            {
                "id": 410442,
                "title": "sql-server-91-faster-using-lead",
                "content": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53447,
                "title": "simple-sql-with-join-1484-ms",
                "content": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1186678,
                "title": "easy-solution-can-be-extended-to-n-consecutive-numbers",
                "content": "This solution is the variation from https://leetcode.com/problems/consecutive-numbers/discuss/237228/My-version-is-more-flexible.-We-could-change-3-to-4-or-5-or-10\\n\\nThe solution provided was brilliant but no longer works in the latest tests because of UNSIGNED BIGINT OUT OF RANGE. This is caused by the negative results from the calculation of `id - row_number()`. By default, row_number() returns a number that is stored in UNSIGNED format, making the calculation result stored in UNSIGNED as well. This will encounter an error when a negative number is passed. (Actually there\\'s a more complex logic to convert them automatically)\\n\\nYou may not expect that `SELECT CAST(-1 AS UNSIGNED)` yields 18446744073709551615 , right? Always be careful when calculating numbers between UNSIGNED and SIGNED!!! Try to manually cast them into the same type before processing.\\n\\n```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53460,
                "title": "accepted-solution-without-joins-works-in-n-consecutive-cases-with-slight-modification",
                "content": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "solutionTags": [],
                "code": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 2243677,
                "title": "a-clean-solution-using-ctes-and-analytical-functions-mssql",
                "content": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997112,
                "title": "mysql-gaps-and-islands-problem-bigint-unsigned-value-is-out-of-range",
                "content": "This problem can be categorized as a gaps-and-islands problem.\\n\\nThe only issue is that there are test cases having id starts with 0 and that caused the error \"BIGINT UNSIGNED value is out of range\" which can be resolved by casting the row_number as signed. The cause of the error is \"Subtraction between integer values, where one is of type UNSIGNED, produces an unsigned result by default.\"\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\\n\\nOther ways of solving this problem includes,\\nself join:\\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\\n\\nLAG() / LEAD():\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548839,
                "title": "3-solutions-compared-performance-and-readability",
                "content": "# Option 1: Derived table\\n```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\\n- Performance: This option uses window functions to compare the current row with the previous and next rows. Window functions can be efficient, but the performance can be influenced by the size of the logs table and the ordering requirements. It\\'s important to ensure appropriate indexes are in place to support the window functions and sorting.\\n\\n- Readability: This option utilizes the power of window functions to compare consecutive rows. It expresses the logic succinctly, making it easier to understand for developers familiar with window functions. However, for those less familiar with window functions, the syntax and the concept of lag and lead functions might require some understanding.\\n\\n# Option 2: Joins\\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\\n- Performance: This option uses self-joins to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes on the `id` and `num` columns. Joins can be efficient, but it\\'s crucial to ensure the indexes are optimized.\\n- Readability: This option expresses the logic using self-joins, which can be more familiar to developers with SQL background. The joins represent the consecutive row comparison, and the logic is relatively straightforward to follow.\\n\\n# Option 3: Implicit Joins\\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```\\n- Performance: This option uses implicit joins in the WHERE clause to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes. Similar to Option 2, it\\'s important to optimize the indexes for better performance.\\n- Readability: Implicit joins can be less readable compared to explicit joins. While the logic is expressed using simple comparisons in the WHERE clause, it might require careful examination to understand the relationship between the joins and the consecutive row comparison.\\n\\n# Conclusion:\\n\\n- If performance is a top priority, Option 1 (Derived Table) is likely to perform well, especially if appropriate indexes are in place. Window functions can be efficient for comparing consecutive rows.\\n- If readability is a priority, Option 2 (Joins) might be the preferred choice. Self-joins are more familiar to SQL developers and can be easier to understand.\\n- Option 3 (Implicit Joins) may be less preferred in terms of readability due to the implicit nature of the joins.\\n\\nIt\\'s important to benchmark and test the performance of these options with your specific dataset and workload to determine the best-performing option in your environment. Unfortunately, leetcode runtime does not provide fair time, and is not supposed to used as such metric.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654155,
                "title": "mysql-lag-and-lead-window-functions",
                "content": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399362,
                "title": "simple-mysql-solution",
                "content": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "solutionTags": [],
                "code": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "codeTag": "Unknown"
            },
            {
                "id": 1720116,
                "title": "best-practice-for-row-number-and-subqueries",
                "content": "The solution may looks intimidating, but **the logic is very simple.**\\nIt is definitely **great** for anyone wants to practice the logic of using Window Function, RowNumber() and subqueries\\n\\n## Solution\\n``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\\n\\n## Explanation\\n### Let\\'s dive to the deepest nested subquery\\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\\nThis part\\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\\nmay be the most difficult part to understand\\n\\n![image](https://assets.leetcode.com/users/images/7dc764cb-d1d3-422e-bc71-2df5323e9118_1643164851.0240996.png)\\n\\nUsing the example provided in the question\\n\\nOn this image, notice that third column, row_number(), is as expected just producing the row index, which is the same value as id.\\n\\nHowever, one thing to notice is that the **order of id changes**, id 5 and id 4\\'s positions are exchanged. This is due to the last colum\\'s ```Partition By num```. ```Partition By``` works like ```Group By```, but display all the records and the record in the same group are displayed together. Therefore, to make sure all the 1s are displayed together, id 5 and id 4 are exchanged. Since we have also included ```order by id```, then in every group, the ids should be in ascending order.\\n\\nYou may wonder \"What\\'s the matter about the grouping with partition by? Isn\\'t every same number put in the same group, how can we find consecutive ones?\" \\n\\n**Note that your row number of the nums does not change** \\n\\nWhen you do a subtraction, you\\'ll see\\n![image](https://assets.leetcode.com/users/images/f6786f16-aace-41f6-884a-5305df029fd3_1643164944.063975.png)\\n\\nHey, those consecutive number have the same value(look at the 1s at the top and 2s at the bottom)\\n\\n#### Why those consecutive number have the same value?\\nNote that the first row_number() gives a row value to the nums, the second partition by in the row_number also gives a row value to the nums. The second row value increment 1 as id increases, no matter the value is consecutive or not. The first value increment 1 only if the nums are consecutive. If your nums are consecutive, then both value increment 1, thus the **difference is always the same**!\\n\\n### For the result of the query\\nYou are basically only grabing the part where values in the third column, \\'ConsecutiveGroup\\' or ```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ``` that are same and count for the number of consecutive value you want.\\n\\n## Comment Below if You have any question or confusion!!!\\n\\nThis solution is inspired by [@neilsons](https://leetcode-cn.com/u/neilsons/)",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\n```Partition By num```\n```Partition By```\n```Group By```\n```order by id```\n```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484648,
                "title": "three-lines-solution-easy-to-understand",
                "content": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261534,
                "title": "mysql-self-join-easy-and-simple",
                "content": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795404,
                "title": "a-general-solution-for-consecutive-problems",
                "content": "Posted solutions are very nice for 3 consecutive number. However, when the consecutive number becomes higher, for example 5, it become too much trouble to put 5 tables in the where clause.\\n\\nBelow is a code inspired by niradranjan\\' s solution on question #1454. It could work for any number of consecutive number.\\n\\n```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53467,
                "title": "explanation-of-consecutive-numbers-problems",
                "content": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "solutionTags": [],
                "code": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "codeTag": "Unknown"
            },
            {
                "id": 3516976,
                "title": "easy-solution-with-join-and-distinct",
                "content": "# code\\n\\n```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451973,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please Press Star ^ above**\\n\\nHere We Use JOIN two time\\n\\nFirst Time to check if first Consecutive number is coming above second Consecutive and same value.\\n```\\n a.id=b.id+1 AND a.num=b.num\\n```\\nSecond Time to check if first Consecutive number is coming above Third Consecutive and same value.\\n```\\na.id=c.id+2 AND a.num=c.num\\n```\\n**Code**\\n\\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n a.id=b.id+1 AND a.num=b.num\\n```\n```\\na.id=c.id+2 AND a.num=c.num\\n```\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696606,
                "title": "easiest-solution-simple",
                "content": "if you like it pls upvote\\n\\njust check three items , if they are in the order and their nums equal eachother just add to result.\\n\\n\\n```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292939,
                "title": "mysql-simple-solution-use-lag",
                "content": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255565,
                "title": "mysql-simple-easy-with-lead-and-lag",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 420588,
                "title": "simple-solution-mysql",
                "content": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "solutionTags": [],
                "code": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "codeTag": "Unknown"
            },
            {
                "id": 3370881,
                "title": "use-lead-and-lag-windows-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nM1: Using LEAD\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\\n\\nM2: Using LEAD and LAG\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097822,
                "title": "easy-simple-solution-using-window-function-lead-and-lag",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971912,
                "title": "easy-to-follow-solution-with-explanation-window-functions",
                "content": "**Runtime**: 426 ms, faster than 81.70% of MySQL online submissions\\n\\n**Solution**: \\n```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```\\n\\n**Explanation**:\\n\\nThis solution uses the `LAG()` and `LEAD()` window functions. As the name suggests, the `LAG` function has the ability to fetch data from a previous row, while `LEAD` fetches data from a subsequent row. You can visit [this website](https://www.mssqltips.com/sqlservertutorial/9127/sql-server-window-functions-lead-and-lag/) if you want to know more.\\n\\nFirst, we create a Common Table Expression (CTE) named `logs_lag_lead`. This CTE retrieves the `id` and `num` columns from the `Logs` table along with two new columns:\\n\\n- `lag_num`, which stores the preceding number (if one exists, else `null`), and\\n- `lead_num`, which stores the succeeding number (if one exists, else `null`).\\n\\nThe contents of the cte are shown below:\\n\\n![image](https://assets.leetcode.com/users/images/c2e62932-4a50-49f8-bded-cd88c5d05666_1650615007.1811059.png)\\n\\nNotice that when we have three consecutive numbers (first three rows, marked by the red rectangle), the row corresponding to the middle number will have an equal value for `num`, `lag_num`, and `lead_num` (marked by the blue rectangle). That\\'s because these two window functions retrieve the previous and following row values that are equal to `num`. \\n\\nWe finalise our solution by writing a simple query that contains the condition `num = lag_num AND num = lead_num` in the `WHERE` clause. Notice that we need to retrieve distinct rows. That\\'s because there might be more than three consecutive numbers; in that case, all middle rows will satisfy the `WHERE` condition, and the query will return the same number multiple times.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698703,
                "title": "faster-than-96-mysql-solution",
                "content": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1648643,
                "title": "easy-mysql-solution",
                "content": "Here is my simple yet effective MySQL Solution:\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444382,
                "title": "window-function-with-partition-flexible-with-any-consecutive-numbers",
                "content": "# **Solution 1: Use Window function, Partition by and order by**\\n\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n # **Solution 2: Multiple by 1.0 to float to avoid the bigINT error**\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n# **Problem Solving Process**\\nThis is the problem\\n![image](https://assets.leetcode.com/users/images/6eb3c961-7109-489b-8cd0-1752f369af96_1630774962.319755.png)\\n\\nWe partition the data by Nums and order by Id to get the row_number(). Then we calculate the difference between the id and row_number() to define as the new_group. \\n![image](https://assets.leetcode.com/users/images/188b2519-66a4-4c46-adfa-f5acee3cc033_1630774936.7532938.png)\\n\\nWe group by Nums and new_group and calcuate the count. We filter out the count >= number ( 3 in this problem)\\n![image](https://assets.leetcode.com/users/images/2ff1390a-9bfc-4f3b-aa38-e07fda3de015_1630775196.275442.png)\\n\\n# **Similar Problems**\\n1. 603. Consecutive Available Seats ( Easy )\\n2. 1811. Find Interview Candidates ( Medium )",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696618,
                "title": "distinct-lead-solution",
                "content": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53458,
                "title": "be-sure-to-use-order-by-id",
                "content": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "solutionTags": [],
                "code": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "codeTag": "Unknown"
            },
            {
                "id": 3109417,
                "title": "180-consecutive-numbers-too-hard-approach-sql-solution",
                "content": "**Understandable Solution using **`With Clouse` , `row_number() `and `order by `\\n1. use with clouse assume table as t1 Get Row number based on order id\\n2. Get number partition based on num order based on id\\n3. take the diffrence in 1 and 2 to get the diff\\n4. select distinct value based on num\\n5. just write condition  `having Count(*) >= n` ;  ``\\n```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658920,
                "title": "consecutive-numbers-easiest-approach",
                "content": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2016799,
                "title": "3-different-solutions",
                "content": "## Solution 1: window function `lag` and `lead`, beat 43%\\n\\n**Logic**: \\n1. for each row attach the previous number and next number next to the current number, and store in `cte`\\n2. condition the `cte` on current number = previous number = next number\\n3. select only `distinct` and rename to `ConsecutiveNums`\\n\\n```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\\n\\n### Solution 2: using `where`, beat 23%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\\n\\n### Solution 3: using `inner join`, beat 46%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803779,
                "title": "simplest-easy-mysql-solution-180-consecutive-numbers",
                "content": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529243,
                "title": "mysql-two-methods",
                "content": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "codeTag": "Unknown"
            },
            {
                "id": 1411179,
                "title": "easy-to-understand-mysql-solution",
                "content": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000765,
                "title": "faster-than-90",
                "content": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874390,
                "title": "use-distinct-and-dense-rank-row-number",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u9898\\u76EE\\u8981\\u6C42\\u627E\\u51FA\\u8FDE\\u7EED3\\u4E2A\\u76F8\\u540CNum\\u7684\\u8BB0\\u5F55\\n\\u4E00\\u5F00\\u59CB\\u4E5F\\u60F3\\u4E0D\\u51FA\\u89E3\\u6CD5\\uFF0C\\u867D\\u7136\\u8FD9\\u4E2A\\u4EBA\\u773C\\u770B\\u662F\\u633A\\u7B80\\u5355\\u7684\\n\\u7ECF\\u641C\\u7D22\\u53D1\\u73B0\\u4E00\\u4E2A\\u5173\\u952E\\u70B9\\uFF0C\\u5C31\\u662F\\u5982\\u679C\\u6570\\u5B57\\u8FDE\\u7EED\\uFF0C\\u90A3\\u4E48\\u4ED6\\u4EECid\\u589E\\u957F\\u548C\\u5206\\u7EC4\\u5185\\u6392\\u5E8F\\u7684\\u589E\\u957F\\u901F\\u5EA6\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\n\\u53C2\\u8003  https://blog.csdn.net/iteye_20478/article/details/82202514?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf[](http://)\\n*\\u56E0\\u4E3Adenserank() \\u548Crownum\\u90FD\\u662F\\u8FDE\\u7EED\\u7684\\u8BA1\\u6570\\u7684\\uFF0C\\u4E00\\u4E2A\\u662F\\u5168\\u5C40\\u8BA1\\u6570\\uFF0C\\u4E00\\u4E2A\\u662F\\u5C40\\u90E8\\u5206\\u7EC4\\u8BA1\\u6570\\uFF0C\\u56E0\\u6B64\\uFF0C\\u4E24\\u4E2A\\u9012\\u589E\\u9891\\u7387\\u90FD\\u662F1\\u7684\\u8FDE\\u7EED\\u76F8\\u51CF\\uFF0C\\u503C\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\uFF0C\\u6BD4\\u5982 \\u5168\\u5C40\\u4E3A 1,2,3,4,5\\uFF0C\\u5206\\u7EC4\\u4E3A 1,2 \\uFF1B1;1,2 \\u7ED3\\u679C 1-1=0,2-2=0\\uFF1B 3-1=2\\uFF1B 4-1=3,5-2=3\\uFF1B \\u56E0\\u6B64 1,2\\uFF1B4,5\\u662F\\u8FDE\\u7EED\\u7684*\\n\\u6240\\u4EE5\\u8FD9\\u9898\\u4F7F\\u7528row_number\\u5E94\\u8BE5\\u4E5F\\u53EF\\u4EE5,\\u8BD5\\u4E86\\u4E00\\u4E0B\\u8FD8\\u5FEB1ms\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u7136\\u540E\\u4F7F\\u7528group by\\u6309Num\\u548C\\u5DEE\\u503C\\u5206\\u7EC4\\n\\u6700\\u540E\\u63D0\\u4EA4\\u7684\\u65F6\\u5019\\u53D1\\u73B0\\u8F93\\u5165\\u7684\\u8BB0\\u5F55\\u91CD\\u590D\\u5F88\\u591A\\uFF0C\\u8FD8\\u8981\\u7528distinct\\u53BB\\u91CD\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820303,
                "title": "mysql-using-just-count-easy-to-be-generalized",
                "content": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767760,
                "title": "simple-mysql",
                "content": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "solutionTags": [],
                "code": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 256431,
                "title": "sql-server-mysql-faster-than-75-join-table-two-times-with-its-own-easy-to-understand",
                "content": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53442,
                "title": "who-said-the-id-increments-by-1",
                "content": "There has been posted many solutions assuming that next row should be identified with Id = Id + 1. As there is no explicit reference in the condition for that, I considered it is fair to give a generic case solution. It is built around a view that identifies the next element:\\n```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\\nWith the original example it'll produce a rather trivial table:\\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\\nAnother view appends a value for the next element:\\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\\nAnd the last query finally \\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```\\nUnfortunately, creating a view is denied by the OJ: \"CREATE VIEW command denied to user 'student'@'localhost' for table 'Next'\".\\nOtherwise it seems reasonable solution working on my private MySQL DB just fine.",
                "solutionTags": [],
                "code": "```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899091,
                "title": "easy-approach-using-nested-query-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explanatory.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing nested queries.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523717,
                "title": "mysql-solution-for-consecutive-numbers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve all the numbers that appear consecutively three or more times in the Logs table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a subquery to select the Num column from the Logs table, along with a calculated column freq that represents the frequency of each number in the sequence of numbers.\\n2. Use the @prev and @cnt variables to keep track of the previous number and the frequency of the current number, respectively.\\n3. If the current number is the same as the previous number, increment the frequency by 1. Otherwise, reset the frequency to 1.\\n4. Use the outer query to select the distinct numbers that have a frequency greater than 2 (i.e., appear consecutively three or more times).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the Logs table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a subquery with a GROUP BY clause is O(n * log n), where n is the number of rows in the table. However, the use of variables to calculate the frequency may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the number of distinct numbers that appear consecutively three or more times in the Logs table. Therefore, the space complexity is O(k), where k is the number of distinct numbers that meet the criteria. The space used by the variables @prev and @cnt is constant, so it does not affect the overall space complexity.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484633,
                "title": "easiest-and-clear-approach",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324154,
                "title": "mysql-solution",
                "content": "# Code 1\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\\n\\n# Code 2\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322142,
                "title": "runtime-129-ms-beats-96-28-one-solution-for-mysql-ms-sql-and-oracle",
                "content": "\\n\\n# Approach\\nUsing $$LAG$$ and $$LEAD$$ to get the numbers before and after the current number\\n\\n\\n\\n# Code\\n```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\\n\\n# Explanation\\n\\n\\nSince, we want to find a number appearing three consecutive times, we need to select a particular number whose previous and next numbers are the same.\\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```\\nThis part of code will give us the selected columns. You can verify your output is correct by checking if *prev_num* for the first num and *next_num* for the last num are *NULL*.\\n\\nThen, we simply need to find numbers that have the same value in three columns i.e., *num*, *prev_num* and *next_num*. Put *DISTINCT* keyword in the outer *SELECT* statement to get unique values.\\n\\nCheck out LAG and LEAD functions on this URL:\\nhttps://learnsql.com/blog/lead-and-lag-functions-in-sql/\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661795,
                "title": "left-join",
                "content": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551312,
                "title": "180-consecutive-numbers",
                "content": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2507961,
                "title": "mysql-windows-functions",
                "content": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "solutionTags": [],
                "code": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386497,
                "title": "mysql-lead-lag-no-joins",
                "content": "Problem is really easy if you are aware of some window functions.\\n**LAG(col_name)** function returns previous record from col_name\\n**LEAD(col_name**) function returns next record from col_name\\n\\nAdditionally you can specify offset and default value.\\n\\n```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314821,
                "title": "mysql-multiple-approaches-cte-inner-join-cross-join-subqueries",
                "content": "1. Using `CROSS JOIN`:\\n```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\\n\\n2. Using subqueries:\\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\\n\\n3. Using `INNER JOIN`:\\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\\n\\n4. Using Common Table Expressions with `LAG` and `LEAD`:\\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```\\n\\n* All solutions will work if the id is incremented regularly (as stated in the problem description). If that\\'s not the case, only the last one will work.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189466,
                "title": "simple-and-fast-sql-solution",
                "content": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1594501,
                "title": "combined-lead-with-lag-in-window-function",
                "content": "What I did was I used the function LEAD and LAG to give me the values after and before, added a condition where they are equal to each other, AND added another condition where either one of those values is equal to the number being evaluated.\\n\\n```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "solutionTags": [],
                "code": "```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497543,
                "title": "beats-100",
                "content": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1360281,
                "title": "used-window-function-ms-sql-server-solution",
                "content": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128822,
                "title": "mysql-solution-with-windows-function",
                "content": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "solutionTags": [],
                "code": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "codeTag": "Unknown"
            },
            {
                "id": 1040628,
                "title": "easy-mysql-solution-w-joins",
                "content": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851140,
                "title": "expandable-solution-using-recursive-cte",
                "content": "The given solution of 2 offest inner joins makes the most sense if the \"consecutive number\" you\\'re looking for is guaranteed to be fixed. But if it was a parameter in a stored procedure or something I think the below solution works better.\\n\\nThis has the same issue as the inner join solution in that it relies on the Id being guaranteed consecutive, which might not be the case in the real world. This could be solved by first dumping the necessary data into a temp table and including a ROW_NUMBER() column, and using that in place of the Id.\\n\\nAnother potential issue is that I\\'m not sure how it would scale with a very large dataset. If you\\'re looking at data in the 100,000+ rows range, and still need the consecutive number you\\'re checking to be dynamic, then maybe a cursor, a while loop, or dynamic SQL would perform better.\\n\\n```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836424,
                "title": "intuitive-solution",
                "content": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687891,
                "title": "simple-ms-sql-solution-with-row-number",
                "content": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 500601,
                "title": "without-using-join-and-it-beat-98-75",
                "content": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498428,
                "title": "mysql-two-methods",
                "content": "The performance of below methods/implementations are very comparable. \\n\\nMethod 1 - `JOIN`\\nBelow are the various flavors for implementations. \\n\\n(396ms, 98.91%):\\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(337ms, 99.08%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(326ms, 99.25%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\nMethod 2 - variables (276ms, 99.69%): \\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468726,
                "title": "ms-sql-solution",
                "content": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238029,
                "title": "simple-sql-solution",
                "content": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133361,
                "title": "oracle-solution-with-lead-window-function",
                "content": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "solutionTags": [],
                "code": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4067837,
                "title": "using-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to find the number which was repeated consecutively three times we are self joining the original table three times by comparing the num value in the first table with the num value in the second table and num value in the second table with the num value in the third table.As mentioned in the problem statement as id is incremented by 1 for every new row.We are joining the tables based on the condition id in the first table should combine with the (id+1) row in the second table when both num values are equal and id in the second table should combine with the (id+1) row in the third table when both num values match\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043322,
                "title": "using-cte-and-lag-lead",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881598,
                "title": "pandas-filter-over-diff-and-diff-diff",
                "content": "# Intuition\\nIf values appear twice in a row, then `.diff() == 0`.\\nif they appear thrice, then `.diff().diff() == 0` as well\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf a value appears a second time consecutively, then `.diff() == 0` for the lower row. If it appears a third time then `.diff() == 0` both for the third and second row. Hence, for the last (third) row we also have `.diff().diff() == 0.` Thus, we arrive at a laconic way to filter values which are consecutive triplicates: `.diff() == 0 & .diff().diff() == 0`. \\n\\nNote that in the actual code we must add `()` around the two conditions since `&` has precedence over `==`. This is because `&` in Python means binary `and` which conventionally precedes equality `==`. However, in `pandas` and `numpy` `&` is overloaded for arrays to function as a vectorized `and`.\\n\\nThe rest of the code is trivial: only keep `num`, drop duplicates, rename column to fit required output format.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ since the table comes sorted\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ bound by worst-case output size\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3867334,
                "title": "easy-solution-using-lead-and-lag-window-function",
                "content": "Lead funtion is used to find the next record and lag is used to find the previous record. I\\'m just comparing whether next number and previous number and current number are equal.\\n\\nUsed CTE (common table expression) for adding lead and lag.\\n\\n```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862867,
                "title": "one-tough-problem-to-solve-but-we-are-tougher-than-this",
                "content": "# Intuition\\nFInd consecutive number which appears three times.\\nWe need to solve this problem using Three columns and assigning equality operator\\n\\n# Approach\\nUse Lag to get previous Number,\\nLead to get Next Number,\\nNum is current Num \\nWhen Curr Num is equal to previous Num and Next Num we know that the number appeared atleast three times in a row\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545415,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433334,
                "title": "mssql-solution-using-lead",
                "content": "# Approach\\nWe can use LEAD() to see what the num values are one and two ids ahead of the current id. If we store these values in a CTE, we can reference them later in the WHERE statement and isolate nums that are the same as one and two ids ahead.\\n\\n# Code\\n```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373892,
                "title": "oracle-easy-solution-2-lines",
                "content": "# Intuition\\n-First, decide that you want to show only the distinct element\\n-Then, think how you are going to put condition in it\\n\\n# Approach\\n-I have said that if the number that we have chosen from Logs table is equal to numbers from logs table with id=id+1 and id=id+2 then that number should be displayed.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327383,
                "title": "simple-lag-window-functions",
                "content": "# Intuition\\nSimple lag Window functions\\n\\n# Approach\\nUsing lag window function to find elements 1 lag and 2 lag away and comparing them against the current number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158342,
                "title": "simple-join-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888747,
                "title": "consecutive-number-with-cte-lead-over",
                "content": "# Intuition\\nComparing rows to find the consecutive sequence \\n\\n# Approach\\nUse CTE to define value from row, row+1 and row+2 using LEAD() OVER() function by id, and then select the distinct value where the conditions are met in sequence\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674379,
                "title": "simple-solution",
                "content": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644029,
                "title": "mysql-lead-over",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601896,
                "title": "clean-simple",
                "content": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "solutionTags": [],
                "code": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "codeTag": "Unknown"
            },
            {
                "id": 2547902,
                "title": "simple-and-easy-to-understand-using-window-function",
                "content": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2327239,
                "title": "simple-lag-lead-solution-for-beginners",
                "content": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317121,
                "title": "oracle",
                "content": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "codeTag": "Unknown"
            },
            {
                "id": 2277787,
                "title": "cte-using-lag-and-lead",
                "content": "This one was kind of tricky and at first I was doing my ORDER BY in the OVER() function by number. But that doesn\\'t make sense since we are looking at order of each number BY id value: so we really want to order the OVER() function by ID not by number:\\n\\nCODE:\\n```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "solutionTags": [],
                "code": "```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271059,
                "title": "with-triple-self-join",
                "content": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "solutionTags": [],
                "code": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2260423,
                "title": "t-sql-with-only-self-joins",
                "content": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202207,
                "title": "mysql-lead-lag-easy-fast-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135338,
                "title": "mysql-solutions",
                "content": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128640,
                "title": "mssql-mysql-query-statement",
                "content": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123589,
                "title": "using-self-joins",
                "content": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2061109,
                "title": "simple-mysql-solution-for-this-tough-question-explanation-in-comments",
                "content": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030606,
                "title": "using-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1995624,
                "title": "logic-that-works-for-all-consecutive-questions",
                "content": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1981277,
                "title": "mysql-easy-solution-two-approaches-window-function-and-inner-join",
                "content": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890960,
                "title": "mysql-solution",
                "content": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861792,
                "title": "2-solutions-with-and-without-window-functions",
                "content": "With window function LAG:\\n\\n```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\\n\\nWith JOIN (faster):\\n\\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813485,
                "title": "easy-solution-2-approaches",
                "content": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575044,
                "title": "ms-sql-faster-than-99-01",
                "content": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "solutionTags": [],
                "code": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1569990,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```\\nSimilar to id == id - 1 && id - 1 == id - 2",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524966,
                "title": "using-rank-can-be-customized-on-any-number-of-consecutive-time",
                "content": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430260,
                "title": "ms-sql-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392637,
                "title": "classical-gaps-islands-problem-window-functions",
                "content": "\\n```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```\\n\\nSee for more details https://explainextended.com/2011/02/18/things-sql-needs-series/",
                "solutionTags": [],
                "code": "```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313518,
                "title": "easiest-solution-which-works-for-any-number-of-consecutive-asked",
                "content": "In the solution below, we select distinct numbers that appear consecutively atleast 3 times. The @counter and @prev are pointer variables. These variables scan the entire table and keep a count of the numbers in the @counter variable whereas @prev keeps track of the previous number to match with the next. If @prev is same as the current row Num, then @counter is increased by 1, else @counter remains valued at 1. @prev is now set to the recently encountered Num. table1 is an alias for the temporary table containing Num and the occurrences column. SELECT @counter:=1, @prev:=NULL is for the first record encountered.\\n```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308569,
                "title": "sql",
                "content": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1286043,
                "title": "easy-mysql-query",
                "content": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "solutionTags": [],
                "code": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 1220736,
                "title": "ms-sql-simple-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150002,
                "title": "mysql-using-lag-and-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146422,
                "title": "ms-sql-using-lead",
                "content": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024006,
                "title": "lag-lead",
                "content": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014073,
                "title": "tsql-100-time-space-using-cte-lag-and-lead",
                "content": "\\nCreate a CTE (nums), creating additional before and after columns for each num. Use `DISTINCT` and simple logical operators\\nand your off!\\n```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "solutionTags": [],
                "code": "```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989843,
                "title": "using-self-join-70-faster",
                "content": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "solutionTags": [],
                "code": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 955363,
                "title": "using-recursive-cte-scalable-to-any-variable",
                "content": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954556,
                "title": "find-consecutive-numbers-with-just-inner-joins-and-where-clause",
                "content": "Here is my code for just using  Inner Joins and Where clause (T-SQL).\\n\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930813,
                "title": "mysql-very-easy-to-understand",
                "content": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "solutionTags": [],
                "code": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "codeTag": "Unknown"
            },
            {
                "id": 843375,
                "title": "mysql-self-join",
                "content": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "solutionTags": [],
                "code": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 802658,
                "title": "simple-mysql-with-lead",
                "content": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793378,
                "title": "ms-sql-server",
                "content": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769884,
                "title": "ms-sql-using-lag-function",
                "content": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 714701,
                "title": "mysql-soln-faster-than-97-8",
                "content": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 637730,
                "title": "msql-very-easy-solution-cross-join",
                "content": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "solutionTags": [],
                "code": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 524379,
                "title": "no-assumption-on-id-uses-lag",
                "content": "no reason to believe the ID numbers are consecutive or give the relevant ordering... if this column was `row_number` or something then it would be reasonable to use it. \\n\\ni\\'m using `lag()` here with `order by null` to leave the ordering as is (and because `order by` specification is mandatory). i couldn\\'t find anything in the docs to support my assumption about the `NULL` behavior but i guess [ppl use it](https://stackoverflow.com/questions/25377014/what-does-this-mean-order-by-null).\\n\\n```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282107,
                "title": "simple-mysql-tuple-check-fast",
                "content": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "solutionTags": [],
                "code": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 185180,
                "title": "solution-without-using-id",
                "content": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "solutionTags": [],
                "code": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172590,
                "title": "my-solution",
                "content": "The idea is from '178.Rank Score'. https://leetcode.com/problems/rank-scores/discuss/53094/Simple-Short-Fast\n\n'''\nSELECT DISTINCT T1.Num ConsecutiveNums\nFROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      GROUP BY Rank\n      HAVING COUNT(Rank) >=3) T1;\n\t\t\t'''",
                "solutionTags": [],
                "code": "FROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      HAVING COUNT(Rank) >=3) T1;",
                "codeTag": "Unknown"
            },
            {
                "id": 140359,
                "title": "simple-solution-no-variables-beats-100-310-ms",
                "content": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 137203,
                "title": "t-sql-windows-function-lag-lead",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53464,
                "title": "solution-sharing",
                "content": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "solutionTags": [],
                "code": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 4078209,
                "title": "python-intuitive-answer-vs-swe-appproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse `rolling()` function to look at windows of size 3\\n\\ncheck if the window has all the same number either using\\n\\n1. `len(set(lst)) == 1`\\n\\nor\\n\\n2. `lst.nunique() == 1`\\n\\nThen do a simple select distinct, filter, and rename to format your output\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\\n\\n\\n# The SWE way\\n\\nSliding window using 2 pointers. \\n\\nPro: intuitive\\nCon: not in the style of data analyst/engineer\\n\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975767,
                "title": "unique-and-simple-approach-using-join-only",
                "content": "\\n\\n# PLEASE UPVOTE\\n\\n\\n```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908675,
                "title": "indexing-with-join-operation",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866747,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582251,
                "title": "simple-mysql-solution-using-select",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339622,
                "title": "correct-approach-to-get-the-answer-in-three-3-lines",
                "content": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "codeTag": "Unknown"
            },
            {
                "id": 2801130,
                "title": "oracle-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584833,
                "title": "simple-mysql",
                "content": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2559254,
                "title": "simple-solution-with-lag",
                "content": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554031,
                "title": "sql-easy-self-join-solution",
                "content": "self joining and comparing the id values and by incrementing and comparing num values.\\n```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539036,
                "title": "mysql-2-simple-solutions",
                "content": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510165,
                "title": "mysql-consecutive-numbers-sol-500ms",
                "content": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491554,
                "title": "by-using-only-where-clause",
                "content": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576547,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576529,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576217,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1575200,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574803,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574675,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573730,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573254,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1572978,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2076376,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2055133,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2034541,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2033887,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2009540,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1987675,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1981201,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1968192,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964519,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964515,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1928129,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1894173,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1891502,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1886034,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1885098,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1876500,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1840378,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1834277,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1823743,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1812353,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1811468,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1798581,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1783851,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1774651,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1771052,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1770055,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1767919,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1761908,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1750843,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736853,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736542,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1734397,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1722840,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1719668,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1714715,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1705254,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1692697,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682725,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682689,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1672485,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1666852,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            }
        ]
    },
    {
        "title": "Wiggle Sort",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            }
        ]
    },
    {
        "title": "Insert Delete GetRandom O(1)",
        "question_content": "<p>Implement the <code>RandomizedSet</code> class:</p>\n\n<ul>\n\t<li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li>\n\t<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li>\n\t<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li>\n\t<li><code>int getRandom()</code> Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called). Each element must have the <b>same probability</b> of being returned.</li>\n</ul>\n\n<p>You must implement the functions of the class such that each function works in&nbsp;<strong>average</strong>&nbsp;<code>O(1)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>Output</strong>\n[null, true, false, true, 2, true, false, 2]\n\n<strong>Explanation</strong>\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>2 *&nbsp;</code><code>10<sup>5</sup></code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>\n\t<li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 85401,
                "title": "java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms",
                "content": "I got a similar question for my phone interview. The difference is that the duplicated number is allowed. So, think that is a follow-up of this question.\\nHow do you modify your code to allow duplicated number?\\n \\n```\\npublic class RandomizedSet {\\n    ArrayList<Integer> nums;\\n    HashMap<Integer, Integer> locs;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        nums = new ArrayList<Integer>();\\n        locs = new HashMap<Integer, Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( contain ) return false;\\n        locs.put( val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( ! contain ) return false;\\n        int loc = locs.get(val);\\n        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val\\n            int lastone = nums.get(nums.size() - 1 );\\n            nums.set( loc , lastone );\\n            locs.put(lastone, loc);\\n        }\\n        locs.remove(val);\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    ArrayList<Integer> nums;\\n    HashMap<Integer, Integer> locs;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        nums = new ArrayList<Integer>();\\n        locs = new HashMap<Integer, Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( contain ) return false;\\n        locs.put( val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( ! contain ) return false;\\n        int loc = locs.get(val);\\n        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val\\n            int lastone = nums.get(nums.size() - 1 );\\n            nums.set( loc , lastone );\\n            locs.put(lastone, loc);\\n        }\\n        locs.remove(val);\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85422,
                "title": "ac-c-solution-unordered-map-vector",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85397,
                "title": "simple-solution-in-python",
                "content": "We just keep track of the index of the added elements, so when we remove them, we copy the last one into it.\\n\\nFrom Python docs (https://wiki.python.org/moin/TimeComplexity) we know that `list.append()` takes O(1), both average and amortized. Dictionary `get` and `set` functions take O(1) average, so we are OK.\\n\\n```\\nimport random\\n\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.nums, self.pos = [], {}\\n        \\n    def insert(self, val):\\n        if val not in self.pos:\\n            self.nums.append(val)\\n            self.pos[val] = len(self.nums) - 1\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            idx, last = self.pos[val], self.nums[-1]\\n            self.nums[idx], self.pos[last] = last, idx\\n            self.nums.pop(); self.pos.pop(val, 0)\\n            return True\\n        return False\\n            \\n    def getRandom(self):\\n        return self.nums[random.randint(0, len(self.nums) - 1)]\\n\\n# 15 / 15 test cases passed.\\n# Status: Accepted\\n# Runtime: 144 ms\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.nums, self.pos = [], {}\\n        \\n    def insert(self, val):\\n        if val not in self.pos:\\n            self.nums.append(val)\\n            self.pos[val] = len(self.nums) - 1\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            idx, last = self.pos[val], self.nums[-1]\\n            self.nums[idx], self.pos[last] = last, idx\\n            self.nums.pop(); self.pos.pop(val, 0)\\n            return True\\n        return False\\n            \\n    def getRandom(self):\\n        return self.nums[random.randint(0, len(self.nums) - 1)]\\n\\n# 15 / 15 test cases passed.\\n# Status: Accepted\\n# Runtime: 144 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455253,
                "title": "python-super-efficient-detailed-explanation",
                "content": "In python, creating a simple api for a set() would be a perfect solution if not for the third operation, getRandom(). We know that we can retrieve an item from a set, and not know what that item will be, but that would not be actually random. (This is due to the way python implements sets. In python3, when using integers, elements are popped from the set in the order they appear in the underlying \\nhashtable. Hence, not actually random.)\\n\\nA set is implemented essentially the same as a dict in python, so the time complexity of add / delete is on average O(1). When it comes to the random function, however, we run into the problem of needing to convert the data into a python list in order to return a random element. That conversion will add a significant overhead to getRandom, thus slowing the whole thing down.\\n\\nInstead of having to do that type conversion (set to list) we can take an approach that involves maintaining both a list and a dictionary side by side. That might look something like:\\n\\n```\\ndata_map == {4: 0, 6: 1, 2: 2, 5: 3}\\ndata == [4, 6, 2, 5]\\n```\\n\\nNotice that the key in the `data_map` is the element in the list, and the value in the `data_map` is the index the element is at in the list. \\n\\nLet\\'s look at the implementation:\\n\\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.data_map = {} # dictionary, aka map, aka hashtable, aka hashmap\\n        self.data = [] # list aka array\\n\\n    def insert(self, val: int) -> bool:\\n\\n        # the problem indicates we need to return False if the item \\n        # is already in the RandomizedSet---checking if it\\'s in the\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.data_map:\\n            return False\\n\\n        # add the element to the dictionary. Setting the value as the \\n        # length of the list will accurately point to the index of the \\n        # new element. (len(some_list) is equal to the index of the last item +1)\\n        self.data_map[val] = len(self.data)\\n\\n        # add to the list\\n        self.data.append(val)\\n        \\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n\\n        # again, if the item is not in the data_map, return False. \\n        # we check the dictionary instead of the list due to lookup complexity\\n        if not val in self.data_map:\\n            return False\\n\\n        # essentially, we\\'re going to move the last element in the list \\n        # into the location of the element we want to remove. \\n        # this is a significantly more efficient operation than the obvious \\n        # solution of removing the item and shifting the values of every item \\n        # in the dicitionary to match their new position in the list\\n        last_elem_in_list = self.data[-1]\\n        index_of_elem_to_remove = self.data_map[val]\\n\\n        self.data_map[last_elem_in_list] = index_of_elem_to_remove\\n        self.data[index_of_elem_to_remove] = last_elem_in_list\\n\\n        # change the last element in the list to now be the value of the element \\n        # we want to remove\\n        self.data[-1] = val\\n\\n        # remove the last element in the list\\n        self.data.pop()\\n\\n        # remove the element to be removed from the dictionary\\n        self.data_map.pop(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n        # if running outside of leetcode, you need to `import random`.\\n        # random.choice will randomly select an element from the list of data.\\n        return random.choice(self.data)\\n```\\n\\nNotes:\\n\\n1) this can be made more efficient by removing the variables `last_elem_in_list` and `index_of_elem_to_remove`. I have used this to aid in readability. \\n2) the remove operation might appear complicated so here\\'s a before and after of what the data looks like:\\n\\n```\\nelement_to_remove = 7\\n\\nbefore:     [4, 7, 9, 3, 5]\\nafter:      [4, 5, 9, 3]\\n\\nbefore:     {4:0, 7:1, 9:2, 3:3, 5:4}\\nafter:      {4:0, 9:2, 3:3, 5:1}\\n```\\n\\nAll we\\'re doing is replacing the element in the list that needs to be removed with the last element in the list. And then we update the values in the dictionary to reflect that.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndata_map == {4: 0, 6: 1, 2: 2, 5: 3}\\ndata == [4, 6, 2, 5]\\n```\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.data_map = {} # dictionary, aka map, aka hashtable, aka hashmap\\n        self.data = [] # list aka array\\n\\n    def insert(self, val: int) -> bool:\\n\\n        # the problem indicates we need to return False if the item \\n        # is already in the RandomizedSet---checking if it\\'s in the\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.data_map:\\n            return False\\n\\n        # add the element to the dictionary. Setting the value as the \\n        # length of the list will accurately point to the index of the \\n        # new element. (len(some_list) is equal to the index of the last item +1)\\n        self.data_map[val] = len(self.data)\\n\\n        # add to the list\\n        self.data.append(val)\\n        \\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n\\n        # again, if the item is not in the data_map, return False. \\n        # we check the dictionary instead of the list due to lookup complexity\\n        if not val in self.data_map:\\n            return False\\n\\n        # essentially, we\\'re going to move the last element in the list \\n        # into the location of the element we want to remove. \\n        # this is a significantly more efficient operation than the obvious \\n        # solution of removing the item and shifting the values of every item \\n        # in the dicitionary to match their new position in the list\\n        last_elem_in_list = self.data[-1]\\n        index_of_elem_to_remove = self.data_map[val]\\n\\n        self.data_map[last_elem_in_list] = index_of_elem_to_remove\\n        self.data[index_of_elem_to_remove] = last_elem_in_list\\n\\n        # change the last element in the list to now be the value of the element \\n        # we want to remove\\n        self.data[-1] = val\\n\\n        # remove the last element in the list\\n        self.data.pop()\\n\\n        # remove the element to be removed from the dictionary\\n        self.data_map.pop(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n        # if running outside of leetcode, you need to `import random`.\\n        # random.choice will randomly select an element from the list of data.\\n        return random.choice(self.data)\\n```\n```\\nelement_to_remove = 7\\n\\nbefore:     [4, 7, 9, 3, 5]\\nafter:      [4, 5, 9, 3]\\n\\nbefore:     {4:0, 7:1, 9:2, 3:3, 5:4}\\nafter:      {4:0, 9:2, 3:3, 5:1}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858286,
                "title": "python3-hashmap-list-got-this-in-google-phone-interview",
                "content": "I had this problem a long time ago in a phone interview with Google and passed it with a hint from the interviewer. Here is what happened:\\n - I started to give the most naive approach.\\n - **init**: create a empty list ```arr```. O(1)\\n - **insert**: Append a new ```val``` to the ```arr```. O(1)\\n - **remove**: Find the index of the ```val``` in the array using ```self.arr.index(val)```, and remove it. O(n)\\n - **getRandom**: random.choice(self.arr) O(1)\\n\\nThe time complexity is O(n) for **remove**, which is not right. So I started to optimize it.\\n - I knew that the indices in the array were important, but I wasn\\'t sure why or what to do with them. So I just created an empty hashmap ```indices```, while talking to the interviewer just to buy myself some time and hopping to get some information from the interviewer.\\n - I modified ```insert``` and ```remove``` by updating the indices when there is a new ```val```, or I need to remove a ```val```.\\n - **Then I got stuck**, I started thinking (and also talking to the interviewer) about how to get the index of ```val``` in ```arr```, will binary search work here somehow? (obviously, I\\'m on the wrong track because remove an element in a list is O(n))\\n - The interviewer was kindly enough and said, **Think about how to remove an element in a list in O(1)**)\\n - **There is only one way, which is arr.pop()**\\n - Then I started to think in this direction, **If I want to remove an element, I need to put it to the end of the ```arr```, and pop it**\\n - What about the element which was originally at the end? I can put it to the position where the ```val``` need to be removed.\\n - Then the algorithm is obvious, \\n (1) Get the index ```i``` of the ```val``` from ```indices```.\\n (2) Update the index of ```arr[-1]``` to ```i``` in the ```indices```, \\n (3) Move the last element ```arr[-1]``` to the i th position.\\n (4) ```pop``` the last element from ```arr``` and remove ```val``` from ```indices```.\\n \\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Store the index of each val in self.arr.\\n        self.indices = {}\\n        # Store all vals.\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        # Return False if val is already present as requested.\\n        if val in self.indices: return False\\n        \\n        # Append val to the array.\\n        # Store its index in the hashmap\\n        self.arr.append(val)\\n        self.indices[val] = len(self.arr)-1\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        # Return False if val is not present as requested.\\n        if val not in self.indices: return False\\n        \\n        # Get the index of the val that needs to be removed.\\n        i = self.indices[val]\\n        \\n        # Update the index of arr[-1] in the indices.\\n        self.indices[self.arr[-1]] = i\\n        \\n        # Move the last element to the i th position.\\n        self.arr[i] = self.arr[-1]\\n        \\n        # remove the last element, and remove the index of val\\n        self.indices.pop(val)\\n        self.arr.pop()\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n```\\n\\nNow try the follow up question **[381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/submissions/detail/877869802/)**\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```arr```\n```val```\n```arr```\n```val```\n```self.arr.index(val)```\n```indices```\n```insert```\n```remove```\n```val```\n```val```\n```val```\n```arr```\n```arr```\n```val```\n```i```\n```val```\n```indices```\n```arr[-1]```\n```i```\n```indices```\n```arr[-1]```\n```pop```\n```arr```\n```val```\n```indices```\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Store the index of each val in self.arr.\\n        self.indices = {}\\n        # Store all vals.\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        # Return False if val is already present as requested.\\n        if val in self.indices: return False\\n        \\n        # Append val to the array.\\n        # Store its index in the hashmap\\n        self.arr.append(val)\\n        self.indices[val] = len(self.arr)-1\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        # Return False if val is not present as requested.\\n        if val not in self.indices: return False\\n        \\n        # Get the index of the val that needs to be removed.\\n        i = self.indices[val]\\n        \\n        # Update the index of arr[-1] in the indices.\\n        self.indices[self.arr[-1]] = i\\n        \\n        # Move the last element to the i th position.\\n        self.arr[i] = self.arr[-1]\\n        \\n        # remove the last element, and remove the index of val\\n        self.indices.pop(val)\\n        self.arr.pop()\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377728,
                "title": "c-optimal-array-unordered-map-commented-explained-solution-average-time-o-1",
                "content": "**Approach:**\\n\\nThe order of elements is not important in the data structure. If we use an array as the data structure, insertion at the end will be in O(1) time but searching whether the element is already present in the array will take O(N) time. Removal of the element will require searching for the element which will take O(N) time and left shifting the subsequent array elements will also take O(N) time. Getting random element will take O(1) time using the rand() function. So, we need some additional data structure that allows us to locate the array index for removal and also to search whether the element is already present or not. This data structure should do these tasks in **average O(1) time**. Hashmap fulfils our requirements.\\n\\n**Optimal Solution** \\n\\n\\n```\\nclass RandomizedSet {\\n\\t// Average Time O(1) & Auxiliary Space O(N)\\nprivate:\\n    vector<int> a; // array vector\\n    unordered_map<int,int> m; // Unordered Map does searching, insertion & deletion of element in average O(1) time\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    \\n    /** Inserts a value to the array vector. Returns true if the array did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to the successive memory location  \\n            // from the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  // insert val at the end of the array\\n            m[val]=a.size()-1; // unordered_map[key]=value stores the array element and \\n\\t\\t\\t                   // its index as key=array element & value=array element index\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the array vector. Returns true if the array contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n\\t        // For example: a=[8,4,3,2], m={[8,0],[4,1],[3,2],[2,3]}, val=4, last=2\\n\\t        // After a[m[val]]=a.back(); a=[8,2,3,2], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After a.pop_back(); a=[8,2,3], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After m[last]=m[val]; a=[8,2,3], m={[8,0],[4,1],[3,2],[2,1]}\\n\\t        // After m.erase(val); a=[8,2,3], m={[8,0],[3,2],[2,1]}\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.\\n\\t\\t\\t\\t                // Then we copy array last element value to the val location in the array\\n            a.pop_back();\\t    // Delete the last element of the array \\n            m[last]=m[val];\\t    // In hashmap, assign index of val in array to the index of the last element   \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n\\t    // rand() function gives random value in the range of 0 to RAND_MAX(whose value is 32767). x%y gives \\n \\t    // remainder when x is divided by y and this remainder is in the range of 0 to y-1.\\n\\t    // rand()%a.size() gives random value in the range of (0 to a.size()-1).\\n\\t    // a[rand()%a.size()] will give random value of array in the range of a[0] to a[a.size()-1].\\n        return a[rand()%a.size()];\\n    }\\n};\\n```\\n\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\t// Average Time O(1) & Auxiliary Space O(N)\\nprivate:\\n    vector<int> a; // array vector\\n    unordered_map<int,int> m; // Unordered Map does searching, insertion & deletion of element in average O(1) time\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    \\n    /** Inserts a value to the array vector. Returns true if the array did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to the successive memory location  \\n            // from the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  // insert val at the end of the array\\n            m[val]=a.size()-1; // unordered_map[key]=value stores the array element and \\n\\t\\t\\t                   // its index as key=array element & value=array element index\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the array vector. Returns true if the array contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n\\t        // For example: a=[8,4,3,2], m={[8,0],[4,1],[3,2],[2,3]}, val=4, last=2\\n\\t        // After a[m[val]]=a.back(); a=[8,2,3,2], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After a.pop_back(); a=[8,2,3], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After m[last]=m[val]; a=[8,2,3], m={[8,0],[4,1],[3,2],[2,1]}\\n\\t        // After m.erase(val); a=[8,2,3], m={[8,0],[3,2],[2,1]}\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.\\n\\t\\t\\t\\t                // Then we copy array last element value to the val location in the array\\n            a.pop_back();\\t    // Delete the last element of the array \\n            m[last]=m[val];\\t    // In hashmap, assign index of val in array to the index of the last element   \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n\\t    // rand() function gives random value in the range of 0 to RAND_MAX(whose value is 32767). x%y gives \\n \\t    // remainder when x is divided by y and this remainder is in the range of 0 to y-1.\\n\\t    // rand()%a.size() gives random value in the range of (0 to a.size()-1).\\n\\t    // a[rand()%a.size()] will give random value of array in the range of a[0] to a[a.size()-1].\\n        return a[rand()%a.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85425,
                "title": "java-solution-beats-99-20-using-hashmap-and-arraylist-with-explanation",
                "content": "The List is used to store numbers and serve the getRandom() method. The Map contains the mapping between the value and its index in the ArrayList. The Map helps to check whether a value is already inserted or not. The main trick is when you remove a value. ArrayList's remove method is O(n) if you remove from random location. To overcome that, we swap the values between (randomIndex, lastIndex) and always remove the entry from the end of the list. After the swap, you need to update the new index of the swapped value (which was previously at the end of the list) in the map.\\n\\n````\\npublic class RandomizedSet {\\n\\n    HashMap<Integer, Integer> valToInd;\\n    List<Integer> list;\\n    int ind = 0;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToInd = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(valToInd.containsKey(val)) return false;\\n        list.add(val);\\n        valToInd.put(val,list.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        int ind = valToInd.getOrDefault(val,-1);\\n        if(ind == -1) return false;\\n        Collections.swap(list,ind,list.size()-1);\\n        int swappedWith = list.get(ind);\\n        valToInd.put(swappedWith,ind);\\n        list.remove(list.size()-1);\\n        valToInd.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int max = list.size();\\n        int min = 0;\\n        int ind = (int)(Math.random() * (max - min) + min);\\n        return list.get(ind);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class RandomizedSet {\\n\\n    HashMap<Integer, Integer> valToInd;\\n    List<Integer> list;\\n    int ind = 0;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToInd = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(valToInd.containsKey(val)) return false;\\n        list.add(val);\\n        valToInd.put(val,list.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        int ind = valToInd.getOrDefault(val,-1);\\n        if(ind == -1) return false;\\n        Collections.swap(list,ind,list.size()-1);\\n        int swappedWith = list.get(ind);\\n        valToInd.put(swappedWith,ind);\\n        list.remove(list.size()-1);\\n        valToInd.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int max = list.size();\\n        int min = 0;\\n        int ind = (int)(Math.random() * (max - min) + min);\\n        return list.get(ind);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683267,
                "title": "python-o-1-using-two-hash-tables-explained",
                "content": "My idea for this problem to achieve `O(1)` complexity for all three operation is to use 2 dictionaries: I called them direct dictionary `dic_direct` and inverse dictionary `dic_invert`.\\n1. In direct dictionary we keep indexes and corresponding values: for example: `0:3`, `1:4`, `2:1` means, that we have `3` values in our dictionary: `[3,4,1]`.\\n2. In invert dictionary we keep the opposite correspondences: `3:0`, `4:1`, `1:2`. Why we need to keep two dictionaries? Because we want to search quickly both by keys and by values.\\n3. `num_elem` is to count number of elements in our set (you can avoid it, but code becomes a bit more readible).\\n\\n**Insert**. When we do insert, we first check if element is already in our invert dictionary, because we are looking for value. We do it in `O(1)`. If element is not here, we just add it to the \"end\" of our dictionaries, by this I mean, we add it with biggest existing index in dicionary, increased by `1`. For example if we want to add new element `10` into  `0:3`, `1:4`, `2:1`, then we have  `0:3`, `1:4`, `2:1`, `3:10`.\\n\\n**Remove:** this one is a bit more complicated. Imagine, that we want to remove element `4` from `0:3`, `1:4`, `2:1`, `3:10`. What we need to do in this case? We find it and delete first, but now we have **gap** in our indexes: `0:3`, `2:1`, `3:10`. We can easily fix it, let us take the last element and put it into our gap, so we have `0:3`, `1:10`, `2:1` now. If we do not have **gap**, that is we removed the last element, then we do not need to do this action. In any case we have `O(1)` complexity.\\n\\n**getRandom** This one is easy, we just generate random number, uniformly distributed between `0` and `1`, multiply it by number of all elements in set and evaluate `floor` function. For example if we have 5 elements, and we generated number `0.7`, then we need to choose element number `3`. Complexity is `O(1)`.\\n\\n```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.dic_direct = {}\\n        self.dic_invert = {}\\n        self.num_elem = 0\\n        \\n    def insert(self, val: int) -> bool:\\n        if val in self.dic_invert:\\n            return False\\n        else:\\n            self.dic_invert[val] = self.num_elem\\n            self.dic_direct[self.num_elem] = val\\n            self.num_elem += 1\\n            return True\\n        \\n    def remove(self, val):\\n        if val not in self.dic_invert:\\n            return False\\n        else:\\n            ind = self.dic_invert.pop(val)\\n            self.dic_direct.pop(ind)\\n            if ind != self.num_elem - 1:\\n                self.dic_direct[ind] = self.dic_direct[self.num_elem - 1]\\n                self.dic_invert[self.dic_direct[self.num_elem - 1]] = ind\\n                self.dic_direct.pop(self.num_elem - 1)\\n            self.num_elem -= 1\\n            return True\\n        \\n    def getRandom(self):\\n        index = floor(random.random()*self.num_elem)\\n        return self.dic_direct[index]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.dic_direct = {}\\n        self.dic_invert = {}\\n        self.num_elem = 0\\n        \\n    def insert(self, val: int) -> bool:\\n        if val in self.dic_invert:\\n            return False\\n        else:\\n            self.dic_invert[val] = self.num_elem\\n            self.dic_direct[self.num_elem] = val\\n            self.num_elem += 1\\n            return True\\n        \\n    def remove(self, val):\\n        if val not in self.dic_invert:\\n            return False\\n        else:\\n            ind = self.dic_invert.pop(val)\\n            self.dic_direct.pop(ind)\\n            if ind != self.num_elem - 1:\\n                self.dic_direct[ind] = self.dic_direct[self.num_elem - 1]\\n                self.dic_invert[self.dic_direct[self.num_elem - 1]] = ind\\n                self.dic_direct.pop(self.num_elem - 1)\\n            self.num_elem -= 1\\n            return True\\n        \\n    def getRandom(self):\\n        index = floor(random.random()*self.num_elem)\\n        return self.dic_direct[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532391,
                "title": "javascript-easy-to-understand-map-array",
                "content": "For this problem, we need to make `insert`, `remove`, and `getRandom` all to O(1) time complexity, so it\\'s straightforward to think about using a map. With a map, we could implement the `insert` and `remove` easily with O(1) time complexity. But how about `getRandom`?\\n\\nLet\\'s take a look at what operations do we need for the `getRandom` method:\\n- Get a random number.\\n- Get the real value according to that random number.\\n\\nLooks like it\\'s pretty easy, right? We could get a random number by `Math.random`, and use an array to store index-based values.\\n\\nBut when we try to finish the code, we may find the `remove` method could not be easy, since if we use something like `splice` to remove the value in an array, it could be not O(1) depends on the implementation, and all the indexes after this element need to be updated.\\n\\nSo, here comes the final key point for this problem, how do we make it O(1) with steady indexes? Let\\'s list some clues:\\n- If we want steady indexes, then we can\\'t remove this element from the list. We must put a value here.\\n- If we wanna remove a value with O(1) in a list, it\\'s straightforward to think about removing the last value.\\n\\nCombined with these clues, it is not difficult for us to find out that we could swap the target value and the last value, then remove it. This could meet our two needs at the same time.\\n\\nAt this moment, the whole strategy is clear, so the next step is just coding:\\n\\n```js\\nclass RandomizedSet {\\n  constructor() {\\n    this.map = new Map();\\n    this.list = [];\\n  }\\n\\n  insert(val) {\\n    if (this.map.has(val)) return false;\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n  }\\n\\n  remove(val) {\\n    if (!this.map.has(val)) return false;\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n  }\\n\\n  getRandom() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n  }\\n\\n  _swap(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass RandomizedSet {\\n  constructor() {\\n    this.map = new Map();\\n    this.list = [];\\n  }\\n\\n  insert(val) {\\n    if (this.map.has(val)) return false;\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n  }\\n\\n  remove(val) {\\n    if (!this.map.has(val)) return false;\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n  }\\n\\n  getRandom() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n  }\\n\\n  _swap(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532314,
                "title": "c-hashmap-list-swap-last-element-when-remove-o-1-in-time-clean-concise",
                "content": "```c++\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mapVal2Idx;\\n    vector<int> list;\\n    \\n    bool insert(int val) {\\n        if (mapVal2Idx.count(val)) return false;\\n        mapVal2Idx[val] = list.size();\\n        list.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!mapVal2Idx.count(val)) return false;\\n        int todoRemoveIdx = mapVal2Idx[val];\\n        mapVal2Idx.erase(val);\\n        if (todoRemoveIdx < list.size() - 1) { // if we can replace with last value\\n            int lastVal = list[list.size() - 1];\\n            list[todoRemoveIdx] = lastVal;\\n            mapVal2Idx[lastVal] = todoRemoveIdx;\\n        }\\n        list.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return list[rand() % list.size()];\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(1)` for all operations",
                "solutionTags": [],
                "code": "```c++\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mapVal2Idx;\\n    vector<int> list;\\n    \\n    bool insert(int val) {\\n        if (mapVal2Idx.count(val)) return false;\\n        mapVal2Idx[val] = list.size();\\n        list.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!mapVal2Idx.count(val)) return false;\\n        int todoRemoveIdx = mapVal2Idx[val];\\n        mapVal2Idx.erase(val);\\n        if (todoRemoveIdx < list.size() - 1) { // if we can replace with last value\\n            int lastVal = list[list.size() - 1];\\n            list[todoRemoveIdx] = lastVal;\\n            mapVal2Idx[lastVal] = todoRemoveIdx;\\n        }\\n        list.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return list[rand() % list.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551158,
                "title": "c-o-1-solution-using-array-and-hashmap-with-explanation",
                "content": "This problem requires us to design a data structure that supports insert, remove, and getRandom in constant time O(1).\\n\\nThis solution uses two data structures, a Hash Table and a resizable array. The Hash Table maps the values to their respective indices in the array. \\n\\n**Insert Operation**\\nThis operation can be easily supported by inserting the new value to the end of the resizable array and updating its index in the Hash Table.\\n\\n**Remove Operation**\\nThis operation is a little tricky. We can easily remove any element from the Hash Table in constant time as long as we know it\\'s value. However, removing an element from the middle of the array is a costly operation. Fortunately, removing the last element of the array can be done in constant time ( using pop_back() ). We will swap the value we want to remove with the last element of the array and then remove the last element of the array.\\n\\n**getRandom Operation**\\nThis operation can be easily done by using C++ inbuilt rand() on the array.\\n\\nThe code is as follows.\\n\\n\\n\\n```\\nclass RandomizedSet {\\n    vector<int> numberList;\\n    unordered_map<int, int> hashTable;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {}\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(hashTable.find(val) != hashTable.end())\\n        {\\n            return false;\\n        }\\n        hashTable[val] = numberList.size();\\n        numberList.push_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(hashTable.find(val) == hashTable.end())\\n        {\\n            return false;\\n        }\\n        swap(numberList[hashTable[val]], numberList[numberList.size() - 1]);\\n        numberList.pop_back();\\n        hashTable[numberList[hashTable[val]]] = hashTable[val];\\n        hashTable.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return numberList[rand() % numberList.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    vector<int> numberList;\\n    unordered_map<int, int> hashTable;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {}\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(hashTable.find(val) != hashTable.end())\\n        {\\n            return false;\\n        }\\n        hashTable[val] = numberList.size();\\n        numberList.push_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(hashTable.find(val) == hashTable.end())\\n        {\\n            return false;\\n        }\\n        swap(numberList[hashTable[val]], numberList[numberList.size() - 1]);\\n        numberList.pop_back();\\n        hashTable[numberList[hashTable[val]]] = hashTable[val];\\n        hashTable.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return numberList[rand() % numberList.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858200,
                "title": "python-c-hashmap-array-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a combination of a *hashmap* and an *array* to keep track of values and provide arbitrary (by index) access in constant time. Time complexity is constant: **O(1)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** Set collections with **O(1)** access time (e.g., *set* in Python or *unordered_set* in C++) do not provide arbitrary access, they are *hashmaps*. This means that we can not query an element by it\\'s index. On the other hand, *SortedSet* (from Python\\'s sortedcontainers) and *set* (C++) store keys in order and do provide access by index, but that\\'s of at least **O(logN)** complexity. As it\\'s common in the data structure development, we can trade space for time. Namely, maintain an additional structure that allows **O(1)** access time. This is possible when we deal with continuously allocated chunks of memory (i.e., arrays), for which we know their precise position (pointer/reference) in memory and can simply shift this position by **k** to get access to the **k**-th element.\\n\\nSo our strategy will be the following.\\n1. Keep a duplicate of all values in the form of array. Now we can query values by index (a random/pseudorandom index in our case).\\n2. When we want to delete a value (by value, not by index), it should also be removed from this array. Thus, for each value we have to store it\\'s index in the array. For this, a hashmap (*dict* in *Python* or *unordered_map* in C++) suffices.\\n3. Insertion is trivial: extend the array by the given value and store its index (i.e., the last index) in the hashmap.\\n4. Deletion is tricky. When we retrieve the index of some value from the hashmap, it\\'s usually somewhere in the middle of the array. To not shift/reallocate space (that is very costly), we simply swap the last value in the array (and pop it) with the removed one. Effectively, this leads to the deletion of the queried value.\\n\\n**Python.** *dict* + *list*.\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.vals = {}  \\n        self.idxs = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.vals : return False \\n        self.vals[val] = len(self.idxs)\\n        self.idxs.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.vals: \\n            lst = self.idxs[-1]     \\n            pos = self.vals[val]\\n            \\n            self.vals[lst] = pos               # move last value to the space\\n            self.idxs[pos] = lst               # occupied by the queried one...\\n            \\n            self.vals.pop(val)                 # ...and delete the respective\\n            self.idxs.pop()                    # data from both structures\\n            \\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.idxs)        # as simple as that\\n```\\n\\n**C++.** *unordered_map* + *vector*.\\n```\\nclass RandomizedSet \\n{\\n    unordered_map<int,int> vals;\\n    vector<int>            idxs;\\n\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) \\n    {\\n        if (vals.count(val)) return false;\\n        vals[val] = idxs.size();\\n        idxs.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val)\\n    {\\n        if (!vals.count(val)) return false;\\n        \\n        int lst = idxs.back();\\n        int pos = vals[val];\\n        \\n        vals[lst] = pos;\\n        idxs[pos] = lst;\\n        \\n        vals.erase(val);\\n        idxs.pop_back();\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return idxs[rand() % idxs.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.vals = {}  \\n        self.idxs = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.vals : return False \\n        self.vals[val] = len(self.idxs)\\n        self.idxs.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.vals: \\n            lst = self.idxs[-1]     \\n            pos = self.vals[val]\\n            \\n            self.vals[lst] = pos               # move last value to the space\\n            self.idxs[pos] = lst               # occupied by the queried one...\\n            \\n            self.vals.pop(val)                 # ...and delete the respective\\n            self.idxs.pop()                    # data from both structures\\n            \\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.idxs)        # as simple as that\\n```\n```\\nclass RandomizedSet \\n{\\n    unordered_map<int,int> vals;\\n    vector<int>            idxs;\\n\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) \\n    {\\n        if (vals.count(val)) return false;\\n        vals[val] = idxs.size();\\n        idxs.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val)\\n    {\\n        if (!vals.count(val)) return false;\\n        \\n        int lst = idxs.back();\\n        int pos = vals[val];\\n        \\n        vals[lst] = pos;\\n        idxs[pos] = lst;\\n        \\n        vals.erase(val);\\n        idxs.pop_back();\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return idxs[rand() % idxs.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85434,
                "title": "java-solution-with-two-hashmaps-easy-to-understand",
                "content": "If we assume the operation of HashMap is O(1), then we have the following solution.\\n\\n```\\nimport java.util.Random;\\n\\npublic class RandomizedSet {\\n    \\n    private Map<Integer, Integer> keyMap;\\n    private Map<Integer, Integer> valueMap;\\n\\tRandom random;\\n    int count;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        keyMap = new HashMap<>();\\n        valueMap = new HashMap<>();\\n\\t\\trandom = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            keyMap.put(val, count);\\n            valueMap.put(count, val);\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            int valueKey = keyMap.get(val);\\n            keyMap.remove(val);\\n            if (valueKey != valueMap.size() - 1) {\\n                valueMap.put(valueKey, valueMap.get(valueMap.size() - 1));\\n                keyMap.put(valueMap.get(valueMap.size() - 1), valueKey);\\n                valueMap.remove(valueMap.size() - 1);\\n            } else {\\n                valueMap.remove(valueKey);\\n            }\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int n = random.nextInt(keyMap.size());\\n        return valueMap.get(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Random;\\n\\npublic class RandomizedSet {\\n    \\n    private Map<Integer, Integer> keyMap;\\n    private Map<Integer, Integer> valueMap;\\n\\tRandom random;\\n    int count;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        keyMap = new HashMap<>();\\n        valueMap = new HashMap<>();\\n\\t\\trandom = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            keyMap.put(val, count);\\n            valueMap.put(count, val);\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            int valueKey = keyMap.get(val);\\n            keyMap.remove(val);\\n            if (valueKey != valueMap.size() - 1) {\\n                valueMap.put(valueKey, valueMap.get(valueMap.size() - 1));\\n                keyMap.put(valueMap.get(valueMap.size() - 1), valueKey);\\n                valueMap.remove(valueMap.size() - 1);\\n            } else {\\n                valueMap.remove(valueKey);\\n            }\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int n = random.nextInt(keyMap.size());\\n        return valueMap.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495119,
                "title": "java-tc-o-1-sc-o-n-using-arraylist-hashmap",
                "content": "```java\\n/**\\n * Using ArrayList & HashMap\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedSet {\\n\\n    List<Integer> nums;\\n    Map<Integer, Integer> idxMap;\\n    Random random;\\n\\n    public RandomizedSet() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        idxMap.put(val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        int idx = idxMap.get(val);\\n        int lastIdx = nums.size() - 1;\\n        if (idx != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            nums.set(idx, lastVal);\\n            idxMap.put(lastVal, idx);\\n        }\\n        nums.remove(lastIdx);\\n        idxMap.remove(val);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```\\n\\nSolution for Part II: [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/discuss/1495123/Java-or-TC:-O(1)-or-SC:-O(N)-or-Using-ArrayList-and-HashMap)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Using ArrayList & HashMap\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedSet {\\n\\n    List<Integer> nums;\\n    Map<Integer, Integer> idxMap;\\n    Random random;\\n\\n    public RandomizedSet() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        idxMap.put(val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        int idx = idxMap.get(val);\\n        int lastIdx = nums.size() - 1;\\n        if (idx != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            nums.set(idx, lastVal);\\n            idxMap.put(lastVal, idx);\\n        }\\n        nums.remove(lastIdx);\\n        idxMap.remove(val);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678412,
                "title": "solution-with-comments-easy-to-understand-c-0-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\nprivate:\\n    std::unordered_map<int, int> mymap;\\n    std::vector<int> list;\\npublic:\\n    RandomizedSet() {\\n        // *The constructor should initialize the member variables.*\\n        //* No need to redeclare them here.*\\n    }\\n    \\n    bool insert(int val) {\\n        //*if value already exist*\\n        if(mymap.count(val)!= 0) return false;\\n\\n        //*if not insert the val to map with value(index of list)*\\n        mymap[val] = list.size(); \\n\\n        //*add the value to list aswell*\\n        list.push_back(val); \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        // *Check if the value exists in the map*\\n        if(mymap.count(val)!=0)\\n        {\\n            // *Get the index of the value in the list*\\n            int index = mymap[val]; \\n\\n            // *Swap the value to be removed with the last value in the list*\\n            int lastvalue = list.back();  //* Get the last value*\\n\\n            //* Replace the value at the given index with the last value*   \\n            list[index] = lastvalue; \\n\\n            list.pop_back(); //* Remove the last element from the list*\\n\\n            // *Update the index of the last value in the map to reflect its new position*\\n            mymap[lastvalue] = index;\\n\\n            //* Remove the value from the map*\\n            mymap.erase(val);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int randomIndex = std::rand() % list.size();\\n        return list[randomIndex];\\n    }\\n};\\n\\n```\\nYou better Upvote (\\u2741\\xB4\\u25E1`\\u2741)\\n\\n![ED21zjgXsAgW4ee.jpg](https://assets.leetcode.com/users/images/ef8c7ff9-30aa-4a83-9306-cc22cb63a99a_1687635763.6714256.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\nprivate:\\n    std::unordered_map<int, int> mymap;\\n    std::vector<int> list;\\npublic:\\n    RandomizedSet() {\\n        // *The constructor should initialize the member variables.*\\n        //* No need to redeclare them here.*\\n    }\\n    \\n    bool insert(int val) {\\n        //*if value already exist*\\n        if(mymap.count(val)!= 0) return false;\\n\\n        //*if not insert the val to map with value(index of list)*\\n        mymap[val] = list.size(); \\n\\n        //*add the value to list aswell*\\n        list.push_back(val); \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        // *Check if the value exists in the map*\\n        if(mymap.count(val)!=0)\\n        {\\n            // *Get the index of the value in the list*\\n            int index = mymap[val]; \\n\\n            // *Swap the value to be removed with the last value in the list*\\n            int lastvalue = list.back();  //* Get the last value*\\n\\n            //* Replace the value at the given index with the last value*   \\n            list[index] = lastvalue; \\n\\n            list.pop_back(); //* Remove the last element from the list*\\n\\n            // *Update the index of the last value in the map to reflect its new position*\\n            mymap[lastvalue] = index;\\n\\n            //* Remove the value from the map*\\n            mymap.erase(val);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int randomIndex = std::rand() % list.size();\\n        return list[randomIndex];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858295,
                "title": "c-hashmap-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(1) for all the operations***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    \\n    // mp has num val as key and index of val in arr as value\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // store the val in array, for finding random number in O(1)\\n    \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        // if val is already present in map\\n        \\n        if(mp.count(val))\\n            return false;\\n        \\n        // if val is not present in map\\n        \\n        // push val in arr\\n        \\n        arr.push_back(val);\\n        \\n        // push val in map\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        // if val is present in map\\n        \\n        if(mp.count(val))\\n        {\\n            // find the index of val from array\\n            \\n            int idx = mp[val];\\n            \\n            // find the last value from array\\n            \\n            int last_val = arr.back();\\n            \\n            // put the last_val at idx\\n            \\n            arr[idx] = last_val;\\n            \\n            // remove the last element from array\\n            \\n            arr.pop_back();\\n            \\n            // update the value of last_val in map\\n           \\n            mp[last_val] = idx;\\n            \\n            // remove the val from map\\n            \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        // generate the random number from (0 to arr.size() - 1)\\n        \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    \\n    // mp has num val as key and index of val in arr as value\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // store the val in array, for finding random number in O(1)\\n    \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        // if val is already present in map\\n        \\n        if(mp.count(val))\\n            return false;\\n        \\n        // if val is not present in map\\n        \\n        // push val in arr\\n        \\n        arr.push_back(val);\\n        \\n        // push val in map\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        // if val is present in map\\n        \\n        if(mp.count(val))\\n        {\\n            // find the index of val from array\\n            \\n            int idx = mp[val];\\n            \\n            // find the last value from array\\n            \\n            int last_val = arr.back();\\n            \\n            // put the last_val at idx\\n            \\n            arr[idx] = last_val;\\n            \\n            // remove the last element from array\\n            \\n            arr.pop_back();\\n            \\n            // update the value of last_val in map\\n           \\n            mp[last_val] = idx;\\n            \\n            // remove the val from map\\n            \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        // generate the random number from (0 to arr.size() - 1)\\n        \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653503,
                "title": "simple-clean-and-modern-c-solution",
                "content": "Quick note for C++ developers: Stop using `rand()`.\\n\\n`rand()` is considered harmful: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful\\n\\n```cpp\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() : seed((random_device())()) {}\\n\\n    bool insert(int val) {\\n        if (lookup.count(val)) return false;\\n        lookup[val] = values.size();\\n        values.emplace_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!lookup.count(val)) return false;\\n        \\n        // copy the last value in the array\\n        // to the current location of the value\\n        // we want to remove\\n        values[lookup[val]] = values.back();\\n        \\n        // set the location of the last value\\n        // in the array to the current location\\n        lookup[values.back()] = lookup[val];\\n        \\n        // remove the current element\\n        values.pop_back();\\n        lookup.erase(val);\\n\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return values[uniform_int_distribution<>\\n                        (0, values.size() - 1)(seed)];\\n    }\\nprivate:\\n    unordered_map<int, int> lookup;\\n    vector<int> values;\\n    default_random_engine seed;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() : seed((random_device())()) {}\\n\\n    bool insert(int val) {\\n        if (lookup.count(val)) return false;\\n        lookup[val] = values.size();\\n        values.emplace_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!lookup.count(val)) return false;\\n        \\n        // copy the last value in the array\\n        // to the current location of the value\\n        // we want to remove\\n        values[lookup[val]] = values.back();\\n        \\n        // set the location of the last value\\n        // in the array to the current location\\n        lookup[values.back()] = lookup[val];\\n        \\n        // remove the current element\\n        values.pop_back();\\n        lookup.erase(val);\\n\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return values[uniform_int_distribution<>\\n                        (0, values.size() - 1)(seed)];\\n    }\\nprivate:\\n    unordered_map<int, int> lookup;\\n    vector<int> values;\\n    default_random_engine seed;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356354,
                "title": "python-solution-time-complexity-insert-o-1-remove-o-1-getrandom-o-1",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.hashTable = {}\\n        self.arr = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.hashTable:\\n            self.hashTable[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        \\n        return False\\n        \\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.hashTable:\\n        \\n            self.hashTable[self.arr[-1]] = self.hashTable[val]\\n            self.arr[self.hashTable[val]] = self.arr[-1]\\n\\n            self.arr.pop()\\n            self.hashTable.pop(val)\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.hashTable = {}\\n        self.arr = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.hashTable:\\n            self.hashTable[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        \\n        return False\\n        \\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.hashTable:\\n        \\n            self.hashTable[self.arr[-1]] = self.hashTable[val]\\n            self.arr[self.hashTable[val]] = self.arr[-1]\\n\\n            self.arr.pop()\\n            self.hashTable.pop(val)\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85459,
                "title": "java-solution-concise-code-with-hashmap-and-arraylist-easy-to-understand",
                "content": "```\\npublic class RandomizedSet {\\n    HashMap<Integer, Integer> map;\\n    ArrayList<Integer> list;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }else {\\n            map.put(val, list.size());\\n            list.add(val);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }else {\\n            int key = map.get(val);\\n            int lastElement = list.get(list.size() - 1);\\n            map.put(lastElement, key);\\n            list.set(key, lastElement);\\n            map.remove(val);\\n            list.remove(list.size() - 1);\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random random = new Random();\\n        return list.get( random.nextInt(list.size()) );\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    HashMap<Integer, Integer> map;\\n    ArrayList<Integer> list;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }else {\\n            map.put(val, list.size());\\n            list.add(val);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }else {\\n            int key = map.get(val);\\n            int lastElement = list.get(list.size() - 1);\\n            map.put(lastElement, key);\\n            list.set(key, lastElement);\\n            map.remove(val);\\n            list.remove(list.size() - 1);\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random random = new Random();\\n        return list.get( random.nextInt(list.size()) );\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532747,
                "title": "javascript",
                "content": "```javascript\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.values = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map[val] !== undefined) return false;\\n    this.map[val] = this.values.length;\\n    this.values.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if (this.map[val] === undefined) return false;\\n    const idx = this.map[val];\\n    delete this.map[val];\\n    const last = this.values.pop();\\n    if (this.values.length === idx) return true;\\n    this.map[last] = idx;\\n    this.values[idx] = last;\\n    return true\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    if (this.values.length === 0) return null;\\n    return this.values[Math.floor(Math.random() * this.values.length)];\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.values = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map[val] !== undefined) return false;\\n    this.map[val] = this.values.length;\\n    this.values.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if (this.map[val] === undefined) return false;\\n    const idx = this.map[val];\\n    delete this.map[val];\\n    const last = this.values.pop();\\n    if (this.values.length === idx) return true;\\n    this.map[last] = idx;\\n    this.values[idx] = last;\\n    return true\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    if (this.values.length === 0) return null;\\n    return this.values[Math.floor(Math.random() * this.values.length)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85485,
                "title": "java-with-hashtable-arraylist",
                "content": "The idea is pretty straightforward. Have a HashMap so we now where are our values are in the list. Use the list to get a random number. During remove be careful how to update the map and the list itself.\\n\\n```java\\npublic class RandomizedSet {\\n\\n    Map<Integer, Integer> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n    Random rnd = new Random();\\n\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        int idx = map.remove(val);\\n        int last = list.remove(list.size() - 1);\\n        if(val != last) {\\n            list.set(idx, last);\\n            map.put(last, idx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rnd.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```java\\npublic class RandomizedSet {\\n\\n    Map<Integer, Integer> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n    Random rnd = new Random();\\n\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        int idx = map.remove(val);\\n        int last = list.remove(list.size() - 1);\\n        if(val != last) {\\n            list.set(idx, last);\\n            map.put(last, idx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rnd.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532784,
                "title": "explanation-of-true-o-1-solution-with-python-code",
                "content": "In order to have O(1) `insert` and `remove` operations, we need an unordered set or dict.\\nIn order to have O(1) `getRandom` operations, we need a data structure with random access. That means we need a `list`. (vector in C)\\nThe hardest part is connecting the two.\\n\\nWhat we can do is have a dictionary (map in C) that for every value we store the index in the list of that value. This way, when we need to remove an element by its value, we know what element from the list to remove without having to traverse the whole list.\\nRemoving an element from the middle of the list while preserving the order of everything else is O(N). But we don\\'t need to preserve the order. So when removing an element from the middle of the list, we can just swap it with the last element of the list, then remove the last element of the list. This makes the remove operation O(1) as whole. Care must be taken to maintain the dictionary of indexes for the swap!\\n\\nCode follows:\\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.elems = []\\n        self.indexes = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.indexes:\\n            return False\\n\\t\\t# New element will be at the end of list\\n        self.indexes[val] = len(self.elems)\\n        self.elems.append(val)\\n        return True\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.indexes:\\n            return False\\n\\n        val_index = self.indexes[val]\\n        last = self.elems[-1]\\n\\t\\t\\n\\t\\t# We\\'re swapping the removed element with the last element in the list.\\n\\t\\t# The last element will move to the position of the element removed.\\n        if val_index < len(self.elems)-1:  # Make sure we\\'re not already last element\\n            self.elems[val_index] = last\\n            self.indexes[last] = val_index\\n\\t\\t\\n\\t\\t# Remove the last element. This is O(1).\\n        self.elems.pop()\\n\\t\\t\\n\\t\\t# The removed element no longer has an index in the list. Update dictionary.\\n        del self.indexes[val]\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.elems)\\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.elems = []\\n        self.indexes = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.indexes:\\n            return False\\n\\t\\t# New element will be at the end of list\\n        self.indexes[val] = len(self.elems)\\n        self.elems.append(val)\\n        return True\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.indexes:\\n            return False\\n\\n        val_index = self.indexes[val]\\n        last = self.elems[-1]\\n\\t\\t\\n\\t\\t# We\\'re swapping the removed element with the last element in the list.\\n\\t\\t# The last element will move to the position of the element removed.\\n        if val_index < len(self.elems)-1:  # Make sure we\\'re not already last element\\n            self.elems[val_index] = last\\n            self.indexes[last] = val_index\\n\\t\\t\\n\\t\\t# Remove the last element. This is O(1).\\n        self.elems.pop()\\n\\t\\t\\n\\t\\t# The removed element no longer has an index in the list. Update dictionary.\\n        del self.indexes[val]\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.elems)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858975,
                "title": "c-using-only-set-comments-added",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(!st.count(val))                                           // if val is not present in the set then put it into the set and then return true\\n        {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(st.count(val))                                            // if val is present in set then erase it from set and return true\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        if(st.size()!=0)                                             // when stack is not empty only then we can return something\\n        {\\n            return *next(st.begin(),rand()%st.size());               // it will select randomly next element from set\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(!st.count(val))                                           // if val is not present in the set then put it into the set and then return true\\n        {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(st.count(val))                                            // if val is present in set then erase it from set and return true\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        if(st.size()!=0)                                             // when stack is not empty only then we can return something\\n        {\\n            return *next(st.begin(),rand()%st.size());               // it will select randomly next element from set\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532825,
                "title": "c-super-simple-clean-and-short-solution-all-o-1",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n        if (m.count(val) != 0) return false;\\n        \\n        m[val] = size;\\n        v.push_back(val);\\n        size++;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val) == 0) return false;\\n        \\n        int idx = m[val];\\n        v[idx] = v[size - 1];\\n        v.pop_back();\\n        m[v[idx]] = idx;\\n        m.erase(val);\\n        size--;\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % size];\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> m;\\n    vector<int> v;\\n    int size = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n        if (m.count(val) != 0) return false;\\n        \\n        m[val] = size;\\n        v.push_back(val);\\n        size++;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val) == 0) return false;\\n        \\n        int idx = m[val];\\n        v[idx] = v[size - 1];\\n        v.pop_back();\\n        m[v[idx]] = idx;\\n        m.erase(val);\\n        size--;\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % size];\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> m;\\n    vector<int> v;\\n    int size = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321789,
                "title": "c-implementation",
                "content": "Notes: Although C# List<T>.Remove is O(n) to shift the elements after removing, that operation practically becomes O(1) when the last element is removed. List<T>.Add is O(1) as the cost of doubling the size is amortized.\\n```\\n    private List<int> nums;\\n    private Dictionary<int,int> map;\\n    private Random rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() \\n    {\\n        map = new Dictionary<int,int>();\\n        nums = new List<int>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) \\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        nums.Add(val);\\n        map.Add(val, nums.Count-1);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) \\n    {\\n        if (!map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        int i = map[val];\\n        nums[i] = nums[nums.Count-1];\\n        map[nums[i]] = i;\\n        \\n        nums.RemoveAt(nums.Count-1);\\n        map.Remove(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() \\n    {\\n        return nums[rand.Next(0,nums.Count)];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private List<int> nums;\\n    private Dictionary<int,int> map;\\n    private Random rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() \\n    {\\n        map = new Dictionary<int,int>();\\n        nums = new List<int>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) \\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        nums.Add(val);\\n        map.Add(val, nums.Count-1);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) \\n    {\\n        if (!map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        int i = map[val];\\n        nums[i] = nums[nums.Count-1];\\n        map[nums[i]] = i;\\n        \\n        nums.RemoveAt(nums.Count-1);\\n        map.Remove(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() \\n    {\\n        return nums[rand.Next(0,nums.Count)];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668525,
                "title": "easy-c-solution-using-hashmap-array-with-detailed-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We\\u2019ll be using two data structures:\\n    1. unordered_map<int, int> to store indexes.\\n    2. vector to store elements.\\n- insert(): First, we\\u2019ll find the element using the map.\\n    - If not present then simply push_back to vector & add to map with last index, cz vector insert at end. ***[mp[val]=a.size()-1]***\\n    - Else we\\u2019ll return false.\\n- remove():\\n    - Find the element to be removed & change the index value with the last element in the vector. *[**a[it->second]=a.back()]***\\n    - Then pop out the last element from vector.\\n    - Now in the map change the current element index number to the element we removed Because we placed that element in place of the removed element. ***[mp[a[it->second]]=it->second]***\\n    - Erase the value from the map.\\n- getRandom():\\n    - The rand() function is used in C/C++ to generate random numbers in the range [0, RAND_MAX).\\n- **Time complexity:** O(1).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class RandomizedSet {\\npublic:\\n    vector<int>a;\\n    unordered_map<int, int> mp;\\n    \\n    /* Initialize your data structure here. */\\n    RandomizedSet() { }\\n    \\n    /* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {   \\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            a.push_back(val);\\n            mp[val]=a.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end())\\n        {\\n            a[it->second]=a.back();\\n            a.pop_back();\\n            mp[a[it->second]]=it->second;\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Get a random element from the set. */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n\\n/*\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class RandomizedSet {\\npublic:\\n    vector<int>a;\\n    unordered_map<int, int> mp;\\n    \\n    /* Initialize your data structure here. */\\n    RandomizedSet() { }\\n    \\n    /* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {   \\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            a.push_back(val);\\n            mp[val]=a.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end())\\n        {\\n            a[it->second]=a.back();\\n            a.pop_back();\\n            mp[a[it->second]]=it->second;\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Get a random element from the set. */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n\\n/*\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163782,
                "title": "python-solution",
                "content": "a list holding the elements and a hashmap mapping each element to its index:\\n```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.s = {}\\n        self.arr = []\\n        self.length = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            return False\\n        else:\\n            self.arr.append(val)\\n            self.length += 1\\n            self.s[val] = self.length-1\\n            return True\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            idx = self.s[val]\\n            last = self.arr[self.length-1]\\n            self.arr[idx] = last\\n            self.s[last] = idx\\n            del self.s[val]\\n            self.arr.pop()\\n            self.length -= 1\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        idx = random.randint(0,self.length-1)\\n        return self.arr[idx]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.s = {}\\n        self.arr = []\\n        self.length = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            return False\\n        else:\\n            self.arr.append(val)\\n            self.length += 1\\n            self.s[val] = self.length-1\\n            return True\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            idx = self.s[val]\\n            last = self.arr[self.length-1]\\n            self.arr[idx] = last\\n            self.s[last] = idx\\n            del self.s[val]\\n            self.arr.pop()\\n            self.length -= 1\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        idx = random.randint(0,self.length-1)\\n        return self.arr[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131876,
                "title": "python-easy-and-clear-solution-96-ms-beats-99",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.nums, self.ind = [], {}\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.ind: \\n            self.nums += val, \\n            self.ind[val] = len(self.nums) - 1\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.ind:\\n            ind, last = self.ind[val], self.nums[-1]\\n            self.nums[ind], self.ind[last] = last, ind\\n            self.nums.pop()\\n            self.ind.pop(val)\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.nums)\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.nums, self.ind = [], {}\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.ind: \\n            self.nums += val, \\n            self.ind[val] = len(self.nums) - 1\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.ind:\\n            ind, last = self.ind[val], self.nums[-1]\\n            self.nums[ind], self.ind[last] = last, ind\\n            self.nums.pop()\\n            self.ind.pop(val)\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.nums)\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858959,
                "title": "c-use-array-hashmap-easy-and-efficient-approach",
                "content": "```\\nclass RandomizedSet \\n {\\npublic:\\n    vector<int> nums; //for storing val\\n    unordered_map<int, int> mp; //for storing val and its index (nums)\\n    RandomizedSet() \\n    {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val) != mp.end()) return false; //when value exist\\n        nums.push_back(val); //storing val in nums\\n        mp[val] = nums.size()-1; //storing val and its index\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val) == mp.end()) return false; //when value doesn\\'t exist\\n        auto it = mp.find(val); //find val in mp;\\n        \\n        //put a last value of nums at the index of val and remove the last index value\\n        nums[it->second] = nums.back();\\n        nums.pop_back();\\n        \\n        //update last value index in map\\n        mp[nums[it->second]] = it->second; \\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        //take any random number and do modules with size of nums \\n        //to get number lies in nums index range and return it\\n        return nums[rand()%nums.size()];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet \\n {\\npublic:\\n    vector<int> nums; //for storing val\\n    unordered_map<int, int> mp; //for storing val and its index (nums)\\n    RandomizedSet() \\n    {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val) != mp.end()) return false; //when value exist\\n        nums.push_back(val); //storing val in nums\\n        mp[val] = nums.size()-1; //storing val and its index\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val) == mp.end()) return false; //when value doesn\\'t exist\\n        auto it = mp.find(val); //find val in mp;\\n        \\n        //put a last value of nums at the index of val and remove the last index value\\n        nums[it->second] = nums.back();\\n        nums.pop_back();\\n        \\n        //update last value index in map\\n        mp[nums[it->second]] = it->second; \\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        //take any random number and do modules with size of nums \\n        //to get number lies in nums index range and return it\\n        return nums[rand()%nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818397,
                "title": "java-2-solutions-hashmap-arraylist",
                "content": "### **Please Upvote** :D\\n##### Naive approach:\\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (list.contains(val)) {\\n            return false;\\n        }\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (list.contains(val)) {\\n            list.remove(Integer.valueOf(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(n) - O(1)\\n```\\n##### Optimal Solution:\\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n\\n        int index = map.get(val);\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        map.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (list.contains(val)) {\\n            return false;\\n        }\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (list.contains(val)) {\\n            list.remove(Integer.valueOf(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(n) - O(1)\\n```\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n\\n        int index = map.get(val);\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        map.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585661,
                "title": "python-hashmap-solution-with-explanation",
                "content": "# Init Function\\nTo keep everything O(1), we have to use a hashmap. \\n\\n**Why hashmap is goated:**\\n1. getting items is constant time\\n2. adding items is constant time\\n3. deleting items is constant time\\n4. checking if items exist is constant time\\n5. editing items is constant time\\n\\nHashmap is `value:index`, btw\\nSo we have a hashmap and an array.\\n\\n# Insert\\nSince nobody likes edge cases, we\\'ll take care of that first: `if val in self.dict: return False`. \\n**Digression Alert:**\\nNotice how I check it with a hashmap? That\\'s O(1). However, if I say `if val in self.list`, then it\\'s O(n). I only add and pop items from the actual list. (You\\'ll see why I pop in just a second)\\n\\n**Back on topic**\\nWe basically append the value to both the goated hashmap and the not-so-goated array:\\n1. for the hashmap, we set `val`\\'s value as the dict\\'s key and `val`\\'s index to the dict\\'s value. (ik it\\'s kinda confusing, go read it again). Since we are appending, the `val`\\'s index will ofc be the last element (length of list)\\n2. for the array, we use the append function\\n\\nAlso don\\'t forget to return true.\\n\\n# Remove\\nThe remove function for an array is O(n), but for a hashmap is O(1). But we have to do it for both. So, how?\\n\\n**Nice little trick:**\\nFact 1: the `pop()` function is O(1)\\nFact 2: you can only `pop()` the last element of an array\\nDoubt: but what if the `val` is in the middle?\\nFact 3: swapping elements is O(1)\\n\\n**THEREFORE**\\nWe swap the value we want to remove with the last value of the array, then pop that value. Ta-da! Constant time!\\n\\nNote: this gets tricky\\n1. we get the last element\\'s value and index\\n2. We set `val`\\'s position in the list to the last element of the list\\'s value\\n3. We set the `val`\\'s value in the dict to the last element of the list\\'s index\\n\\nWe basically overwrite the lsat value in the list, cuz it\\'s going to be deleted anyways. \\n\\nAnd of course we remove the last element from the list and the dict.\\n\\n# getRandom\\nThis is self explanatory. I use `random.choice(` to get a random element from the list. O(1) already, piece of cake.\\n\\n\\n\\n```py\\nclass RandomizedSet():\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n        self.list = []\\n\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            return False\\n        self.dict[val] = len(self.list)\\n        self.list.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            last_element_val, last_element_idx = self.list[-1], self.dict[val]\\n            self.list[last_element_idx], self.dict[last_element_val] = last_element_val, last_element_idx\\n            # delete the last element\\n            self.list.pop()\\n            del self.dict[val]\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return choice(self.list)\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass RandomizedSet():\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n        self.list = []\\n\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            return False\\n        self.dict[val] = len(self.list)\\n        self.list.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            last_element_val, last_element_idx = self.list[-1], self.dict[val]\\n            self.list[last_element_idx], self.dict[last_element_val] = last_element_val, last_element_idx\\n            # delete the last element\\n            self.list.pop()\\n            del self.dict[val]\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return choice(self.list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684251,
                "title": "javascript-clean-solution-using-map-and-array",
                "content": "```javascript\\nclass RandomizedSet {\\n    \\n    constructor() {\\n        this.map = new Map();\\n        this.arr = [];\\n    }\\n    \\n    insert(val) {\\n        if(this.map.has(val)) return false;\\n        \\n        this.map.set(val, this.arr.length);\\n        this.arr.push(val);\\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.map.has(val)) return false;\\n        \\n        const valIdx = this.map.get(val);\\n        const lastIdx = this.arr.length-1;\\n        const lastNum = this.arr[lastIdx];\\n        \\n        // swap \\'val\\' with the last element\\n        [this.arr[valIdx], this.arr[lastIdx]] = [this.arr[lastIdx], this.arr[valIdx]];\\n        // pop \\'val\\' from the array\\n        this.arr.pop();\\n        // update the last element\\'s index to be \\'val\\'s\\' index\\n        this.map.set(lastNum, valIdx);\\n        // delete \\'val\\' from the map\\n        this.map.delete(val);\\n        return true;\\n    }\\n    \\n    getRandom() {\\n        const randIdx = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[randIdx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RandomizedSet {\\n    \\n    constructor() {\\n        this.map = new Map();\\n        this.arr = [];\\n    }\\n    \\n    insert(val) {\\n        if(this.map.has(val)) return false;\\n        \\n        this.map.set(val, this.arr.length);\\n        this.arr.push(val);\\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.map.has(val)) return false;\\n        \\n        const valIdx = this.map.get(val);\\n        const lastIdx = this.arr.length-1;\\n        const lastNum = this.arr[lastIdx];\\n        \\n        // swap \\'val\\' with the last element\\n        [this.arr[valIdx], this.arr[lastIdx]] = [this.arr[lastIdx], this.arr[valIdx]];\\n        // pop \\'val\\' from the array\\n        this.arr.pop();\\n        // update the last element\\'s index to be \\'val\\'s\\' index\\n        this.map.set(lastNum, valIdx);\\n        // delete \\'val\\' from the map\\n        this.map.delete(val);\\n        return true;\\n    }\\n    \\n    getRandom() {\\n        const randIdx = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[randIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589197,
                "title": "javascript-es6-o-1-using-class-and-maps",
                "content": "* using 2 hashmaps instead of an array, to have a better guarantee that access / deletion will be in O(1)\\n(comments welcome if I am missing something like if an array in js can have element deleted in O(1))\\n\\n```javascript\\nclass RandomizedSet {\\n    constructor() {\\n        this.valMap = new Map(),\\n        this.indexMap = new Map();\\n        \\n        this.highest = -1;\\n    }\\n    \\n    insert(val) {\\n        if(this.valMap.has(val)) return false;\\n        \\n        this.highest += 1;\\n        this.valMap.set(val, this.highest);\\n        this.indexMap.set(this.highest, val);\\n        \\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.valMap.has(val)) return false;\\n        \\n        const currIdx = this.valMap.get(val);\\n        const valAtLastIdx = this.indexMap.get(this.highest);\\n        this.indexMap.set(currIdx, valAtLastIdx); \\n        this.valMap.set(valAtLastIdx, currIdx);\\n        this.valMap.delete(val);\\n        this.indexMap.delete(this.highest);\\n        \\n        this.highest -= 1;\\n        \\n        return true;\\n    }\\n    \\n    getRandom() {\\n        if(this.highest < 0) return null;\\n        \\n        const rnd = this.generateRandom();\\n        return this.indexMap.get(rnd);\\n    }\\n    \\n    generateRandom() {\\n        return Math.floor(Math.random() * (this.highest + 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RandomizedSet {\\n    constructor() {\\n        this.valMap = new Map(),\\n        this.indexMap = new Map();\\n        \\n        this.highest = -1;\\n    }\\n    \\n    insert(val) {\\n        if(this.valMap.has(val)) return false;\\n        \\n        this.highest += 1;\\n        this.valMap.set(val, this.highest);\\n        this.indexMap.set(this.highest, val);\\n        \\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.valMap.has(val)) return false;\\n        \\n        const currIdx = this.valMap.get(val);\\n        const valAtLastIdx = this.indexMap.get(this.highest);\\n        this.indexMap.set(currIdx, valAtLastIdx); \\n        this.valMap.set(valAtLastIdx, currIdx);\\n        this.valMap.delete(val);\\n        this.indexMap.delete(this.highest);\\n        \\n        this.highest -= 1;\\n        \\n        return true;\\n    }\\n    \\n    getRandom() {\\n        if(this.highest < 0) return null;\\n        \\n        const rnd = this.generateRandom();\\n        return this.indexMap.get(rnd);\\n    }\\n    \\n    generateRandom() {\\n        return Math.floor(Math.random() * (this.highest + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85414,
                "title": "2-python-implementations-using-dictionary-and-list-syned-and-asyned-with-explanation",
                "content": "Quite a number of people have posted their C++ code based on the same idea, which is:\\n1. A plain list does most of the job. It makes sure ```insert``` and ```getRandom``` is O(1).\\n2. The dictionary comes in handy when you need to make ```remove``` O(1). The dictionary maps the values to their indices in the list, so when you want to quickly remove something from the list, you always know where to start.\\n\\nSo, here come 2 flavors:\\n\\n**Synced version**, in which the list and dictionary are always having the same size.\\nNo actual swapping is needed for ```remove``` because the last element of the list is always going to be popped out, anyway. Don't bother to write to the last slot.\\n```\\nimport random\\nclass RandomizedSet(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        self.d[val] = len(self.l)\\n        self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\\n\\n**Asynced version**, in which I use the dict to keep track of the array size so I can avoid shrinking the list.\\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        i = len(self.d)\\n        self.d[val] = i\\n        if i < len(self.l):\\n            self.l[i] = val\\n        else:\\n            self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[len(self.d)-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        return True\\n\\n    def getRandom(self):\\n        return self.l[random.randrange(len(self.d))]\\n```\\n\\nThe first implementation is shorter and cleaner, but i may prefer the second one in real life because it has less memory expansion and shrinking.",
                "solutionTags": [],
                "code": "```insert```\n```getRandom```\n```remove```\n```remove```\n```\\nimport random\\nclass RandomizedSet(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        self.d[val] = len(self.l)\\n        self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        i = len(self.d)\\n        self.d[val] = i\\n        if i < len(self.l):\\n            self.l[i] = val\\n        else:\\n            self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[len(self.d)-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        return True\\n\\n    def getRandom(self):\\n        return self.l[random.randrange(len(self.d))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85492,
                "title": "sharing-my-c-solution-with-explanation-swap-and-pop-when-remove",
                "content": "Idea is to use two data structures to do book-keeping:\\n1. unordered_map<int, int> to store <number-to-index> relationship\\n2. vector<int> to store <index-to-number> relationship\\n3. You can use the size from map or vector to determine how many elements are there but I tend to use a explicit member variable \"size\" to record as we are designing a new data structure.\\n* insert():\\nsimply add to map and push_back to vector\\nincrement size\\n* getRandom():\\ngenerate a random integer randIdx from 0 to size - 1, and simply return the element at index randIdx (from the vector)\\n* remove():\\nswap the element to be removed with the last element in the vector\\npop out the last element\\nupdate book-keeping information in both data structures\\ndecrement size\\n\\ncode in cpp:\\n```\\nclass RandomizedSet {\\n    unordered_map<int, int> index; // map of num to its index in nums array\\n    vector<int> nums; // storing the actual numbers inserted\\n    int size;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() : size(0) {\\n        /* initialize random seed: */\\n        srand (time(NULL));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (index.find(val) != index.end())\\n            return false;\\n            \\n        nums.push_back(val);\\n        index[val] = size ++;\\n        return true;s\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (index.find(val) == index.end())\\n            return false;\\n        \\n        int back = nums.back();\\n        int backIdx = index[back];\\n        \\n        int delIdx = index[val];\\n        \\n        swap(nums[backIdx], nums[delIdx]); // swap with last element in nums\\n        nums.pop_back();\\n        \\n        index[back] = delIdx; // update last element's index in map\\n        index.erase(val); // erase val entry from map\\n        \\n        size --;\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (size <= 0) return -1; // should be an exception\\n        \\n        /* generate secret number between 0 and size - 1: */\\n        int randIdx = rand() % size;\\n        \\n        return nums[randIdx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> index; // map of num to its index in nums array\\n    vector<int> nums; // storing the actual numbers inserted\\n    int size;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() : size(0) {\\n        /* initialize random seed: */\\n        srand (time(NULL));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (index.find(val) != index.end())\\n            return false;\\n            \\n        nums.push_back(val);\\n        index[val] = size ++;\\n        return true;s\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (index.find(val) == index.end())\\n            return false;\\n        \\n        int back = nums.back();\\n        int backIdx = index[back];\\n        \\n        int delIdx = index[val];\\n        \\n        swap(nums[backIdx], nums[delIdx]); // swap with last element in nums\\n        nums.pop_back();\\n        \\n        index[back] = delIdx; // update last element's index in map\\n        index.erase(val); // erase val entry from map\\n        \\n        size --;\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (size <= 0) return -1; // should be an exception\\n        \\n        /* generate secret number between 0 and size - 1: */\\n        int randIdx = rand() % size;\\n        \\n        return nums[randIdx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111760,
                "title": "c-simple-vector-hash-map-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a map and a vector. Map will keep track of indexes of vals  and vector for vals . At remove operation just swap the number which is to be removed and the last one and then do pop_back and also update the index of last element in map. In this way we can remove the elements and also check the element is presnt or not. \\nAnd for getRandom just return a random number presnt in the vector using `rand() ` function use `rand()%size` becuase rand() should be genrating indexes upto n-1 not beyond that .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    map<int,int>mp;\\n    vector<int>ans;\\n  \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[ans.back()]=mp[val];\\n         swap(ans.back(),ans[mp[val]]);\\n         ans.pop_back();\\n        mp.erase(val);\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return ans[rand()%mp.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    map<int,int>mp;\\n    vector<int>ans;\\n  \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[ans.back()]=mp[val];\\n         swap(ans.back(),ans[mp[val]]);\\n         ans.pop_back();\\n        mp.erase(val);\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return ans[rand()%mp.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463464,
                "title": "c-hashmap-96-faster-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> num;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val)==m.end())\\n        {\\n            m[val]=num.size();\\n            num.push_back(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val)!=m.end())\\n        {\\n            // replace the element val in num by last element of num and delete last element of num\\n            int ind=m[val];\\n            num[ind]=num[num.size()-1];\\n            m[num[num.size()-1]]=ind;\\n            num.pop_back();\\n            m.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int p=rand()%num.size();\\n        return num[p];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> num;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val)==m.end())\\n        {\\n            m[val]=num.size();\\n            num.push_back(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val)!=m.end())\\n        {\\n            // replace the element val in num by last element of num and delete last element of num\\n            int ind=m[val];\\n            num[ind]=num[num.size()-1];\\n            m[num[num.size()-1]]=ind;\\n            num.pop_back();\\n            m.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int p=rand()%num.size();\\n        return num[p];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532364,
                "title": "simple-to-understand-using-map-list-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nThe main idea of this solution is to use a list to store the values added, and use a map to determine if an item has been added already.\\n\\nThe map is also used to store the list index of the added item. This makes it so we know which index to work with when we want to remove an item from the list.\\n\\nIn some testcases, values are removed in non-uniform order, so to ensure proper removal, we \\'swap\\' places of the value to remove with the last item in the list. This makes it so only the last item in the list is always the index to have items removed from.\\n\\n```\\npublic class RandomizedSet {\\n    // For randomizing the list\\n    private Random r;\\n    \\n    // To determine if an item has been added, and store its list index\\n    private Dictionary<int, int> map;\\n    \\n    // To store the items added\\n    private List<int> values;\\n\\n    public RandomizedSet() {\\n        r = new Random();\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n    }\\n    \\n    public bool Insert(int val) {\\n        // Determine if item exists in map\\n        if (map.ContainsKey(val)) {\\n            return false;\\n        }\\n        \\n        // Add value to the list\\n        values.Add(val);   \\n\\n        // Save the value with its list index to the map\\n        map[val] = values.Count - 1;\\n        \\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        // Determine if item exists in map\\n        if (!map.ContainsKey(val)) {\\n            return false;\\n        }\\n                \\n        // Get the current index for the item to remove\\n        var currentIndex = map[val];\\n\\n        // Get the last index for the item at the end\\n        var lastIndex = values.Count - 1;\\n\\n        // \\'Swap\\' places of the last item in the list with the item to be removed\\n        values[currentIndex] = values[lastIndex];\\n\\n        // Update the map for the item that we \\'swapped\\' with its new list index\\n        map[values[currentIndex]] = currentIndex;\\n\\n        // Remove the swapped item from the list (this is the item to be removed)\\n        values.RemoveAt(lastIndex);\\n\\n        // Remove the item to be removed from the map\\n        map.Remove(val);\\n            \\n        return true;\\n    }\\n    \\n    public int GetRandom() {\\n        var randomIndex = r.Next(0, values.Count);\\n        return values[randomIndex];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    // For randomizing the list\\n    private Random r;\\n    \\n    // To determine if an item has been added, and store its list index\\n    private Dictionary<int, int> map;\\n    \\n    // To store the items added\\n    private List<int> values;\\n\\n    public RandomizedSet() {\\n        r = new Random();\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n    }\\n    \\n    public bool Insert(int val) {\\n        // Determine if item exists in map\\n        if (map.ContainsKey(val)) {\\n            return false;\\n        }\\n        \\n        // Add value to the list\\n        values.Add(val);   \\n\\n        // Save the value with its list index to the map\\n        map[val] = values.Count - 1;\\n        \\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        // Determine if item exists in map\\n        if (!map.ContainsKey(val)) {\\n            return false;\\n        }\\n                \\n        // Get the current index for the item to remove\\n        var currentIndex = map[val];\\n\\n        // Get the last index for the item at the end\\n        var lastIndex = values.Count - 1;\\n\\n        // \\'Swap\\' places of the last item in the list with the item to be removed\\n        values[currentIndex] = values[lastIndex];\\n\\n        // Update the map for the item that we \\'swapped\\' with its new list index\\n        map[values[currentIndex]] = currentIndex;\\n\\n        // Remove the swapped item from the list (this is the item to be removed)\\n        values.RemoveAt(lastIndex);\\n\\n        // Remove the item to be removed from the map\\n        map.Remove(val);\\n            \\n        return true;\\n    }\\n    \\n    public int GetRandom() {\\n        var randomIndex = r.Next(0, values.Count);\\n        return values[randomIndex];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494177,
                "title": "the-simplest-solution-c-using-set-only",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)!=s.end())\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return *next(s.begin(),rand()%s.size());\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)!=s.end())\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return *next(s.begin(),rand()%s.size());\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230425,
                "title": "javascript-solution-with-comments-performance-beat-100-using-array-and-map",
                "content": "```\\n/**\\n * Thoughts:\\n * 0. What is the type of the items to be inserted? Is it always a number?\\n * 1a. Keep a dynamically sized array of the items, supporting O(1) insertion\\n *     and O(1) getRandom using a randomly generated number from 0 to array length\\n * 1b. Keep a hash map of items to their index in the array. When an item\\n *     is to be removed, get index from the hash map and move last element\\n *     in the array to overwrite this index (to prevent the array from\\n *     growing sparse and breaking getRandom). Then remove the value-index\\n *     mapping from the hash map. Now we have O(1) delete.\\n * 2. Alternative approach: Depending on the answer to 0, we could use a trie\\n *    instead of a hash map + array. A trie provides O(m) insertion and deletion,\\n *    where m is the number of characters in the item key. Hash map always has to\\n *    look at the entire key, so this is still a relative O(1). If the items are\\n *    alphanumeric strings, we can do a-z nodes at the top level and binary\\n *    tree nodes below. If the items are numbers, we can stringify them and do\\n *    0-9 at the top level and binary below. It\\'s a bit trickier to equalize\\n *    the likelihood of getRandom for the trie though. Have to track number of nodes in each \\n *    branch and calculate based on that.\\n * 3. Use array/hashtable approach from 1a and 1b above (not trie from 2)\\n *\\n * Time spent: ~20 mins thinking at night + ~15 implementing + 5 + 5 (+ ~15 debugging!)\\n */\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.array = [];\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    const {array, map} = this;\\n    \\n    if (map.has(val))\\n        return false;\\n    \\n    array.push(val);\\n    map.set(val, array.length - 1);\\n    \\n    // TODO account for wrong type of val or array too large?\\n    return true;\\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    const {array, map} = this;\\n    \\n    if (!map.has(val))\\n        return false;\\n    \\n    const [last, index] = [array[array.length - 1], map.get(val)];\\n    \\n    array[index] = last;\\n    map.set(last, index);\\n    \\n    array.pop();\\n    map.delete(val);\\n    \\n    return true;    \\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n * TODO: What should behavior be on empty set?\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    const {array} = this;\\n    \\n    const r = Math.floor(array.length * Math.random());\\n    return array[r];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = Object.create(RandomizedSet).createNew()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n * \\n * Me: I\\'ve heard that before. I bet it\\'s really instantiated like this:\\n * var obj = new RandomizedSet();\\n * Update: Actually their API worked!\\n */\\n\\n/*\\n== TESTING (cases we\\'d want to test) ==\\nsimple example (given)\\noperations on empty set\\nduplicates\\nnull/undefined values\\nnon-number values\\nnegative numbers\\nmassive numbers\\nmassive array size and number of operations\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Thoughts:\\n * 0. What is the type of the items to be inserted? Is it always a number?\\n * 1a. Keep a dynamically sized array of the items, supporting O(1) insertion\\n *     and O(1) getRandom using a randomly generated number from 0 to array length\\n * 1b. Keep a hash map of items to their index in the array. When an item\\n *     is to be removed, get index from the hash map and move last element\\n *     in the array to overwrite this index (to prevent the array from\\n *     growing sparse and breaking getRandom). Then remove the value-index\\n *     mapping from the hash map. Now we have O(1) delete.\\n * 2. Alternative approach: Depending on the answer to 0, we could use a trie\\n *    instead of a hash map + array. A trie provides O(m) insertion and deletion,\\n *    where m is the number of characters in the item key. Hash map always has to\\n *    look at the entire key, so this is still a relative O(1). If the items are\\n *    alphanumeric strings, we can do a-z nodes at the top level and binary\\n *    tree nodes below. If the items are numbers, we can stringify them and do\\n *    0-9 at the top level and binary below. It\\'s a bit trickier to equalize\\n *    the likelihood of getRandom for the trie though. Have to track number of nodes in each \\n *    branch and calculate based on that.\\n * 3. Use array/hashtable approach from 1a and 1b above (not trie from 2)\\n *\\n * Time spent: ~20 mins thinking at night + ~15 implementing + 5 + 5 (+ ~15 debugging!)\\n */\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.array = [];\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    const {array, map} = this;\\n    \\n    if (map.has(val))\\n        return false;\\n    \\n    array.push(val);\\n    map.set(val, array.length - 1);\\n    \\n    // TODO account for wrong type of val or array too large?\\n    return true;\\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    const {array, map} = this;\\n    \\n    if (!map.has(val))\\n        return false;\\n    \\n    const [last, index] = [array[array.length - 1], map.get(val)];\\n    \\n    array[index] = last;\\n    map.set(last, index);\\n    \\n    array.pop();\\n    map.delete(val);\\n    \\n    return true;    \\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n * TODO: What should behavior be on empty set?\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    const {array} = this;\\n    \\n    const r = Math.floor(array.length * Math.random());\\n    return array[r];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = Object.create(RandomizedSet).createNew()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n * \\n * Me: I\\'ve heard that before. I bet it\\'s really instantiated like this:\\n * var obj = new RandomizedSet();\\n * Update: Actually their API worked!\\n */\\n\\n/*\\n== TESTING (cases we\\'d want to test) ==\\nsimple example (given)\\noperations on empty set\\nduplicates\\nnull/undefined values\\nnon-number values\\nnegative numbers\\nmassive numbers\\nmassive array size and number of operations\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85505,
                "title": "c-solution-using-unordered-map-and-vector",
                "content": "Hi all,\\n\\nThe idea is to keep a vector for picking a random number and hash map (unordered_map in c++) for quick insert / removal. The map keeps the indices in the vector as the value so the corresponding entry in vector can be adjusted in O(1) time.\\n\\n    class RandomizedSet {\\n    private:\\n        unordered_map<int, int> indices; // the value is the index of the key\\n        vector<int> vals;\\n    public:\\n        /** Initialize your data structure here. */\\n        RandomizedSet() {\\n            srand((int)time(0));\\n        }\\n        \\n        /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n        bool insert(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                // add the new value's index\\n                indices.insert(pair<int, int>(val, vals.size()));\\n                vals.push_back(val);\\n                \\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        /** Removes a value from the set. Returns true if the set contained the specified element. */\\n        bool remove(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                return false;\\n            }\\n            \\n            // remove val\\n            int index = it->second;\\n            vals[index] = vals[vals.size() - 1];\\n            indices.find(vals[index])->second = index;\\n            vals.pop_back();\\n            indices.erase(it);\\n\\n            return true;\\n        }\\n        \\n        /** Get a random element from the set. */\\n        int getRandom() {\\n            int pick = rand() % vals.size();\\n\\n            return vals[pick];\\n        }\\n    };",
                "solutionTags": [],
                "code": "Hi all,\\n\\nThe idea is to keep a vector for picking a random number and hash map (unordered_map in c++) for quick insert / removal. The map keeps the indices in the vector as the value so the corresponding entry in vector can be adjusted in O(1) time.\\n\\n    class RandomizedSet {\\n    private:\\n        unordered_map<int, int> indices; // the value is the index of the key\\n        vector<int> vals;\\n    public:\\n        /** Initialize your data structure here. */\\n        RandomizedSet() {\\n            srand((int)time(0));\\n        }\\n        \\n        /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n        bool insert(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                // add the new value's index\\n                indices.insert(pair<int, int>(val, vals.size()));\\n                vals.push_back(val);\\n                \\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        /** Removes a value from the set. Returns true if the set contained the specified element. */\\n        bool remove(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                return false;\\n            }\\n            \\n            // remove val\\n            int index = it->second;\\n            vals[index] = vals[vals.size() - 1];\\n            indices.find(vals[index])->second = index;\\n            vals.pop_back();\\n            indices.erase(it);\\n\\n            return true;\\n        }\\n        \\n        /** Get a random element from the set. */\\n        int getRandom() {\\n            int pick = rand() % vals.size();\\n\\n            return vals[pick];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3904827,
                "title": "cpp-solution-hash-table",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> mp; //<num , index at which num is present>\\n    vector<int> ans;\\n    RandomizedSet() \\n    {\\n        ios_base::sync_with_stdio(false);    \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val)!=mp.end())\\n        {\\n            return false;\\n        }    \\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val)==mp.end())\\n        {\\n            return false;\\n        }    \\n        int index = mp[val]; //index of no that has to be removed\\n        int last_ele = ans.back();\\n\\n        mp[last_ele] = index;\\n        swap(ans[index],ans[ans.size()-1]); //swapping last element and val\\n\\n        ans.pop_back(); //removing val\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return ans[rand()%ans.size()];    \\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> mp; //<num , index at which num is present>\\n    vector<int> ans;\\n    RandomizedSet() \\n    {\\n        ios_base::sync_with_stdio(false);    \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val)!=mp.end())\\n        {\\n            return false;\\n        }    \\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val)==mp.end())\\n        {\\n            return false;\\n        }    \\n        int index = mp[val]; //index of no that has to be removed\\n        int last_ele = ans.back();\\n\\n        mp[last_ele] = index;\\n        swap(ans[index],ans[ans.size()-1]); //swapping last element and val\\n\\n        ans.pop_back(); //removing val\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return ans[rand()%ans.size()];    \\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858191,
                "title": "c-dictionary-and-list",
                "content": "As a bonus there is a [video](https://www.youtube.com/watch?v=46dZH7LDbf8) where Neetcode creator interviews one arrogant Meta intern by using exactly the same question.\\n```\\npublic class RandomizedSet {\\n    private Random rnd = new();\\n    private Dictionary<int, int> map = new();\\n    private List<int> list = new();\\n\\n    public RandomizedSet() {}\\n    \\n    public bool Insert(int val) {\\n        if(map.ContainsKey(val)) return false;\\n        list.Add(val);\\n        map.Add(val, list.Count-1);\\n        return true;\\n    }\\n    public bool Remove(int val) {\\n        if(!map.ContainsKey(val)) return false;\\n        int lastVal = list[list.Count-1];\\n        list[list.Count-1] = val;\\n        list[map[val]] = lastVal;\\n        map[lastVal] = map[val];\\n        map.Remove(val);\\n        list.RemoveAt(list.Count-1);\\n        return true;\\n    }\\n    public int GetRandom() {\\n        int idx = rnd.Next(0, list.Count);\\n        return list[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    private Random rnd = new();\\n    private Dictionary<int, int> map = new();\\n    private List<int> list = new();\\n\\n    public RandomizedSet() {}\\n    \\n    public bool Insert(int val) {\\n        if(map.ContainsKey(val)) return false;\\n        list.Add(val);\\n        map.Add(val, list.Count-1);\\n        return true;\\n    }\\n    public bool Remove(int val) {\\n        if(!map.ContainsKey(val)) return false;\\n        int lastVal = list[list.Count-1];\\n        list[list.Count-1] = val;\\n        list[map[val]] = lastVal;\\n        map[lastVal] = map[val];\\n        map.Remove(val);\\n        list.RemoveAt(list.Count-1);\\n        return true;\\n    }\\n    public int GetRandom() {\\n        int idx = rnd.Next(0, list.Count);\\n        return list[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790366,
                "title": "this-is-why-we-love-c",
                "content": "380. Insert Delete GetRandom O(1)\\n\\nlet C# do all the under the hood magic. \\n\\n```\\npublic class RandomizedSet {\\n    \\n    HashSet<int> myHash;\\n    Random myRand;\\n\\n    public RandomizedSet() {\\n        myHash = new HashSet<int>();\\n        myRand = new Random();\\n    }\\n    \\n    public bool Insert(int val) {\\n        if(myHash.Contains(val))\\n            return false;\\n        myHash.Add(val);\\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        if(myHash.Contains(val))\\n        {\\n            myHash.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int GetRandom() {\\n        return myHash.ElementAt(myRand.Next(myHash.Count));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n ```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    \\n    HashSet<int> myHash;\\n    Random myRand;\\n\\n    public RandomizedSet() {\\n        myHash = new HashSet<int>();\\n        myRand = new Random();\\n    }\\n    \\n    public bool Insert(int val) {\\n        if(myHash.Contains(val))\\n            return false;\\n        myHash.Add(val);\\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        if(myHash.Contains(val))\\n        {\\n            myHash.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int GetRandom() {\\n        return myHash.ElementAt(myRand.Next(myHash.Count));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1533092,
                "title": "easy-java-solution-with-explanations",
                "content": "\\tclass RandomizedSet {\\n\\t\\t// map contains value with it\\'s index\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\t// contains values\\n\\t\\tList<Integer> allValues;\\n\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tallValues = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (map.containsKey(val)) return false;\\n\\n\\t\\t\\tallValues.add(val);\\n\\t\\t\\t// keep track of index in array\\n\\t\\t\\tmap.put(val, allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!map.containsKey(val)) return false;\\n\\n\\t\\t\\t// set the index of val with last element\\n\\t\\t\\tallValues.set(map.get(val), allValues.get(allValues.size() - 1));\\n\\t\\t\\t// update index in map\\n\\t\\t\\tmap.put(allValues.get(allValues.size() - 1), map.get(val));\\n\\n\\t\\t\\tmap.remove(val);\\n\\t\\t\\t// O(1) remove\\n\\t\\t\\tallValues.remove(allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\t// [0, size - 1]\\n\\t\\t\\treturn allValues.get((int)(Math.random() * allValues.size()));\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tclass RandomizedSet {\\n\\t\\t// map contains value with it\\'s index\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\t// contains values\\n\\t\\tList<Integer> allValues;\\n\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tallValues = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (map.containsKey(val)) return false;\\n\\n\\t\\t\\tallValues.add(val);\\n\\t\\t\\t// keep track of index in array\\n\\t\\t\\tmap.put(val, allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!map.containsKey(val)) return false;\\n\\n\\t\\t\\t// set the index of val with last element\\n\\t\\t\\tallValues.set(map.get(val), allValues.get(allValues.size() - 1));\\n\\t\\t\\t// update index in map\\n\\t\\t\\tmap.put(allValues.get(allValues.size() - 1), map.get(val));\\n\\n\\t\\t\\tmap.remove(val);\\n\\t\\t\\t// O(1) remove\\n\\t\\t\\tallValues.remove(allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\t// [0, size - 1]\\n\\t\\t\\treturn allValues.get((int)(Math.random() * allValues.size()));\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 699791,
                "title": "python-logic-explained-simple-solution",
                "content": "```\\nclass RandomizedSet:\\n    ## RC ##\\n    ## APPROACH : HASHMAP ##\\n    #   1. Insertion operation in list is O(1) but not deletion\\n    #   2. So we create one Hashmap with key,index and other list\\n    #   3. for deleting we go to hashmap, get index, go to that index in list, swap that element with last element.\\n    #   4. save the index to last element in hashmap and delete list last element\\n\\n    def __init__(self):\\n        self.lists = []\\n        self.hmap = {}\\n        self.length = 0\\n\\n    def insert(self, val: int) -> bool:\\n        if(val in self.hmap):\\n            return False\\n        self.hmap[val] = self.length\\n        self.length += 1\\n        self.lists.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if(val not in self.hmap):\\n            return False\\n        index = self.hmap[val]\\n        self.hmap[self.lists[-1]] = index\\n        self.lists[index], self.lists[-1] = self.lists[-1], self.lists[index]\\n        self.lists.pop()\\n        self.hmap.pop(val)\\n        self.length -= 1\\n        return True\\n\\n    def getRandom(self) -> int:\\n        ri = random.randint(0, self.length - 1)\\n        return self.lists[ri]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n    ## RC ##\\n    ## APPROACH : HASHMAP ##\\n    #   1. Insertion operation in list is O(1) but not deletion\\n    #   2. So we create one Hashmap with key,index and other list\\n    #   3. for deleting we go to hashmap, get index, go to that index in list, swap that element with last element.\\n    #   4. save the index to last element in hashmap and delete list last element\\n\\n    def __init__(self):\\n        self.lists = []\\n        self.hmap = {}\\n        self.length = 0\\n\\n    def insert(self, val: int) -> bool:\\n        if(val in self.hmap):\\n            return False\\n        self.hmap[val] = self.length\\n        self.length += 1\\n        self.lists.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if(val not in self.hmap):\\n            return False\\n        index = self.hmap[val]\\n        self.hmap[self.lists[-1]] = index\\n        self.lists[index], self.lists[-1] = self.lists[-1], self.lists[index]\\n        self.lists.pop()\\n        self.hmap.pop(val)\\n        self.length -= 1\\n        return True\\n\\n    def getRandom(self) -> int:\\n        ri = random.randint(0, self.length - 1)\\n        return self.lists[ri]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243033,
                "title": "a-picture-is-worth-a-thousand-words-here-is-the-clearest-explanation-for-the-classic-approach",
                "content": "Classic Approach: **hashtable + array**\\n\\nTo **Insert**, we just have to\\n1. append the item to the end of the array\\n2. add the key:index in the hashtable\\n![image](https://assets.leetcode.com/users/calvinchankf/image_1550985158.png)\\n\\n\\nTo **Remove**, we just have to\\n1. assign the last item to the target index\\n2. swap the target item and the last item\\n3. delete the key from the hashtable\\n![image](https://assets.leetcode.com/users/calvinchankf/image_1550985430.png)\\n\\n\\nTo **Random**, just randomly get a number between 0 and length of array(exclusively) and return arr[random number]\\n\\nHere is the code for your reference\\n\\n```go\\n// 32 ms, faster than 100.00%\\n\\ntype RandomizedSet struct {\\n\\tHashTable map[int]int\\n\\tArr       []int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() RandomizedSet {\\n\\treturn RandomizedSet{make(map[int]int), []int{}}\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\treturn false\\n\\t}\\n\\tthis.HashTable[val] = len(this.Arr)\\n\\tthis.Arr = append(this.Arr, val)\\n\\treturn true\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\t// find the target index of the val from the hashtable\\n\\t\\ttargetIdx := this.HashTable[val]\\n\\t\\t// assign the last item to the target index\\n\\t\\tthis.HashTable[this.Arr[len(this.Arr)-1]] = targetIdx\\n\\t\\t// swap the target item and the last item\\n\\t\\tthis.Arr[targetIdx], this.Arr[len(this.Arr)-1] = this.Arr[len(this.Arr)-1], this.Arr[targetIdx]\\n\\t\\t// remove the last item\\n\\t\\tthis.Arr = this.Arr[:len(this.Arr)-1]\\n\\t\\t// delete the key from hashtable\\n\\t\\tdelete(this.HashTable, val)\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n/** Get a random element from the set. */\\nfunc (this *RandomizedSet1) GetRandom() int {\\n\\tr := rand.Intn(len(this.Arr))\\n\\treturn this.Arr[r]\\n}\\n```\\n\\nRef:  https://www.youtube.com/watch?v=y240Qh9H9uk",
                "solutionTags": [],
                "code": "```go\\n// 32 ms, faster than 100.00%\\n\\ntype RandomizedSet struct {\\n\\tHashTable map[int]int\\n\\tArr       []int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() RandomizedSet {\\n\\treturn RandomizedSet{make(map[int]int), []int{}}\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\treturn false\\n\\t}\\n\\tthis.HashTable[val] = len(this.Arr)\\n\\tthis.Arr = append(this.Arr, val)\\n\\treturn true\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\t// find the target index of the val from the hashtable\\n\\t\\ttargetIdx := this.HashTable[val]\\n\\t\\t// assign the last item to the target index\\n\\t\\tthis.HashTable[this.Arr[len(this.Arr)-1]] = targetIdx\\n\\t\\t// swap the target item and the last item\\n\\t\\tthis.Arr[targetIdx], this.Arr[len(this.Arr)-1] = this.Arr[len(this.Arr)-1], this.Arr[targetIdx]\\n\\t\\t// remove the last item\\n\\t\\tthis.Arr = this.Arr[:len(this.Arr)-1]\\n\\t\\t// delete the key from hashtable\\n\\t\\tdelete(this.HashTable, val)\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n/** Get a random element from the set. */\\nfunc (this *RandomizedSet1) GetRandom() int {\\n\\tr := rand.Intn(len(this.Arr))\\n\\treturn this.Arr[r]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141493,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "**Basic Idea:** \\n* List is used to store the numbers and serve GetRandom() method. \\n* Dictionary contains the mapping between the value and it\\'s index in the List. \\n* Dictionary helps to check whether a value is already inserted or not. \\n* The **trick** is when you **remove** a value. List\\'s RemoveAt method is O(n), if you remove from random location. To overcome that, we swap the values between (randomIndex, lastIndex) and always remove the entry from the end of the list. \\n* After the swap, you need to update the new index of the swapped value (which was previously at the end of the list) in the map.\\n```\\npublic class RandomizedSet {\\n    \\n    List<int> set;\\n    Dictionary<int, int> map;\\n    Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet()\\n    {\\n        this.set = new List<int>();\\n        this.map = new Dictionary<int, int>();\\n        this.random = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (!this.map.ContainsKey(val))\\n        {\\n            this.map[val] = this.set.Count;\\n            this.set.Add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        int valIndex;\\n        if (this.map.TryGetValue(val, out valIndex))\\n        {\\n            //Cache current last element in set.\\n            int lastIndexInSet = this.set.Count - 1;\\n            int lastElement = this.set[lastIndexInSet];   \\n            //Move val to be removed to last in set.\\n            this.map[val] = lastIndexInSet;   \\n            this.set[lastIndexInSet] = val;\\n            //Move cached last element to where the val to be removed was before it was move to last.\\n            this.set[valIndex] = lastElement;   \\n            this.map[lastElement] = valIndex;\\n            //Remove the last element from the set.\\n            this.set.RemoveAt(this.set.Count - 1);\\n            this.map.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int GetRandom()\\n    {\\n        return this.set[this.random.Next(this.set.Count)];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    \\n    List<int> set;\\n    Dictionary<int, int> map;\\n    Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet()\\n    {\\n        this.set = new List<int>();\\n        this.map = new Dictionary<int, int>();\\n        this.random = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (!this.map.ContainsKey(val))\\n        {\\n            this.map[val] = this.set.Count;\\n            this.set.Add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        int valIndex;\\n        if (this.map.TryGetValue(val, out valIndex))\\n        {\\n            //Cache current last element in set.\\n            int lastIndexInSet = this.set.Count - 1;\\n            int lastElement = this.set[lastIndexInSet];   \\n            //Move val to be removed to last in set.\\n            this.map[val] = lastIndexInSet;   \\n            this.set[lastIndexInSet] = val;\\n            //Move cached last element to where the val to be removed was before it was move to last.\\n            this.set[valIndex] = lastElement;   \\n            this.map[lastElement] = valIndex;\\n            //Remove the last element from the set.\\n            this.set.RemoveAt(this.set.Count - 1);\\n            this.map.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int GetRandom()\\n    {\\n        return this.set[this.random.Next(this.set.Count)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321129,
                "title": "easy-c-solution-using-unordered-set",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end()){\\n            s.insert(val);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)!=s.end()){\\n            auto it=s.find(val);\\n            s.erase(it);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int n=rand()%s.size();\\n        auto it =s.begin();\\n        advance(it, n); // advances the iterator \\u2018it\\u2019 by n element positions\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end()){\\n            s.insert(val);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)!=s.end()){\\n            auto it=s.find(val);\\n            s.erase(it);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int n=rand()%s.size();\\n        auto it =s.begin();\\n        advance(it, n); // advances the iterator \\u2018it\\u2019 by n element positions\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859387,
                "title": "short-and-super-clear-set-solution",
                "content": "The built-in `HashSet` set class already has everything we need, except getting an element by index, so let\\'s use LINQ\\'s `ElementAt` method for that, even though it\\'s a bit slow:\\n```csharp\\npublic class RandomizedSet\\n{\\n    HashSet<int> set = new();\\n    Random rnd = new();\\n\\n    public bool Insert(int n) => set.Add(n);\\n    \\n    public bool Remove(int n) => set.Remove(n);\\n    \\n    public int GetRandom() => set.ElementAt(rnd.Next(set.Count));\\n}\\n```\\nTo make `GetRandom()` faster, we can convert the set to a list with `ToList()` and only then get an element by index:\\n```csharp\\nset.ToList()[rnd.Next(set.Count)];\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```csharp\\npublic class RandomizedSet\\n{\\n    HashSet<int> set = new();\\n    Random rnd = new();\\n\\n    public bool Insert(int n) => set.Add(n);\\n    \\n    public bool Remove(int n) => set.Remove(n);\\n    \\n    public int GetRandom() => set.ElementAt(rnd.Next(set.Count));\\n}\\n```\n```csharp\\nset.ToList()[rnd.Next(set.Count)];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161458,
                "title": "java-beats-100",
                "content": "```\\nclass RandomizedSet {\\n    HashMap<Integer,Integer> list=null;\\n    int[] array=null;\\n    int index=0;\\n    Random random=null;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list=new HashMap<Integer,Integer>();\\n        array=new int[100001];\\n        random=new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            array[index]=val;\\n            list.put(val,index);\\n            index++;\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            int pos=list.remove(val);\\n            array[pos]=array[index-1];\\n            if(list.containsKey(array[index-1])){\\n            list.put(array[index-1],pos);\\n            }\\n            index--;\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return array[random.nextInt(index)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    HashMap<Integer,Integer> list=null;\\n    int[] array=null;\\n    int index=0;\\n    Random random=null;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list=new HashMap<Integer,Integer>();\\n        array=new int[100001];\\n        random=new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            array[index]=val;\\n            list.put(val,index);\\n            index++;\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            int pos=list.remove(val);\\n            array[pos]=array[index-1];\\n            if(list.containsKey(array[index-1])){\\n            list.put(array[index-1],pos);\\n            }\\n            index--;\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return array[random.nextInt(index)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683251,
                "title": "easy-c-explanation",
                "content": "```\\nclass RandomizedSet {\\n    //this map monitors if a values is present or not\\n    //if present it also gives its index\\n    unordered_map<int, int> cache;  \\n    \\n    //here we store the values\\n    vector<int> values;\\n    \\n    //Note : map is required for O(1) insertion and deletion\\n    //       vector is required for O(1) random selection\\n    \\n    int n = 0;        //this keeps the size of vector\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n      if(cache.count(val))\\n          return false;\\n        \\n      cache[val] = n++;\\n      values.push_back(val);\\n      return true;\\n    }\\n    \\n    bool remove(int val) {\\n       if(!cache.count(val))\\n          return false;\\n      \\n        \\n        //To remove an element we get it\\'s index from cache map,\\n        //place last element of vector at this index\\n        //also update index of last element in cache map\\n        //and remove the last element in O(1) time\\n        //Also note : if we would have used  erase function for vector, it would have cost O(n)\\n        \\n        int ind = cache[val];\\n        int last_element = values.back();\\n        values[ind] = last_element;\\n        cache[last_element] = ind;\\n        values.pop_back();\\n        n--;\\n\\n        cache.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n     return values[rand()%n];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    //this map monitors if a values is present or not\\n    //if present it also gives its index\\n    unordered_map<int, int> cache;  \\n    \\n    //here we store the values\\n    vector<int> values;\\n    \\n    //Note : map is required for O(1) insertion and deletion\\n    //       vector is required for O(1) random selection\\n    \\n    int n = 0;        //this keeps the size of vector\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n      if(cache.count(val))\\n          return false;\\n        \\n      cache[val] = n++;\\n      values.push_back(val);\\n      return true;\\n    }\\n    \\n    bool remove(int val) {\\n       if(!cache.count(val))\\n          return false;\\n      \\n        \\n        //To remove an element we get it\\'s index from cache map,\\n        //place last element of vector at this index\\n        //also update index of last element in cache map\\n        //and remove the last element in O(1) time\\n        //Also note : if we would have used  erase function for vector, it would have cost O(n)\\n        \\n        int ind = cache[val];\\n        int last_element = values.back();\\n        values[ind] = last_element;\\n        cache[last_element] = ind;\\n        values.pop_back();\\n        n--;\\n\\n        cache.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n     return values[rand()%n];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3546345,
                "title": "really-easy-approach-java-o-1-beats-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private Map<Integer, Integer> map;\\n    private List<Integer> listOfNumbers;\\n    private Random rn;\\n\\n    public RandomizedSet() {\\n        this.map = new HashMap<Integer, Integer>();\\n        this.listOfNumbers = new ArrayList<Integer>();\\n        this.rn = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            listOfNumbers.add(val);\\n            map.put(val, listOfNumbers.size() - 1);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (map.containsKey(val)) {\\n            int index = map.remove(val);\\n            int lastVal = listOfNumbers.remove(listOfNumbers.size() - 1);\\n            if (lastVal != val) {\\n                listOfNumbers.set(index, lastVal);\\n                map.put(lastVal, index);\\n            }\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int random = rn.nextInt(listOfNumbers.size());\\n        return listOfNumbers.get(random);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private Map<Integer, Integer> map;\\n    private List<Integer> listOfNumbers;\\n    private Random rn;\\n\\n    public RandomizedSet() {\\n        this.map = new HashMap<Integer, Integer>();\\n        this.listOfNumbers = new ArrayList<Integer>();\\n        this.rn = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            listOfNumbers.add(val);\\n            map.put(val, listOfNumbers.size() - 1);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (map.containsKey(val)) {\\n            int index = map.remove(val);\\n            int lastVal = listOfNumbers.remove(listOfNumbers.size() - 1);\\n            if (lastVal != val) {\\n                listOfNumbers.set(index, lastVal);\\n                map.put(lastVal, index);\\n            }\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int random = rn.nextInt(listOfNumbers.size());\\n        return listOfNumbers.get(random);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252931,
                "title": "380-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe class RandomizedSet is implemented using a hash table and an array. The hash table stores the values and their indices in the array, while the array stores the actual values.\\n\\nThe insert method takes a value as input and adds it to the set if it does not already exist in the set. If the value already exists, it returns False to indicate that the operation was not successful. To check if the value exists in the set, the hash table is checked. If the value does not exist, the value is added to the end of the array, and the value-index pair is added to the hash table. The time complexity of this method is O(1) on average.\\n\\nThe remove method takes a value as input and removes it from the set if it exists in the set. If the value does not exist, it returns False to indicate that the operation was not successful. To check if the value exists in the set, the hash table is checked. If the value exists, the index of the value in the array is obtained from the hash table, and the last value in the array is obtained. The value at the index is replaced with the last value in the array, and the index of the last value in the hash table is updated. The last value in the array is then removed, and the value-index pair for the removed value is removed from the hash table. The time complexity of this method is O(1) on average.\\n\\nThe getRandom method returns a random value from the set. To do this, a random value is chosen from the array using the random.choice method. The time complexity of this method is O(1) on average.\\n\\nOverall, the time complexity of each method is O(1) on average since all operations involve constant time hash table and array operations. The space complexity of the class is O(n), where n is the number of values in the set, since it uses a hash table and an array to store the values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet:\\n\\n  def __init__(self):\\n    \"\"\"\\n    Initialize your data structure here.\\n    \"\"\"\\n    self.val_to_index = {}  # Hash table to store values and their indices in the array\\n    self.vals = []          # Array to store the actual values\\n\\n  def insert(self, val: int) -> bool:\\n    \"\"\"\\n    Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n    \"\"\"\\n    if val in self.val_to_index:    # If the value already exists in the hash table, return false\\n        return False\\n    self.val_to_index[val] = len(self.vals)    # Add the value to the hash table with its index in the array\\n    self.vals.append(val)           # Append the value to the end of the array\\n    return True                     # Return true to indicate success\\n\\n  def remove(self, val: int) -> bool:\\n    \"\"\"\\n    Removes a value from the set. Returns true if the set contained the specified element.\\n    \"\"\"\\n    if val not in self.val_to_index:    # If the value does not exist in the hash table, return false\\n        return False\\n    index = self.val_to_index[val]      # Get the index of the value in the array\\n    last_val = self.vals[-1]            # Get the last value in the array\\n    self.vals[index] = last_val         # Swap the value at the index with the last value in the array\\n    self.val_to_index[last_val] = index # Update the index of the last value in the hash table\\n    self.vals.pop()                     # Remove the last value from the array\\n    del self.val_to_index[val]           # Remove the removed value from the hash table\\n    return True                          # Return true to indicate success\\n\\n  def getRandom(self) -> int:\\n    \"\"\"\\n    Get a random element from the set.\\n    \"\"\"\\n    return random.choice(self.vals)     # Return a random value from the array\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n  def __init__(self):\\n    \"\"\"\\n    Initialize your data structure here.\\n    \"\"\"\\n    self.val_to_index = {}  # Hash table to store values and their indices in the array\\n    self.vals = []          # Array to store the actual values\\n\\n  def insert(self, val: int) -> bool:\\n    \"\"\"\\n    Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n    \"\"\"\\n    if val in self.val_to_index:    # If the value already exists in the hash table, return false\\n        return False\\n    self.val_to_index[val] = len(self.vals)    # Add the value to the hash table with its index in the array\\n    self.vals.append(val)           # Append the value to the end of the array\\n    return True                     # Return true to indicate success\\n\\n  def remove(self, val: int) -> bool:\\n    \"\"\"\\n    Removes a value from the set. Returns true if the set contained the specified element.\\n    \"\"\"\\n    if val not in self.val_to_index:    # If the value does not exist in the hash table, return false\\n        return False\\n    index = self.val_to_index[val]      # Get the index of the value in the array\\n    last_val = self.vals[-1]            # Get the last value in the array\\n    self.vals[index] = last_val         # Swap the value at the index with the last value in the array\\n    self.val_to_index[last_val] = index # Update the index of the last value in the hash table\\n    self.vals.pop()                     # Remove the last value from the array\\n    del self.val_to_index[val]           # Remove the removed value from the hash table\\n    return True                          # Return true to indicate success\\n\\n  def getRandom(self) -> int:\\n    \"\"\"\\n    Get a random element from the set.\\n    \"\"\"\\n    return random.choice(self.vals)     # Return a random value from the array\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860038,
                "title": "java-o-1-solution-using-hashset-and-array",
                "content": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> randomSet;\\n        \\n    public RandomizedSet() {\\n        randomSet = new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (randomSet.contains(val)) {\\n            return false;\\n        }\\n        randomSet.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (randomSet.contains(val)) {\\n            randomSet.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        Integer[] numbers = randomSet.toArray(new Integer[randomSet.size()]);\\n        Random random = new Random();\\n        int randomNumber = random.nextInt(randomSet.size());\\n        return numbers[randomNumber];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> randomSet;\\n        \\n    public RandomizedSet() {\\n        randomSet = new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (randomSet.contains(val)) {\\n            return false;\\n        }\\n        randomSet.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (randomSet.contains(val)) {\\n            randomSet.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        Integer[] numbers = randomSet.toArray(new Integer[randomSet.size()]);\\n        Random random = new Random();\\n        int randomNumber = random.nextInt(randomSet.size());\\n        return numbers[randomNumber];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859125,
                "title": "easy-cpp-solution-using-vector-and-rand-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to create functions to insert values, remove values and to output any random element from set of elements.\\nSo we can use vector to store the input values and to get random values we can use CPP In-Built function rand() .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we initialize a vector,\\nthen before inserting we check if element is already present,if  present then we return false as we can\\'t insert same element again, else we can insert element and we return true.\\nNow, \\nwhen creating remove(int val), we first need to check that if there is no element in the vector then we can\\'t remove further elements and thus we return false, else we remove element using erase() function and return true,else if we don\\'t find element then we return false.\\n\\nNow, the most interesting part is getRandom(), where we have to return a random element where we use rand() function which generates a random value in a specific range, thus we return elements at random indices in vector and return them.\\nHope you Understand!\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBest case:   **O(1)**\\nWorst case:  **O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(N)**\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private:\\n    vector<int>vec;\\npublic:\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        for(auto it:vec)\\n        {\\n            if(it==val)\\n            return false;\\n        }\\n        vec.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(vec.size()<1)return false;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==val)\\n            {\\n                vec.erase(vec.begin()+i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private:\\n    vector<int>vec;\\npublic:\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        for(auto it:vec)\\n        {\\n            if(it==val)\\n            return false;\\n        }\\n        vec.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(vec.size()<1)return false;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==val)\\n            {\\n                vec.erase(vec.begin()+i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859103,
                "title": "c-solution",
                "content": "``` C++ []\\nclass RandomizedSet {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n        \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n                \\n        if(mp.count(val))\\n            return false;\\n        \\n        arr.push_back(val);\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.count(val))\\n        {            \\n            int idx = mp[val];\\n                        \\n            int last_val = arr.back();\\n                        \\n            arr[idx] = last_val;\\n                        \\n            arr.pop_back();\\n                       \\n            mp[last_val] = idx;\\n                        \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n                \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```\\n\\n*Upvote if it helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass RandomizedSet {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n        \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n                \\n        if(mp.count(val))\\n            return false;\\n        \\n        arr.push_back(val);\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.count(val))\\n        {            \\n            int idx = mp[val];\\n                        \\n            int last_val = arr.back();\\n                        \\n            arr[idx] = last_val;\\n                        \\n            arr.pop_back();\\n                       \\n            mp[last_val] = idx;\\n                        \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n                \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165896,
                "title": "easy-to-understand-c-solution-using-vector-and-hash-map",
                "content": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> mymap;\\n    vector<int> myvec;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (mymap.find(val) != mymap.end()) return false;\\n        myvec.push_back(val);\\n        int index = myvec.size() - 1;\\n        mymap[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (mymap.find(val) == mymap.end()) return false;\\n        // Reset the last value of myvec to the index and pop back\\n        int index = mymap[val];\\n        int last_val = myvec.back();\\n        myvec[index] = last_val;\\n        myvec.pop_back();\\n        mymap[last_val] = index;\\n        mymap.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (myvec.size() == 1) return myvec[0];\\n        int size  = myvec.size();\\n        //cout << \"size is \" << size << endl;\\n        int index = rand() % (size);\\n        return myvec[index];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> mymap;\\n    vector<int> myvec;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (mymap.find(val) != mymap.end()) return false;\\n        myvec.push_back(val);\\n        int index = myvec.size() - 1;\\n        mymap[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (mymap.find(val) == mymap.end()) return false;\\n        // Reset the last value of myvec to the index and pop back\\n        int index = mymap[val];\\n        int last_val = myvec.back();\\n        myvec[index] = last_val;\\n        myvec.pop_back();\\n        mymap[last_val] = index;\\n        mymap.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (myvec.size() == 1) return myvec[0];\\n        int size  = myvec.size();\\n        //cout << \"size is \" << size << endl;\\n        int index = rand() % (size);\\n        return myvec[index];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1006328,
                "title": "a-c-solution-and-thought-process",
                "content": "First up my solution:\\n```\\n// Time: O(1), Space: O(n)\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(ht.find(val)==ht.end()){\\n            vec.push_back(val);\\n            ht[val]=vec.size()-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(ht.find(val)!=ht.end()){\\n            vec[ht[val]]=vec[vec.size()-1];\\n            ht[vec[vec.size()-1]]=ht[val];\\n            vec.pop_back();\\n            ht.erase(val);\\n            return true;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(vec.size()==1)\\n            return vec[0];\\n        else{\\n            int idx=rand()%(vec.size());\\n            return vec[idx];   \\n        }\\n    }\\n    \\n    unordered_map<int,int> ht;\\n    vector<int> vec;\\n};\\n```\\n\\nWhen I first looked at the problem, it seems quite straightforward. Inserting and deleting in constant time means hashtable. But when I start working on the get random, it starts to get trickier. I was initially thinking that I can find random in constant time using unordered_set iterator and do something like (ht.begin()+somerandint). But I realized that ht iterator is not a random access iterator, meaning in order to get to a specific iterator I have to iterator from the begin iterator which takes linear time. Therefore, we need a container with random access. vector is an obvious choice. But I was stuck again, because vector erasing sounds like linear time. After looking at the solution, I realize that the erasing is usually linear because we need to keep the order vector. In cases like this, we don\\'t care about maintaining the order of elements and removing a specific element can be done in constant time by utilizing pop_back().\\n\\nNot very familiar with the random stl class, so if there\\'s a better way to get rand from a vector, let me know.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Time: O(1), Space: O(n)\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(ht.find(val)==ht.end()){\\n            vec.push_back(val);\\n            ht[val]=vec.size()-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(ht.find(val)!=ht.end()){\\n            vec[ht[val]]=vec[vec.size()-1];\\n            ht[vec[vec.size()-1]]=ht[val];\\n            vec.pop_back();\\n            ht.erase(val);\\n            return true;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(vec.size()==1)\\n            return vec[0];\\n        else{\\n            int idx=rand()%(vec.size());\\n            return vec[idx];   \\n        }\\n    }\\n    \\n    unordered_map<int,int> ht;\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731469,
                "title": "standard-java-solution",
                "content": "### Theory\\nThe main issue with this problem is that we are asked to generate a random value from any value of a set, and sets aren\\'t indexed. So we must keep a list as the main structure, with a map that maps from value -> index, as well as a psudeo random generator object.\\n\\nIn order to maintain O(1) time in the remove (ArrayList.remove() will take O(N) worst case), we must shift the last element in the list to the spot where we delete the value. It makes much more sense in code,\\n\\n### Solution\\n```\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n    private Random rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n        list.add(val);\\n        map.put(val, list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int lastElement = list.get(list.size() - 1);\\n        int index = map.get(val);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        list.remove(list.size() - 1);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n    private Random rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n        list.add(val);\\n        map.put(val, list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int lastElement = list.get(list.size() - 1);\\n        int index = map.get(val);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        list.remove(list.size() - 1);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685574,
                "title": "challenge-me-for-shorter-solution-4-line",
                "content": "**Idea**:  \\njust to prove how close the desired data structre is to set. BTW, it is also another case where it is possible to write short and sexy code as python.\\n\\nTo get the solution 100% meet the requirement, you can refer to other top voted posts. \\nIf you this post increase your love for STL, please help upvote. Thanks.\\n\\n**Warning**:  This dose not meet the O(1) time complexity requirement.\\n\\nThe solution here is a sub-optimal solution just to illustrate the power of STL.\\nMay the force of STL be with you.**\\n\\n\\nTime complexity:\\nInsert:  O(1)\\nremove: O(1)\\ngetRandom:O(N). But this took me one year to realize we can do this.\\nReference: \\nhttps://en.cppreference.com/w/cpp/container/unordered_set/erase\\nhttps://en.cppreference.com/w/cpp/container/unordered_set/insert\\n\\n\\n```\\nclass RandomizedSet { // An elegant sub-optimal Solution for fun in the name of study by codedayday: https://leetcode.com/codedayday/\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_set<int> m_;\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); //return the number of elements erased. \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {        \\n        return *next(m_.begin(), rand() % m_.size());\\n    }\\n};\\n```\\n\\n\\nAs a reference, a 9-line python solution with same idea from https://leetcode.com/dayeon486/ is also pasted at the end of this poster.\\nOnce again, the solution is sub-optimal since the implementation of getRandom() is based on hashset, the time cost must be O(N), instead of O(1).\\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.s = set()\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.s:\\n            self.s.add(val)\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.s:\\n            self.s.remove(val)\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.sample(self.s, 1)[0]\\n```\\nCredit:\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/discuss/684502/Accepted-python-using-only-one-SET\\n\\nNote1:\\nLet\\'s be clear: the time complexity of following operation is O(N)\\n```\\nrandom.sample(self.s, 1)[0]\\n```\\nReference: \\nYou can check the implementation of random.sample() for more details here:      \\n https://stackoverflow.com/questions/10483377/time-complexity-of-random-sample\\n",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet { // An elegant sub-optimal Solution for fun in the name of study by codedayday: https://leetcode.com/codedayday/\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_set<int> m_;\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); //return the number of elements erased. \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {        \\n        return *next(m_.begin(), rand() % m_.size());\\n    }\\n};\\n```\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.s = set()\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.s:\\n            self.s.add(val)\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.s:\\n            self.s.remove(val)\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.sample(self.s, 1)[0]\\n```\n```\\nrandom.sample(self.s, 1)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683902,
                "title": "c-solution-using-vector-hash-map",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(!m_.count(val)) {\\n            v_.push_back(val);\\n            m_[val]=v_.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m_.count(val)){\\n            int i=m_[val];\\n            swap(v_[i], v_[v_.size()-1]);\\n            v_.pop_back();\\n            m_[v_[i]]=i;\\n            m_.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int i=rand()%m_.size();\\n        return v_[i];\\n        \\n    }\\n    \\nprivate:\\n    vector<int> v_;\\n    unordered_map<int, int> m_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(!m_.count(val)) {\\n            v_.push_back(val);\\n            m_[val]=v_.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m_.count(val)){\\n            int i=m_[val];\\n            swap(v_[i], v_[v_.size()-1]);\\n            v_.pop_back();\\n            m_[v_[i]]=i;\\n            m_.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int i=rand()%m_.size();\\n        return v_[i];\\n        \\n    }\\n    \\nprivate:\\n    vector<int> v_;\\n    unordered_map<int, int> m_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138129,
                "title": "python-solution",
                "content": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.array = []\\n        self.idx_dict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_dict:\\n            self.array.append(val)\\n            self.idx_dict[val] = len(self.array) - 1\\n            return True\\n\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.idx_dict:\\n            idx = self.idx_dict[val]\\n            self.array[idx], self.array[len(self.array)-1] = self.array[len(self.array)-1], self.array[idx]\\n            self.idx_dict[self.array[idx]] = idx\\n            self.array.pop()\\n            self.idx_dict.pop(val, None)\\n            return True\\n\\n        return False\\n\\n    # Assume there are element in the array\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        ran_idx = random.randint(0, len(self.array)-1)\\n        return self.array[ran_idx]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.array = []\\n        self.idx_dict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_dict:\\n            self.array.append(val)\\n            self.idx_dict[val] = len(self.array) - 1\\n            return True\\n\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.idx_dict:\\n            idx = self.idx_dict[val]\\n            self.array[idx], self.array[len(self.array)-1] = self.array[len(self.array)-1], self.array[idx]\\n            self.idx_dict[self.array[idx]] = idx\\n            self.array.pop()\\n            self.idx_dict.pop(val, None)\\n            return True\\n\\n        return False\\n\\n    # Assume there are element in the array\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        ran_idx = random.randint(0, len(self.array)-1)\\n        return self.array[ran_idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062167,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end())\\n        return false;\\n        v.push_back(val);\\n        mp[val]=v.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end())\\n        return false;\\n        int i=mp[val];\\n        v[i]=v[v.size()-1];\\n        mp[v[v.size()-1]]=i;\\n        v.pop_back();\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end())\\n        return false;\\n        v.push_back(val);\\n        mp[val]=v.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end())\\n        return false;\\n        int i=mp[val];\\n        v[i]=v[v.size()-1];\\n        mp[v[v.size()-1]]=i;\\n        v.pop_back();\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860897,
                "title": "python-3-380-insert-delete-getrandom-t-m-80-75",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.randSet = defaultdict()\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.randSet: return False\\n        \\n        self.randSet[val]= None\\n        return True\\n        \\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.randSet: return False\\n        \\n        self.randSet.pop(val)\\n        return True\\n\\n    \\n    def getRandom(self) -> int:\\n        \\n        return choice(list(self.randSet.keys()))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.randSet = defaultdict()\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.randSet: return False\\n        \\n        self.randSet[val]= None\\n        return True\\n        \\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.randSet: return False\\n        \\n        self.randSet.pop(val)\\n        return True\\n\\n    \\n    def getRandom(self) -> int:\\n        \\n        return choice(list(self.randSet.keys()))",
                "codeTag": "Java"
            },
            {
                "id": 2860859,
                "title": "c-vector-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought came in mind to choose \\'set\\' as data structure, but it take O(n) time comlexity for the finding of random number, so i have use vector, but time complexity for removal of the element from vector will be O(n), to reduce the time complexity of removal i have use unordered_map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have apply simple approach, swap the element which have to remove to the last index then remove the last index. Update the index of swapped element in map and remove the element from map.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    int i;\\n    RandomizedSet() {\\n        i=-1;\\n    }\\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            v.push_back(val);\\n            i++;\\n            mp[val]=i;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(i>=0 && mp.find(val)!=mp.end()){\\n            int index=mp[val];\\n            swap(v[index],v[i]);\\n            mp[v[index]]=index;\\n            mp.erase(val);\\n            v.pop_back();\\n            i--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    int i;\\n    RandomizedSet() {\\n        i=-1;\\n    }\\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            v.push_back(val);\\n            i++;\\n            mp[val]=i;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(i>=0 && mp.find(val)!=mp.end()){\\n            int index=mp[val];\\n            swap(v[index],v[i]);\\n            mp[v[index]]=index;\\n            mp.erase(val);\\n            v.pop_back();\\n            i--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859787,
                "title": "array-and-hashmap-used-o-1-for-each-operation-very-east-and-concise",
                "content": "# Intuition\\n> Always insert elements in the end of the array and put the index and value in the hashmap\\n\\n> To Delete, always swap the element with the last element of the array and update the index of the last element in the hashmap and delete the last element from the array and hashmap\\n\\n> To get random element, return random element from the array from the range: 0 to top-1\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for EachOperation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2*10e5)$$, but for Asymptomatic cases, it is $$O(1)$$ since the program do not allocate extra space for the array for the following runtimes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    static int[] arr;\\n    int top=-1;\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    public RandomizedSet() {\\n        if(arr==null) arr = new int[200001];\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!map.containsKey(val)){\\n            top++;\\n            arr[top]=val;\\n            map.put(val,top);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int pos = map.get(val);\\n            map.put(arr[top],pos);\\n            arr[pos] = arr[pos] + arr[top] - (arr[top] = arr[pos]); // swapping\\n            top--;\\n            map.remove(val);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public int getRandom() {\\n        return arr[(int)(Math.random()*(top+1))];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\n    static int[] arr;\\n    int top=-1;\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    public RandomizedSet() {\\n        if(arr==null) arr = new int[200001];\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!map.containsKey(val)){\\n            top++;\\n            arr[top]=val;\\n            map.put(val,top);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int pos = map.get(val);\\n            map.put(arr[top],pos);\\n            arr[pos] = arr[pos] + arr[top] - (arr[top] = arr[pos]); // swapping\\n            top--;\\n            map.remove(val);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public int getRandom() {\\n        return arr[(int)(Math.random()*(top+1))];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858201,
                "title": "golang",
                "content": "```\\ntype RandomizedSet struct {\\n    m map[int]int\\n    l []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    m := make(map[int]int)\\n    l := make([]int, 0)\\n    return RandomizedSet{m, l}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.m[val]; ok {\\n        return false\\n    }\\n    this.m[val] = len(this.l)\\n    this.l = append(this.l, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.m[val]; !ok {\\n        return false\\n    }\\n    n, i := len(this.l), this.m[val]\\n    this.l[i], this.l[n-1] = this.l[n-1], this.l[i]\\n    this.m[this.l[i]] = i\\n    this.l = this.l[:n-1]\\n    delete(this.m, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    i := rand.Intn(len(this.l))\\n    return this.l[i]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    m map[int]int\\n    l []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    m := make(map[int]int)\\n    l := make([]int, 0)\\n    return RandomizedSet{m, l}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.m[val]; ok {\\n        return false\\n    }\\n    this.m[val] = len(this.l)\\n    this.l = append(this.l, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.m[val]; !ok {\\n        return false\\n    }\\n    n, i := len(this.l), this.m[val]\\n    this.l[i], this.l[n-1] = this.l[n-1], this.l[i]\\n    this.m[this.l[i]] = i\\n    this.l = this.l[:n-1]\\n    delete(this.m, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    i := rand.Intn(len(this.l))\\n    return this.l[i]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858185,
                "title": "explained-optimized-o-1-cpp-fully-commented",
                "content": "# Complexity\\n- Time complexity: Average Time O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Auxiliary Space O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach\\n- We will take order of elements is not important in the data structure. \\n- If we use an array as the data structure, insertion at the end will be in O(1) time but searching whether the element is already present in the array will take O(N) time. \\n- Removal of the element will require searching for the element which will take O(N) time and left shifting the subsequent array elements will also take O(N) time.\\n-  Getting random element will take O(1) time using the rand() function. \\n- So, we need some additional data structure that allows us to locate the array index for removal and also to search whether the element is already present or not. \\n- This data structure should do these tasks in average O(1) time. Hashmap fulfils our requirements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# CPP Code\\n```\\nclass RandomizedSet {\\n\\t// Thanks to Bhalerao-2002\\nprivate:\\n    // array vector\\n    vector<int> a;\\n     // Unordered Map does searching, insertion & deletion of element in average O(1) time\\n    unordered_map<int,int> m;\\npublic:\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    //Insert\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to next memory location  \\n            // of the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  \\n            m[val]=a.size()-1; \\n            return true;\\n        }\\n    }\\n    \\n    //Remove\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.     \\n            a.pop_back();\\t   \\n            m[last]=m[val];\\t     \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n```\\n#Upvote if it Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\t// Thanks to Bhalerao-2002\\nprivate:\\n    // array vector\\n    vector<int> a;\\n     // Unordered Map does searching, insertion & deletion of element in average O(1) time\\n    unordered_map<int,int> m;\\npublic:\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    //Insert\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to next memory location  \\n            // of the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  \\n            m[val]=a.size()-1; \\n            return true;\\n        }\\n    }\\n    \\n    //Remove\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.     \\n            a.pop_back();\\t   \\n            m[last]=m[val];\\t     \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854916,
                "title": "easy-explanation-of-getrandom-function-golang-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever in questions it says O(1), I always think about HashMap. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare map in our concrete class, which is going to store the keys.\\n- Insert() - straight forward, if not present then add\\n- Remove() - straight forward, if present then delete\\n- GetRandom() - Need to think how we can get the randomKey, here we will find the length of the map, and using golang `rand` package we can get the random value in a range(in our case len of the map). We will introduce a counter which is going to tell us when to return the key.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\ntype RandomizedSet struct {\\n    mp map[int]bool\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{\\n        mp: make(map[int]bool),\\n    }\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.mp[val]; !ok{\\n        this.mp[val] = true\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.mp[val]; ok {\\n        delete(this.mp, val)\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    l := len(this.mp)\\n    randNumber := rand.Intn(l)\\n    counter := 0\\n\\n    for k := range this.mp {\\n        if counter == randNumber {\\n            return k\\n        }\\n        counter++\\n    }\\n    return -1\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Insert(val);\\n * param_2 := obj.Remove(val);\\n * param_3 := obj.GetRandom();\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    mp map[int]bool\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{\\n        mp: make(map[int]bool),\\n    }\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.mp[val]; !ok{\\n        this.mp[val] = true\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.mp[val]; ok {\\n        delete(this.mp, val)\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    l := len(this.mp)\\n    randNumber := rand.Intn(l)\\n    counter := 0\\n\\n    for k := range this.mp {\\n        if counter == randNumber {\\n            return k\\n        }\\n        counter++\\n    }\\n    return -1\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Insert(val);\\n * param_2 := obj.Remove(val);\\n * param_3 := obj.GetRandom();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766001,
                "title": "easy-peasy-using-dictnory-and-sortedcontainer-library-tc-logn",
                "content": "```\\nimport random\\nfrom sortedcontainers import SortedList\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n    def insert(self, val: int) -> bool:\\n        if(self.dc[val]==1):\\n            return False\\n        self.dc[val]=1\\n        self.arr.add(val)\\n        return True\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]==0):\\n            return False\\n        self.dc[val]=0\\n        self.arr.discard(val)\\n        return True\\n    def getRandom(self) -> int:\\n        x=random.randint(0,len(self.arr)-1)\\n        return(self.arr[x])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random\\nfrom sortedcontainers import SortedList\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n    def insert(self, val: int) -> bool:\\n        if(self.dc[val]==1):\\n            return False\\n        self.dc[val]=1\\n        self.arr.add(val)\\n        return True\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]==0):\\n            return False\\n        self.dc[val]=0\\n        self.arr.discard(val)\\n        return True\\n    def getRandom(self) -> int:\\n        x=random.randint(0,len(self.arr)-1)\\n        return(self.arr[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676472,
                "title": "python-solution-using-dictionary-and-list-392-ms-faster-then-98-18-with-comments",
                "content": "\\tdef __init__(self):\\n        # Using Dictionary and List\\n        self.dict = {} # To maintain the index\\n        self.list = [] # To store all the values\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.dict:\\n            return False # If the element is already in the dictionary then return False\\n        \\n        self.dict[val] = len(self.list) # settinng the value with their in dex in hashmap\\n        self.list.append(val) #Appending the value in the list\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.dict: # Removing only if the value is in the dictionary\\n            last_element = self.list[-1] # getting the last element in the list\\n            index = self.dict[val] # getting the index value of the element to be removed from the dictionary\\n            \\n            self.list[index] = last_element # Replacing the element to be removed with the last element in the list\\n            self.dict[last_element] = index # setting the index value of the last element which was changed recently in the dictionary\\n            \\n            self.list.pop() # Popping the last element from the list\\n            del self.dict[val] #deleting the value from dictionary too which was deleted from the list\\n            return True\\n        return False # IF value not in the dictionary then return false\\n\\n    def getRandom(self) -> int:\\n        \\n        return choice(self.list) #Function to get the random element from the list\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7274f826-6295-4059-91ed-7a3a759e1755_1641681196.611421.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "\\tdef __init__(self):\\n        # Using Dictionary and List\\n        self.dict = {} # To maintain the index\\n        self.list = [] # To store all the values\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.dict:\\n            return False # If the element is already in the dictionary then return False\\n        \\n        self.dict[val] = len(self.list) # settinng the value with their in dex in hashmap\\n        self.list.append(val) #Appending the value in the list\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.dict: # Removing only if the value is in the dictionary\\n            last_element = self.list[-1] # getting the last element in the list\\n            index = self.dict[val] # getting the index value of the element to be removed from the dictionary\\n            \\n            self.list[index] = last_element # Replacing the element to be removed with the last element in the list\\n            self.dict[last_element] = index # setting the index value of the last element which was changed recently in the dictionary\\n            \\n            self.list.pop() # Popping the last element from the list\\n            del self.dict[val] #deleting the value from dictionary too which was deleted from the list\\n            return True\\n        return False # IF value not in the dictionary then return false\\n\\n    def getRandom(self) -> int:\\n        \\n        return choice(self.list) #Function to get the random element from the list\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7274f826-6295-4059-91ed-7a3a759e1755_1641681196.611421.png)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1541026,
                "title": "python3-o-1",
                "content": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.stack = []\\n        self.dict = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.dict:\\n            return False\\n\\n        self.dict[val] = len(self.stack)\\n        self.stack.append(val)\\n        return True\\n        \\n    def remove(self, val: int) -> bool:\\n\\t    # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val not in self.dict:\\n            return False        \\n        last = self.stack[-1]\\n        ind = self.dict[val] \\n        \\n        self.dict[last] = ind\\n        self.stack[ind] = last\\n        \\n        self.stack.pop()\\n        \\n        self.dict.pop(val)\\n        \\n        \\n        return True        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.stack = []\\n        self.dict = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.dict:\\n            return False\\n\\n        self.dict[val] = len(self.stack)\\n        self.stack.append(val)\\n        return True\\n        \\n    def remove(self, val: int) -> bool:\\n\\t    # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val not in self.dict:\\n            return False        \\n        last = self.stack[-1]\\n        ind = self.dict[val] \\n        \\n        self.dict[last] = ind\\n        self.stack[ind] = last\\n        \\n        self.stack.pop()\\n        \\n        self.dict.pop(val)\\n        \\n        \\n        return True        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1532400,
                "title": "simple-c-solution-using-unordered-set",
                "content": "This is O(n) Solution :\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> S;\\n    \\n    RandomizedSet() {\\n        S.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(S.find(val) == S.end())\\n        {\\n            S.insert(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(S.find(val) != S.end())\\n        {\\n            S.erase(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        int r = rand()%S.size();\\n        \\n        auto it = S.begin();\\n        \\n        while(r--)\\n            it++;\\n        \\n        return *it;\\n    }\\n};\\n```\\n\\nThis is O(1) Solution :\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        mp.clear();\\n        arr.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(mp.find(val) == mp.end())\\n        {\\n            arr.push_back(val);\\n            mp[val] = arr.size()-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.find(val) != mp.end())\\n        {\\n            int t = mp[val];\\n            int s = arr.size();\\n            \\n            arr[t] = arr[s-1];\\n            mp[arr[t]] = t;\\n            \\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {      \\n        \\n        int s = arr.size();\\n        \\n        return arr[rand() % s];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> S;\\n    \\n    RandomizedSet() {\\n        S.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(S.find(val) == S.end())\\n        {\\n            S.insert(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(S.find(val) != S.end())\\n        {\\n            S.erase(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        int r = rand()%S.size();\\n        \\n        auto it = S.begin();\\n        \\n        while(r--)\\n            it++;\\n        \\n        return *it;\\n    }\\n};\\n```\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        mp.clear();\\n        arr.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(mp.find(val) == mp.end())\\n        {\\n            arr.push_back(val);\\n            mp[val] = arr.size()-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.find(val) != mp.end())\\n        {\\n            int t = mp[val];\\n            int s = arr.size();\\n            \\n            arr[t] = arr[s-1];\\n            mp[arr[t]] = t;\\n            \\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {      \\n        \\n        int s = arr.size();\\n        \\n        return arr[rand() % s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506448,
                "title": "c-188ms-98-simple-easy-small-and-clean",
                "content": "Runtime: 188 ms, faster than 97.88% of C++ online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 97 MB, less than 83.92% of C++ online submissions for Insert Delete GetRandom O(1).\\n**General idea:**\\nwe asked to solve this task with time O1 for all cases : \\n1. inserting : put new value into \"tail\" vector and into map {value , index into vector}  **=> all operation with time O1**\\n2. erasing : **small trick !** we do swap with our erasing element and \"tail\" of vector and change in table value with key from \"tail\" of vector , after it do pop_back and erase(old key)  **=> all operation with time O1** \\n3. give random element form array **=> all operation with time O1**\\n```\\nclass RandomizedSet {\\npublic:\\n  unordered_map<int,int>table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    if(table.count(val)) return false; \\n    table[val] = v.size();\\n    v.push_back(val);\\n    return true;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    int old_index = table[val];\\n    table[v[old_index] = v.back()] = old_index;\\n    \\n    v.pop_back();\\n    table.erase(val);\\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n  unordered_map<int,int>table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    if(table.count(val)) return false; \\n    table[val] = v.size();\\n    v.push_back(val);\\n    return true;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    int old_index = table[val];\\n    table[v[old_index] = v.back()] = old_index;\\n    \\n    v.pop_back();\\n    table.erase(val);\\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440937,
                "title": "java-hashmap-arraylist-solution",
                "content": "```\\n// HashMap + ArrayList Solution\\n// HashMap to store <val, index> pair. \\n// remove(): Move the last element in ArrayList to the deleted element position to remove the element. Update the <val, index> pair in HashMap.\\n// Time complexity: O(1) for initialization, insert, remove and getRandom\\n// Space complexity: O(N)\\nclass RandomizedSet {\\n    private Random random;\\n    private List<Integer> list;\\n    private Map<Integer, Integer> valIdxMap;  // Stores <val, index> pair\\n\\n    public RandomizedSet() {\\n        random = new Random();\\n        list = new ArrayList<>();\\n        valIdxMap = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (valIdxMap.containsKey(val)) return false;\\n        valIdxMap.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!valIdxMap.containsKey(val)) return false;\\n        int idx = valIdxMap.get(val);\\n        // Move last element to deleted position.\\n        int lastVal = list.get(list.size() - 1);\\n        list.set(idx, lastVal);\\n        valIdxMap.put(lastVal, idx);\\n        // Remove last element\\n        list.remove(list.size() - 1);\\n        valIdxMap.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx = random.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// HashMap + ArrayList Solution\\n// HashMap to store <val, index> pair. \\n// remove(): Move the last element in ArrayList to the deleted element position to remove the element. Update the <val, index> pair in HashMap.\\n// Time complexity: O(1) for initialization, insert, remove and getRandom\\n// Space complexity: O(N)\\nclass RandomizedSet {\\n    private Random random;\\n    private List<Integer> list;\\n    private Map<Integer, Integer> valIdxMap;  // Stores <val, index> pair\\n\\n    public RandomizedSet() {\\n        random = new Random();\\n        list = new ArrayList<>();\\n        valIdxMap = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (valIdxMap.containsKey(val)) return false;\\n        valIdxMap.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!valIdxMap.containsKey(val)) return false;\\n        int idx = valIdxMap.get(val);\\n        // Move last element to deleted position.\\n        int lastVal = list.get(list.size() - 1);\\n        list.set(idx, lastVal);\\n        valIdxMap.put(lastVal, idx);\\n        // Remove last element\\n        list.remove(list.size() - 1);\\n        valIdxMap.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx = random.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129713,
                "title": "readable-java-solution",
                "content": "**Approch:**\\n1. We know one thing that remove last element from a arraylist is O(1) operation . \\n2. will try to remove in such a way that we will get the idx of value which to be remove in arraylist and then swap it with last value in arraylist and then remove (O(1)).\\n3. we need to store every value with their index . -> HashMap<Integer,Integer> best fit.\\n4. If getrandom function was not there then we can solve it using hashmap only just remove the value and insert the value in O(1) but because of getRandom we need to maintain values  in arraylist.  \\n**CODE:**\\n```\\nclass RandomizedSet {\\n     HashMap<Integer,Integer> valueIndexMap;\\n     ArrayList<Integer> values;\\n \\n    public RandomizedSet() {\\n        valueIndexMap=new HashMap<>();\\n        values=new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n       if(valueIndexMap.containsKey(val)) return false;\\n        values.add(val);\\n        valueIndexMap.put(val,values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueIndexMap.containsKey(val)) return false;\\n        int idx=valueIndexMap.get(val);            //idx of value to be deleted\\n        if(idx==values.size()-1){\\n            valueIndexMap.remove(val);\\n             values.remove(values.size()-1);\\n            return true;\\n        }\\n        \\n        int lastValue=values.get(values.size()-1);  //last value\\n        valueIndexMap.remove(val);                 \\n        valueIndexMap.put(lastValue,idx);\\n     \\n        Collections.swap(values,idx,values.size()-1);\\n        values.remove(values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand=new Random();\\n        int random=rand.nextInt(values.size());\\n        return values.get(random);\\n    } \\n}\\n```\\n**COMPLEXITY:**\\n```\\nTime : Insert :O(1) and Remove:O(1)\\n Space:O(n)\\n```\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n     HashMap<Integer,Integer> valueIndexMap;\\n     ArrayList<Integer> values;\\n \\n    public RandomizedSet() {\\n        valueIndexMap=new HashMap<>();\\n        values=new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n       if(valueIndexMap.containsKey(val)) return false;\\n        values.add(val);\\n        valueIndexMap.put(val,values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueIndexMap.containsKey(val)) return false;\\n        int idx=valueIndexMap.get(val);            //idx of value to be deleted\\n        if(idx==values.size()-1){\\n            valueIndexMap.remove(val);\\n             values.remove(values.size()-1);\\n            return true;\\n        }\\n        \\n        int lastValue=values.get(values.size()-1);  //last value\\n        valueIndexMap.remove(val);                 \\n        valueIndexMap.put(lastValue,idx);\\n     \\n        Collections.swap(values,idx,values.size()-1);\\n        values.remove(values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand=new Random();\\n        int random=rand.nextInt(values.size());\\n        return values.get(random);\\n    } \\n}\\n```\n```\\nTime : Insert :O(1) and Remove:O(1)\\n Space:O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110295,
                "title": "c-hash-map-to-vector-index-solution-with-explanations",
                "content": "**Thought process:**\\n* Constant insert, lookup, remove indicates we need a hash map or hash set. If there is no getRandom it would be the end of the story.\\n* Randomly access any data member is screaming for random access container, like vector.\\n* How to take advantage of the capabilities from both containers? We build a hash map mapping from key to vector index where key is the value.\\n* Insert and getRandom are easy and straight forward but remove is a bit tricky.\\n* If the item being removed is not at the end of the vector, we need to swap its position with the end of the vector item then reduce the vector size by one. Rememer to update hash map after vector data swap.\\n```\\n  /** Initialize your data structure here. */\\n  RandomizedSet() {\\n    // Could consider use time to init random seed here.\\n  }\\n    \\n  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n  bool insert(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor != lut_.end())\\n      return false;\\n    lut_.insert({val, vals_.size()});\\n    vals_.push_back(val);\\n    return true;\\n  }\\n  \\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\\n  bool remove(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor == lut_.end())\\n      return false;\\n    int pos = itor->second;\\n    lut_.erase(itor);\\n    if (pos != vals_.size()-1) {\\n      vals_[pos] = vals_.back();\\n      lut_[vals_[pos]] = pos;\\n    }\\n    vals_.pop_back();\\n    return true;\\n  }\\n  \\n  /** Get a random element from the set. */\\n  int getRandom() {\\n    return vals_[rand()%vals_.size()];\\n  }\\n\\nprivate:\\n  std::unordered_map<int, int> lut_;\\n  std::vector<int> vals_;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  /** Initialize your data structure here. */\\n  RandomizedSet() {\\n    // Could consider use time to init random seed here.\\n  }\\n    \\n  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n  bool insert(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor != lut_.end())\\n      return false;\\n    lut_.insert({val, vals_.size()});\\n    vals_.push_back(val);\\n    return true;\\n  }\\n  \\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\\n  bool remove(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor == lut_.end())\\n      return false;\\n    int pos = itor->second;\\n    lut_.erase(itor);\\n    if (pos != vals_.size()-1) {\\n      vals_[pos] = vals_.back();\\n      lut_[vals_[pos]] = pos;\\n    }\\n    vals_.pop_back();\\n    return true;\\n  }\\n  \\n  /** Get a random element from the set. */\\n  int getRandom() {\\n    return vals_[rand()%vals_.size()];\\n  }\\n\\nprivate:\\n  std::unordered_map<int, int> lut_;\\n  std::vector<int> vals_;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932085,
                "title": "commented-c-easy",
                "content": "```\\nclass RandomizedSet {\\n    \\n    // has the numbers to store\\n    vector<int> num;\\n    \\n    // has index of the numbers stored\\n    unordered_map<int, int> num_index;\\n    \\npublic:\\n    RandomizedSet() {\\n    }\\n\\n   /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        \\n        // add number in our vector and store\\n        // its position in \\n        \\n        if(num_index.find(val) != num_index.end())\\n            return false;\\n            \\n        num.push_back(val);\\n        num_index[val] = (num.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        \\n        // we will remove the element from map and from vector\\n        // as well, but we can only remove from vector when it\\n        // the element to be removed is at the end\\n        \\n        // so, we will move the last element to the place of the\\n        // element to be removed and then  delete the last value\\n        // of the vector\\n        \\n        if(num_index.find(val) == num_index.end())\\n            return false;\\n        \\n        int last = num.back();\\n        int to_be_removed = num_index[val];\\n      \\n        num[to_be_removed] = last;\\n        num_index[last] = to_be_removed;\\n        num_index.erase(val);\\n        num.pop_back();\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return num[rand()%num.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    \\n    // has the numbers to store\\n    vector<int> num;\\n    \\n    // has index of the numbers stored\\n    unordered_map<int, int> num_index;\\n    \\npublic:\\n    RandomizedSet() {\\n    }\\n\\n   /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        \\n        // add number in our vector and store\\n        // its position in \\n        \\n        if(num_index.find(val) != num_index.end())\\n            return false;\\n            \\n        num.push_back(val);\\n        num_index[val] = (num.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        \\n        // we will remove the element from map and from vector\\n        // as well, but we can only remove from vector when it\\n        // the element to be removed is at the end\\n        \\n        // so, we will move the last element to the place of the\\n        // element to be removed and then  delete the last value\\n        // of the vector\\n        \\n        if(num_index.find(val) == num_index.end())\\n            return false;\\n        \\n        int last = num.back();\\n        int to_be_removed = num_index[val];\\n      \\n        num[to_be_removed] = last;\\n        num_index[last] = to_be_removed;\\n        num_index.erase(val);\\n        num.pop_back();\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return num[rand()%num.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750733,
                "title": "c-solution-using-hashtable-and-array",
                "content": "```\\n/*\\n    https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/\\n*/\\nclass RandomizedSet {\\nprivate:\\n    // (element, idx in array)\\n    unordered_map<int, int> elements_;\\n    default_random_engine gen_;\\n    vector<int> all_nums_;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(elements_.count(val))\\n            return false;\\n        // The new element is added to the last of vector \\n        elements_.emplace(val, all_nums_.size());\\n        all_nums_.emplace_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(elements_.count(val)) {\\n            // to make the removal from array in O(1),\\n            // we swap it with the last element\\n            swap(all_nums_[elements_[val]], all_nums_.back());\\n            // update the index of swapped element in hash table\\n            elements_[all_nums_[elements_[val]]] = elements_[val];\\n            elements_.erase(val);\\n            all_nums_.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int low = 0, high = elements_.size() - 1;\\n        int idx = uniform_int_distribution<int>{low, high}(gen_);\\n        return all_nums_[idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/\\n*/\\nclass RandomizedSet {\\nprivate:\\n    // (element, idx in array)\\n    unordered_map<int, int> elements_;\\n    default_random_engine gen_;\\n    vector<int> all_nums_;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(elements_.count(val))\\n            return false;\\n        // The new element is added to the last of vector \\n        elements_.emplace(val, all_nums_.size());\\n        all_nums_.emplace_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(elements_.count(val)) {\\n            // to make the removal from array in O(1),\\n            // we swap it with the last element\\n            swap(all_nums_[elements_[val]], all_nums_.back());\\n            // update the index of swapped element in hash table\\n            elements_[all_nums_[elements_[val]]] = elements_[val];\\n            elements_.erase(val);\\n            all_nums_.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int low = 0, high = elements_.size() - 1;\\n        int idx = uniform_int_distribution<int>{low, high}(gen_);\\n        return all_nums_[idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684531,
                "title": "vector-hashmap-c-easy-understanding-o-1-with-picture-explanation",
                "content": "\\nFirst we use srand(time(0)) to get the random value: if you curious check this out: http://www.cplusplus.com/reference/cstdlib/srand/\\n\\nonly unordered_set will not give you o(1) random_element_get\\n\\nyou need to use combination of map+ vector(List) as shown below:\\n\\n![image](https://assets.leetcode.com/users/frostcs/image_1592024176.png)\\n\\n\\n```\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n     srand(time(0));   \\n    }\\n    \\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            v.emplace_back(val);\\n            int n = v.size();\\n            m[val] = n-1;\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end()){\\n            return false;\\n        }\\n        m[v.back()] = m[val];\\n        v[m[val]] = v.back();\\n        v.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int r = rand() % v.size();\\n        return v[r];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n     srand(time(0));   \\n    }\\n    \\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            v.emplace_back(val);\\n            int n = v.size();\\n            m[val] = n-1;\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end()){\\n            return false;\\n        }\\n        m[v.back()] = m[val];\\n        v[m[val]] = v.back();\\n        v.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int r = rand() % v.size();\\n        return v[r];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683944,
                "title": "c-simple-o-1-solution-using-list-and-dictionary",
                "content": "```\\npublic class RandomizedSet {\\n    private Dictionary<int,int> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        _dict = new Dictionary<int,int>();\\n        _list = new List<int>();\\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if (_dict.ContainsKey(val))\\n            return false;\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int index = _dict[val];\\n        (_list[index], _list[^1]) = (_list[^1], _list[index]);\\n        _dict[_list[index]] = index;\\n        _list.RemoveAt(_list.Count-1);\\n        _dict.Remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        int index = _rand.Next(0,_list.Count);\\n        return _list[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    private Dictionary<int,int> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        _dict = new Dictionary<int,int>();\\n        _list = new List<int>();\\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if (_dict.ContainsKey(val))\\n            return false;\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int index = _dict[val];\\n        (_list[index], _list[^1]) = (_list[^1], _list[index]);\\n        _dict[_list[index]] = index;\\n        _list.RemoveAt(_list.Count-1);\\n        _dict.Remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        int index = _rand.Next(0,_list.Count);\\n        return _list[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683882,
                "title": "heavily-commented-javascript-solution-with-thought-process-explained",
                "content": "```\\n/* Interesting question. My first thought would be to use a map/dict as that\\nwould support insert & remove at O(1)\\n\\nBut how would we make random work? to pick a random element, we need to either have a \\ntotal number, plus a way to access by that number. We could put the vals in an extra array\\nbut that would lead to O(n) with deletion. \\n\\nUnless we\\'re ok with ruining our look up array \\nand only delete when we come across them randomly when asked.\\nThat would work as long as there are not a ton of deletetions.\\n\\nAt this point I went to check solutions, I saw this one:\\nhttps://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3358/discuss/683603/Javascript-and-C%2B%2B-solutions/576499\\n\\nI don\\'t agree with the first solution, but the second is promising:\\n\\nA basic array with the inserts\\nA Map with the inserts as keys and the position in the basic array as values.\\n\\nAdding will be : \\nBasic array: push(inserted)\\nMap: set(inserted, basicArray.length - 1)\\n\\nRemoving will be:\\nMap: index = get(inserted) delete(inserted)\\nBasic Array: swap index with end of array (and update the swap in the Map) and pop off\\n\\nRandom is classic random on the array\\n\\nIt will be beautiful\\n\\n*/\\n\\n\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.basicArray = [];\\n    this.map = new Map();\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (!this.map.has(val)) {\\n        // simple push\\n        this.basicArray.push(val);\\n    \\n        // store in map and also where in the array it\\'s located\\n        this.map.set(val, this.basicArray.length - 1);\\n        return true;\\n    } else {\\n        return false;\\n    }\\n    \\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    var index;\\n    \\n    var swap = function (arr, i1, i2) {\\n        var temp = arr[i1];\\n        arr[i1] = arr[i2];\\n        arr[i2] = temp;\\n    }\\n    \\n    if (this.map.has(val)) {\\n        // where in the basic array is it\\n        index = this.map.get(val);\\n        \\n        // delete from map\\n        this.map.delete(val);\\n        \\n        // delete from array\\n        if (index !== this.basicArray.length - 1) {\\n            // we need to swap with the last element so we can pop it off\\n            // without disrupting too much else in the array. only the swapped item needs\\n            // to be updated in the map\\n            \\n            swap(this.basicArray, index, this.basicArray.length - 1);            \\n            \\n            // update the new location for the poor swapped item \\n            // that had nothing to do with val but just happened \\n            // to be at the end of the array\\n            this.map.set(this.basicArray[index], index);\\n        }\\n        this.basicArray.pop();\\n        return true;\\n        \\n    } else {\\n        return false;    \\n    }\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    var randomIndex = Math.floor(this.basicArray.length * Math.random());\\n    \\n    return this.basicArray[randomIndex];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/* Interesting question. My first thought would be to use a map/dict as that\\nwould support insert & remove at O(1)\\n\\nBut how would we make random work? to pick a random element, we need to either have a \\ntotal number, plus a way to access by that number. We could put the vals in an extra array\\nbut that would lead to O(n) with deletion. \\n\\nUnless we\\'re ok with ruining our look up array \\nand only delete when we come across them randomly when asked.\\nThat would work as long as there are not a ton of deletetions.\\n\\nAt this point I went to check solutions, I saw this one:\\nhttps://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3358/discuss/683603/Javascript-and-C%2B%2B-solutions/576499\\n\\nI don\\'t agree with the first solution, but the second is promising:\\n\\nA basic array with the inserts\\nA Map with the inserts as keys and the position in the basic array as values.\\n\\nAdding will be : \\nBasic array: push(inserted)\\nMap: set(inserted, basicArray.length - 1)\\n\\nRemoving will be:\\nMap: index = get(inserted) delete(inserted)\\nBasic Array: swap index with end of array (and update the swap in the Map) and pop off\\n\\nRandom is classic random on the array\\n\\nIt will be beautiful\\n\\n*/\\n\\n\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.basicArray = [];\\n    this.map = new Map();\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (!this.map.has(val)) {\\n        // simple push\\n        this.basicArray.push(val);\\n    \\n        // store in map and also where in the array it\\'s located\\n        this.map.set(val, this.basicArray.length - 1);\\n        return true;\\n    } else {\\n        return false;\\n    }\\n    \\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    var index;\\n    \\n    var swap = function (arr, i1, i2) {\\n        var temp = arr[i1];\\n        arr[i1] = arr[i2];\\n        arr[i2] = temp;\\n    }\\n    \\n    if (this.map.has(val)) {\\n        // where in the basic array is it\\n        index = this.map.get(val);\\n        \\n        // delete from map\\n        this.map.delete(val);\\n        \\n        // delete from array\\n        if (index !== this.basicArray.length - 1) {\\n            // we need to swap with the last element so we can pop it off\\n            // without disrupting too much else in the array. only the swapped item needs\\n            // to be updated in the map\\n            \\n            swap(this.basicArray, index, this.basicArray.length - 1);            \\n            \\n            // update the new location for the poor swapped item \\n            // that had nothing to do with val but just happened \\n            // to be at the end of the array\\n            this.map.set(this.basicArray[index], index);\\n        }\\n        this.basicArray.pop();\\n        return true;\\n        \\n    } else {\\n        return false;    \\n    }\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    var randomIndex = Math.floor(this.basicArray.length * Math.random());\\n    \\n    return this.basicArray[randomIndex];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249013,
                "title": "java-concise-fast-beats-100",
                "content": "There\\'s no cool new idea here; it\\'s just another HashMap & ArrayList solution.\\n\\nBut I noticed that many of the posted solutions are very...wordy.  I\\'ve tried to be more concise.\\n\\n```\\nclass RandomizedSet {\\n    ArrayList<Integer> byIndex = new ArrayList<Integer>();\\n    HashMap<Integer,Integer> byValue = new HashMap<Integer,Integer>();\\n    Random rng = new Random();\\n\\n    public RandomizedSet() {}\\n    \\n    public boolean insert(int val) {\\n        if( byValue.containsKey(val) ) return false;\\n        byValue.put( val, byValue.size() );\\n        byIndex.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if( !byValue.containsKey(val) ) return false;\\n        byIndex.set( byValue.get(val), byIndex.get( byIndex.size()-1 ) );\\n        byValue.put( byIndex.remove( byIndex.size()-1 ), byValue.get(val) );\\n        byValue.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() { return byIndex.get( rng.nextInt( byIndex.size() ) ); }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    ArrayList<Integer> byIndex = new ArrayList<Integer>();\\n    HashMap<Integer,Integer> byValue = new HashMap<Integer,Integer>();\\n    Random rng = new Random();\\n\\n    public RandomizedSet() {}\\n    \\n    public boolean insert(int val) {\\n        if( byValue.containsKey(val) ) return false;\\n        byValue.put( val, byValue.size() );\\n        byIndex.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if( !byValue.containsKey(val) ) return false;\\n        byIndex.set( byValue.get(val), byIndex.get( byIndex.size()-1 ) );\\n        byValue.put( byIndex.remove( byIndex.size()-1 ), byValue.get(val) );\\n        byValue.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() { return byIndex.get( rng.nextInt( byIndex.size() ) ); }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904434,
                "title": "using-one-hash-map-and-one-array",
                "content": "# Code\\n```\\nvar RandomizedSet = function () {\\n    this.data = []; // Store the elements in the set\\n    this.indexMap = new Map(); // Map to store element-to-index mapping\\n};\\n\\n/** \\n * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n * @param {number} val - The value to insert.\\n * @return {boolean} - True if the set did not already contain the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.insert = function (val) {\\n    if (this.indexMap.has(val)) return false; // Element already exists in the set\\n    this.data.push(val); // Add the element to the end of the array\\n    this.indexMap.set(val, this.data.length - 1); // Map element to its index\\n    return true;\\n};\\n\\n/** \\n * Removes a value from the set. Returns true if the set contained the specified element.\\n * @param {number} val - The value to remove.\\n * @return {boolean} - True if the set contained the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.remove = function (val) {\\n    if (!this.indexMap.has(val)) return false; // Element doesn\\'t exist in the set\\n\\n    const index = this.indexMap.get(val); // Get the index of the element to remove\\n    const lastElement = this.data.pop(); // Remove and get the last element\\n\\n    // If the element to remove is not the last element, swap it with the last element\\n    if (index !== this.data.length) {\\n        this.data[index] = lastElement; // Swap with the removed element\\n        this.indexMap.set(lastElement, index); // Update indexMap\\n    }\\n\\n    this.indexMap.delete(val); // Remove the element from the indexMap\\n    return true;\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number} - A random element from the set.\\n */\\nRandomizedSet.prototype.getRandom = function () {\\n    const i = Math.floor(Math.random() * this.data.length); // Generate a random index\\n    return this.data[i]; // Return the element at the random index\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RandomizedSet = function () {\\n    this.data = []; // Store the elements in the set\\n    this.indexMap = new Map(); // Map to store element-to-index mapping\\n};\\n\\n/** \\n * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n * @param {number} val - The value to insert.\\n * @return {boolean} - True if the set did not already contain the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.insert = function (val) {\\n    if (this.indexMap.has(val)) return false; // Element already exists in the set\\n    this.data.push(val); // Add the element to the end of the array\\n    this.indexMap.set(val, this.data.length - 1); // Map element to its index\\n    return true;\\n};\\n\\n/** \\n * Removes a value from the set. Returns true if the set contained the specified element.\\n * @param {number} val - The value to remove.\\n * @return {boolean} - True if the set contained the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.remove = function (val) {\\n    if (!this.indexMap.has(val)) return false; // Element doesn\\'t exist in the set\\n\\n    const index = this.indexMap.get(val); // Get the index of the element to remove\\n    const lastElement = this.data.pop(); // Remove and get the last element\\n\\n    // If the element to remove is not the last element, swap it with the last element\\n    if (index !== this.data.length) {\\n        this.data[index] = lastElement; // Swap with the removed element\\n        this.indexMap.set(lastElement, index); // Update indexMap\\n    }\\n\\n    this.indexMap.delete(val); // Remove the element from the indexMap\\n    return true;\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number} - A random element from the set.\\n */\\nRandomizedSet.prototype.getRandom = function () {\\n    const i = Math.floor(Math.random() * this.data.length); // Generate a random index\\n    return this.data[i]; // Return the element at the random index\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767488,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757600,
                "title": "c-simple-solution-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing unordered_set\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitializing unordered_set and simply checking whether element is present or not, inserting, erasing. Randomly selecting any insex and advancing iterator to that index and returning value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n        return false;\\n        else\\n        {\\n            s.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int t = rand()%s.size();\\n        auto it = s.begin();\\n        advance(it,t);\\n        return *(it);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n        return false;\\n        else\\n        {\\n            s.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int t = rand()%s.size();\\n        auto it = s.begin();\\n        advance(it,t);\\n        return *(it);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687193,
                "title": "step-by-step-approach-o-1",
                "content": "# Intuition\\nThe problem requires us to implement a data structure called RandomizedSet, which supports three operations: insert, remove, and getRandom. The insert operation adds a value to the set if it doesn\\'t already exist and returns true, or returns false if the value already exists. The remove operation removes a value from the set if it exists and returns true, or returns false if the value doesn\\'t exist. The getRandom operation returns a random value from the set.\\n\\n# Approach\\nTo solve this problem, we can use a combination of a Set and an array. We\\'ll use the Set to store the unique values and ensure constant-time operations for checking existence and removing values. We\\'ll use the array to store the values in a random order and facilitate the getRandom operation.\\n\\nHere\\'s a breakdown of each operation:\\n\\n1. insert(val: number): boolean: To insert a value, we\\'ll first check if it already exists in the set using set.has(val). If it does, we\\'ll return false to indicate that the value was not inserted. Otherwise, we\\'ll add the value to both the set and the array, and return true.\\n\\n2. remove(val: number): boolean: To remove a value, we\\'ll first check if it exists in the set using set.has(val). If it doesn\\'t, we\\'ll return false to indicate that the value was not removed. Otherwise, we\\'ll delete the value from both the set and the array. To efficiently remove the value from the array, we\\'ll swap it with the last value in the array and then pop the last element. This way, the array remains in a random order even after removal. Finally, we\\'ll return true.\\n\\n3. getRandom(): number: To get a random value, we\\'ll convert the set to an array using Array.from(set). Then, we\\'ll generate a random index within the bounds of the array using Math.random() * array.length. Finally, we\\'ll return the value at the random index.\\n\\n# Complexity\\n- Time complexity:\\nInsert: O(1)\\nRemove: O(1)\\ngetRandom: O(1)\\n- Space complexity:\\nO(n), where n is the number of elements in the set.\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private set: Set<number>;\\n    private array: number[];\\n\\n    constructor() {\\n        this.set = new Set<number>();\\n        this.array = [];\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.add(val);\\n        this.array.push(val);\\n        return true;\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.delete(val);\\n        const index = this.array.indexOf(val);\\n        this.array[index] = this.array[this.array.length - 1];\\n        this.array.pop();\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        const randomIndex = Math.floor(Math.random() * this.array.length);\\n        return this.array[randomIndex];\\n    }\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private set: Set<number>;\\n    private array: number[];\\n\\n    constructor() {\\n        this.set = new Set<number>();\\n        this.array = [];\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.add(val);\\n        this.array.push(val);\\n        return true;\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.delete(val);\\n        const index = this.array.indexOf(val);\\n        this.array[index] = this.array[this.array.length - 1];\\n        this.array.pop();\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        const randomIndex = Math.floor(Math.random() * this.array.length);\\n        return this.array[randomIndex];\\n    }\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666361,
                "title": "insert-delete-getrandom-o-1",
                "content": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399642,
                "title": "simple-c-solution-using-unordered-set",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (st.count(val)) return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (!st.count(val)) return false;\\n        st.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        int n = rand() % st.size();\\n        auto it = st.begin();\\n        advance(it, n);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (st.count(val)) return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (!st.count(val)) return false;\\n        st.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        int n = rand() % st.size();\\n        auto it = st.begin();\\n        advance(it, n);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859704,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map or Set\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code 1\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(!mp.count(val)) {\\n            arr.push_back(val);\\n            mp[val] = arr.size() - 1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.count(val)) {\\n            int idx = mp[val];\\n            int last_val = arr.back();\\n            arr[idx] = last_val;\\n            arr.pop_back();  \\n            mp[last_val] = idx;            \\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx = rand() % arr.size();\\n        return arr[rand_idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\n\\n\\n# Code 2\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n\\n    RandomizedSet() {\\n  \\n    }\\n\\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val)) {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % st.size();\\n        return *next(st.begin(), r);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(!mp.count(val)) {\\n            arr.push_back(val);\\n            mp[val] = arr.size() - 1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.count(val)) {\\n            int idx = mp[val];\\n            int last_val = arr.back();\\n            arr[idx] = last_val;\\n            arr.pop_back();  \\n            mp[last_val] = idx;            \\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx = rand() % arr.size();\\n        return arr[rand_idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n\\n    RandomizedSet() {\\n  \\n    }\\n\\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val)) {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % st.size();\\n        return *next(st.begin(), r);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859563,
                "title": "java-easy-to-understand-hashmap-arraylist",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/design/RandomizedSet.java",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2859235,
                "title": "rust-swap-remove",
                "content": "# Code\\n```rust\\nuse std::collections::HashMap;\\nuse rand::seq::SliceRandom;\\n\\nstruct RandomizedSet {\\n    hash: HashMap<i32, usize>,\\n    v: Vec<i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            v: Vec::new(),\\n        }\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        if self.hash.contains_key(&val) {\\n            return false;\\n        }\\n        self.hash.insert(val, self.v.len());\\n        self.v.push(val);\\n        true\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        match self.hash.remove(&val) {\\n            None => false,\\n            Some(i) => {\\n                self.v.swap_remove(i);\\n                if i < self.v.len() {\\n                    self.hash.insert(self.v[i], i);\\n                }\\n                true\\n            }\\n        }\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        *self.v.choose(&mut rand::thread_rng()).unwrap()\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * let obj = RandomizedSet::new();\\n * let ret_1: bool = obj.insert(val);\\n * let ret_2: bool = obj.remove(val);\\n * let ret_3: i32 = obj.get_random();\\n */\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\nuse rand::seq::SliceRandom;\\n\\nstruct RandomizedSet {\\n    hash: HashMap<i32, usize>,\\n    v: Vec<i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            v: Vec::new(),\\n        }\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        if self.hash.contains_key(&val) {\\n            return false;\\n        }\\n        self.hash.insert(val, self.v.len());\\n        self.v.push(val);\\n        true\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        match self.hash.remove(&val) {\\n            None => false,\\n            Some(i) => {\\n                self.v.swap_remove(i);\\n                if i < self.v.len() {\\n                    self.hash.insert(self.v[i], i);\\n                }\\n                true\\n            }\\n        }\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        *self.v.choose(&mut rand::thread_rng()).unwrap()\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * let obj = RandomizedSet::new();\\n * let ret_1: bool = obj.insert(val);\\n * let ret_2: bool = obj.remove(val);\\n * let ret_3: i32 = obj.get_random();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859143,
                "title": "easy-approach-using-map-c-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are using array, then insert and getRandom operation will take constant time but delete operation will take linear time complexity, as we will have to traverse to that index. But we can do it in O(1) time if we can store the indexes of each element in array somewhere so that instead of traversing each time for deletion, we can directly go to that index and delete.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can use unordered map to store the indexes as it operates in constant time complexity.\\n2. While inserting the val to our set, we will store its index in map.\\n3. While deleting, we can simply pop back after locating the last element to current index as order of elements do not matter here.\\n4. Update the index of last element in map which was shifted.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    vector<int> set;\\n    unordered_map<int,int> indexFinder;\\n    RandomizedSet() {\\n        //RandomizedSet randomizedSet = new RandomizedSet();\\n    }\\n    \\n    bool insert(int val) {\\n        if(indexFinder.find(val) != indexFinder.end()) return false;\\n        else\\n        {\\n            set.push_back(val);\\n            indexFinder[val] = set.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if(indexFinder.find(val) == indexFinder.end()) return false;\\n        else{\\n            int lastEle = set.back();\\n            int indexToBeRemoved = indexFinder[val];\\n            set[indexToBeRemoved] = lastEle;\\n            set.pop_back();\\n            indexFinder[lastEle] = indexToBeRemoved;\\n            indexFinder.erase(val);\\n            return true;\\n\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return set[rand()%set.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    vector<int> set;\\n    unordered_map<int,int> indexFinder;\\n    RandomizedSet() {\\n        //RandomizedSet randomizedSet = new RandomizedSet();\\n    }\\n    \\n    bool insert(int val) {\\n        if(indexFinder.find(val) != indexFinder.end()) return false;\\n        else\\n        {\\n            set.push_back(val);\\n            indexFinder[val] = set.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if(indexFinder.find(val) == indexFinder.end()) return false;\\n        else{\\n            int lastEle = set.back();\\n            int indexToBeRemoved = indexFinder[val];\\n            set[indexToBeRemoved] = lastEle;\\n            set.pop_back();\\n            indexFinder[lastEle] = indexToBeRemoved;\\n            indexFinder.erase(val);\\n            return true;\\n\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return set[rand()%set.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859001,
                "title": "python-pain",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.storage = dict() # \\n        self.MODULO = 1000\\n        self.vals = []\\n\\n        \\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            return False\\n        else:\\n            self.storage[val] = len(self.vals)\\n            self.vals.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            index_of_removal = self.storage[val]\\n            self.vals[index_of_removal] = self.vals[-1]\\n            self.storage[self.vals[-1]] = index_of_removal\\n            self.vals.pop()\\n            del self.storage[val]\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return choice(self.vals)\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.storage = dict() # \\n        self.MODULO = 1000\\n        self.vals = []\\n\\n        \\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            return False\\n        else:\\n            self.storage[val] = len(self.vals)\\n            self.vals.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            index_of_removal = self.storage[val]\\n            self.vals[index_of_removal] = self.vals[-1]\\n            self.storage[self.vals[-1]] = index_of_removal\\n            self.vals.pop()\\n            del self.storage[val]\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return choice(self.vals)\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858556,
                "title": "most-easiest-clean-optimized-code",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() { }\\n    \\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val))\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        vector<int> a;\\n        for(auto it : st) a.push_back(it);\\n        return a[(rand() % a.size())];  // rand() function % size of the array, means it will generate a random index from 0 to array.size()-1, thats all we need.\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() { }\\n    \\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val))\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        vector<int> a;\\n        for(auto it : st) a.push_back(it);\\n        return a[(rand() % a.size())];  // rand() function % size of the array, means it will generate a random index from 0 to array.size()-1, thats all we need.\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2858469,
                "title": "javascript-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/insert-delete-getrandom-o1.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.list = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map.has(val)) return false;\\n\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.map.has(val)) return false;\\n\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n};\\n\\nRandomizedSet.prototype._swap = function(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n};\\n\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.list = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map.has(val)) return false;\\n\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.map.has(val)) return false;\\n\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n};\\n\\nRandomizedSet.prototype._swap = function(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n};\\n\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858206,
                "title": "simple-ts-solution",
                "content": "# Intuition\\nSet can do all tasks except for getRandom().\\nHence, the task is to establish the getRandom() function.\\n\\n# Approach\\nUse an array to store values, use a Map to store val -> position_in_array.\\n\\nThen for insert, array push is O(1), record position is easy.\\n\\nFor delete, Map delete is O(1), if element is at last, array pop is O(1), if it is not at the last position, swap the element at last position with it, update the position record in Map. Then pop() O(1).\\n\\nTo get random index, just use `Math.floor(Math.random() * array.length)`.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(n) where n is the maximum number of elements stored.\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    valPos: Map<number, number> // value, index\\n    vals: number[]\\n\\n    constructor() {\\n        this.valPos = new Map()\\n        this.vals = []\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.valPos.has(val)) return false\\n        this.valPos.set(val, this.vals.length)\\n        this.vals.push(val)\\n        return true\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.valPos.has(val)) return false\\n        const pos = this.valPos.get(val)\\n        if (pos !== this.vals.length - 1) {\\n            const lastVal = this.vals[this.vals.length - 1];\\n            // swap position with the last element\\n            [this.vals[pos], this.vals[this.vals.length - 1]] = [this.vals[this.vals.length - 1], this.vals[pos]]\\n            this.valPos.set(lastVal, pos) // update position record\\n        }\\n        this.valPos.delete(val)\\n        this.vals.pop()\\n        return true\\n    }\\n\\n    getRandom(): number {\\n        return this.vals[Math.floor(Math.random() * this.vals.length)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass RandomizedSet {\\n    valPos: Map<number, number> // value, index\\n    vals: number[]\\n\\n    constructor() {\\n        this.valPos = new Map()\\n        this.vals = []\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.valPos.has(val)) return false\\n        this.valPos.set(val, this.vals.length)\\n        this.vals.push(val)\\n        return true\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.valPos.has(val)) return false\\n        const pos = this.valPos.get(val)\\n        if (pos !== this.vals.length - 1) {\\n            const lastVal = this.vals[this.vals.length - 1];\\n            // swap position with the last element\\n            [this.vals[pos], this.vals[this.vals.length - 1]] = [this.vals[this.vals.length - 1], this.vals[pos]]\\n            this.valPos.set(lastVal, pos) // update position record\\n        }\\n        this.valPos.delete(val)\\n        this.vals.pop()\\n        return true\\n    }\\n\\n    getRandom(): number {\\n        return this.vals[Math.floor(Math.random() * this.vals.length)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858162,
                "title": "daily-leetcoding-challenge-november-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-delete-getrandom-o1/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** HashMap + ArrayList\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-delete-getrandom-o1/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2853456,
                "title": "java-randomizedset-has-hybrid-set-made-of-map-and-list-to-allow-tc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- As the name of the class says, it shall behave like a set upon insertion or removal of values. So a \"set-ish\" abstract data type is needed to store the values, and will allow constant access times for insertion and removal.\\n- The randomized get() requires to use a random number generator to calculate the choice, and one can assume, that the library standard provides such a constant time random number generator.\\n- But the Java sets do not provide constant time random access methods to the stored items by index. Thus, a common set must probably be iterated.\\n- To support both acess methods (insert/remove by key, and get by randomized index), a kind of hybrid data structure is needed: a set that can be accessed randomly by index, like a list, and by key, like a set or map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use a HashMap to store the inserted values (as keys), so that the set aspect gets satisfied.\\n- Use an ArrayList to store the values as themselves, and use the indexes of the values in the list as values for the key map. This satisfies the random access by index requirement.\\n- Both tables are associated by the indexes:\\n  - HashMap: value (key aspect) --> index\\n  - ArrayList: index --> value (value aspect).\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ average for all operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the number of items stored in the class at any time. Grows by one with each successful insertion, shrinks by one with each successful removal.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n\\n    private final Map<Integer, Integer> keys;\\n    private final List<Integer> values;\\n    private final Random random = new Random();\\n\\n    public RandomizedSet() {\\n        keys = new HashMap<>();\\n        values = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (keys.containsKey(val)) return false;\\n        keys.put(val, values.size());\\n        values.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!keys.containsKey(val)) return false;\\n        int candidateIndex = keys.get(val);\\n        int lastIndex = values.size() - 1;\\n        values.set(candidateIndex, values.get(lastIndex));\\n        keys.put(values.get(candidateIndex), candidateIndex);\\n        keys.remove(val);\\n        values.remove(lastIndex);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size()));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    private final Map<Integer, Integer> keys;\\n    private final List<Integer> values;\\n    private final Random random = new Random();\\n\\n    public RandomizedSet() {\\n        keys = new HashMap<>();\\n        values = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (keys.containsKey(val)) return false;\\n        keys.put(val, values.size());\\n        values.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!keys.containsKey(val)) return false;\\n        int candidateIndex = keys.get(val);\\n        int lastIndex = values.size() - 1;\\n        values.set(candidateIndex, values.get(lastIndex));\\n        keys.put(values.get(candidateIndex), candidateIndex);\\n        keys.remove(val);\\n        values.remove(lastIndex);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size()));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847534,
                "title": "javascript-map",
                "content": "It\\'s easy to solve this problem by Object in JavaScript. But hashmap is a good way that need to be implement.\\n\\nRecord the Value-Index pair in hashmap to simplify the remove process.\\n\\n```\\n\\nvar RandomizedSet = function() {\\n    this.set = [];\\n    // record the value index to simpilfy the element swap\\n    this.valueIndexMap = new Map();\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    this.set.push(val);\\n    this.valueIndexMap.set(val, this.set.length -1);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    const indexToRemove = this.valueIndexMap.get(val);\\n    // update valueIndexMap first\\n    this.valueIndexMap.set(this.set[this.set.length - 1], indexToRemove);\\n    this.valueIndexMap.delete(val);\\n    this.set[indexToRemove] = this.set[this.set.length - 1];\\n    this.set[this.set.length - 1] = val;\\n    this.set.pop();\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.set[Math.floor(Math.random()*this.set.length)];\\n}\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar RandomizedSet = function() {\\n    this.set = [];\\n    // record the value index to simpilfy the element swap\\n    this.valueIndexMap = new Map();\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    this.set.push(val);\\n    this.valueIndexMap.set(val, this.set.length -1);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    const indexToRemove = this.valueIndexMap.get(val);\\n    // update valueIndexMap first\\n    this.valueIndexMap.set(this.set[this.set.length - 1], indexToRemove);\\n    this.valueIndexMap.delete(val);\\n    this.set[indexToRemove] = this.set[this.set.length - 1];\\n    this.set[this.set.length - 1] = val;\\n    this.set.pop();\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.set[Math.floor(Math.random()*this.set.length)];\\n}\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786085,
                "title": "optimised-java-solution-unlike-others-only-hashset",
                "content": "**Easiest Solution :D\\nUpvote \\uD83D\\uDD3C\\u2705**\\n```\\nclass RandomizedSet {\\n\\n    HashSet<Integer> hs;\\n    \\n    public RandomizedSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!hs.contains(val))\\n        {\\n            hs.add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(hs.contains(val))\\n        {\\n            hs.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    int t=0;\\n    public int getRandom() {\\n        \\n        //int n=hs.size();\\n       List<Integer> list = new ArrayList<Integer>(hs);\\n       int r=(int)(Math.random()*hs.size());\\n        \\n       return list.get(r);\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "**Easiest Solution :D\\nUpvote \\uD83D\\uDD3C\\u2705**\\n```\\nclass RandomizedSet {\\n\\n    HashSet<Integer> hs;\\n    \\n    public RandomizedSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!hs.contains(val))\\n        {\\n            hs.add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(hs.contains(val))\\n        {\\n            hs.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    int t=0;\\n    public int getRandom() {\\n        \\n        //int n=hs.size();\\n       List<Integer> list = new ArrayList<Integer>(hs);\\n       int r=(int)(Math.random()*hs.size());\\n        \\n       return list.get(r);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309586,
                "title": "easy-solution-using-vectors-and-map-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedSet() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            m[val] = size;\\n            v.push_back(val);\\n            size++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            int ind = m[val];\\n            v[ind] = v[size-1];\\n            v.pop_back();\\n            m[v[ind]] = ind;\\n            m.erase(val);\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedSet() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            m[val] = size;\\n            v.push_back(val);\\n            size++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            int ind = m[val];\\n            v[ind] = v[size-1];\\n            v.pop_back();\\n            m[v[ind]] = ind;\\n            m.erase(val);\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219082,
                "title": "easy-solution-combined-array-and-hashmap",
                "content": "If we only consider the insert and delete method, hashmap can solve this proble. \\nAdding the new function: Each element must have the same probability of being returned.\\nSo Array is must be used to generate the random index number. \\nHashMap key is its value, and value part is the index of the key in the arraylist to maintain this arraylist to achieve random pick function.\\n\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> loc;\\n    Random rand;\\n    public RandomizedSet() {\\n        \\n        map = new HashMap<>();\\n        loc = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            return false;\\n        }\\n        map.put(val, loc.size());\\n        loc.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        \\n        int temp;\\n        int index = map.get(val);\\n        temp = loc.get(loc.size() - 1);\\n        loc.set(index, temp);\\n        \\n        loc.remove(loc.size() - 1);\\n        \\n        map.put(temp, index);\\n        map.remove(val);\\n        return true;\\n\\n    }\\n    \\n    public int getRandom() {\\n        return loc.get(rand.nextInt(loc.size()));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> loc;\\n    Random rand;\\n    public RandomizedSet() {\\n        \\n        map = new HashMap<>();\\n        loc = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            return false;\\n        }\\n        map.put(val, loc.size());\\n        loc.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        \\n        int temp;\\n        int index = map.get(val);\\n        temp = loc.get(loc.size() - 1);\\n        loc.set(index, temp);\\n        \\n        loc.remove(loc.size() - 1);\\n        \\n        map.put(temp, index);\\n        map.remove(val);\\n        return true;\\n\\n    }\\n    \\n    public int getRandom() {\\n        return loc.get(rand.nextInt(loc.size()));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780409,
                "title": "java-solution-with-arraylist-and-hashmap",
                "content": "```\\nclass RandomizedSet {\\n\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random rand = new Random(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list  = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val))\\n            return false;\\n        \\n        map.put(val, list.size());\\n        list.add(val); //\\u5148\\u52A0map\\u518D\\u52A0list\\u4E0D\\u7136index\\u4F1A\\u51FA\\u95EE\\u9898\\u3002\\u3002\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val))\\n            return false;\\n        \\n        int ind = map.get(val);\\n        int last = list.get(list.size()-1);\\n        //swap\\n        list.set(ind, last);\\n        map.put(last,ind);\\n        //last element is the thing you want to delete from both\\n        list.remove(list.size()-1);\\n        map.remove(val);\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random rand = new Random(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list  = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val))\\n            return false;\\n        \\n        map.put(val, list.size());\\n        list.add(val); //\\u5148\\u52A0map\\u518D\\u52A0list\\u4E0D\\u7136index\\u4F1A\\u51FA\\u95EE\\u9898\\u3002\\u3002\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val))\\n            return false;\\n        \\n        int ind = map.get(val);\\n        int last = list.get(list.size()-1);\\n        //swap\\n        list.set(ind, last);\\n        map.put(last,ind);\\n        //last element is the thing you want to delete from both\\n        list.remove(list.size()-1);\\n        map.remove(val);\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625918,
                "title": "c-hashmap-array",
                "content": "Use hashmap to store the mapping between numbers and their indexes in array.\\n\\nRemove:\\nswap the target with last element in the array and delete.\\n\\nGet Random:\\nget a random number from array using a random index.\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.count(val)){\\n            return false;\\n        }\\n        m[val]=v.size();\\n        v.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!m.count(val))\\n            return false;\\n        else{\\n            int lastnum=v[v.size()-1];\\n            swap(v[m[val]],v[v.size()-1]);\\n            v.pop_back();\\n            m[lastnum]=m[val];\\n            m.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int sz=v.size();\\n        int rnum=rand()%sz;\\n        return v[rnum];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.count(val)){\\n            return false;\\n        }\\n        m[val]=v.size();\\n        v.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!m.count(val))\\n            return false;\\n        else{\\n            int lastnum=v[v.size()-1];\\n            swap(v[m[val]],v[v.size()-1]);\\n            v.pop_back();\\n            m[lastnum]=m[val];\\n            m.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int sz=v.size();\\n        int rnum=rand()%sz;\\n        return v[rnum];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558069,
                "title": "python-faster-than-89",
                "content": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.indexes = {}\\n        self.values = []\\n        \\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        \\n        if val in self.indexes:\\n            return False\\n        else: \\n            self.values.append(val)\\n            self.indexes[val] = len(self.values)-1\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.indexes:\\n            last = len(self.values)-1\\n            index = self.indexes[val]\\n            \\n            self.indexes[self.values[last]] = index\\n            self.values[index], self.values[last] = self.values[last], self.values[index]\\n            \\n            del self.indexes[val]\\n            self.values.pop(last)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.values)\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.indexes = {}\\n        self.values = []\\n        \\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        \\n        if val in self.indexes:\\n            return False\\n        else: \\n            self.values.append(val)\\n            self.indexes[val] = len(self.values)-1\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.indexes:\\n            last = len(self.values)-1\\n            index = self.indexes[val]\\n            \\n            self.indexes[self.values[last]] = index\\n            self.values[index], self.values[last] = self.values[last], self.values[index]\\n            \\n            del self.indexes[val]\\n            self.values.pop(last)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.values)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517398,
                "title": "python-faster-than-96",
                "content": "Key thing is that every operation has to be O(1) . let\\'s work from backwards.\\n\\n1. getRandom() -> we can only get O(1) for this if the values are stored in something like list and \\nwe are able to select a random index. We won\\'t be able to do this with a hashmap or hashet since \\nwe would have to convert all the keys to a list first and that will entail an O(N) operation. \\n\\n2. remove() -> since we know that getRandom() woud need a list , but removal of value in a list is O(N).\\nIf we have access to the index we want to remove, then it could be O(1). So we can use an extra dictionary \\nto store the value as key and index as value. But there is a catch here, when we delete an element from the list the mapping that we have already also needs to be updated. One trick here is to swap out the element that is to be deleted with the last element of the array, so that we are only doing a pop operation. The index of the last value has to be also updated correctly. \\n\\n3. insert() -> insert is straightforward . We check if the value is not present in the dictionary, then add it to both the list and dictionary. \\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.hm = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.hm:\\n            self.hm[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        return False\\n    \\n    def remove(self, val: int) -> bool:\\n        if len(self.arr) == 0:\\n            return False\\n        if val in self.hm:\\n                \\n            idx = self.hm[val]\\n            last_val = self.arr[-1]\\n            self.hm[last_val] = idx\\n            self.arr[idx], self.arr[-1] = last_val, self.arr[idx]\\n            self.arr.pop()\\n            del self.hm[val]\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Key thing is that every operation has to be O(1) . let\\'s work from backwards.\\n\\n1. getRandom() -> we can only get O(1) for this if the values are stored in something like list and \\nwe are able to select a random index. We won\\'t be able to do this with a hashmap or hashet since \\nwe would have to convert all the keys to a list first and that will entail an O(N) operation. \\n\\n2. remove() -> since we know that getRandom() woud need a list , but removal of value in a list is O(N).\\nIf we have access to the index we want to remove, then it could be O(1). So we can use an extra dictionary \\nto store the value as key and index as value. But there is a catch here, when we delete an element from the list the mapping that we have already also needs to be updated. One trick here is to swap out the element that is to be deleted with the last element of the array, so that we are only doing a pop operation. The index of the last value has to be also updated correctly. \\n\\n3. insert() -> insert is straightforward . We check if the value is not present in the dictionary, then add it to both the list and dictionary. \\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.hm = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.hm:\\n            self.hm[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        return False\\n    \\n    def remove(self, val: int) -> bool:\\n        if len(self.arr) == 0:\\n            return False\\n        if val in self.hm:\\n                \\n            idx = self.hm[val]\\n            last_val = self.arr[-1]\\n            self.hm[last_val] = idx\\n            self.arr[idx], self.arr[-1] = last_val, self.arr[idx]\\n            self.arr.pop()\\n            del self.hm[val]\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1489610,
                "title": "java-easy-to-understand",
                "content": "\\n\\n```\\nclass RandomizedSet {\\n\\n    int arr[];\\n    HashMap<Integer,Integer> hm;\\n    int last;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        arr=new int[200001];\\n        hm=new HashMap<Integer,Integer>();\\n        last=-1;\\n        //print();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        //print();\\n        if(hm.containsKey(val))\\n            return false;\\n        last++;\\n        arr[last]=val;\\n        hm.put(val,last);\\n        //System.out.println(last);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        //print();\\n\\t\\t/*\\n\\t\\twe find index of the element that is to be removed\\n\\t\\tintead of removing it we replace it with last element\\n\\t\\tupdate index in hashmap as we just changed it\\n\\t\\t*/\\n        if(hm.containsKey(val)){\\n            int index=hm.get(val);\\n            arr[index]=arr[last];\\n            hm.put(arr[index],index);\\n            last--;\\n            hm.remove(val);\\n            //System.out.println(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        //print();\\n        Random rand = new Random(); //instance of random class\\n        int upperbound = last+1;\\n        //generate random values from 0-24\\n        int index = rand.nextInt(upperbound); \\n        //System.out.println(\"index \"+index);\\n        return arr[index];\\n    }\\n    public void print(){\\n        for(int i=0;i<=last;i++){\\n            System.out.print(arr[i]+\" \");\\n        }\\n        System.out.println(hm);\\n    }\\n\\t//if you find this helpful, please upvote..\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    int arr[];\\n    HashMap<Integer,Integer> hm;\\n    int last;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        arr=new int[200001];\\n        hm=new HashMap<Integer,Integer>();\\n        last=-1;\\n        //print();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        //print();\\n        if(hm.containsKey(val))\\n            return false;\\n        last++;\\n        arr[last]=val;\\n        hm.put(val,last);\\n        //System.out.println(last);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        //print();\\n\\t\\t/*\\n\\t\\twe find index of the element that is to be removed\\n\\t\\tintead of removing it we replace it with last element\\n\\t\\tupdate index in hashmap as we just changed it\\n\\t\\t*/\\n        if(hm.containsKey(val)){\\n            int index=hm.get(val);\\n            arr[index]=arr[last];\\n            hm.put(arr[index],index);\\n            last--;\\n            hm.remove(val);\\n            //System.out.println(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        //print();\\n        Random rand = new Random(); //instance of random class\\n        int upperbound = last+1;\\n        //generate random values from 0-24\\n        int index = rand.nextInt(upperbound); \\n        //System.out.println(\"index \"+index);\\n        return arr[index];\\n    }\\n    public void print(){\\n        for(int i=0;i<=last;i++){\\n            System.out.print(arr[i]+\" \");\\n        }\\n        System.out.println(hm);\\n    }\\n\\t//if you find this helpful, please upvote..\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282582,
                "title": "c-easy-simple-clean-using-only-unordered-map",
                "content": "```\\n// Using Unordred_map \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,bool> mp;\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        auto it = mp.begin();\\n        advance(it, rand() % mp.size());\\n        return it -> first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n// Using Unordred_map \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,bool> mp;\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        auto it = mp.begin();\\n        advance(it, rand() % mp.size());\\n        return it -> first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225544,
                "title": "discussion-on-various-data-structure-possibilities-why-hashmap-arrays-c-explained",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 24th May, 2021\\n---------------------------------\\n\\nC++ program for \"Inserting, Deleting and Getting Random Element in O(1) time\"\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/\\n------\\n\\nSolution: The data structure that comes to our mind with O(1) are:\\n    - HashMaps: Insert, Delete in O(1) but getting any random value would need an iterator and that \\n        iteration in hashmap to a random index would be O(n).\\n        It  doesn\\'t have support for [] operator.\\n    - DLL: Insert, Delete in O(1) time but again to traverse to a specific index will take O(n) time. \\n        It  doesn\\'t have support for [] operator\\n    - Set: Insert and Remove in O(1) time for unordered_set but it doesnt have the [] operator to access any index.\\n        To acccess a random index, you must traverse the set in O(n) time.\\n    - Vectors/Arrays: Insert is O(1) but to know if an element is already present will take O(n) time if done at end. \\n        Remove any element is O(1) through a stratergy discussed below but to know iff it is present is again O(n)\\n        Getting Random Index is O(1) since any index can be accessed through [] operator.\\n        The only difficulty with Vectors is \"HOW TO KNOW IF AN ELEMENT IS PRESENT IN IT?\" in O(1) time.\\n        \\n    - Vectors/Arrays+HashMaps: Hashmaps store indexes of elements and solve the problem above, vector stores the elements.\\n        Insert: To know if already inserted, we use Hashmap and get it in O(1) time.\\n            If not inserted, we insert in vector in O(1) time\\n        Remove: TO know if present or not, we use Hashmap and get it in O(1) time.\\n            If present, we remove it from vector like this:\\n                Copy element of last index to the element to be removed index\\n                Pop the last index in O(1) time.\\n                Update map with new index of last element and remove element to be deleted from the map\\n        Get Random: Simply choose a random number and access it with the [] operator.\\n\\nTime Complexity: O(1) for all operations\\nSpace Complexity: O(1) for all operations\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\nclass RandomizedSet {\\npublic:\\n    unordered_map <int, int > m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        // If my map has the val, return false\\n        if(m.count(val)){\\n            return false;\\n        }\\n        // If my map doesn\\'t have it, push it in the vector\\n        // Update the map with the val and index of the vector\\n        else{\\n            v.push_back(val);\\n            m[val] = v.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    \\n    bool remove(int val) {\\n        // If map doesn\\'t have the value, return false    \\n        if (m.find(val) == m.end()) return false;\\n        \\n        // We\\'re sure that map has the val. Get the index of the stored val\\n        auto it = m.find(val);\\n        \\n        // update the vector in index of val to be = last element in v\\n        // it->second : index of the element \\'val\\' which is to be deleted\\n        v[it->second] = v.back();\\n        \\n        // remove the last element, we have got rid of \\'val\\' from the vector \\'v\\' now\\n        v.pop_back();\\n        \\n        // map\\'s index for last element has changed to old index of val, so update it\\n        m[v[it->second]] = it->second;\\n        \\n        // map\\'s val would still show the old index, erase it\\n        m.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 24th May, 2021\\n---------------------------------\\n\\nC++ program for \"Inserting, Deleting and Getting Random Element in O(1) time\"\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/\\n------\\n\\nSolution: The data structure that comes to our mind with O(1) are:\\n    - HashMaps: Insert, Delete in O(1) but getting any random value would need an iterator and that \\n        iteration in hashmap to a random index would be O(n).\\n        It  doesn\\'t have support for [] operator.\\n    - DLL: Insert, Delete in O(1) time but again to traverse to a specific index will take O(n) time. \\n        It  doesn\\'t have support for [] operator\\n    - Set: Insert and Remove in O(1) time for unordered_set but it doesnt have the [] operator to access any index.\\n        To acccess a random index, you must traverse the set in O(n) time.\\n    - Vectors/Arrays: Insert is O(1) but to know if an element is already present will take O(n) time if done at end. \\n        Remove any element is O(1) through a stratergy discussed below but to know iff it is present is again O(n)\\n        Getting Random Index is O(1) since any index can be accessed through [] operator.\\n        The only difficulty with Vectors is \"HOW TO KNOW IF AN ELEMENT IS PRESENT IN IT?\" in O(1) time.\\n        \\n    - Vectors/Arrays+HashMaps: Hashmaps store indexes of elements and solve the problem above, vector stores the elements.\\n        Insert: To know if already inserted, we use Hashmap and get it in O(1) time.\\n            If not inserted, we insert in vector in O(1) time\\n        Remove: TO know if present or not, we use Hashmap and get it in O(1) time.\\n            If present, we remove it from vector like this:\\n                Copy element of last index to the element to be removed index\\n                Pop the last index in O(1) time.\\n                Update map with new index of last element and remove element to be deleted from the map\\n        Get Random: Simply choose a random number and access it with the [] operator.\\n\\nTime Complexity: O(1) for all operations\\nSpace Complexity: O(1) for all operations\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\nclass RandomizedSet {\\npublic:\\n    unordered_map <int, int > m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        // If my map has the val, return false\\n        if(m.count(val)){\\n            return false;\\n        }\\n        // If my map doesn\\'t have it, push it in the vector\\n        // Update the map with the val and index of the vector\\n        else{\\n            v.push_back(val);\\n            m[val] = v.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    \\n    bool remove(int val) {\\n        // If map doesn\\'t have the value, return false    \\n        if (m.find(val) == m.end()) return false;\\n        \\n        // We\\'re sure that map has the val. Get the index of the stored val\\n        auto it = m.find(val);\\n        \\n        // update the vector in index of val to be = last element in v\\n        // it->second : index of the element \\'val\\' which is to be deleted\\n        v[it->second] = v.back();\\n        \\n        // remove the last element, we have got rid of \\'val\\' from the vector \\'v\\' now\\n        v.pop_back();\\n        \\n        // map\\'s index for last element has changed to old index of val, so update it\\n        m[v[it->second]] = it->second;\\n        \\n        // map\\'s val would still show the old index, erase it\\n        m.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136695,
                "title": "java-simple-solution",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    List<Integer>list;\\n    //pair as num-index index in list;\\n    Map<Integer,Integer>map;\\n    public RandomizedSet() {\\n      list=new ArrayList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) return false;\\n        map.put(val,list.size());\\n        list.add(list.size(),val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n      if(!map.containsKey(val)) return false;\\n        int pos=map.get(val);\\n        for(int i=pos+1;i<list.size();i++)\\n            map.put(list.get(i),i-1);\\n        list.remove(pos);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index=(int)(Math.random()*(list.size()));\\n        return list.get(index);\\n    }\\n}\\n```\\ngetRandom() and insert() are both O(1) in worst case\\nbut remove() have O(1) in average case \\n\\n***please,upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    List<Integer>list;\\n    //pair as num-index index in list;\\n    Map<Integer,Integer>map;\\n    public RandomizedSet() {\\n      list=new ArrayList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) return false;\\n        map.put(val,list.size());\\n        list.add(list.size(),val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n      if(!map.containsKey(val)) return false;\\n        int pos=map.get(val);\\n        for(int i=pos+1;i<list.size();i++)\\n            map.put(list.get(i),i-1);\\n        list.remove(pos);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index=(int)(Math.random()*(list.size()));\\n        return list.get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030464,
                "title": "javascript-o-1-beat-96-29-run-time-super-easy-understanding-short-code",
                "content": "```\\nRuntime: 140 ms, faster than 96.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 47.3 MB, less than 77.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\n```\\n\\n```\\nvar RandomizedSet = function() {\\n    this.storage = {}\\n    this.nums = []\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(this.storage[val] !== undefined) return false\\n    this.nums.push(val)\\n    this.storage[val] = this.nums.length - 1\\n    return true\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(this.storage[val] === undefined) return false\\n    let len = this.nums.length - 1;\\n    let index = this.storage[val];\\n    this.storage[this.nums[len]] = this.storage[val];\\n    [this.nums[index], this.nums[len]] = [this.nums[len], this.nums[index]];\\n    this.nums.pop()\\n    return delete this.storage[val]\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.nums[Math.floor(this.nums.length * Math.random())]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime: 140 ms, faster than 96.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 47.3 MB, less than 77.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\n```\n```\\nvar RandomizedSet = function() {\\n    this.storage = {}\\n    this.nums = []\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(this.storage[val] !== undefined) return false\\n    this.nums.push(val)\\n    this.storage[val] = this.nums.length - 1\\n    return true\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(this.storage[val] === undefined) return false\\n    let len = this.nums.length - 1;\\n    let index = this.storage[val];\\n    this.storage[this.nums[len]] = this.storage[val];\\n    [this.nums[index], this.nums[len]] = [this.nums[len], this.nums[index]];\\n    this.nums.pop()\\n    return delete this.storage[val]\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.nums[Math.floor(this.nums.length * Math.random())]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928434,
                "title": "java-o-1-beats-100-hashmap-arraylist",
                "content": "Maintaining a HashMap is necessary for O(1) inserts, removals, and membership checks. Each map entry is a key-value pair of (value, index of value in ArrayList). ArrayList is necessary for O(1) access to random elements.\\n\\ninsert() and getRandom() are relatively straightforward, the tricky part is the removal. ArrayList removal takes O(n) time for a random element, but if the element is at the end of the ArrayList, it takes constant time. So whenever an element is removed, swap it in the ArrayList with the final element before removing the element from both the ArrayList and HashMap. The HashMap index entry of the swapped element needs to be updated accordingly (the swapped element was originally at the end, but is now where the removed element used to be).\\n\\n```\\nclass RandomizedSet {\\n    List<Integer> list = new ArrayList<Integer>(); \\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n        map.put(val, list.size());\\n        list.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int swap1 = map.get(val);\\n        int swap2 = list.size() - 1;\\n        int val2 = list.get(swap2);\\n        map.put(val2, swap1);\\n        map.remove(val);\\n        list.set(swap1, val2);\\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int a = (int)(Math.random() * list.size());\\n        return list.get(a);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    List<Integer> list = new ArrayList<Integer>(); \\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n        map.put(val, list.size());\\n        list.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int swap1 = map.get(val);\\n        int swap2 = list.size() - 1;\\n        int val2 = list.get(swap2);\\n        map.put(val2, swap1);\\n        map.remove(val);\\n        list.set(swap1, val2);\\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int a = (int)(Math.random() * list.size());\\n        return list.get(a);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 816623,
                "title": "solution-using-both-hashmap-and-hashset",
                "content": "We can use HashSet if we call getRandom rarely to save memory.\\n\\n```\\nclass RandomizedSet {\\n    Set<Integer> hset;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hset = new HashSet<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hset.contains(val)) return false;\\n        \\n        hset.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hset.contains(val)) return false;\\n        \\n        hset.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Integer[] temp = hset.toArray(new Integer[0]);\\n        return temp[random.nextInt(hset.size())];\\n    }\\n}\\n```\\nHashMap + ArrayList Solution:\\n\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> hash;\\n    ArrayList<Integer> list;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hash = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hash.containsKey(val)) return false;\\n        \\n        hash.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hash.containsKey(val)) return false;\\n        \\n        int index = hash.get(val);\\n        if(index < list.size() - 1) {\\n            list.set(index, list.get(list.size() -1));\\n        }\\n        hash.put(list.get(list.size() - 1), index);\\n        hash.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Set<Integer> hset;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hset = new HashSet<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hset.contains(val)) return false;\\n        \\n        hset.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hset.contains(val)) return false;\\n        \\n        hset.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Integer[] temp = hset.toArray(new Integer[0]);\\n        return temp[random.nextInt(hset.size())];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794826,
                "title": "swift-simple-using-array-and-hashmap-for-indexes",
                "content": "```\\nfinal class RandomizedSet {\\n    var hashMap = [Int: Int]()\\n    var arr = [Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        if hashMap[val] != nil {\\n            return false\\n        }\\n        arr.append(val)\\n        hashMap[val] = arr.count - 1\\n        return true\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if hashMap[val] == nil {\\n            return false\\n        }\\n        let index = hashMap[val]!\\n        let lastVal = arr.last!\\n        arr.swapAt(index, arr.count - 1)\\n        hashMap[lastVal] = index\\n        arr.removeLast()\\n        hashMap.removeValue(forKey: val)\\n        return true\\n    }\\n    \\n    /** Get a random element from the set. */\\n    func getRandom() -> Int {\\n        return arr.randomElement()!\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class RandomizedSet {\\n    var hashMap = [Int: Int]()\\n    var arr = [Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        if hashMap[val] != nil {\\n            return false\\n        }\\n        arr.append(val)\\n        hashMap[val] = arr.count - 1\\n        return true\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if hashMap[val] == nil {\\n            return false\\n        }\\n        let index = hashMap[val]!\\n        let lastVal = arr.last!\\n        arr.swapAt(index, arr.count - 1)\\n        hashMap[lastVal] = index\\n        arr.removeLast()\\n        hashMap.removeValue(forKey: val)\\n        return true\\n    }\\n    \\n    /** Get a random element from the set. */\\n    func getRandom() -> Int {\\n        return arr.randomElement()!\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683806,
                "title": "c-an-accepted-but-wrong-solution-with-hashset",
                "content": "**Idea:**\\nThis is only for fun and help readers like myself to understand the iterator manipulation within c++ hashmap and hashset\\n\\nThe only point of this point is that: no random access within hashmap and hashset.\\nSo we should resort to random accessible containor like vector to complete picture.\\n\\n\\nTime Complexity:  O(N)   (Because of getRandom() )\\nSpace Complexity: O(N)\\n\\n\\n```\\nclass RandomizedSet { // An elegant WRONG Solution for fun in the name of study\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); // return the number of elements erased.                       \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(m_.size() < 1 ) return -1;\\n        int index = rand() % m_.size();        \\n        //return *(m_.begin() + index); // Note: Err. No + operation for for C++ hashset/hashmap\\n        auto it=m_.begin();\\n        //while(index-- > 0) it++; // ok\\n        std::advance(it, index);\\n        return *it;\\n    }\\n    \\nprivate:      \\n    unordered_set<int> m_;  \\n};\\n```\\n\\n**Bonus:**\\nHere is the my updated version of 4-line, it is so sexy that I write a new post:\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/discuss/685574/challenge-me-for-shorter-solution-4-line",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet { // An elegant WRONG Solution for fun in the name of study\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); // return the number of elements erased.                       \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(m_.size() < 1 ) return -1;\\n        int index = rand() % m_.size();        \\n        //return *(m_.begin() + index); // Note: Err. No + operation for for C++ hashset/hashmap\\n        auto it=m_.begin();\\n        //while(index-- > 0) it++; // ok\\n        std::advance(it, index);\\n        return *it;\\n    }\\n    \\nprivate:      \\n    unordered_set<int> m_;  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623157,
                "title": "simple-c-faster-than-71-63",
                "content": "### Accepted Solution with Runtime: 164 ms, faster than 71.63%\\n#### Main idea behind this solution:\\n- create a `List<int>` with all added elements\\n- keep values also in `Dictionary<int, int>` with `value` as a key and `index` (of above `List<int>`) as a value\\n- when adding new element - expand `List<int>` and add value to `Dictionary<int, int>`\\n- when removing - remove from `Dictionary` and update `List<int>` by putting **its last element** in place of the deleted one (accessible by index kept in Dictionary)\\n\\n```\\npublic class RandomizedSet {\\n    Dictionary<int, int> dict;\\n    List<int> elements;\\n    private Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        dict = new Dictionary<int, int>();\\n        elements = new List<int>();\\n        random = new Random();        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if(dict.ContainsKey(val))\\n            return false;\\n\\n        var newIdx = elements.Count();\\n        elements.Add(val);\\n        dict.Add(val, newIdx);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if(dict.ContainsKey(val))\\n        {\\n            var elementIdx = dict[val];\\n            dict.Remove(val);\\n            \\n            RemoveElementAtIdx(elementIdx);           \\n        }\\n        else\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private void RemoveElementAtIdx(int idx)\\n    {\\n        var countElements = elements.Count();\\n        if (idx == countElements - 1)\\n            elements.RemoveAt(idx);\\n        else\\n        {\\n            var lastElem = elements[countElements - 1];\\n            elements[idx] = lastElem;\\n            elements.RemoveAt(countElements - 1);\\n            dict[lastElem] = idx;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        var rnd = random.Next(0, elements.Count);\\n        return elements[rnd];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    Dictionary<int, int> dict;\\n    List<int> elements;\\n    private Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        dict = new Dictionary<int, int>();\\n        elements = new List<int>();\\n        random = new Random();        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if(dict.ContainsKey(val))\\n            return false;\\n\\n        var newIdx = elements.Count();\\n        elements.Add(val);\\n        dict.Add(val, newIdx);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if(dict.ContainsKey(val))\\n        {\\n            var elementIdx = dict[val];\\n            dict.Remove(val);\\n            \\n            RemoveElementAtIdx(elementIdx);           \\n        }\\n        else\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private void RemoveElementAtIdx(int idx)\\n    {\\n        var countElements = elements.Count();\\n        if (idx == countElements - 1)\\n            elements.RemoveAt(idx);\\n        else\\n        {\\n            var lastElem = elements[countElements - 1];\\n            elements[idx] = lastElem;\\n            elements.RemoveAt(countElements - 1);\\n            dict[lastElem] = idx;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        var rnd = random.Next(0, elements.Count);\\n        return elements[rnd];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614685,
                "title": "simple-approach-using-unordered-map-and-vector-with-full-explanation-and-complete-code-in-c",
                "content": "In this question we are required to generete a special kind of data structure supporting following features:-\\n1. insert(val)\\n2. remove(val)\\n3. getRandom\\n\\nAll operations in O(1)\\n\\n***Resolving getRandom : -***\\nhere we have to return any random value that is present in our data structure. At first sight we observe that both insert and remove operation are satisfied by using set in O(1). Let us say that we are using unordered_set for first 2 operations, than we found that to get any random value from the set you have to iterate over it as set or even map does not support getting any value in O(1) but using vector you can achieve this, as with index value you can access any item in array in O(1).\\n\\nThus using set alone you cannot achieve all the 3 functions in required time. Thus use of set is eliminanted from above discussion.\\n\\nNow we have to use 2 different data structure one is unordered map and another is a vector\\nkey as the given val and value as index of the vector where that value is stored in vector.\\nSo, when we remove anything from map we should also remove it from vector.\\n***Now you say that removing something from vector is not O(1) as we are required to do because when remove function is called we should delete our value both from map and vector. However in this case we can achieve delete operation in O(1), by moving swapping the value to be deleted with the last value in vector and then deleting the last value, deleting last value in vector is O(1) operation.***\\n\\n***return v[rand()%v.size()];***\\nwe use rand() function to generate any random value and mod it with vector size thus giving us random index value of vector.\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,int> mp;\\n    vector<int> v;\\n    int currIndex = 0;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = currIndex;\\n            v.push_back(val);\\n            currIndex++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()){\\n            return false;\\n        }\\n        int index = mp[val];\\n        int size = v.size();\\n        \\n        if(index ==  size-1){\\n            v.pop_back();\\n            mp.erase(val);\\n            return true;\\n        }\\n        else{\\n            mp.erase(val);\\n            mp[v[size-1]] = index;\\n            swap(v[index],v[size-1]);\\n            v.pop_back();\\n            currIndex--;\\n            return true;\\n        }     \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```\\n \\n hope it helps!!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,int> mp;\\n    vector<int> v;\\n    int currIndex = 0;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = currIndex;\\n            v.push_back(val);\\n            currIndex++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()){\\n            return false;\\n        }\\n        int index = mp[val];\\n        int size = v.size();\\n        \\n        if(index ==  size-1){\\n            v.pop_back();\\n            mp.erase(val);\\n            return true;\\n        }\\n        else{\\n            mp.erase(val);\\n            mp[v[size-1]] = index;\\n            swap(v[index],v[size-1]);\\n            v.pop_back();\\n            currIndex--;\\n            return true;\\n        }     \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 436771,
                "title": "javascript-array-of-values-and-map-of-values-and-locations-in-array",
                "content": "```\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.arr = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(val in this.map) return false;\\n    this.map[val] = this.arr.length;\\n    this.arr.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(!(val in this.map)) return false;\\n    var end = this.arr[this.arr.length - 1];\\n    var original = this.map[val];\\n    this.map[end] = original;\\n    this.arr[original] = end;\\n    delete this.map[val];\\n    this.arr.pop();\\n    return true;\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.arr[Math.floor(Math.random() * this.arr.length)];\\n};\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.arr = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(val in this.map) return false;\\n    this.map[val] = this.arr.length;\\n    this.arr.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(!(val in this.map)) return false;\\n    var end = this.arr[this.arr.length - 1];\\n    var original = this.map[val];\\n    this.map[end] = original;\\n    this.arr[original] = end;\\n    delete this.map[val];\\n    this.arr.pop();\\n    return true;\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.arr[Math.floor(Math.random() * this.arr.length)];\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 396771,
                "title": "strictly-o-1-python-solution-easy-to-understand-beats-97",
                "content": "Basically you will need a dictionary, a list and an int to record the number of elements in the list. \\n\\nThe dictionary will store values and their positions in the list.\\nThe list store the values. \\nEvery time you remove a value, you get the position of this value in the list. Exchange it with the last element in the list, so that the other elements in the list have the same position as before, except for the last element. You can modify the position of the last element from the dictionary\\n\\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \\n        self.dic={}\\n        self.lst=[]\\n        self.cnt=0\\n        \\n\\n    def insert(self, val):\\n      \\n        if val in self.dic:\\n            return False\\n        self.dic[val]=self.cnt\\n        self.cnt+=1\\n        self.lst.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n\\n        \\n        if val not in self.dic:\\n            return False\\n        \\n        pos=self.dic[val]\\n        if pos!=self.cnt-1:\\n            self.lst[pos]=self.lst[-1]\\n            self.dic[self.lst[-1]]=pos\\n        self.dic.pop(val)\\n        self.lst.pop()\\n        self.cnt-=1\\n        return True\\n            \\n        \\n\\n    def getRandom(self):\\n\\n        randnum=random.randint(0, self.cnt-1)\\n        return self.lst[randnum]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \\n        self.dic={}\\n        self.lst=[]\\n        self.cnt=0\\n        \\n\\n    def insert(self, val):\\n      \\n        if val in self.dic:\\n            return False\\n        self.dic[val]=self.cnt\\n        self.cnt+=1\\n        self.lst.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n\\n        \\n        if val not in self.dic:\\n            return False\\n        \\n        pos=self.dic[val]\\n        if pos!=self.cnt-1:\\n            self.lst[pos]=self.lst[-1]\\n            self.dic[self.lst[-1]]=pos\\n        self.dic.pop(val)\\n        self.lst.pop()\\n        self.cnt-=1\\n        return True\\n            \\n        \\n\\n    def getRandom(self):\\n\\n        randnum=random.randint(0, self.cnt-1)\\n        return self.lst[randnum]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 329120,
                "title": "python-o-1-o-1-o-1",
                "content": "```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = {}\\n        self.l = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            return False\\n        else:\\n            self.d[val] = len(self.l)\\n            self.l.append(val)\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            self.d[self.l[-1]] = self.d[val]\\n            self.l[self.d.pop(val)] = self.l[-1]\\n            self.l.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return self.l[random.randint(0, len(self.l) - 1)]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = {}\\n        self.l = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            return False\\n        else:\\n            self.d[val] = len(self.l)\\n            self.l.append(val)\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            self.d[self.l[-1]] = self.d[val]\\n            self.l[self.d.pop(val)] = self.l[-1]\\n            self.l.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return self.l[random.randint(0, len(self.l) - 1)]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247273,
                "title": "c-100-using-hashmap-and-vector-no-vector-removal",
                "content": "Overall my solution is similar to hashmap and array method mentioned in other answers. My method don\\'t need to remove element from vector. A variable is used to mark the new entry of vector. Code see below.\\n\\n```\\nclass RandomizedSet {\\nprivate: \\n    unordered_map<int, int> numLoc;\\n    vector<int> nums;\\n    int In = 0;\\n    \\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\\n    std::mt19937 gen; //Standard mersenne_twister_engine seeded with rd()\\n    std::uniform_int_distribution<int> dis;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        gen = mt19937(rd());\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (numLoc.find(val) != numLoc.end()) return false;\\n        numLoc.insert({val, In});\\n        if (In == nums.size())\\n            nums.push_back(val);\\n        else nums[In] = val;\\n        ++In;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (numLoc.find(val) == numLoc.end()) return false;\\n        int loc = numLoc.find(val)->second;\\n        nums[loc] = nums[In - 1];\\n        numLoc.find(nums[loc])->second = loc;\\n        --In;\\n        numLoc.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (In > 0) {\\n            dis = uniform_int_distribution<int>(0, In - 1);\\n            // cout << dis(gen);\\n            return nums[dis(gen)];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\nprivate: \\n    unordered_map<int, int> numLoc;\\n    vector<int> nums;\\n    int In = 0;\\n    \\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\\n    std::mt19937 gen; //Standard mersenne_twister_engine seeded with rd()\\n    std::uniform_int_distribution<int> dis;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        gen = mt19937(rd());\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (numLoc.find(val) != numLoc.end()) return false;\\n        numLoc.insert({val, In});\\n        if (In == nums.size())\\n            nums.push_back(val);\\n        else nums[In] = val;\\n        ++In;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (numLoc.find(val) == numLoc.end()) return false;\\n        int loc = numLoc.find(val)->second;\\n        nums[loc] = nums[In - 1];\\n        numLoc.find(nums[loc])->second = loc;\\n        --In;\\n        numLoc.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (In > 0) {\\n            dis = uniform_int_distribution<int>(0, In - 1);\\n            // cout << dis(gen);\\n            return nums[dis(gen)];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 197079,
                "title": "go-faster-than-100",
                "content": "```\\nimport \"math/rand\"\\n\\ntype RandomizedSet struct {\\n    nums []int\\n    nti map[int]int // num to index\\n}\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{[]int{}, make(map[int]int)}\\n}\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    \\n    if _, ok := this.nti[val]; ok {\\n        return false\\n    }\\n    \\n    this.nums     = append(this.nums, val)\\n    this.nti[val] = len(this.nums)-1\\n    \\n    return true\\n}\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    \\n    if i, ok := this.nti[val]; !ok {\\n        return false\\n    } else {\\n        \\n        if len(this.nums) < 2 {\\n            this.nums = this.nums[0:0]\\n        } else {\\n            \\n            swap := this.nums[len(this.nums)-1]\\n            \\n            this.nti[swap] = i\\n            this.nums[i]   = swap\\n            this.nums      = this.nums[0:len(this.nums)-1]\\n        }\\n        \\n        delete(this.nti, val)\\n        return true\\n    }\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.nums[rand.Int() % len(this.nti)]\\n}\\n```\\n\\nIt\\'s important to note that Golang\\'s list implementation is a Linked List, so  \\n`this.nums      = this.nums[0:len(this.nums)-1]`\\nis an O(1) operation",
                "solutionTags": [],
                "code": "```\\nimport \"math/rand\"\\n\\ntype RandomizedSet struct {\\n    nums []int\\n    nti map[int]int // num to index\\n}\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{[]int{}, make(map[int]int)}\\n}\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    \\n    if _, ok := this.nti[val]; ok {\\n        return false\\n    }\\n    \\n    this.nums     = append(this.nums, val)\\n    this.nti[val] = len(this.nums)-1\\n    \\n    return true\\n}\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    \\n    if i, ok := this.nti[val]; !ok {\\n        return false\\n    } else {\\n        \\n        if len(this.nums) < 2 {\\n            this.nums = this.nums[0:0]\\n        } else {\\n            \\n            swap := this.nums[len(this.nums)-1]\\n            \\n            this.nti[swap] = i\\n            this.nums[i]   = swap\\n            this.nums      = this.nums[0:len(this.nums)-1]\\n        }\\n        \\n        delete(this.nti, val)\\n        return true\\n    }\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.nums[rand.Int() % len(this.nti)]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 188460,
                "title": "java-solution-using-hashmap-arraylist-all-operations-o-1-with-explanation",
                "content": "Many people have a question of how we do removal in ```O(1)``` So for removal we can swap the value with last element in the list and then just remove last element. Removal of last element is ```O(1)``` as the last space is just deallocated whereas if we do a remove without swapping then it can take ```O(n)``` in worse case as we would have to shift the complete  array.\\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    int lastIndex;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        lastIndex = 0;\\n    }\\n\\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        list.add(val);\\n        map.put(val, lastIndex);\\n        lastIndex++;\\n\\n        return true;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        map.put(list.get(lastIndex-1), map.get(val));\\n        swap(map.get(val), lastIndex-1);\\n        list.remove(lastIndex-1);\\n        map.remove(val);\\n        lastIndex--;\\n\\n        return true;\\n    }\\n\\n    private void swap(int id1, int id2) {\\n        int temp = list.get(id1);\\n        list.set(id1, list.get(id2));\\n        list.set(id2, temp);\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand = new Random();\\n        int idx = rand.nextInt(((lastIndex-1) - 0) + 1) + 0;\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```O(1)```\n```O(1)```\n```O(n)```\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    int lastIndex;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        lastIndex = 0;\\n    }\\n\\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        list.add(val);\\n        map.put(val, lastIndex);\\n        lastIndex++;\\n\\n        return true;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        map.put(list.get(lastIndex-1), map.get(val));\\n        swap(map.get(val), lastIndex-1);\\n        list.remove(lastIndex-1);\\n        map.remove(val);\\n        lastIndex--;\\n\\n        return true;\\n    }\\n\\n    private void swap(int id1, int id2) {\\n        int temp = list.get(id1);\\n        list.set(id1, list.get(id2));\\n        list.set(id2, temp);\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand = new Random();\\n        int idx = rand.nextInt(((lastIndex-1) - 0) + 1) + 0;\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184120,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    HashSet<Integer> h;\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        h = new HashSet<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(h.contains(val))\\n            return false;\\n        h.add(val);\\n        return true;        \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(h.contains(val))\\n            h.remove(val);\\n        else\\n            return false;\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index = rand.nextInt(h.size());\\n        Iterator<Integer> iter = h.iterator();\\n        for (int i = 0; i < index; i++) {\\n            iter.next();\\n        }\\n        return iter.next();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    HashSet<Integer> h;\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        h = new HashSet<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(h.contains(val))\\n            return false;\\n        h.add(val);\\n        return true;        \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(h.contains(val))\\n            h.remove(val);\\n        else\\n            return false;\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index = rand.nextInt(h.size());\\n        Iterator<Integer> iter = h.iterator();\\n        for (int i = 0; i < index; i++) {\\n            iter.next();\\n        }\\n        return iter.next();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138375,
                "title": "map-and-list",
                "content": "There are 2 classic data structures: list, map\\n- For O(1) insertion, list and map satisfy\\n- For O(1) removal by value, map satisfies\\n- For O(1) getRandom, list satisfies\\n\\nIn order to achive the above at the same time, we maintain both map and list:\\n- list of values `valList`\\n- map value to location `valToLoc`\\n\\nAs for removal, the entry should be removed from both `valList` and `valToLoc`.\\n\\nBut removal in `valList` takes O(n) time since it requires all the succeeding elements to be shifted to fill out the space created by removed element.\\n\\nWe can avoid that by swapping `val` with the last element of the list (`if val is not the last one`), and then deleting the last element.\\n\\n```\\n    // Map value to location in list.\\n    private static Map<Integer, Integer> valToLoc;\\n    // List of values.\\n    private static List<Integer> valList;\\n    private static final Random random = new Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToLoc = new HashMap<>();\\n        valList = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (valToLoc.containsKey(val)) \\n            return false;\\n        \\n        valToLoc.put(val, valList.size());\\n        valList.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!valToLoc.containsKey(val))\\n            return false;\\n        \\n        int posToDelete = valToLoc.get(val);\\n        valToLoc.remove(val);\\n        if (posToDelete != valList.size() - 1) {\\n            int lastVal = valList.get(valList.size() - 1);\\n            valList.set(posToDelete, lastVal);\\n            valToLoc.put(lastVal, posToDelete);\\n        }\\n        valList.remove(valList.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return valList.get(random.nextInt(valList.size()));\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    // Map value to location in list.\\n    private static Map<Integer, Integer> valToLoc;\\n    // List of values.\\n    private static List<Integer> valList;\\n    private static final Random random = new Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToLoc = new HashMap<>();\\n        valList = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (valToLoc.containsKey(val)) \\n            return false;\\n        \\n        valToLoc.put(val, valList.size());\\n        valList.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!valToLoc.containsKey(val))\\n            return false;\\n        \\n        int posToDelete = valToLoc.get(val);\\n        valToLoc.remove(val);\\n        if (posToDelete != valList.size() - 1) {\\n            int lastVal = valList.get(valList.size() - 1);\\n            valList.set(posToDelete, lastVal);\\n            valToLoc.put(lastVal, posToDelete);\\n        }\\n        valList.remove(valList.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return valList.get(random.nextInt(valList.size()));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85412,
                "title": "why-always-hash-the-truely-o-1",
                "content": "Change echo value into binary, and regard it as a string.\\nWe can storage it with a Trie.\\nAnd we change a little and fit duplicates allowed version.\\n```\\ntypedef struct RandomizedSetNode_S {\\n    int iCnt;\\n    struct RandomizedSetNode_S* apstSucc[2];\\n} RandomizedSetNode;\\n\\ntypedef struct {\\n    RandomizedSetNode *head;\\n} RandomizedSet;\\n\\n/** Initialize your data structure here. */\\nRandomizedSetNode* randomizedSetNodeCreate() {\\n    RandomizedSetNode *pstRet = malloc(sizeof(RandomizedSetNode));\\n    pstRet->iCnt = 0;\\n    pstRet->apstSucc[0] = NULL;\\n    pstRet->apstSucc[1] = NULL;\\n    return pstRet;\\n}\\n\\nvoid randomizedSetNodeFree(RandomizedSetNode* obj) {\\n    if (obj->apstSucc[0] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[0]);\\n    }\\n    if (obj->apstSucc[1] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[1]);\\n    }\\n    free(obj);\\n}\\n\\n/** Initialize your data structure here. */\\nRandomizedSet* randomizedSetCreate() {\\n    RandomizedSet *pstRet = malloc(sizeof(RandomizedSet));\\n    pstRet->head = randomizedSetNodeCreate();\\n    return pstRet;\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nbool randomizedSetInsert(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode == NULL) {\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    if (pstNode != NULL) {\\n        return false;\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt++;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            pstNode->apstSucc[iBit] = randomizedSetNodeCreate();\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt++;\\n    }\\n    return true;\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nbool randomizedSetRemove(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            return false;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt--;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit]->iCnt == 1) {\\n            randomizedSetNodeFree(pstNode->apstSucc[iBit]);\\n            pstNode->apstSucc[iBit] = NULL;\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt--;\\n    }\\n    return true;\\n}\\n\\n/** Get a random element from the set. */\\nint randomizedSetGetRandom(RandomizedSet* obj) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    int iZeroCnt, iOneCnt;\\n    int iAnswer = 0, iBit;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        iZeroCnt = 0;\\n        iOneCnt = 0;\\n        if (pstNode->apstSucc[0] != NULL) {\\n            iZeroCnt = pstNode->apstSucc[0]->iCnt;\\n        }\\n        if (pstNode->apstSucc[1] != NULL) {\\n            iOneCnt = pstNode->apstSucc[1]->iCnt;\\n        }\\n        assert(iZeroCnt + iOneCnt > 0);\\n        if ((rand() + 1.) / (RAND_MAX + 2.) < iZeroCnt * 1. / (iZeroCnt + iOneCnt)) {\\n            iBit = 0;\\n        } else {\\n            iBit = 1;\\n        }\\n        assert(iBit == 1 || iZeroCnt > 0);\\n        assert(iBit == 0 || iOneCnt > 0);\\n        iAnswer |= iBit << iPos;\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    \\n    return iAnswer;\\n}\\n\\nvoid randomizedSetFree(RandomizedSet* obj) {\\n    randomizedSetNodeFree(obj->head);\\n    free(obj);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct RandomizedSetNode_S {\\n    int iCnt;\\n    struct RandomizedSetNode_S* apstSucc[2];\\n} RandomizedSetNode;\\n\\ntypedef struct {\\n    RandomizedSetNode *head;\\n} RandomizedSet;\\n\\n/** Initialize your data structure here. */\\nRandomizedSetNode* randomizedSetNodeCreate() {\\n    RandomizedSetNode *pstRet = malloc(sizeof(RandomizedSetNode));\\n    pstRet->iCnt = 0;\\n    pstRet->apstSucc[0] = NULL;\\n    pstRet->apstSucc[1] = NULL;\\n    return pstRet;\\n}\\n\\nvoid randomizedSetNodeFree(RandomizedSetNode* obj) {\\n    if (obj->apstSucc[0] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[0]);\\n    }\\n    if (obj->apstSucc[1] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[1]);\\n    }\\n    free(obj);\\n}\\n\\n/** Initialize your data structure here. */\\nRandomizedSet* randomizedSetCreate() {\\n    RandomizedSet *pstRet = malloc(sizeof(RandomizedSet));\\n    pstRet->head = randomizedSetNodeCreate();\\n    return pstRet;\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nbool randomizedSetInsert(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode == NULL) {\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    if (pstNode != NULL) {\\n        return false;\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt++;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            pstNode->apstSucc[iBit] = randomizedSetNodeCreate();\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt++;\\n    }\\n    return true;\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nbool randomizedSetRemove(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            return false;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt--;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit]->iCnt == 1) {\\n            randomizedSetNodeFree(pstNode->apstSucc[iBit]);\\n            pstNode->apstSucc[iBit] = NULL;\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt--;\\n    }\\n    return true;\\n}\\n\\n/** Get a random element from the set. */\\nint randomizedSetGetRandom(RandomizedSet* obj) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    int iZeroCnt, iOneCnt;\\n    int iAnswer = 0, iBit;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        iZeroCnt = 0;\\n        iOneCnt = 0;\\n        if (pstNode->apstSucc[0] != NULL) {\\n            iZeroCnt = pstNode->apstSucc[0]->iCnt;\\n        }\\n        if (pstNode->apstSucc[1] != NULL) {\\n            iOneCnt = pstNode->apstSucc[1]->iCnt;\\n        }\\n        assert(iZeroCnt + iOneCnt > 0);\\n        if ((rand() + 1.) / (RAND_MAX + 2.) < iZeroCnt * 1. / (iZeroCnt + iOneCnt)) {\\n            iBit = 0;\\n        } else {\\n            iBit = 1;\\n        }\\n        assert(iBit == 1 || iZeroCnt > 0);\\n        assert(iBit == 0 || iOneCnt > 0);\\n        iAnswer |= iBit << iPos;\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    \\n    return iAnswer;\\n}\\n\\nvoid randomizedSetFree(RandomizedSet* obj) {\\n    randomizedSetNodeFree(obj->head);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85431,
                "title": "c-80ms-solution",
                "content": " class RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(umap.find(val) == umap.end()) {\\n            umap[val] = vec.size();\\n            vec.push_back(val);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto iter = umap.find(val);\\n        if(iter == umap.end()) {\\n            return false;\\n        } else {\\n            int back = vec.back();\\n            if(back != val) {\\n                vec[umap[val]] = back;\\n                umap[back] = umap[val];\\n            }\\n            umap.erase(iter);\\n            vec.pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int size = vec.size();\\n        srand(time(0));\\n        return vec[rand()%size];\\n        \\n    }\\nprivate:\\n    vector<int> vec;\\n    unordered_map<int, int> umap;\\n};",
                "solutionTags": [],
                "code": " class RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(umap.find(val) == umap.end()) {\\n            umap[val] = vec.size();\\n            vec.push_back(val);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto iter = umap.find(val);\\n        if(iter == umap.end()) {\\n            return false;\\n        } else {\\n            int back = vec.back();\\n            if(back != val) {\\n                vec[umap[val]] = back;\\n                umap[back] = umap[val];\\n            }\\n            umap.erase(iter);\\n            vec.pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int size = vec.size();\\n        srand(time(0));\\n        return vec[rand()%size];\\n        \\n    }\\nprivate:\\n    vector<int> vec;\\n    unordered_map<int, int> umap;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3584797,
                "title": "best-optimised-solution-with-the-best-runtime-provided-beats-90-of-cpp-solutions-in-speed-and-mem",
                "content": "# Intuition\\nWe can use the set but we cannot access the random index directly from the set without traversing it..so this will result in more time complexity.\\n\\n# Approach\\nWe can use an unordered_map and vector in the insertion we keep track of the indices and we add the value to vector and add the index of the element\\'s index to the map and in the deletion we change the key index to the last index and replace it with the last value and we just delete and erase from the map..so in random we can return a value by rand() funtion.\\n\\n# Complexity\\n- Time complexity:\\nInsertion-->O(1)\\nDeletion-->O(1map)\\nRandom-->O(1)\\n- Space complexity:\\nmap-->O(n)\\nvector-->O(n)\\n\\n# Code\\n```\\nclass RandomizedSet {\\nprivate:\\nunordered_map<int,int> m;\\nvector<int>v;    \\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n       if(m.count(val))\\n       return false;\\n       m[val]=v.size();\\n       v.push_back(val);\\n       return true;\\n    }\\n    \\n    bool remove(int val) {\\n      if(!m.count(val))\\n      return false;\\n      int p=v.back();\\n      m[p]=m[val];\\n      v[m[val]]=p;\\n      v.pop_back();\\n      m.erase(val);\\n      return true;\\n    }\\n    \\n    int getRandom() {\\n     return v[rand()% v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\nprivate:\\nunordered_map<int,int> m;\\nvector<int>v;    \\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n       if(m.count(val))\\n       return false;\\n       m[val]=v.size();\\n       v.push_back(val);\\n       return true;\\n    }\\n    \\n    bool remove(int val) {\\n      if(!m.count(val))\\n      return false;\\n      int p=v.back();\\n      m[p]=m[val];\\n      v[m[val]]=p;\\n      v.pop_back();\\n      m.erase(val);\\n      return true;\\n    }\\n    \\n    int getRandom() {\\n     return v[rand()% v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423045,
                "title": "insert-delete-getrandom-o-1",
                "content": "------------------- Easy C++ Solution -------------------\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    set<int>s;\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val) != s.end()){\\n            return false;\\n        }\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n         if(s.find(val) == s.end()){\\n            return false;\\n        }\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        set<int>::iterator it = s.begin();\\n        advance(it, rand()%s.size());\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n    set<int>s;\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val) != s.end()){\\n            return false;\\n        }\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n         if(s.find(val) == s.end()){\\n            return false;\\n        }\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        set<int>::iterator it = s.begin();\\n        advance(it, rand()%s.size());\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279003,
                "title": "using-inbuilt-function-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet\\n    def initialize()\\n        @a = []\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n        if @a.include?(val)\\n            return false\\n        else\\n            @a.push(val)\\n            return true\\n        end\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n        if @a.include?(val)\\n            @a.delete(val)\\n            return true\\n        else\\n            return false\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        @a.sample\\n    end\\n\\n\\nend\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet.new()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.get_random()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass RandomizedSet\\n    def initialize()\\n        @a = []\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n        if @a.include?(val)\\n            return false\\n        else\\n            @a.push(val)\\n            return true\\n        end\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n        if @a.include?(val)\\n            @a.delete(val)\\n            return true\\n        else\\n            return false\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        @a.sample\\n    end\\n\\n\\nend\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet.new()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.get_random()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270967,
                "title": "java-using-arraylist-30-ms",
                "content": "I used binary search to make the elements inside array list unique.\\n\\n# Complexity\\n- Time complexity: \\n\\n# Code\\n```\\nclass RandomizedSet {\\n    ArrayList<Integer> list;\\n    static Random random = new Random();\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            list.add(-res - 1, val);\\n            return true;\\n        } else return false;\\n    }\\n\\n    public boolean remove(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            return false;\\n        } else {\\n            list.remove(res);\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    ArrayList<Integer> list;\\n    static Random random = new Random();\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            list.add(-res - 1, val);\\n            return true;\\n        } else return false;\\n    }\\n\\n    public boolean remove(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            return false;\\n        } else {\\n            list.remove(res);\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220426,
                "title": "c-self-explanatory",
                "content": "#\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    unordered_map<int, int> index;\\n    vector<int>value;\\n\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                return false;\\n            }\\n            \\n        }\\n        this->value.push_back(val);\\n        this->index[val] = this->value.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                index[value.back()] = index[val];\\n                value[index[val]] = value.back();\\n                index[val] = -1;\\n                value.pop_back();\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return value[rand()%value.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> index;\\n    vector<int>value;\\n\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                return false;\\n            }\\n            \\n        }\\n        this->value.push_back(val);\\n        this->index[val] = this->value.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                index[value.back()] = index[val];\\n                value[index[val]] = value.back();\\n                index[val] = -1;\\n                value.pop_back();\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return value[rand()%value.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051687,
                "title": "simple-c-solution-using-map-and-array",
                "content": "\\tclass RandomizedSet {\\n\\tpublic:\\n\\t   unordered_map<int,int>mp;\\n\\t\\tvector<int>arr;\\n\\t\\tRandomizedSet() {\\n\\n\\t\\t}\\n    \\n    bool insert(int val) {\\n     if(mp.count(val))\\n     {\\n         return false;\\n     }\\n     arr.push_back(val);\\n     mp[val] = arr.size()-1;\\n     return true;\\n    }\\n    \\n    bool remove(int val) {\\n     if(mp.count(val))\\n     {\\n     int index = mp[val];\\n     int v = arr.back();\\n     arr[index] = v;\\n     mp[v] = index;\\n     arr.pop_back();\\n     mp.erase(val);\\n    return true;\\n     }\\n    return false;\\n    }\\n    \\n    int getRandom() {\\n      int index = rand()%arr.size();\\n      return arr[index];  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "\\tclass RandomizedSet {\\n\\tpublic:\\n\\t   unordered_map<int,int>mp;\\n\\t\\tvector<int>arr;\\n\\t\\tRandomizedSet() {\\n\\n\\t\\t}\\n    \\n    bool insert(int val) {\\n     if(mp.count(val))\\n     {\\n         return false;\\n     }\\n     arr.push_back(val);\\n     mp[val] = arr.size()-1;\\n     return true;\\n    }\\n    \\n    bool remove(int val) {\\n     if(mp.count(val))\\n     {\\n     int index = mp[val];\\n     int v = arr.back();\\n     arr[index] = v;\\n     mp[v] = index;\\n     arr.pop_back();\\n     mp.erase(val);\\n    return true;\\n     }\\n    return false;\\n    }\\n    \\n    int getRandom() {\\n      int index = rand()%arr.size();\\n      return arr[index];  \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2860093,
                "title": "insert-delete-getrandom-o-1-unordered-map-vector",
                "content": "**Insert Delete GetRandom O(1)**\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int>mp;\\n    vector<int>arr;\\n\\t\\n    // Initializes the RandomizedSet object.\\n    RandomizedSet() { }\\n    \\n\\t// Inserts an item val into the set if not present.\\n\\t//Returns true if the set did not already contain the specified element,\\n\\t//false otherwise.\\n\\t//count function returns true if val is present in map\\n    bool insert(int val) {\\n        if(mp.count(val)){\\n            return false;\\n        }\\n        arr.push_back(val);\\n        mp[val]=arr.size()-1;\\n        return true;\\n    }\\n    \\n\\t//Removes an item val from the set if present. \\n\\t//Returns true if the set contained the specified element.\\n    bool remove(int val) {\\n        \\n        if(mp.count(val)){\\n            int indexx = mp[val];\\n            int v=arr.back();\\n            arr[indexx]=v;\\n            mp[v]=indexx;\\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// Get a random element from the set.\\n\\t//rand()%arr.size() will give the random element in the \\n\\t//range of arr size.\\n    int getRandom() {\\n        int index = rand()%arr.size();\\n        return arr[index];\\n    }\\n};\\n```\\n\\n**More Explanation**(found this in discussion section)\\n\\nUsually the first thing that comes to find when we hear \"insert\" in constant time is \"hashmaps\".\\nThat\\'s the reason we use an unordered_map here which stores the element as \" key \" and its position in vector as the \"value \".. The average time complexity of search , insert and remove elements from a hashmap is O(1).\\n\\nHowever , here we need to support \"Random()\" access in O(1) as well. so we are using a vector here to achieve that.\\nHere is the trick to remove in constant time.\\nHere is the pseudo-code\\n\\n1) If the element you are trying to remove is the last element in the vector, remove it, done, ELSE,\\n2) Read the last element of the vector and write it over the element-to-be-removed\\n\\n3) Now remove the last element of the vector. (C++ pop_back() in a vector is O(1))\\nThat is exactly the trick we are using here, only that we need to update our hashmap as well.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int>mp;\\n    vector<int>arr;\\n\\t\\n    // Initializes the RandomizedSet object.\\n    RandomizedSet() { }\\n    \\n\\t// Inserts an item val into the set if not present.\\n\\t//Returns true if the set did not already contain the specified element,\\n\\t//false otherwise.\\n\\t//count function returns true if val is present in map\\n    bool insert(int val) {\\n        if(mp.count(val)){\\n            return false;\\n        }\\n        arr.push_back(val);\\n        mp[val]=arr.size()-1;\\n        return true;\\n    }\\n    \\n\\t//Removes an item val from the set if present. \\n\\t//Returns true if the set contained the specified element.\\n    bool remove(int val) {\\n        \\n        if(mp.count(val)){\\n            int indexx = mp[val];\\n            int v=arr.back();\\n            arr[indexx]=v;\\n            mp[v]=indexx;\\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// Get a random element from the set.\\n\\t//rand()%arr.size() will give the random element in the \\n\\t//range of arr size.\\n    int getRandom() {\\n        int index = rand()%arr.size();\\n        return arr[index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859750,
                "title": "go-solution-everything-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\ntype RandomizedSet struct {\\n    store map[int]int\\n    indexes []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{store: make(map[int]int), indexes: make([]int, 0)}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.store[val]; ok {\\n        return false\\n    }\\n    this.indexes = append(this.indexes, val)\\n    this.store[val] = len(this.indexes) -1\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    itemIndex, ok := this.store[val]\\n    if !ok {\\n        return false\\n    }\\n    lastIndex := len(this.indexes) -1\\n    lastElem := this.indexes[lastIndex]\\n    this.indexes[itemIndex] = lastElem\\n    this.store[lastElem] = itemIndex\\n    delete(this.store, val)\\n    this.indexes = this.indexes[:len(this.indexes)-1]\\n    return true\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.indexes[rand.Intn(len(this.indexes))]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    store map[int]int\\n    indexes []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{store: make(map[int]int), indexes: make([]int, 0)}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.store[val]; ok {\\n        return false\\n    }\\n    this.indexes = append(this.indexes, val)\\n    this.store[val] = len(this.indexes) -1\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    itemIndex, ok := this.store[val]\\n    if !ok {\\n        return false\\n    }\\n    lastIndex := len(this.indexes) -1\\n    lastElem := this.indexes[lastIndex]\\n    this.indexes[itemIndex] = lastElem\\n    this.store[lastElem] = itemIndex\\n    delete(this.store, val)\\n    this.indexes = this.indexes[:len(this.indexes)-1]\\n    return true\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.indexes[rand.Intn(len(this.indexes))]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859673,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random random;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val))\\n            return false;\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))\\n            return false;\\n        \\n        int i = map.remove(val);\\n        int last = list.size()-1;\\n        if(i != last){\\n            int lastVal = list.get(last);\\n            list.set(i, lastVal);\\n            map.put(lastVal, i);\\n        }\\n        list.remove(last);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random random;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val))\\n            return false;\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))\\n            return false;\\n        \\n        int i = map.remove(val);\\n        int last = list.size()-1;\\n        if(i != last){\\n            int lastVal = list.get(last);\\n            list.set(i, lastVal);\\n            map.put(lastVal, i);\\n        }\\n        list.remove(last);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859606,
                "title": "swift-4-lines-easy-to-understand",
                "content": "```\\nclass RandomizedSet {\\n    var store: Set<Int> = []\\n\\n    init() {}\\n    \\n    func insert(_ val: Int) -> Bool {\\n        return store.insert(val).inserted == false ? false : true\\n    }\\n    \\n    func remove(_ val: Int) -> Bool {\\n        return store.remove(val) != nil ? true : false\\n    }\\n    \\n    func getRandom() -> Int {\\n        // store.first ?? 0 should work as set is an unordered list and \\n        // store.first O(1) but it doesn\\'t work here and test 17 is wrong\\n        return store.randomElement() ?? 0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass RandomizedSet {\\n    var store: Set<Int> = []\\n\\n    init() {}\\n    \\n    func insert(_ val: Int) -> Bool {\\n        return store.insert(val).inserted == false ? false : true\\n    }\\n    \\n    func remove(_ val: Int) -> Bool {\\n        return store.remove(val) != nil ? true : false\\n    }\\n    \\n    func getRandom() -> Int {\\n        // store.first ?? 0 should work as set is an unordered list and \\n        // store.first O(1) but it doesn\\'t work here and test 17 is wrong\\n        return store.randomElement() ?? 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858902,
                "title": "easy-approach-using-set",
                "content": "**Approach**\\nWe will make use of Unordered_Set. We know we can insert , find and remove an element in O(1) using unordered_set.\\nThe question arises for getRandom() method. Using C++ rand() function we will generate any random number between 0 to set.size()-1 , and we will move the Set iterator to point to that index.\\n\\n**To generate random number between 0 to set.size() -1**\\n\\t\\t int random=rand()%s.size();\\n**To move set iterator to that index we will make use of advance() method of set library,**\\nauto it=s.begin();\\nadvance(it , random());\\nThis will advance the iterator **it** to the index speicified in random.\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s; \\n    RandomizedSet() {\\n      \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=true;\\n        if(s.find(val)!=s.end())\\n            flag=false;\\n        s.insert(val);\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        auto it = s.begin();\\n        int random = rand() % s.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s; \\n    RandomizedSet() {\\n      \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=true;\\n        if(s.find(val)!=s.end())\\n            flag=false;\\n        s.insert(val);\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        auto it = s.begin();\\n        int random = rand() % s.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858821,
                "title": "rust-hashset",
                "content": "```\\nuse std::collections::HashSet;\\nuse rand::{Rng, prelude::IteratorRandom};\\n\\nstruct RandomizedSet {\\n    set: HashSet<i32>,\\n}\\n\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        RandomizedSet{set: HashSet::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        self.set.insert(val)\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        self.set.remove(&val)\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = rand::thread_rng();\\n        *self.set.iter().choose(&mut rng).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse rand::{Rng, prelude::IteratorRandom};\\n\\nstruct RandomizedSet {\\n    set: HashSet<i32>,\\n}\\n\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        RandomizedSet{set: HashSet::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        self.set.insert(val)\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        self.set.remove(&val)\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = rand::thread_rng();\\n        *self.set.iter().choose(&mut rng).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858561,
                "title": "python-simple-and-easy-way-to-solve-with-explanation-92-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Initialize Set\\n        self.sets = set()\\n\\n    def insert(self, val: int) -> bool:\\n        # If n is present in set then return false\\n        if val in self.sets : \\n            return False\\n        \\n        # If n is not present in set then add it to the set.\\n        self.sets.add(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        # If n is in set then remove n else return false\\n        if val in self.sets:\\n            self.sets.remove(val)\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        # Return random number using random module\\n        return random.choice(list(self.sets))\\n```\\n**For Leetcode Solution with Explanation Visit this Blog:\\nhttps://www.python-techs.com\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Initialize Set\\n        self.sets = set()\\n\\n    def insert(self, val: int) -> bool:\\n        # If n is present in set then return false\\n        if val in self.sets : \\n            return False\\n        \\n        # If n is not present in set then add it to the set.\\n        self.sets.add(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        # If n is in set then remove n else return false\\n        if val in self.sets:\\n            self.sets.remove(val)\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        # Return random number using random module\\n        return random.choice(list(self.sets))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858520,
                "title": "java-hashmap-arraylist",
                "content": "Lets thing of the solution incrementally, consider you put the values in an ArrayList, that way is trivial to add values and get random values. \\nThe only problem is how do you delete a value from there. This can be solved by using a HashMap to keep the indexes of the values, so when you need to remove a value you know where to remove the value from. \\nthe new problem is that removing a value will change the indexes in all the values following the deleted one, adjusting the values would bump complexity to O(n) (remember we want O(1)). So what if no value follows the deleted one... so you guessed it, the fix to this problem is to always delete the value at the end, that way there are no indexes to be adjusted. so first you swap the value to be deleted with the last value, and then you delete the last value. I hope this was helpful. remember to vote up in case you found this useful :)\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> valToPos = new HashMap<>();\\n    List <Integer> vals = new ArrayList<>();\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(valToPos.containsKey(val)) return false;\\n        vals.add(val);\\n        valToPos.put(val, vals.size()-1);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!valToPos.containsKey(val)) return false;\\n        int pos = valToPos.remove(val);\\n        int last = vals.remove(vals.size() - 1);\\n        if(pos == vals.size()) return true;\\n        vals.set(pos, last);\\n        valToPos.put(last, pos);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return vals.get(rand.nextInt(vals.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "Lets thing of the solution incrementally, consider you put the values in an ArrayList, that way is trivial to add values and get random values. \\nThe only problem is how do you delete a value from there. This can be solved by using a HashMap to keep the indexes of the values, so when you need to remove a value you know where to remove the value from. \\nthe new problem is that removing a value will change the indexes in all the values following the deleted one, adjusting the values would bump complexity to O(n) (remember we want O(1)). So what if no value follows the deleted one... so you guessed it, the fix to this problem is to always delete the value at the end, that way there are no indexes to be adjusted. so first you swap the value to be deleted with the last value, and then you delete the last value. I hope this was helpful. remember to vote up in case you found this useful :)\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> valToPos = new HashMap<>();\\n    List <Integer> vals = new ArrayList<>();\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(valToPos.containsKey(val)) return false;\\n        vals.add(val);\\n        valToPos.put(val, vals.size()-1);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!valToPos.containsKey(val)) return false;\\n        int pos = valToPos.remove(val);\\n        int last = vals.remove(vals.size() - 1);\\n        if(pos == vals.size()) return true;\\n        vals.set(pos, last);\\n        valToPos.put(last, pos);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return vals.get(rand.nextInt(vals.size()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2685432,
                "title": "easy-solution-in-c-using-advance-iterator-in-hashset",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(st.find(val)!=st.end())\\n            return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.find(val)!=st.end()){\\n            st.erase(st.find(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it=st.begin();\\n        int random=rand()%st.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(st.find(val)!=st.end())\\n            return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.find(val)!=st.end()){\\n            st.erase(st.find(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it=st.begin();\\n        int random=rand()%st.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672216,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571481,
                "title": "typescript",
                "content": "```\\nclass RandomizedSet {\\n    set = new Set<number>();\\n\\n    constructor() { }\\n\\n    insert(val: number): boolean {\\n        let result = !this.set.has(val);\\n        this.set.add(val);\\n        return result;\\n    }\\n\\n    remove(val: number): boolean {\\n        let result = this.set.has(val);\\n        this.set.delete(val);\\n        return result;\\n    }\\n\\n    getRandom(): number {\\n        return [...this.set.values()][Math.floor(Math.random() * this.set.size)];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\n    set = new Set<number>();\\n\\n    constructor() { }\\n\\n    insert(val: number): boolean {\\n        let result = !this.set.has(val);\\n        this.set.add(val);\\n        return result;\\n    }\\n\\n    remove(val: number): boolean {\\n        let result = this.set.has(val);\\n        this.set.delete(val);\\n        return result;\\n    }\\n\\n    getRandom(): number {\\n        return [...this.set.values()][Math.floor(Math.random() * this.set.size)];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536845,
                "title": "c-inser-delete-getrandom-o-1",
                "content": "Idea: If we want to delete an element val in the array in O(1) time, we can first swap this element to the end of the array, and then pop it off. And we need a hash table  to record the index corresponding to each element value.\\n```\\nclass RandomizedSet {\\n    public:\\n    vector<int> nums;\\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    public:\\n    vector<int> nums;\\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516920,
                "title": "java-fast-than-97",
                "content": "class RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n    \\n\\n\\n\\n  ```\\nclass RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n\\n    public RandomizedSet() {\\n       map= new HashMap<>();\\n       list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n       if(map.containsKey(val)){\\n           return false;\\n       }\\n        \\n          int index = list.size();\\n          list.add(val);\\n          map.put(val,index);\\n          return true;\\n       \\n       \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int index = map.get(val);\\n\\t\\t\\t//remove in list is not lways O(1), only when it is last one\\n\\t\\t\\t//so if it is last one, we just remove it\\n\\t\\t\\t//if it is in the other place, we could swap with last one, then remove it\\n            if(index == list.size()-1){\\n                list.remove(index);\\n            }else{\\n                int last = list.size()-1;\\n                int swapvalue = list.get(last);\\n                list.set(index,swapvalue);\\n                list.remove(last);\\n                map.put(swapvalue,index);    \\n            }\\n            map.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int size = list.size();\\n        int random = (int)(Math.random()*size);\\n        return list.get(random);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n    \\n\\n\\n\\n  ```\\nclass RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n\\n    public RandomizedSet() {\\n       map= new HashMap<>();\\n       list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n       if(map.containsKey(val)){\\n           return false;\\n       }\\n        \\n          int index = list.size();\\n          list.add(val);\\n          map.put(val,index);\\n          return true;\\n       \\n       \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int index = map.get(val);\\n\\t\\t\\t//remove in list is not lways O(1), only when it is last one\\n\\t\\t\\t//so if it is last one, we just remove it\\n\\t\\t\\t//if it is in the other place, we could swap with last one, then remove it\\n            if(index == list.size()-1){\\n                list.remove(index);\\n            }else{\\n                int last = list.size()-1;\\n                int swapvalue = list.get(last);\\n                list.set(index,swapvalue);\\n                list.remove(last);\\n                map.put(swapvalue,index);    \\n            }\\n            map.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int size = list.size();\\n        int random = (int)(Math.random()*size);\\n        return list.get(random);\\n        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2491664,
                "title": "python-simple-implementation-using-map",
                "content": "```\\nfrom random import randint\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.m = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.m:\\n            self.m[val] = val\\n            return True\\n        else:\\n            return False\\n        \\n    def remove(self, val: int) -> bool:\\n        if val not in self.m:\\n            return False\\n        del self.m[val]\\n        return True\\n\\n    def getRandom(self) -> int:\\n        size = len(self.m)\\n        ind = randint(0, size-1)\\n        keys = list(self.m)\\n        return keys[ind]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom random import randint\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.m = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.m:\\n            self.m[val] = val\\n            return True\\n        else:\\n            return False\\n        \\n    def remove(self, val: int) -> bool:\\n        if val not in self.m:\\n            return False\\n        del self.m[val]\\n        return True\\n\\n    def getRandom(self) -> int:\\n        size = len(self.m)\\n        ind = randint(0, size-1)\\n        keys = list(self.m)\\n        return keys[ind]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483261,
                "title": "tc-o-1-short-easy-super-efficient-approach-beats-99-76-without-using-find-function",
                "content": "This problem only requires to design a data structure that supports these operations insert, remove, and getRandom in constant time complexity O(1).\\n\\nPlease **upvote** if you like this simpler solution (**Without using find function basically which avoids O(log n) time extra operation**).\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    // Using vector to store elements and map to store elements with index+1 value;\\n    unordered_map<int,int>mp;\\n    vector<int>vec;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp[val])\\n            return false;\\n        \\n        vec.push_back(val); //0 based indexing\\n        mp[val]=vec.size(); //1 based indexing to avoid to use find func in map\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!mp[val])\\n            return false;\\n        \\n        int index=mp[val]-1;\\n        int last_val=vec.back();\\n        swap(vec[index],vec[vec.size()-1]); // swapping last element with index of val index\\n        vec.pop_back();\\n        mp[last_val]=index+1;\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        if(vec.size()>0)\\n            return vec[rand()%vec.size()];\\n        \\n        return -1; // list is empty\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    // Using vector to store elements and map to store elements with index+1 value;\\n    unordered_map<int,int>mp;\\n    vector<int>vec;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp[val])\\n            return false;\\n        \\n        vec.push_back(val); //0 based indexing\\n        mp[val]=vec.size(); //1 based indexing to avoid to use find func in map\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!mp[val])\\n            return false;\\n        \\n        int index=mp[val]-1;\\n        int last_val=vec.back();\\n        swap(vec[index],vec[vec.size()-1]); // swapping last element with index of val index\\n        vec.pop_back();\\n        mp[last_val]=index+1;\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        if(vec.size()>0)\\n            return vec[rand()%vec.size()];\\n        \\n        return -1; // list is empty\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566348,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565062,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1564790,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565840,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1938482,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699778,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571653,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1927731,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699732,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571879,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1566348,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565062,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1564790,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565840,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1938482,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699778,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571653,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1927731,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699732,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571879,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571652,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2025084,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1572651,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1571654,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1575880,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1632263,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2069454,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2055711,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2054644,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2054315,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2027680,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2017395,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2010852,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2007158,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1964069,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1959369,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1956467,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1935914,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1917844,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1909513,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1796538,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1769803,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1768485,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1757001,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1750096,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1741927,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1741199,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1715813,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700351,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700278,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700217,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1700210,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1700195,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699871,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699860,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699721,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699600,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699540,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699535,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699451,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            }
        ]
    }
]